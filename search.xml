<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web前端开发常用代码整理]]></title>
    <url>%2Fblog%2F4808.html</url>
    <content type="text"><![CDATA[web前端开发常用代码整理 IE条件注释条件注释简介 IE中的条件注释（Conditional comments）对IE的版本和IE非IE有优秀的区分能力，是WEB设计中常用的hack方法。条件注释只能用于IE5以上，IE10以上不支持。 如果你安装了多个IE，条件注释将会以最高版本的IE为标准。 条件注释的基本结构和HTML的注释(&lt;!– –&gt;)是一样的。因此IE以外的浏览器将会把它们看作是普通的注释而完全忽略它们。 IE将会根据if条件来判断是否如解析普通的页面内容一样解析条件注释里的内容。 条件注释使用方法示例 123456&lt;!–-[if IE 5]&gt;仅IE5.5可见&lt;![endif]–-&gt;&lt;!–-[if gt IE 5.5]&gt;仅IE 5.5以上可见&lt;![endif]–-&gt;&lt;!–-[if lt IE 5.5]&gt;仅IE 5.5以下可见&lt;![endif]–-&gt;&lt;!–-[if gte IE 5.5]&gt;IE 5.5及以上可见&lt;![endif]–-&gt;&lt;!–-[if lte IE 5.5]&gt;IE 5.5及以下可见&lt;![endif]–-&gt;&lt;!–-[if !IE 5.5]&gt;非IE 5.5的IE可见&lt;![endif]–-&gt; html代码用js动态加载进页面123&lt;script type="text/html" id="T-pcList"&gt; //这里面是你要放的html代码，例如放一个div的内容&lt;/script&gt; 把上面的js动态加入到页面中 123456$(function()&#123;var s=$("#T-pcList").html();//获得js的html内容$(".picScroll-left .bd").html(s);//把s的内容放到class为bd内thisstyle();//执行某个函数&#125;); js判断用户访问的是PC还是mobile123456789101112131415161718192021222324var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; var sUserAgent = navigator.userAgent; return &#123; trident: u.indexOf('Trident') &gt; -1, presto: u.indexOf('Presto') &gt; -1, isChrome: u.indexOf("chrome") &gt; -1, isSafari: !u.indexOf("chrome") &gt; -1 &amp;&amp; (/webkit|khtml/).test(u), isSafari3: !u.indexOf("chrome") &gt; -1 &amp;&amp; (/webkit|khtml/).test(u) &amp;&amp; u.indexOf('webkit/5') != -1, webKit: u.indexOf('AppleWebKit') &gt; -1, gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, mobile: !!u.match(/AppleWebKit.*Mobile.*/), ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, iPhone: u.indexOf('iPhone') &gt; -1, iPad: u.indexOf('iPad') &gt; -1, iWinPhone: u.indexOf('Windows Phone') &gt; -1 &#125;; &#125;()&#125;if(browser.versions.mobile || browser.versions.iWinPhone)&#123; window.location = "http:/www.baidu.com/m/";&#125; js如何判断用户是否是用微信浏览器根据关键字 MicroMessenger 来判断是否是微信内置的浏览器。判断函数如下： 12345678function isWeiXin()&#123; var ua = window.navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i) == 'micromessenger')&#123; return true; &#125;else&#123; return false; &#125; &#125; JS,Jquery获取各种屏幕的宽度和高度Javascript:文档可视区域宽： document.documentElement.clientWidth文档可视区域高： document.documentElement.clientHeight 网页可见区域宽： document.body.clientWidth网页可见区域高： document.body.clientHeight网页可见区域宽： document.body.offsetWidth (包括边线的宽)网页可见区域高： document.body.offsetHeight (包括边线的高)网页正文全文宽： document.body.scrollWidth网页正文全文高： document.body.scrollHeight网页被卷去的高： document.body.scrollTop网页被卷去的左： document.body.scrollLeft网页正文部分上： window.screenTop网页正文部分左： window.screenLeft屏幕分辨率的高： window.screen.height屏幕分辨率的宽： window.screen.width屏幕可用工作区高度： window.screen.availHeight屏幕可用工作区宽度： window.screen.availWidth JQuery: $(document).ready(function(){alert($(window).height()); //浏览器当前窗口可视区域高度alert($(document).height()); //浏览器当前窗口文档的高度alert($(document.body).height());//浏览器当前窗口文档body的高度alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin alert($(window).width()); //浏览器当前窗口可视区域宽度alert($(document).width());//浏览器当前窗口文档对象宽度alert($(document.body).width());//浏览器当前窗口文档body的宽度alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin }) jquery对文本框只读状态与可读状态的相互转化12$('input').removeAttr('Readonly');$('input').attr('Readonly','true'); js/jquery实现密码框输入聚焦，失焦问题js实现方法：html代码： 1&lt;input id="i_input" type="text" value='会员卡号/手机号' /&gt; js代码： 123456789101112131415161718192021222324window.onload = function()&#123;var oIpt = document.getElementById("i_input"); if(oIpt.value == "会员卡号/手机号")&#123; oIpt.style.color = "#888"; &#125;else&#123; oIpt.style.color = "#000"; &#125; oIpt.onfocus = function()&#123; if(this.value == "会员卡号/手机号")&#123; this.value=""; this.style.color = "#000"; this.type = "password"; &#125;else&#123; this.style.color = "#000"; &#125; &#125;; oIpt.onblur = function()&#123; if(this.value == "")&#123; this.value="会员卡号/手机号"; this.style.color = "#888"; this.type = "text"; &#125; &#125;;&#125; jquery实现方法:html代码： 12&lt;input type="text" class="oldpsw" id="showPwd" value="请输入您的注册密码"/&gt;&lt;input type="password" name="psw" class="oldpsw" id="password" value="" style="display:none;"/&gt; jquery代码： 1234567891011121314$("#showPwd").focus(function() &#123; var text_value=$(this).val(); if (text_value =='请输入您的注册密码') &#123; $("#showPwd").hide(); $("#password").show().focus(); &#125;&#125;);$("#password").blur(function() &#123; var text_value = $(this).val(); if (text_value == "") &#123; $("#showPwd").show(); $("#password").hide(); &#125;&#125;); 获取当前日期1234567891011121314151617var calculateDate = function()&#123; var date = new Date();var weeks = ["日","一","二","三","四","五","六"];return date.getFullYear()+"年"+(date.getMonth()+1)+"月"+ date.getDate()+"日 星期"+weeks[date.getDay()];&#125;$(function()&#123;$("#dateSpan").html(calculateDate());&#125;) 时间倒计时（固定倒计时的结束时间）12345678910111213141516171819202122232425262728293031323334353637function countdown() &#123; var endtime = new Date("Jan 18, 2015 23:50:00"); var nowtime = new Date(); if (nowtime &gt;= endtime) &#123; document.getElementById("_lefttime").innerHTML = "倒计时间结束"; return; &#125; var leftsecond = parseInt((endtime.getTime() - nowtime.getTime()) / 1000); if (leftsecond &lt; 0) &#123; leftsecond = 0; &#125; __d = parseInt(leftsecond / 3600 / 24); __h = parseInt((leftsecond / 3600) % 24); __m = parseInt((leftsecond / 60) % 60); __s = parseInt(leftsecond % 60); document.getElementById("_lefttime").innerHTML = __d + "天" + __h + "小时" + __m + "分" + __s + "秒";&#125;countdown();setInterval(countdown, 1000); 10秒倒计时跳转html代码： 1&lt;div id="showtimes"&gt;&lt;/div&gt; js代码： 123456789101112131415161718192021222324//设定倒数秒数 var t = 10; //显示倒数秒数 function showTime()&#123; t -= 1; document.getElementById('showtimes').innerHTML= t; if(t==0)&#123; location.href='error404.asp'; &#125; //每秒执行一次,showTime() setTimeout("showTime()",1000); &#125; //执行showTime() showTime(); 判断浏览器的简单有效方法1234567891011121314151617181920function getInternet()&#123; if(navigator.userAgent.indexOf("MSIE")&gt;0) &#123; return "MSIE"; //IE浏览器 &#125; if(isFirefox=navigator.userAgent.indexOf("Firefox")&gt;0)&#123; return "Firefox"; //Firefox浏览器 &#125; if(isSafari=navigator.userAgent.indexOf("Safari")&gt;0) &#123; return "Safari"; //Safan浏览器 &#125; if(isCamino=navigator.userAgent.indexOf("Camino")&gt;0)&#123; return "Camino"; //Camino浏览器 &#125; if(isMozilla=navigator.userAgent.indexOf("Gecko/")&gt;0)&#123; return "Gecko"; //Gecko浏览器 &#125; &#125; 每隔0.1s改变图片的路径1&lt;div id="tt"&gt;&lt;img src="images/1.jpg" alt=""/&gt;&lt;/div&gt; js代码： 123456789101112131415161718192021222324(function()&#123; function chagesimagesrc(t)&#123; document.getElementById("tt").childNodes[0].src="images/"+t+".jpg"; &#125; setInterval(function()&#123; for(var i=0;i&lt;2;i++)&#123; setTimeout((function(t)&#123; return function()&#123; chagesimagesrc(t); &#125; &#125;)(i+1),i*100) &#125; &#125;,1000);&#125;)() 点击某个div区域之外，隐藏该div一般写法： 123456$(document).on("click",function(e)&#123; var target = $(e.target); if(target.closest(".city_box,#city_select a.selected").length == 0)&#123; $(".city_box").hide(); &#125;&#125;) 更全的方式： 1234567891011$(document).click(function(e)&#123; var _con = $(' 目标区域 '); // 设置目标区域 if(!_con.is(e.target) &amp;&amp; _con.has(e.target).length === 0)&#123; // Mark 1 some code... // 功能代码 &#125;&#125;);/* Mark 1 的原理：判断点击事件发生在区域外的条件是：1. 点击事件的对象不是目标区域本身2. 事件对象同时也不是目标区域的子元素*/ js获取某年某月的哪些天是周六和周日12345678910111213141516171819202122232425&lt;p id="text"&gt;&lt;/p&gt; &lt;script type="text/javascript"&gt;function time(y,m)&#123; var tempTime = new Date(y,m,0); var time = new Date(); var saturday = new Array(); var sunday = new Array(); for(var i=1;i&lt;=tempTime.getDate();i++)&#123; time.setFullYear(y,m-1,i); var day = time.getDay(); if(day == 6)&#123; saturday.push(i); &#125;else if(day == 0)&#123; sunday.push(i); &#125; &#125; var text = y+"年"+m+"月份"+"&lt;br /&gt;" +"周六："+saturday.toString()+"&lt;br /&gt;" +"周日："+sunday.toString(); document.getElementById("text").innerHTML = text;&#125; time(2014,7);&lt;/script&gt; 如何在手机上禁止浏览器的网页滚动方法一： 1&lt;body ontouchmove="event.preventDefault()" &gt; 方法二： 123456789 &lt;script type="text/javascript"&gt; document.addEventListener('touchmove', function(event) &#123; event.preventDefault();&#125;) &lt;/script&gt; 改变type=file默认样式，”浏览”等字体12345&lt;input type="file" id="browsefile" style="visibility:hidden" onchange="filepath.value=this.value"&gt;&lt;input type="button" id="filebutton" value="" onclick="browsefile.click()"&gt;&lt;input type="textfield" id="filepath"&gt; js判断变量是否未定义的代码一般如果变量通过var声明，但是并未初始化的时候，变量的值为undefined，而未定义的变量则需要通过 “typeof 变量”的形式来判断，否则会发生错误。实际应用：variable有的页面我们不定义,但有的页面定义了，就可以需要这样的判断方法，没有定义的就不执行。 12345if("undefined" != typeof variable)&#123; if(variable=="abc")&#123; console.log('成功'); &#125; &#125; 针对IE6，7的hack，该怎么写你可能会这么回答：使用“&gt;”，“_”，“*”等各种各样的符号来写hack。是的，这样做没错，但是需要记住每个符号分别被哪些浏览器识别，并且如果写的太乱将造成代码 阅读起来十分困难。学习CSS必须抱有一种质疑精神，有没有一种hack方法可以不写这些乱七八糟的符号，并且代码易维护易读呢？我们可以看看好搜首页是怎么做的：在页面顶端有这样一句话： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"/&gt;&lt;head&gt;&lt;!--[if lt IE 7 ]&gt;&lt;html class="ie6"&gt;&lt;![endif]--&gt;&lt;!--[if IE 7 ]&gt;&lt;html class="ie7"&gt;&lt;![endif]--&gt;&lt;!--[if IE 8 ]&gt;&lt;html class="ie8"&gt;&lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt;&lt;html class="ie9"&gt;&lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html class="w3c"&gt;&lt;!--&lt;![endif]--&gt;&lt;/head&gt; 在页面的CSS中，会看到这样的规则： 123456789.ie7 #hd_usernav:before, .ie8 #hd_usernav:before &#123; display: none&#125;.ie6 .skin_no #hd_nav li, .ie7 .skin_no #hd_nav li, .ie8 .skin_no #hd_nav li &#123; border-right-color: #c5c5c5&#125;.ie6 .skin_no #hd_nav a, .ie7 .skin_no #hd_nav a, .ie8 .skin_no #hd_nav a &#123; color: #c5c5c5&#125; 行内级元素可以设置宽高吗？有哪些？在面试时，当被问到行内级元素可否设置宽高时，根据我们的经验往往会回答不能。但是这样往往着了面试官的道，因为有一些特殊的行内元素，比如img，input，select等等，是可以被设置宽高的。一个内容不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。比如img是一个置换元素，当不对它设置宽高时，它会按照本身的宽高进行显示。所以这个问题的正确答案应该是置换元素可以，非置换元素不可以。 js动态创建css样式添加到head内123456789101112131415161718192021222324252627282930function addCSS(cssText)&#123; var style = document.createElement('style'); var head = document.head || document.getElementsByTagName('head')[0]; style.type = 'text/css'; if(style.styleSheet)&#123; //IE var func = function()&#123; try&#123; //防止IE中stylesheet数量超过限制而发生错误 style.styleSheet.cssText = cssText; &#125;catch(e)&#123; &#125; &#125; //如果当前styleSheet还不能用，则放到异步中则行 if(style.styleSheet.disabled)&#123; setTimeout(func,10); &#125;else&#123; func(); &#125; &#125;else&#123; //w3c //w3c浏览器中只要创建文本节点插入到style元素中就行了 var textNode = document.createTextNode(cssText); style.appendChild(textNode); &#125; //把创建的style元素插入到head中 head.appendChild(style); &#125;//使用addCSS('#demo&#123; height: 30px; background:#f00;&#125;'); 在IE8以及其低版本浏览器下，IE独有属性styleSheet.cssText。所以一般的兼容简单写法： 12345678var style = document.createElement('style');style.type = "text/css";if (style.styleSheet) &#123; //IE style.styleSheet.cssText = '/*..css content here..*/';&#125; else &#123; //w3c style.innerHTML = '/*..css content here..*/';&#125;document.getElementsByTagName('head')[0].appendChild(style); form表单提交时设置编码格式123&lt;form name="form" method="post" action="XXXX" accept-charset="utf-8" onsubmit="document.charset='utf-8';"&gt; //内容&lt;/form&gt; js 加入收藏代码123456789101112131415function addFavorite(title, url) &#123; url = encodeURI(url); try &#123; window.external.addFavorite(url, title); &#125; catch (e) &#123; try &#123; window.sidebar.addPanel(title, url, ""); &#125; catch (e) &#123; alert("加入收藏失败,Ctrl+D进行添加"); &#125; &#125;&#125; addFavorite(document.title,window.location); 打印方法：（整个页面 window.print()） 12345678910111213141516function Printpart(id_str)//id-str 内容中的id&#123;var el = document.getElementById(id_str);var iframe = document.createElement('IFRAME');var doc = null;iframe.setAttribute('style', 'position:absolute;width:0px;height:0px;left:-500px;top:-500px;');document.body.appendChild(iframe);doc = iframe.contentWindow.document;doc.write('&lt;div&gt;' + el.innerHTML + '&lt;/div&gt;');doc.close();iframe.contentWindow.focus();iframe.contentWindow.print();if (navigator.userAgent.indexOf("MSIE") &gt; 0)&#123;document.body.removeChild(iframe);&#125;&#125; 参考地址：http://www.cnblogs.com/yeming…http://www.cnblogs.com/jikey/… js强制手机页面横屏显示12345678$( window ).on( "orientationchange", function( event ) &#123; if (event.orientation=='portrait') &#123; $('body').css('transform', 'rotate(90deg)'); &#125; else &#123; $('body').css('transform', 'rotate(0deg)'); &#125;&#125;);$( window ).orientationchange(); jquery获得select中option的索引html代码： 1234&lt;select class="select-green"&gt; &lt;option value="0"&gt;高级客户经理&lt;/option&gt; &lt;option value="1"&gt;中级客户经理&lt;/option&gt;&lt;/select&gt; jquery代码： 12345$(".select-green").change(function()&#123; var _indx = $(this).get(0).selectedIndex; $(".selectall .selectCon").hide(); $(".selectall .selectCon").eq(_indx).fadeIn();&#125;); 注：其中(this).get(0)与(this)[0]等价 获取上传文件的大小html代码： 1&lt;input type="file" id="filePath" onchange="getFileSize(this)"/&gt; js代码： 1234567891011121314151617181920//兼容IE9低版本获取文件的大小function getFileSize(obj)&#123; var filesize; if(obj.files)&#123; filesize = obj.files[0].size; &#125;else&#123; try&#123; var path,fso; path = document.getElementById('filePath').value; fso = new ActiveXObject("Scripting.FileSystemObject"); filesize = fso.GetFile(path).size; &#125; catch(e)&#123; //在IE9及低版本浏览器，如果不容许ActiveX控件与页面交互，点击了否，就无法获取size console.log(e.message); //Automation 服务器不能创建对象 filesize = 'error'; //无法获取 &#125; &#125; return filesize;&#125; 限制上传文件的类型如果是高版本浏览器，一般在HTML代码中写就能实现，如： 1&lt;input type="file" name="filePath" accept=".jpg,.jpeg,.doc,.docxs,.pdf"&gt; 如果限制上传文件为图片类型，如下： 1&lt;input type="file" class="file" value="上传" accept="image/*"/&gt; 但是在其它低版本浏览器就不管用了，需要js来判断。 html代码： 1&lt;input type="file" id="filePath" onchange="limitTypes()"/&gt; js代码： 123456789101112131415161718192021222324252627/* 通过扩展名，检验文件格式。 *@parma filePath&#123;string&#125; 文件路径 *@parma acceptFormat&#123;Array&#125; 允许的文件类型 *@result 返回值&#123;Boolen&#125;：true or false */function checkFormat(filePath,acceptFormat)&#123; var resultBool= false, ex = filePath.substring(filePath.lastIndexOf('.') + 1); ex = ex.toLowerCase(); for(var i = 0; i &lt; acceptFormat.length; i++)&#123; if(acceptFormat[i] == ex)&#123; resultBool = true; break; &#125; &#125; return resultBool;&#125;; function limitTypes()&#123; var obj = document.getElementById('filePath'); var path = obj.value; var result = checkFormat(path,['bmp','jpg','jpeg','png']); if(!result)&#123; alert('上传类型错误，请重新上传'); obj.value = ''; &#125;&#125; 随机产生lowwer - upper之间的随机数1234function selectFrom(lower, upper) &#123; var sum = upper - lower + 1; //总数-第一个数+1 return Math.floor(Math.random() * sum + lower);&#125;; 保留后端传递到前端页面的空格12345var objt = &#123; name:' aaaa 这是一个空格多的标签 这是一个空格多的标签' &#125; objt.name = objt.name.replace(/\s/g,'&amp;nbsp;'); console.log(objt.name); 用firebug查看结果： 为什么Image对象的src属性要写在onload事件后面？123var image=new Image();imgae.onload = funtion;imgae.src = 'url' js内部是按顺序逐行执行的，可以认为是同步的给imgae赋值src时，去加载图片这个过程是异步的，这个异步过程完成后，如果有onload，则执行onload 如果先赋值src，那么这个异步过程可能在你赋值onload之前就完成了（比如图片缓存，或者是js由于某些原因被阻塞了），那么onload就不会执行反之，js同步执行确定onload赋值完成后才会赋值src,可以保证这个异步过程在onload赋值完成后才开始进行，也就保证了onload一定会被执行到 跨浏览器添加事件12345678//跨浏览器添加事件 function addEvent(obj,type,fn)&#123; if(obj.addEventListener)&#123; obj.addEventListener(type,fn,false); &#125;else if(obj.attachEvent)&#123;//IE obj.attchEvent('on'+type,fn); &#125; &#125; 跨浏览器移除事件12345678//跨浏览器移除事件function removeEvent(obj,type,fn)&#123; if(obj.removeEventListener)&#123; obj.removeEventListener(type,fn,false); &#125;else if(obj.detachEvent)&#123;//兼容IE obj.detachEvent('on'+type,fn); &#125;&#125; 跨浏览器阻止默认行为123456789//跨浏览器阻止默认行为 function preDef(ev)&#123; var e = ev || window.event; if(e.preventDefault)&#123; e.preventDefault(); &#125;else&#123; e.returnValue =false; &#125; &#125; 跨浏览器获取目标对象12345678//跨浏览器获取目标对象function getTarget(ev)&#123; if(ev.target)&#123;//w3c return ev.target; &#125;else if(window.event.srcElement)&#123;//IE return window.event.srcElement; &#125;&#125; 跨浏览器获取滚动条位置1234567//跨浏览器获取滚动条位置，sp == scroll position function getSP()&#123; return&#123; top: document.documentElement.scrollTop || document.body.scrollTop, left : document.documentElement.scrollLeft || document.body.scrollLeft; &#125; &#125; 跨浏览器获取可视窗口大小123456789101112131415//跨浏览器获取可视窗口大小 function getWindow () &#123; if(typeof window.innerWidth !='undefined') &#123; return&#123; width : window.innerWidth, height : window.innerHeight &#125; &#125; else&#123; return &#123; width : document.documentElement.clientWidth, height : document.documentElement.clientHeight &#125; &#125; &#125; js 对象冒充123456789101112131415&lt;script type = 'text/javascript'&gt; function Person(name , age)&#123; this.name = name ; this.age = age ; this.say = function ()&#123; return "name : "+ this.name + " age: "+this.age ; &#125; ; &#125; var o = new Object() ;//可以简化为Object() Person.call(o , "zhangsan" , 20) ; console.log(o.say() );//name : zhangsan age: 20 &lt;/script&gt; js 异步加载和同步加载异步加载也叫非阻塞模式加载，浏览器在下载js的同时，同时还会执行后续的页面处理。在script标签内，用js创建一个script元素并插入到document中，这种就是异步加载js文件了： 12345678(function() &#123; var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = 'http://yourdomain.com/script.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(s, x); &#125;)(); 同步加载 平常默认用的都是同步加载。如： 1&lt;script src="http://yourdomain.com/script.js"&gt;&lt;/script&gt; 同步模式又称阻塞模式，会阻止流览器的后续处理。停止了后续的文件的解析，执行，如图像的渲染。浏览器之所以会采用同步模式，是因为加载的js文件中有对dom的操作，重定向，输出document等默认行为，所以同步才是最安全的。 通常会把要加载的js放到body结束标签之前，使得js可在页面最后加载，尽量减少阻塞页面的渲染。这样可以先让页面显示出来。 同步加载流程是瀑布模型，异步加载流程是并发模型。 js获取屏幕坐标123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7"/&gt; &lt;meta name="auther" content="fq" /&gt; &lt;title&gt;获取鼠标坐标&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; function mousePosition(ev)&#123; if(ev.pageX || ev.pageY)&#123; return &#123;x:ev.pageX, y:ev.pageY&#125;; &#125; return &#123; x:ev.clientX + document.body.scrollLeft - document.body.clientLeft, y:ev.clientY + document.body.scrollTop - document.body.clientTop &#125;; &#125; function mouseMove(ev)&#123; ev = ev || window.event; var mousePos = mousePosition(ev); document.getElementById('xxx').value = mousePos.x; document.getElementById('yyy').value = mousePos.y; &#125; document.onmousemove = mouseMove;&lt;/script&gt;X:&lt;input id="xxx" type="text" /&gt; Y:&lt;input id="yyy" type="text" /&gt;&lt;/body&gt;&lt;/html&gt; 注释：1.documentElement 属性可返回文档的根节点。2.scrollTop() 为滚动条向下移动的距离3.document.documentElement.scrollTop 指的是滚动条的垂直坐标4.document.documentElement.clientHeight 指的是浏览器可见区域高度 DTD已声明的情况下： 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 如果在页面中添加这行标记的话 IE1234document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度 Firefox123456document.documentElement.scrollHeight ==&gt; 浏览器所有内容高度document.body.scrollHeight ==&gt; 浏览器所有内容高度document.documentElement.scrollTop ==&gt; 浏览器滚动部分高度document.body.scrollTop ==&gt;始终为0document.documentElement.clientHeight ==&gt;浏览器可视部分高度document.body.clientHeight ==&gt; 浏览器所有内容高度 Chrome123456document.documentElement.scrollHeight ==&gt; 浏览器所有内容高度document.body.scrollHeight ==&gt; 浏览器所有内容高度document.documentElement.scrollTop==&gt; 始终为0document.body.scrollTop==&gt;浏览器滚动部分高度document.documentElement.clientHeight ==&gt; 浏览器可视部分高度document.body.clientHeight ==&gt; 浏览器所有内容高度 浏览器所有内容高度即浏览器整个框架的高度，包括滚动条卷去部分+可视部分+底部隐藏部分的高度总和 浏览器滚动部分高度即滚动条卷去部分高度即可视顶端距离整个对象顶端的高度。 综上 1、document.documentElement.scrollTop和document.body.scrollTop始终有一个为0，所以可以用这两个的和来求scrollTop 2、scrollHeight、clientHeight 在DTD已声明的情况下用documentElement，未声明的情况下用body clientHeight在IE和FF下，该属性没什么差别，都是指浏览器的可视区域，即除去浏览器的那些工具栏状态栏剩下的页面展示空间的高度。 PageX和clientXPageX:鼠标在页面上的位置,从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化 clientX:鼠标在页面上可视区域的位置,从浏览器可视区域左上角开始,即是以浏览器滑动条此刻的滑动到的位置为参考点,随滑动条移动 而变化. 可是悲剧的是,PageX只有FF特有,IE则没有这个，所以在IE下使用这个： PageY=clientY+scrollTop-clientTop;(只讨论Y轴,X轴同理,下同) scrollTop代表的是被浏览器滑动条滚过的长度 offsetX:IE特有,鼠标相比较于触发事件的元素的位置,以元素盒子模型的内容区域的左上角为参考点,如果有boder,可能出现负值 只有clientX和screenX 皆大欢喜是W3C标准.其他的,都纠结了.最给力的是，chrome和safari一条龙通杀!完全支持所有属性 js拖拽效果12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang="zn-CN"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; #login&#123; height: 100px; width: 100px; border: 1px solid black; position: relative; top:200px; left: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="login"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDiv = document.getElementById("login"); oDiv.onmousedown = function(e)&#123; var e = e || window.event;//window.event兼容IE,当事件发生时有效 var diffX = e.clientX - oDiv.offsetLeft;//获取鼠标点击的位置到所选对象的边框的水平距离 var diffY = e.clientY - oDiv.offsetTop; document.onmousemove = function(e)&#123; //需设为document对象才能作用于整个文档 var e = e||window.event; oDiv.style.left = e.clientX - diffX + 'px';//style.left表示所选对象的边框到浏览器左侧距离 oDiv.style.top = e.clientY -diffY + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null;//清除鼠标释放时的对象移动方法 document.onmouseup = null; &#125; &#125;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS特效-tab选项卡列表切换]]></title>
    <url>%2Fblog%2F59893.html</url>
    <content type="text"><![CDATA[tab选项卡列表切换 index.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;列表切换效果代码&lt;/title&gt;&lt;link rel="stylesheet" href="css/tab.css" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="tab"&gt; &lt;h3 class="up" id="two1" onmouseover="setContentTab('two',1,4)"&gt;热点新闻&lt;/h3&gt; &lt;div class="block" id="con_two_1"&gt; &lt;ul&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[新闻热点]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;点点妙：欢庆“十一”送祝福&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[新闻热点]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;点点妙携手移动端APP 开创棋牌游戏新模&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[新闻热点]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;看棋牌大亨如何颠覆快播江湖&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[新闻热点]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;棋牌行业：解密点点妙合作内幕 分成竟高达&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="two2" onmouseover="setContentTab('two',2,4)"&gt;合作播报&lt;/h3&gt; &lt;div id="con_two_2"&gt; &lt;ul&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[合作播报]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;收银妹代理棋牌游戏 成功晋级游戏女老板2&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[合作播报]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;收银妹代理棋牌游戏 成功晋级游戏女老板1&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[合作播报]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;IT精英放弃高薪只因想“玩”游戏&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[合作播报]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;“干爹”扶持，乐猴棋牌开疆拓土&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="two3" onmouseover="setContentTab('two',3,4)"&gt;行业咨询&lt;/h3&gt; &lt;div id="con_two_3"&gt; &lt;ul&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[行业咨询]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;收银妹代理棋牌游戏 成功晋级游戏女老板3&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[行业咨询]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;紫金阁：代理棋牌游戏如何能稳赚不亏？&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[行业咨询]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;你知道吗？“紫金阁”竟然升级做了“小三”&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[行业咨询]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;都市娱乐赚钱首选 棋牌游戏代理&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="two4" onmouseover="setContentTab('two',4,4)"&gt;运营攻略&lt;/h3&gt; &lt;div id="con_two_4"&gt; &lt;ul&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[运营攻略]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;加盟网络棋牌游戏的注意事项&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[运营攻略]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;奇葩：一款可以自动赚钱的棋牌游戏&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[运营攻略]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;代理棋牌游戏 紫金阁支招稳赚不亏&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="tab_menu" href="#"&gt;[运营攻略]&lt;/a&gt;&lt;a class="tab_title" href="#"&gt;棋牌行业内幕：什么时候代理棋牌游戏最合适&lt;/a&gt;&lt;span&gt;2014-09-05&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt;function setContentTab(name, curr, n) &#123; for (i = 1; i &lt;= n; i++) &#123; var menu = document.getElementById(name + i); var cont = document.getElementById("con_" + name + "_" + i); menu.className = i == curr ? "up" : ""; if (i == curr) &#123; cont.style.display = "block"; &#125; else &#123; cont.style.display = "none"; &#125; &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; tab.css1234567891011121314151617181920212223242526/* CSS Document */#tab &#123; width:412px; height:216px; position:relative;margin:40px auto 0 auto;&#125;/*设置容器高宽等*/html &gt; body #tab &#123; width:412px;&#125;/*兼容IE6:IE6下宽度不够*/#tab div &#123; position:absolute; top:30px; left:0; width:412px; height:186px;&#125;/*设置容器高宽等*/#tab div &#123; display:none;&#125;/*设置容器默认隐藏:不用ID是因为下面将利用class来控制容器显示,而class优先级低于id选择器*/#tab .block &#123; display:block;&#125;/*选中的容器*/#tab h3 &#123; float:left; width:103px; height:30px; line-height:30px; margin:0 0 0 0; font-size:12px; cursor:pointer; background-color:#c5c5c5; text-align:center; color:#5a5a5a; font-family:Microsoft YaHei;font-weight:normal;&#125;/*默认标题样式*/#tab .up &#123; background:#0292cf;color:#fff;&#125;/*选中的标题样式*//*修饰列表内容*/#tab ul &#123; list-style:none; padding:0; height:186px; margin-top:0px;&#125;#tab li &#123; margin-left:10px; margin-right:10px; border-bottom:1px dotted #c6c6c6; height:22px; padding-top:23px; overflow:hidden; font-size:12px;&#125;#tab li a &#123; display:inline; font-size:12px; text-decoration:none; text-indent:10px; margin-right:10px;&#125;#tab li span&#123; display:block; float:right; margin-right:5px; color: #bdacb3;&#125;a.tab_title:link &#123; color: #5a5a5a; text-decoration:none;&#125;a.tab_title:visited &#123; color:#5a5a5a; text-decoration:none;&#125;a.tab_title:hover &#123; color:#5a5a5a; text-decoration:none;&#125;a.tab_title:active &#123; color:#5a5a5a; text-decoration:none;&#125;a.tab_menu:link &#123; color:#6464d5; text-decoration:none;&#125;a.tab_menu:hover &#123; color:#8888e0; text-decoration:underline;&#125; 参考: http://www.lanrenzhijia.com/tab ​ https://www.cnblogs.com/cheryshi/p/7903918.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring定时任务之Quartz]]></title>
    <url>%2Fblog%2F6441.html</url>
    <content type="text"><![CDATA[Spring中的定时任务功能，最好的办法当然是使用Quartz来实现。我使用的是Maven来管理项目 需要的Jar包quartz-1.8.5.jar commons-logging.jar spring-core-3.0.5.RELEASE.jar spring-beans-3.0.5.RELEASE.jar spring-context-3.0.5.RELEASE.jar spring-context-support-3.0.5.RELEASE.jar spring-asm-3.0.5.RELEASE.jar spring-expression-3.0.5.RELEASE.jar spring.transaction-3.0.5.RELEASE.jar spring-web-3.0.5.RELEASE.jar Maven的pom.xml的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;QtzTest&lt;/groupId&gt; &lt;artifactId&gt;QtzTest&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;properties&gt; &lt;springframework.version&gt;3.0.5.RELEASE&lt;/springframework.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;1.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;7.5.4.v20111024&lt;/version&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt; &lt;webApp&gt; &lt;contextPath&gt;/$&#123;project.artifactId&#125;&lt;/contextPath&gt; &lt;/webApp&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在Spring中使用Quartz有两种方式实现第一种是任务类继承QuartzJobBean 第二种则是在配置文件里定义任务类和要执行的方法，类和方法仍然是普通类。 很显然，第二种方式远比第一种方式来的灵活。 第一种方式的JAVA代码：12345678910111213141516171819package com.ncs.hj; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.springframework.scheduling.quartz.QuartzJobBean; public class SpringQtz extends QuartzJobBean&#123; private static int counter = 0; protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; System.out.println(); long ms = System.currentTimeMillis(); System.out.println("\t\t" + new Date(ms)); System.out.println(ms); System.out.println("(" + counter++ + ")"); String s = (String) context.getMergedJobDataMap().get("service"); System.out.println(s); System.out.println(); &#125; &#125; 第二种方式的JAVA代码：12345678910111213141516package com.ncs.hj; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.springframework.scheduling.quartz.QuartzJobBean; import java.util.Date; public class SpringQtz &#123; private static int counter = 0; protected void execute() &#123; long ms = System.currentTimeMillis(); System.out.println("\t\t" + new Date(ms)); System.out.println("(" + counter++ + ")"); &#125; &#125; Spring的配置文件1234567891011121314151617181920212223242526272829303132333435363738&lt;!------------ 配置调度程序quartz ，其中配置JobDetail有两种方式--------------&gt; &lt;!--方式一：使用JobDetailBean，任务类必须实现Job接口 --&gt; &lt;bean id="myjob" class="org.springframework.scheduling.quartz.JobDetailBean"&gt; &lt;property name="name" value="exampleJob"&gt;&lt;/property&gt; &lt;property name="jobClass" value="com.ncs.hj.SpringQtz"&gt;&lt;/property&gt; &lt;property name="jobDataAsMap"&gt; &lt;map&gt; &lt;entry key="service"&gt;&lt;value&gt;simple is the beat&lt;/value&gt;&lt;/entry&gt; &lt;/map&gt; ;/property&gt; &lt;/bean&gt; &lt;!--运行时请将方式一注释掉！ --&gt; &lt;!-- 方式二：使用MethodInvokingJobDetailFactoryBean，任务类可以不实现Job接口，通过targetMethod指定调用方法--&gt; &lt;!-- 定义目标bean和bean中的方法 --&gt; &lt;bean id="SpringQtzJob" class="com.ncs.hj.SpringQtz"/&gt; &lt;bean id="SpringQtzJobMethod" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject"&gt; &lt;ref bean="SpringQtzJob"/&gt; &lt;/property&gt; &lt;property name="targetMethod"&gt; &lt;!-- 要执行的方法名称 --&gt; &lt;value&gt;execute&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- ======================== 调度触发器 ======================== --&gt; &lt;bean id="CronTriggerBean" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt; &lt;property name="jobDetail" ref="SpringQtzJobMethod"&gt;&lt;/property&gt; &lt;property name="cronExpression" value="0/5 * * * * ?"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ======================== 调度工厂 ======================== --&gt; &lt;bean id="SpringJobSchedulerFactoryBean" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="CronTriggerBean"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 关于cronExpression表达式一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒][分] [小时][日] [月][星期] [年] 序号 说明 是否必填 允许填写的值 允许的符号 1 秒 是 0－59 , - * / 2 分 是 0－59 , - * / 3 小时 是 0－23 , - * / 4 日 是 1－31 , - * ? / L W 5 月 是 1－12 or JAN-DEC , - * / 6 星期 是 1-7 or SUN-SAT , - * ? / L # 7 年 否 1970-2099 , - * / 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。 “-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。 表示所有值. 如在“分”上设置“”，表示每分钟触发。“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？” “月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同 “L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题 W表示离指定日期的最近那个工作日(周一至周五).例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”). 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发； 常用示例: 0 0 12 ? 每天12点触发 0 15 10 ? 每天10点15分触发 0 15 10 ? 每天10点15分触发 0 15 10 ? * 每天10点15分触发 0 15 10 ? 2005 2005年每天10点15分触发 0 14 * ? 每天14点到14点59分之间，每分钟触发一次 0 0/5 14 ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发） 0 0/5 14，18 ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发） 0 0-5 14 ? 每天14点到14点05分之间，每分钟触发 0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发 0 15 10 ? * MON-FRI 周一到周五每天10点15分触发 0 15 10 15 * ? 每月15号10点15分触发 0 15 10 L * ? 每月最后一天的10点15分触发 0 15 10 ? * 6L 每月最后一个周五的10点15分触发 0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发 0 15 10 ? * 6#3 每月第三个周五的10点15分触发 0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次 web.xml里面配置Spring12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-config.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;/web-app&gt; 其他加载任务loadTask.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.imc.task;import java.text.ParseException;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import java.util.UUID;import org.apache.commons.lang.StringUtils;import org.quartz.JobDataMap;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.quartz.CronTriggerFactoryBean;import org.springframework.scheduling.quartz.JobDetailFactoryBean;import com.imc.entity.assist.CmsTask;import com.imc.manager.assist.CmsTaskMng;/** * @author Tom */public class LoadTask&#123; /** * 系统初始加载任务 */ public void loadTask()&#123; List&lt;CmsTask&gt;tasks=taskMng.getList(); if(tasks.size()&gt;0)&#123; for (int i = 0; i &lt; tasks.size(); i++) &#123; CmsTask task=tasks.get(i); //任务开启状态 执行任务调度 if(task.getEnable())&#123; try &#123; JobDetailFactoryBean jobDetailFactoryBean = new JobDetailFactoryBean(); //设置任务名称 if(StringUtils.isNotBlank(task.getTaskCode()))&#123; jobDetailFactoryBean.setName(task.getTaskCode()); &#125;else&#123; UUID uuid=UUID.randomUUID(); jobDetailFactoryBean.setName(uuid.toString()); task.setTaskCode(uuid.toString()); taskMng.update(task, task.getAttr()); &#125; jobDetailFactoryBean.setJobClass(getClassByTask(task.getJobClass())); //任务需要参数attr属性 jobDetailFactoryBean.setJobDataMap(getJobDataMap(task.getAttr())); jobDetailFactoryBean.setGroup(Scheduler.DEFAULT_GROUP); jobDetailFactoryBean.afterPropertiesSet(); CronTriggerFactoryBean cronTriggerFactoryBean=new CronTriggerFactoryBean(); cronTriggerFactoryBean.setBeanName("cron_" + i); cronTriggerFactoryBean.setCronExpression(taskMng.getCronExpressionFromDB(task.getId())); cronTriggerFactoryBean.setGroup(Scheduler.DEFAULT_GROUP); cronTriggerFactoryBean.setName("cron_" + i); cronTriggerFactoryBean.setDescription(""); cronTriggerFactoryBean.afterPropertiesSet(); //调度任务 scheduler.scheduleJob(jobDetailFactoryBean.getObject(), cronTriggerFactoryBean.getObject()); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; /** * * @param params 任务参数 * @return */ private JobDataMap getJobDataMap(Map&lt;String,String&gt; params)&#123; JobDataMap jdm=new JobDataMap(); Set&lt;String&gt;keySet=params.keySet(); Iterator&lt;String&gt;it=keySet.iterator(); while(it.hasNext())&#123; String key=it.next(); jdm.put(key, params.get(key)); &#125; return jdm; &#125; /** * * @param taskClassName 任务执行类名 * @return * @throws ClassNotFoundException */ private Class&lt;?&gt; getClassByTask(String taskClassName) throws ClassNotFoundException&#123; return Class.forName(taskClassName); &#125; @Autowired private CmsTaskMng taskMng; @Autowired private Scheduler scheduler;&#125; 用户同步任务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.File;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import imc.c6.api.sysuser.SysUserAPI;import imc.c6.api.sysuser.SysUserRoleAPI;import imc.c6.api.sysuser.dto.SysDept;import imc.c6.api.sysuser.dto.SysUser;import com.imc.common.util.PropertyUtils;import com.imc.common.web.springmvc.RealPathResolver;import com.imc.core.entity.CmsGroup;import com.imc.core.entity.CmsUser;import com.imc.core.entity.CmsUserExt;import com.imc.core.manager.CmsUserExtMng;import com.imc.core.manager.CmsUserMng;import com.imc.core.manager.UnifiedUserMng;import java.util.Map;public class UserDayJob&#123; private static final Logger log = LoggerFactory.getLogger(UserDayJob.class); public void execute() &#123; String a =PropertyUtils.getPropertyValue( new File(realPathResolver.get(com.imc.cms.Constants.imc_CONFIG)),"cms.usetype"); String usetype=propertyUtils.getPropertiesString("cms.usetype"); if ((usetype.equals("3"))||(usetype.equals("2")))&#123; manager.getMember(); manager.getAdmin(); &#125; &#125; @Autowired private CmsUserMng manager; @Autowired private CmsUserExtMng extManager; @Autowired protected PropertyUtils propertyUtils; @Autowired private RealPathResolver realPathResolver;&#125; 配置文件quartz-task.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" default-lazy-init="false"&gt; &lt;bean id="executor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt; &lt;property name="corePoolSize" value="10" /&gt; &lt;property name="maxPoolSize" value="100" /&gt; &lt;property name="queueCapacity" value="500" /&gt; &lt;/bean&gt; &lt;!--每日任务(内容相关) --&gt; &lt;bean id="contentDayJob" class="com.imc.task.job.ContentDayJob"&gt;&lt;/bean&gt; &lt;bean id="contentDayJobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="contentDayJob" /&gt; &lt;property name="targetMethod" value="execute" /&gt; &lt;/bean&gt; &lt;bean id="contentDayJobTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="contentDayJobDetail" /&gt; &lt;property name="cronExpression" value="0 0 0 * * ?" /&gt; &lt;/bean&gt; &lt;bean id="siteDayJob" class="com.imc.task.job.SiteDayJob"&gt;&lt;/bean&gt; &lt;bean id="siteDayJobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="siteDayJob" /&gt; &lt;property name="targetMethod" value="execute" /&gt; &lt;/bean&gt; &lt;bean id="siteDayJobTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="siteDayJobDetail" /&gt; &lt;property name="cronExpression" value="0 0 0 * * ?" /&gt; &lt;/bean&gt; &lt;!-- 用户同步任务 --&gt; &lt;bean id="userDayJob" class="com.imc.task.job.UserDayJob"&gt;&lt;/bean&gt; &lt;bean id="userDayJobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="userDayJob" /&gt; &lt;property name="targetMethod" value="execute" /&gt; &lt;/bean&gt; &lt;bean id="userDayJobTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="userDayJobDetail" /&gt; &lt;property name="cronExpression" value="*/5 * * * * ?" /&gt; &lt;/bean&gt; &lt;!-- 调度器 --&gt; &lt;bean name="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;!-- 通过applicationContextSchedulerContextKey属性配置spring上下文 --&gt; &lt;property name="applicationContextSchedulerContextKey"&gt; &lt;value&gt;applicationContext&lt;/value&gt; &lt;/property&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="contentDayJobTrigger" /&gt; &lt;ref bean="siteDayJobTrigger" /&gt; &lt;ref bean="userDayJobTrigger" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="taskExecutor" ref="executor" /&gt; &lt;/bean&gt; &lt;!--加载数据库任务--&gt; &lt;bean id="loadTask" class="com.imc.task.LoadTask" init-method="loadTask" /&gt; &lt;/beans&gt;]]></content>
      <categories>
        <category>Quartz</category>
      </categories>
      <tags>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aJax使用小结]]></title>
    <url>%2Fblog%2F7931.html</url>
    <content type="text"><![CDATA[aJax使用小结 ajax方法参数 url:要求为String类型的参数，（默认为当前页地址）发送请求的地址。 type:要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 timeout:要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 async: 要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 cache: 要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看 processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。 dataType: 要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：xml：返回XML文档，可用JQuery处理。html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。json：返回JSON数据。jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。text：返回纯文本字符串。 beforeSend： 要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。 123function(XMLHttpRequest)&#123; this; //调用本次ajax请求时传递的options参数 &#125; complete： 要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。 function(XMLHttpRequest, textStatus){ this; //调用本次ajax请求时传递的options参数 } success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。 ​ (1)由服务器返回，并根据dataType参数进行处理后的数据。 (2)描述状态的字符串。 1234function(data, textStatus)&#123; //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数 &#125; error: 要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： 1234function(XMLHttpRequest, textStatus, errorThrown)&#123; //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数 &#125; contentType： 要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。 dataFilter： 要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 1234function(data, type)&#123; //返回处理后的数据 return data; &#125; dataFilter： 要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 1234function(data, type)&#123; //返回处理后的数据 return data; &#125; global： 要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。 ifModified： 要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。 jsonp： 要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。 username： 要求为String类型的参数，用于响应HTTP访问认证请求的用户名。 password： 要求为String类型的参数，用于响应HTTP访问认证请求的密码。 processData： 要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。 scriptCharset： 要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。 标准写法12345678910111213141516$(function()&#123; $('button').click(function() &#123; var name = $(this).attr('name'); $.ajax(&#123; url : "hello.do", type : "POST", data : &#123;'search' : name&#125;, dataType: json, success : function(data)&#123; alert('success'); &#125;,error : function()&#123; alert('error'); &#125; &#125;); &#125;);&#125;); 顺便说一下$.each()函数: $.each()函数不同于JQuery对象的each()方法，它是一个全局函数，不操作JQuery对象，而是以一个数组或者对象作为第1个参数，以一个回调函数作为第2个参数。回调函数拥有两个参数：第1个为对象的成员或数组的索引，第2个为对应变量或内容。 参考 一些参数用例及解释 ajax提交到后台数据成功但返回不走success而走的error ajax不执行success回调而是执行error回调 参考API]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件的上传和下载]]></title>
    <url>%2Fblog%2F64131.html</url>
    <content type="text"><![CDATA[文件的上传和下载 文件的上传和下载绝对路径上传存的是绝对路径D:\tomct……. 123456789101112131415161718192021/** * @Description: 生成上传文件的文件名，文件名以时间+3位随机数+"_"+文件的原始名称 * @param filename 文件的原始名称 * @return 时间+3位随机数+"_"+文件的原始名称 */ private String makeFileName(String filename) &#123; // 2.jpg // 为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名 // return UUID.randomUUID().toString() + "_" + filename; // 日期格式化 DateFormat df = new SimpleDateFormat("yyyyMMddhhmmssSSS"); // 当前的时间 String name = df.format(new Date()); // 三位的随机数 Random r = new Random(); // name=时间+三位的随机数 for (int i = 0; i &lt; 3; i++) &#123; name += r.nextInt(10); // +=会自动的将int转换为string &#125; return name + "_" + filename; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 为防止一个目录下面出现太多文件，要使用hash算法打散存储 * 使用"/" 支持linux系统 * @param filename 文件名，要根据文件名生成存储目录 * @param savePath 文件存储路径 * @return 新的存储目录 */ private String makePath(String filename,String savePath)&#123; //得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址 int hashcode = filename.hashCode(); int dir1 = hashcode &amp; 0xf; //0--15 int dir2 = (hashcode &amp; 0xf0)&gt;&gt;4; //0-15 //构造新的保存目录 String dir = savePath + "/" + dir1 + "/" + dir2+"/"; //upload\2\3 upload\3\5 //File既可以代表文件也可以代表目录 File file = new File(dir); //如果目录不存在 if(!file.exists())&#123; //创建目录 file.mkdirs(); &#125; return dir; String savePath = this.getServletContext().getRealPath("/WEB-INF/upload"); File root = new File(savePath); if (!root.exists()) &#123; //创建临时目录 root.mkdir(); &#125; InputStream is = new FileInputStream(file); //得到上传文件的扩展名 .xle String fileExtName = fileFileName.substring(fileFileName.lastIndexOf(".")+1); //得到文件的真实的保存目录 String realSavePath = makePath(fileFileName, savePath); //修改文件的存储名字,防止文件多了出现重名保存失败 String storeName = makeFileName(fileFileName); //创建一个文件输出流 OutputStream os = new FileOutputStream(realSavePath + "/" + storeName); byte[] buffer = new byte[1024]; int length = 0; while(-1 != (length = is.read(buffer, 0, buffer.length))) &#123; os.write(buffer); &#125; os.close(); is.close(); //数据库存储的字段和名字 String urlAndName = realSavePath +storeName ; notice.setAttachment(urlAndName); &#125;catch (Exception e) &#123; e.printStackTrace(); return SUCCESS ; &#125; 下载文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public String download() throws ServletException, Exception &#123; HttpServletRequest req = ServletActionContext.getRequest(); Long id = Long.parseLong(req.getParameter("id")); noticeQuery.setId(id); System.out.println(); // 获取文件的全名和绝对磁盘地址 Notice notice = noticeService.selectByPrimaryKey(noticeQuery.getId()); // String urlAndName = kbm.getKbmAdjunct(); String urlAndName = notice.getAttachment(); // 处理获取到的上传文件的文件名的路径部分，只保留文件名部分 String url = urlAndName.substring(0, urlAndName.lastIndexOf("/")); String storeName = urlAndName.substring( urlAndName.lastIndexOf("/")+1); String realName = storeName.substring(storeName.indexOf("_")+1); // 上传的文件都是保存在/WEB-INF/upload目录下的子目录当中 File file = new File(url + "/" + storeName); // 如果文件不存在 if (!file.exists()) &#123; // 错误提示 this.getServletResponse().setCharacterEncoding("utf-8"); this.getServletResponse().getWriter().write("您要下载的资源已被删除！！");// servletRequest.setAttribute("message", "您要下载的资源已被删除！！");// servletRequest.getRequestDispatcher("/message.jsp").forward(// servletRequest, servletResponse); return ""; &#125; // 处理文件名 // String realname = fileStoreName.substring(fileStoreName.indexOf("_") // + 1); // 设置响应头，控制浏览器下载该文件 servletResponse.setHeader("content-disposition", "attachment;filename=" + URLEncoder.encode(realName, "UTF-8")); // 读取要下载的文件，保存到文件输入流 FileInputStream in = new FileInputStream(file); // 创建输出流 OutputStream out = servletResponse.getOutputStream(); byte buffer[] = new byte[1024]; int len = 0; // 循环将输入流中的内容读取到缓冲区当中 while ((len = in.read(buffer)) &gt; 0) &#123; // 输出缓冲区的内容到浏览器，实现文件下载 out.write(buffer, 0, len); &#125; // 关闭文件输入流 in.close(); // 关闭输出流 out.close(); return NONE; &#125; 文件上传和下载相对路径上传存的是相对路径 http://127.0.0.1/tomcat..... 1234567891011121314151617181920212223242526272829303132333435363738394041public String upload () &#123;File filePath = new File(ServletActionContext.getServletContext().getRealPath("/")); String savePath = filePath.getParentFile().getParent()+"/attachment/securitysupervision"; File root = new File(savePath); if (!root.exists()) &#123; //创建临时目录 root.mkdirs(); System.out.println( root.mkdir()); &#125; InputStream is = new FileInputStream(file); //得到上传文件的扩展名 .xls String fileExtName = fileFileName.substring(fileFileName.lastIndexOf(".")+1); //得到文件的真实的保存目录 String realSavePath = servletRequest.getScheme() + "://"+ servletRequest.getServerName() + ":" + servletRequest.getServerPort()+servletRequest.getContextPath()+"/attachment/securitysupervision/"; //String realSavePath = makePath(fileFileName, savePath); //修改文件的存储名字,防止文件多了出现重名保存失败 String storeName = makeFileName(fileFileName); //创建一个文件输出流 OutputStream os = new FileOutputStream(savePath + "\\" + storeName); byte[] buffer = new byte[1024]; int length = 0; while(-1 != (length = is.read(buffer, 0, buffer.length))) &#123; os.write(buffer); &#125; os.close(); is.close(); //数据库存储的字段和名字 String urlAndName = realSavePath +storeName ; kbm.setKbmAdjunct(urlAndName); &#125;catch (Exception e) &#123; e.printStackTrace(); return "error" ; &#125;&#125; 下载文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Kbm kbm = kbmService.selectAddrByKbmId(kbmQuery.getId()) ; String urlAndName = kbm.getKbmAdjunct(); if (urlAndName != null &amp;&amp; !urlAndName.equals("")) &#123; // 处理获取到的上传文件的文件名的路径部分，只保留文件名部分 HttpServletRequest request=ServletActionContext.getRequest(); String basePath=request.getScheme() + "://"+ request.getServerName() + ":" + request.getServerPort()+request.getContextPath(); System.out.println(basePath); String url = urlAndName.substring(basePath.length()+1, urlAndName.lastIndexOf("/")); String storeName = urlAndName.substring(urlAndName.lastIndexOf("/") + 1); String realName = storeName.substring(storeName.indexOf("_") + 1); // 上传的文件都是保存在/WEB-INF/upload目录下的子目录当中 //File file = new File(url + "" + storeName); File filePath = new File(ServletActionContext.getServletContext().getRealPath("/")); String savePath = filePath.getParentFile().getParent()+"/attachment/securitysupervision"; System.out.println(savePath); File file = new File(savePath + "/" + storeName); // 如果文件不存在 if (!file.exists()) &#123; // 错误提示 servletRequest.setAttribute("message", "您要下载的资源已被删除！！"); servletRequest.getRequestDispatcher("/message.jsp").forward( servletRequest, servletResponse); return ""; &#125; // 处理文件名 // String realname = // fileStoreName.substring(fileStoreName.indexOf("_") + 1); // 设置响应头，控制浏览器下载该文件 servletResponse.setHeader( "content-disposition", "attachment;filename=" + URLEncoder.encode(realName, "UTF-8")); // 读取要下载的文件，保存到文件输入流 FileInputStream in = new FileInputStream(file); // 创建输出流 OutputStream out = servletResponse.getOutputStream(); byte buffer[] = new byte[1024]; int len = 0; // 循环将输入流中的内容读取到缓冲区当中 while ((len = in.read(buffer)) &gt; 0) &#123; // 输出缓冲区的内容到浏览器，实现文件下载 out.write(buffer, 0, len); &#125; // 关闭文件输入流 in.close(); // 关闭输出流 out.close(); return NONE;]]></content>
      <categories>
        <category>fileUpload</category>
      </categories>
      <tags>
        <tag>fileUpload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK版本共存切换研究]]></title>
    <url>%2Fblog%2F20841.html</url>
    <content type="text"><![CDATA[JDK版本共存切换研究 场景：公司项目使用的jdk为1.7，最近不是很忙，找到一个爬虫系统学习。该系统使用到了jdk1.8的特性，所以I need 俩版本，开整！！！ 准备两个版本的jdk12jdk-7u67-windows-x64.exejdk-8u162-windows-x64.exe 安装jdk路径为：12D:\Java\JDK\JDK1.7\jdk1.7.0_67D:\Java\JDK\JDK1.8\jdk1.8.0_162 tips: win7以下电脑推荐使用Rapid Environment Editor修改电脑环境变量。 ####设置两个子JAVA_HOME 一个总，设置两个子JAVA_HOME 12JAVA_HOME7 = D:\Java\JDK\JDK1.7\jdk1.7.0_67JAVA_HOME8 = D:\Java\JDK\JDK1.8\jdk1.8.0_162 此处JAVA_HOME设置即为你更换jdk版本是所要修改的地方 1JAVA_HOME = %JAVA_HOME8% 设置path添加如下内容(注意添加’;’) 1;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 添加classpath变量 变量值 1%JAVA_HOME%lib\dt.jar;%JAVA_HOME%\lib\tools.jar 查看版本是否更换成功1java -version javac -version 若未成功，请看接下来的6 未成功解决方案1删除C:\Windows\System32目录下的java.exe,javaw.exe，javaws.exe删除即可。 若java -version和javac -version版本不一致 将%JAVA_HOME%\bin加在PATH变量的头，执行java -version和javac -version，版本已然一致。 注册表1HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment 注意：C:\Windows\System32底下的java.exe，javaw.exe，javaws.exe是JDK7的，版本就是JDK7；是JDK8的，版本就是JDK8。 安装jdk8的时候，安装过程中会在系统变量Path的最前面加上了C:\ProgramData\Oracle\Java\javapath;，这是安装jdk8的时候带出来的，并且在Path的最前面，所以无论修改注册表还是Java控制台都没有用，执行的指令在系统变量中搜寻命令时最先找到的就是C:\ProgramData\Oracle\Java\javapath;，始终是jdk8的。那么，我们需要把Path最前面的C:\ProgramData\Oracle\Java\javapath;删除，这样才能对JAVA_HOME修改来切换需要的jdk环境。 参考： JDK1.6,JDK1.7,JDK1.8安装共存问题 https://blog.csdn.net/just_coming_here/article/details/51775909 JDK7与JDK8环境共存与切换 https://www.cnblogs.com/iathanasy/p/8507647.html JDK7与JDK8共存问题小思 https://www.cnblogs.com/fxmemory/p/7234848.html]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS防止表单重复提交]]></title>
    <url>%2Fblog%2F53250.html</url>
    <content type="text"><![CDATA[JS防止表单重复提交第一种： 用flag标识，下面的代码设置checkSubmitFlg标志： 1234567891011&lt;script language="”javascript”"&gt; var checkSubmitFlg = false; function checkSubmit()&#123; if(checkSubmitFlg ==true)&#123; return false; //当表单被提交过一次后checkSubmitFlg将变为true,根据判断将无法进行提交。 &#125; checkSubmitFlg ==true; return true; &#125; &lt; /script &gt; &lt; form name=”form1” method=”post” onsubmit=”return checkSubmit();”&gt; ………..&lt; /form&gt; 第二种： 在onsubmit事件中设置，在第一次提交后使提交按钮失效，代码如下： 123456&lt;form action=”about:blank” method=”post” onsubmit="getElementById(‘submitInput').disabled=true;return true;" target=”_blank”&gt; &lt;input type=”submit” id=”submitInput”/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;/script&gt; 因为程序源码跟WIN2000的注册表有冲突，帖子发出后会出现无效页面，以致于论坛里有很多无恶意的重复帖子，后来想出了一个办法，用JS避免重复提交，下面是部分源码： 1234567891011121314151617181920212223242526272829&lt;script Language='JavaScript'&gt; function formsubmit() &#123; Today = new Date(); var NowHour = Today.getHours(); var NowMinute = Today.getMinutes(); var NowSecond = Today.getSeconds(); var mysec = (NowHour * 3600) + (NowMinute * 60) + NowSecond; if ((mysec - document.formsubmitf.mypretime.value) &gt; 600) //600只是一个时间值，就是5分钟内禁止重复提交，值随你高兴设 &#123; document.formsubmitf.mypretime.value = mysec; &#125; else &#123; alert(' 按一次就够了，请勿重复提交！请耐心等待！谢谢合作！'); return false; &#125; document.forms.formsubmitf.submit(); &#125;&lt;/script&gt;&lt;/HEAD&gt;&lt;BODY BGCOLOR="#FFFFFF"&gt; &lt;form name=formsubmitf id="the" method="post" action="XXX.asp"&gt; &lt;input type=hidden name='mypretime' value='0'&gt; //这句不能少，用隐含变量传递一个时间初值 //这里是你要提交的内容 &lt;input type="button" value="写好了" name="button1" class="4round" onclick='formsubmit()'&gt; &lt;font class="red"&gt;(请按一次，耐心等待！)&lt;/font&gt; &lt;input type="reset" value="重 写" name="button2" class="4round"&gt; &lt;/form&gt; 用了这个代码，论坛的重复帖子明显减少，不过有个缺点，就是刷新一次，检测就不起作用，好处就是利用JS检测，不需要额外的权限支持，至于效果如何，用不用就随你们了，（最好前端跟后端都加上检测）.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目操作技巧]]></title>
    <url>%2Fblog%2F44283.html</url>
    <content type="text"><![CDATA[maven项目技巧 Eclipse导入Maven项目并启动的步骤 空白处右击Import选择General里的Existing Projects into Workspace→Next，Browse找到要导入项目所在，选中要导入的项目点击确定；一定要勾选Copy projects into eorkspace→Finish； 导入本地项目之后先进行配置，配置步骤如下： (1).导入项目 右击maven→update project →OK； (2).项目名→右击→properties (3).resource 修改字体 utf-8 ​ (4).deployment assembly 点击 add 添加maven dependencies ​ (6).java compiler 中 compiler compliance settings 选1.6 ​ (7)找到Project Facets 查看Java是改为1.6； ​ (8)如果JRE版本不对，应该首先右击Properties选择Workspacec default JRE(jre6)点击OK； 导入数据库数据步骤如下: (1).在localhost创建一个数据库，名字与导入文件一致； (2)右击选择运行SQL文件；数据库中导入数据文件，选择好要导入的文件，不勾选“每个运行中运行多重查询”和“SETAUTOCOMMIT=0”；开始即可 导入之后将资源文件中关于数据库的配置用户名密码改成需要的即可； 建server部署项目启动即可 eclipse maven项目导出所使用的jar包方法 在eclipse中定位到maven项目的pom.xml文件 右击pom.xml文件，选择Run As–》Run Configurations（或者Maven build…） 在打开的页面中，Goals输入“dependency:copy-dependencies”，后点击“Run”即可 在当前项目的目录的“targed/dependency”下就可以看见。 方法2 或者：在dos环境，进入到pom.xml所在的文件夹。 输入命令：mvn dependency:copy-dependencies 也可在当前项目的目录的“targed/dependency”下开间maven项目引用的jar包。eclipse 中maven项目的运行 eclispe maven项目运行 项目构建时，右键pom.xml文件，选择Run As–》Run Configurations（或者Maven build…） Golas:中输入项目构建命令，比如compile, run后就开始编译了。 开发中代码的运行调试，找到要运行的java代码运行，和普通的Java代码一样运行就可以了。]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 文件上传及下载]]></title>
    <url>%2Fblog%2F25709.html</url>
    <content type="text"><![CDATA[Java 文件上传及下载 文件上传 文件上传操作通常会附加一些限制，如：文件类型、上传文件总大小、每个文件的最大大小等。除此以外，作为一个通用组件还需要考虑更多的问题，如：支持自定义文件保存目录、支持相对路径和绝对路径、支持自定义保存的文件的文件名称、支持上传进度反馈和上传失败清理等。另外，本座也不想重新造车轮，本组件是基于 Commons File Upload 实现，省却了本座大量的工作 ^_^ 下面先从一个具体的使用例子讲起： 上传请求界面及代码 123456789101112131415161718192021222324252627282930313233&lt;form action="checkupload.action" method="post" enctype="multipart/form-data"&gt; First Name: &lt;input type="text" name="firstName" value="丑"&gt; &lt;br&gt; Last Name: &lt;input type="text" name="lastName" value="怪兽"&gt; &lt;br&gt; Birthday: &lt;input type="text" name="birthday" value="1978-11-03"&gt; &lt;br&gt; Gender: 男 &lt;input type="radio"" name="gender" value="false"&gt; &amp;nbsp;女 &lt;input type="radio"" name="gender" value="true" checked="checked"&gt; &lt;br&gt; Working age: &lt;select name="workingAge"&gt; &lt;option value="-1"&gt;-请选择-&lt;/option&gt; &lt;option value="3"&gt;三年&lt;/option&gt; &lt;option value="5" selected="selected"&gt;五年&lt;/option&gt; &lt;option value="10"&gt;十年&lt;/option&gt; &lt;option value="20"&gt;二十年&lt;/option&gt; &lt;/select&gt; &lt;br&gt; Interest: 游泳 &lt;input type="checkbox" name="interest" value="1" checked="checked"&gt; &amp;nbsp;打球 &lt;input type="checkbox" name="interest" value="2" checked="checked"&gt; &amp;nbsp;下棋 &lt;input type="checkbox" name="interest" value="3"&gt; &amp;nbsp;打麻将 &lt;input type="checkbox" name="interest" value="4"&gt; &amp;nbsp;看书 &lt;input type="checkbox" name="interest" value="5" checked="checked"&gt; &lt;br&gt; Photo 1.1: &lt;input type="file"" name="photo-1"&gt; &lt;br&gt; Photo 1.2: &lt;input type="file"" name="photo-1"&gt; &lt;br&gt; Photo 2.1: &lt;input type="file"" name="photo-2"&gt; &lt;br&gt; &lt;br&gt; &lt;input type="submit" value="确 定"&gt;&amp;nbsp;&amp;nbsp;&lt;input type="reset" value="重 置"&gt;&lt;/form&gt; 从上面的 HTML 代码可以看出，表单有 6 个普通域和 3 个文件域，其中前两个文件域的 name 属性相同。 上传处理代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import com.bruce.util.BeanHelper;import com.bruce.util.Logger;import com.bruce.util.http.FileUploader;import com.bruce.util.http.FileUploader.FileInfo;import static com.bruce.util.http.FileUploader.*;@SuppressWarnings("unused")public class CheckUpload extends ActionSupport&#123; // 上传路径 private static final String UPLOAD_PATH = "upload"; // 可接受的文件类型 private static final String[] ACCEPT_TYPES = &#123;"txt", "pdf", "doc", ".Jpg", "*.zip", "*.RAR"&#125;; // 总上传文件大小限制 private static final long MAX_SIZE = 1024 * 1024 * 100; // 单个传文件大小限制 private static final long MAX_FILE_SIZE = 1024 * 1024 * 10; @Override public String execute() &#123; // 创建 FileUploader 对象 FileUploader fu = new FileUploader(UPLOAD_PATH, ACCEPT_TYPES, MAX_SIZE, MAX_FILE_SIZE); // 根据实际情况设置对象属性（可选） /* fu.setFileNameGenerator(new FileNameGenerator() &#123; @Override public String generate(FileItem item, String suffix) &#123; return String.format("%d_%d", item.hashCode(), item.get().hashCode()); &#125; &#125;); fu.setServletProgressListener(new ProgressListener() &#123; @Override public void update(long pBytesRead, long pContentLength, int pItems) &#123; System.out.printf("%d: length -&gt; %d, read -&gt; %d.n", pItems, pContentLength, pBytesRead); &#125; &#125;); */ // 执行上传并获取操作结果 Result result = fu.upload(getRequest(), getResponse()); // 检查操作结果 if(result != FileUploader.Result.SUCCESS) &#123; // 设置 request attribute setRequestAttribute("error", fu.getCause()); // 记录日志 Logger.exception(fu.getCause(), "upload file fail", Level.ERROR, false); return ERROR; &#125; // 通过非文件表单域创建 Form Bean Persion persion = BeanHelper.createBean(Persion.class, fu.getParamFields()); // 图片保存路径的列表 List&lt;String&gt; photos = new ArrayList&lt;String&gt;(); /* 轮询文件表单域，填充 photos */ Set&lt;String&gt; keys = fu.getFileFields().keySet(); for(String key : keys) &#123; FileInfo[] ffs = fu.getFileFields().get(key); for(FileInfo ff : ffs) &#123; photos.add(String.format("(%s) %s%s%s", key, fu.getSavePath(), File.separator, ff.getSaveFile().getName())); &#125; &#125; // 设置 Form Bean 的 photos 属性 persion.setPhotos(photos); // 设置 request attribute setRequestAttribute("persion", persion); return SUCCESS; &#125;&#125; public class Persion&#123; private String firstName; private String lastName; private Date birthday; private boolean gender; private int workingAge; private int[] interest; private List&lt;String&gt; photos;&#125; public static class FileInfo&#123; private String uploadFileName; private File saveFile;&#125; 分析下上面的 Java 代码，本例先根据保存目录、文件大小限制和文件类型限制创建一个 FileUploader 对象，然后调用该对象的 upload() 方法执行上传并返回操作结果，如果上传成功则 通过 getParamFields() 方法获取所有非文件表单域内容，并交由 BeanHelper 进行解析创建 Form Bean，再调用 getFileFields() 方法获取所有文件表单域的 FileInfo（FileInfo 包含上传文件的原始名称和被保存文件的 File 对象），最后完成 Form Bean 所有字段的填充并把 Form Bean 设置为 request 属性。 上传结果界面及代码 1234567891011121314&lt;table border="1"&gt;&lt;caption&gt;Persion Attributs&lt;/caption&gt; &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;&lt;c:out value="$&#123;persion.firstName&#125; $&#123;persion.lastName&#125;"/&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Brithday&lt;/td&gt;&lt;td&gt;&lt;c:out value="$&#123;persion.birthday&#125;"/&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Gender&lt;/td&gt;&lt;td&gt;&lt;c:out value="$&#123;persion.gender&#125;"/&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Working Age&lt;/td&gt;&lt;td&gt;&lt;c:out value="$&#123;persion.workingAge&#125;"/&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Interest&lt;/td&gt;&lt;td&gt;&lt;c:forEach var="its" items="$&#123;persion.interest&#125;"&gt; &lt;c:out value="$&#123;its&#125;" /&gt; &amp;nbsp; &lt;/c:forEach&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Photos&lt;/td&gt;&lt;td&gt;&lt;c:forEach var="p" items="$&#123;persion.photos&#125;"&gt; &lt;c:out value="$&#123;p&#125;" /&gt;&lt;br&gt; &lt;/c:forEach&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 从上面的处理结果可以看出，文件上传组件 FileUploader 正确地处理了表单的所有文件域和非文件域名，并且，整个文件上传操作过程非常简单，无需用户过多参与。下面我们来详细看看组件的主要实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278public class FileUploader&#123; / 不限制文件上传总大小的 Size Max 常量 */ public static final long NO_LIMIT_SIZE_MAX = -1; / 不限制文件上传单个文件大小的 File Size Max 常量 */ public static final long NO_LIMIT_FILE_SIZE_MAX = -1; / 默认的写文件阀值 */ public static final int DEFAULT_SIZE_THRESHOLD = DiskFileItemFactory.DEFAULT_SIZE_THRESHOLD; / 默认的文件名生成器 */ public static final FileNameGenerator DEFAULT_FILE_NAME_GENERATOR = new CommonFileNameGenerator(); / 设置上传文件的保存路径（不包含文件名） * * 文件路径，可能是绝对路径或相对路径&lt;br&gt; * 1) 绝对路径：以根目录符开始（如：'/'、'D:'），是服务器文件系统的路径&lt;br&gt; * 2) 相对路径：不以根目录符开始，是相对于 WEB 应用程序 Context 的路径，（如：mydir 是指 * '$&#123;WEB-APP-DIR&#125;/mydir'）&lt;br&gt; * 3) 规则：上传文件前会检查该路径是否存在，如果不存在则会尝试生成该路径，如果生成失败则 * 上传失败并返回 &#123;@link Result#INVALID_SAVE_PATH&#125; * */ private String savePath; / 文件上传的总文件大小限制 */ private long sizeMax = NO_LIMIT_SIZE_MAX; / 文件上传的单个文件大小限制 */ private long fileSizeMax = NO_LIMIT_FILE_SIZE_MAX; / 可接受的上传文件类型集合，默认：不限制 */ private Set&lt;String&gt; acceptTypes = new LStrSet(); / 非文件表单域的映射 */ private Map&lt;String, String[]&gt; paramFields = new HashMap&lt;String, String[]&gt;(); / 文件表单域的映射 */ private Map&lt;String, FileInfo[]&gt; fileFields = new HashMap&lt;String, FileInfo[]&gt;(); / 文件名生成器 */ private FileNameGenerator fileNameGenerator = DEFAULT_FILE_NAME_GENERATOR; // commons file upload 相关属性 private int factorySizeThreshold = DEFAULT_SIZE_THRESHOLD; private String factoryRepository; private FileCleaningTracker factoryCleaningTracker; private String servletHeaderencoding; private ProgressListener servletProgressListener; / 文件上传失败的原因（文件上传失败时使用） */ private Throwable cause; / 执行上传 * * @param request : &#123;@link HttpServletRequest&#125; 对象 * @param response : &#123;@link HttpServletResponse&#125; 对象 * * @return : 成功：返回 &#123;@link Result#SUCCESS&#125; ，失败：返回其他结果， * 失败原因通过 &#123;@link FileUploader#getCause()&#125; 获取 * */ @SuppressWarnings("unchecked") public Result upload(HttpServletRequest request, HttpServletResponse response) &#123; reset(); // 获取上传目录绝对路径 String absolutePath = getAbsoluteSavePath(request); if(absolutePath == null) &#123; cause = new FileNotFoundException(String.format("path '%s' not found or is not directory", savePath)); return Result.INVALID_SAVE_PATH; &#125; ServletFileUpload sfu = getFileUploadComponent(); List&lt;FileItemInfo&gt; fiis = new ArrayList&lt;FileItemInfo&gt;(); List&lt;FileItem&gt; items = null; Result result = Result.SUCCESS; // 获取文件名生成器 String encoding = servletHeaderencoding != null ? servletHeaderencoding : request.getCharacterEncoding(); FileNameGenerator fnGenerator = fileNameGenerator != null ? fileNameGenerator : DEFAULT_FILE_NAME_GENERATOR; try &#123; // 执行上传操作 items = (List&lt;FileItem&gt;)sfu.parseRequest(request); &#125; catch (FileUploadException e) &#123; cause = e; if(e instanceof FileSizeLimitExceededException) result = Result.FILE_SIZE_EXCEEDED; else if(e instanceof SizeLimitExceededException) result = Result.SIZE_EXCEEDED; else if(e instanceof InvalidContentTypeException) result = Result.INVALID_CONTENT_TYPE; else if(e instanceof IOFileUploadException) result = Result.FILE_UPLOAD_IO_EXCEPTION; else result = Result.OTHER_PARSE_REQUEST_EXCEPTION; &#125; if(result == Result.SUCCESS) &#123; // 解析所有表单域 result = parseFileItems(items, fnGenerator, absolutePath, encoding, fiis); if(result == Result.SUCCESS) // 保存文件 result = writeFiles(fiis); &#125; return result; &#125; // 解析所有表单域 private Result parseFileItems(List&lt;FileItem&gt; items, FileNameGenerator fnGenerator, String absolutePath, String encoding, List&lt;FileItemInfo&gt; fiis) &#123; for(FileItem item : items) &#123; if(item.isFormField()) // 解析非文件表单域 parseFormField(item, encoding); else &#123; if(item.getSize() == 0) continue; // 解析文件表单域 Result result = parseFileField(item, absolutePath, fnGenerator, fiis); if(result != Result.SUCCESS) &#123; reset(); cause = new InvalidParameterException(String.format("file '%s' not accepted", item.getName())); return result; &#125; &#125; &#125; return Result.SUCCESS; &#125; // 解析文件表单域 private Result parseFileField(FileItem item, String absolutePath, FileNameGenerator fnGenerator, List&lt;FileItemInfo&gt; fiis) &#123; String suffix = null; String uploadFileName = item.getName(); boolean isAcceptType = acceptTypes.isEmpty(); if(!isAcceptType) &#123; suffix = null; int stuffPos = uploadFileName.lastIndexOf("."); if(stuffPos != -1) &#123; suffix = uploadFileName.substring(stuffPos, uploadFileName.length()).toLowerCase(); isAcceptType = acceptTypes.contains(suffix); &#125; &#125; if(!isAcceptType) return Result.INVALID_FILE_TYPE; // 通过文件名生成器获取文件名 String saveFileName = fnGenerator.generate(item, suffix); if(!saveFileName.endsWith(suffix)) saveFileName += suffix; String fullFileName = absolutePath + File.separator + saveFileName; File saveFile = new File(fullFileName); FileInfo info = new FileInfo(uploadFileName, saveFile); // 添加表单域文件信息 fiis.add(new FileItemInfo(item, saveFile)); addFileField(item.getFieldName(), info); return Result.SUCCESS; &#125; private void parseFormField(FileItem item, String encoding) &#123; String name = item.getFieldName(); String value = item.getString(); // 字符串编码转换 if(!GeneralHelper.isStrEmpty(value) &amp;&amp; encoding != null) &#123; try &#123; value = new String(value.getBytes("ISO-8859-1"), encoding); &#125; catch(UnsupportedEncodingException e) &#123; &#125; &#125; // 添加表单域名/值映射 addParamField(name, value); &#125; / 文件名生成器接口 * * 每次保存一个上传文件前都需要调用该接口的 &#123;@link FileNameGenerator#generate&#125; 方法生成要保存的文件名 * */ public static interface FileNameGenerator &#123; / 文件名生成方法 * * @param item : 上传文件对应的 &#123;@link FileItem&#125; 对象 * @param suffix : 上传文件的后缀名 * */ String generate(FileItem item, String suffix); &#125; / 默认通用文件名生成器 * * 实现 &#123;@link FileNameGenerator&#125; 接口，根据序列值和时间生成唯一文件名 * */ public static class CommonFileNameGenerator implements FileNameGenerator &#123; private static final int MAX_SERIAL = 999999; private static final AtomicInteger atomic = new AtomicInteger(); private static int getNextInteger() &#123; int value = atomic.incrementAndGet(); if(value &gt;= MAX_SERIAL) atomic.set(0); return value; &#125; / 根据序列值和时间生成 'XXXXXX_YYYYYYYYYYYYY' 格式的唯一文件名 */ @Override public String generate(FileItem item, String suffix) &#123; int serial = getNextInteger(); long millsec = System.currentTimeMillis(); return String.format("%06d_%013d", serial, millsec); &#125; &#125; / 上传文件信息结构体 */ public static class FileInfo &#123; private String uploadFileName; private File saveFile; // getters and setters ... &#125; private class FileItemInfo &#123; FileItem item; File file; // getters and setters ... &#125; / 文件上传结果枚举值 */ public static enum Result &#123; / 成功 */ SUCCESS, / 失败：文件总大小超过限制 */ SIZE_EXCEEDED, / 失败：单个文件大小超过限制 */ FILE_SIZE_EXCEEDED, / 失败：请求表单类型不正确 */ INVALID_CONTENT_TYPE, / 失败：文件上传 IO 错误 */ FILE_UPLOAD_IO_EXCEPTION, / 失败：解析上传请求其他异常 */ OTHER_PARSE_REQUEST_EXCEPTION, / 失败：文件类型不正确 */ INVALID_FILE_TYPE, / 失败：文件写入失败 */ WRITE_FILE_FAIL, / 失败：文件的保存路径不正确 */ INVALID_SAVE_PATH; &#125;&#125; 应用可以实现自己的 FileNameGenerator 类替代默认的文件名生成器。 上传操作通过 FileUploader.Result 返回结果，并没有采用抛出异常的方式，因为本座认为在这里采用异常方式报告结果其实并不方便使用；另一方面，程序可以通过 getCause() 获取详细的错误信息。 文件下载 相对于文件上传，文件下载则简单很多，主要实现流程是根据文件名找到实际文件，并利用 Java 的相关类对 I/O 流进行读写。下面先看看一个使用示例： 1234567891011121314151617181920212223242526272829import static com.bruce.util.http.FileDownloader.*;public class TestDownload extends ActionSupport&#123; // 绝对路径 private static final String ABSOLUTE_PATH = "/Server/apache-tomcat-6.0.32/webapps/portal/download/下载测试 - 文本文件.txt"; // 相对路径 private static final String RELATE_PATH = "download/下载测试 - 项目框架.jpg"; @Override public String execute() &#123; int type = getIntParam("type", 1); String filePath = (type == 1 ? ABSOLUTE_PATH : RELATE_PATH); // 创建 FileDownloader 对象 FileDownloader fdl = new FileDownloader(filePath); // 执行下载 Result result = fdl.downLoad(getRequest(), getResponse()); // 检查下载结果 if(result != Result.SUCCESS) &#123; // 记录日志 Logger.exception(fdl.getCause(), String.format("download file '%s' fail", fdl.getFilePath()), Level.ERROR, false); &#125; return NONE; &#125;&#125; 从这个示例可以看出，文件下载组件的使用方法更简单，因为它不需要对下载结果进行很多处理。可以看出该组件也支持相对路径和绝对路径。下面我们来详细看看组件的主要实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/ 文件下载器 */public class FileDownloader&#123; / 默认字节交换缓冲区大小 */ public static final int DEFAULT_BUFFER_SIZE = 1024 * 4; / 下载文件的默认 Mime Type */ public static final String DEFAULT_CONTENT_TYPE = "application/force-download"; / 设置下载文件的路径（包含文件名） * * filePath : 文件路径，可能是绝对路径或相对路径&lt;br&gt; * 1) 绝对路径：以根目录符开始（如：'/'、'D:'），是服务器文件系统的路径&lt;br&gt; * 2) 相对路径：不以根目录符开始，是相对于 WEB 应用程序 Context 的路径，（如：mydir/myfile 是指 '$&#123;WEB-APP-DIR&#125;/mydir/myfile'） */ private String filePath; / 显示在浏览器的下载对话框中的文件名称，默认与 filePath 参数中的文件名一致 */ private String saveFileName; / 下载文件的 Mime Type，默认：&#123;@link FileDownloader#DEFAULT_CONTENT_TYPE&#125; */ private String contentType = DEFAULT_CONTENT_TYPE; / 字节缓冲区大小，默认：&#123;@link FileDownloader#DEFAULT_CONTENT_TYPE&#125; */ private int bufferSize = DEFAULT_BUFFER_SIZE; / 获取文件下载失败的原因（文件下载失败时使用） */ private Throwable cause; / 执行下载 * * @param request : &#123;@link HttpServletRequest&#125; 对象 * @param response : &#123;@link HttpServletResponse&#125; 对象 * * @return : 成功：返回 &#123;@link Result#SUCCESS&#125; ，失败：返回其他结果， * 失败原因通过 &#123;@link FileDownloader#getCause()&#125; 获取 * */ public Result downLoad(HttpServletRequest request, HttpServletResponse response) &#123; reset(); try &#123; // 获取要下载的文件的 File 对象 File file = getFile(request); // 执行下载操作 downLoadFile(request, response, file); &#125; catch(Exception e) &#123; cause = e; if(e instanceof FileNotFoundException) return Result.FILE_NOT_FOUND; if(e instanceof IOException) return Result.READ_WRITE_FAIL; return Result.UNKNOWN_EXCEPTION; &#125; return Result.SUCCESS; &#125; // 执行下载操作 private void downLoadFile(HttpServletRequest request, HttpServletResponse response, File file) throws IOException &#123; String fileName = new String(saveFileName.getBytes(), "ISO-8859-1"); // 解析 HTTP 请求头，获取文件的读取范围 Range&lt;Integer&gt; range = parseDownloadRange(request); int length = (int)file.length(); int begin = 0; int end = length - 1; // 设置 HTTP 响应头 response.setContentType(contentType); response.setContentLength(length); response.setHeader("Content-Disposition", "attachment;filename=" + fileName); // 确定文件的读取范围（用于断点续传） if(range != null) &#123; if(range.getBegin() != null) &#123; begin = range.getBegin(); if(range.getEnd() != null) end = range.getEnd(); &#125; else &#123; if(range.getEnd() != null) begin = end + range.getEnd() + 1; &#125; String contentRange = String.format("bytes %d-%d/%d", begin, end, length); response.setHeader("Accept-Ranges", "bytes"); response.setHeader("Content-Range", contentRange); response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); &#125; // 实际执行下载操作 doDownloadFile(response, file, begin, end); &#125; // 实际执行下载操作 private void doDownloadFile(HttpServletResponse response, File file, int begin, int end) throws IOException &#123; InputStream is = null; OutputStream os = null; try &#123; byte[] b = new byte[bufferSize]; is = new BufferedInputStream(new FileInputStream(file)); os = new BufferedOutputStream(response.getOutputStream()); // 跳过已下载的文件内容 is.skip(begin); // I/O 读写 for(int i, left = end - begin + 1; left &gt; 0 &amp;&amp; ((i = is.read(b, 0, Math.min(b.length, left))) != -1); left -= i) os.write(b, 0, i); os.flush(); &#125; finally &#123; if(is != null) &#123;try&#123;is.close();&#125; catch(IOException e) &#123;&#125;&#125; if(os != null) &#123;try&#123;os.close();&#125; catch(IOException e) &#123;&#125;&#125; &#125; &#125; / 文件下载结果枚举值 */ public static enum Result &#123; / 成功 */ SUCCESS, / 失败：文件不存在 */ FILE_NOT_FOUND, / 失败：读写操作失败 */ READ_WRITE_FAIL, / 失败：未知异常 */ UNKNOWN_EXCEPTION; &#125;&#125;]]></content>
      <categories>
        <category>fileupload</category>
      </categories>
      <tags>
        <tag>fileupload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO Path and Files]]></title>
    <url>%2Fblog%2F58642.html</url>
    <content type="text"><![CDATA[Java NIO Path接口和Files类配合操作文件 Path接口 1、Path表示的是一个目录名序列，其后还可以跟着一个文件名，路径中第一个部件是根部件时就是绝对路径，例如 / 或 C:\ ，而允许访问的根部件取决于文件系统； 2、以根部件开始的路径是绝对路径，否则就是相对路径； 3、静态的Paths.get方法接受一个或多个字符串，字符串之间自动使用默认文件系统的路径分隔符连接起来（Unix是 /，Windows是 \ ），这就解决了跨平台的问题，接着解析连接起来的结果，如果不是合法路径就抛出InvalidPathException异常，否则就返回一个Path对象； 123//假设是Unix的文件系统Path absolute = Paths.get("/home", "cat"); //绝对路径 Path relative = Pahts.get("ixenos", "config", "user.properties"); //相对路径 4、由String路径获取Path对象 get还可以获取一整条路径（即多个部件构成的单个字符串），例如从配置文件中读取路径： 123String baseDir = properties.getProperty("base.dir"); //可能获得 /opt/ixenos 或者 C:\Program Files\ixenos Path basePath = Paths.get(baseDir); 5、组合或解析路径 1) 调用 p.resolve(q) 将按下面的规则返回一个Path：如果q是绝对路径，则返回q，否则追加路径返回 p/q 或者 p\q 1234Path workRelative = Paths.get("work");Path workPath = basePath.resolve(workRelative); //resolve也可以接受字符串形参Path workPath = basePath.resolve("work"); 2) 调用 p.resolveSibling(“q”) 将解析指定路径 p 的父路径 o ，并产生兄弟路径 o/q 12345Path tempPath = workPath.resolveSibling("temp"); /* 如果workPath是 /opt/ixenos/work 那么将创建 /opt/ixenos/temp */ 3) 调用 p.relativize(r) 将产生一个冗余路径q，对q进行解析将产生相对路径r，最终r不包含和p的交集路径 123456789101112/* pathA为 /home/misty pathB为 /home/ixenos/config 现已pathA对pathB进行相对化操作，将产生冗余路径*/Path pathC = pathA.relativize(pathB); //此时pathC为 ../ixenos/config/* normalize方法将移除冗余部件*/Path pathD = pathC.normalize(); //pathD为 /ixenos/config 4) toAbsolutePath 将产生给定路径的绝对路径，从根部件开始 5) Path类还有一些有用的断开和组合路径的方法，比如 getParent、getFileName、getRoot//获得根目录 6) Path有个toFile方法用来跟遗留类File类打交道，File类也有个toPath方法 Files工具类 1、读写文件方法签名: 12static path **write**(Path path, byte[] bytes, OpenOption... options) static path write(Path path, Iterable&lt;? extends CharSequence&gt; lines, OpenOption... options) 这里只列举下面用到的方法，更多方法请看API文档… 其中OpenOption是个nio接口，StandardOpenOption是其枚举实现类，各枚举实例功能请查看API文档 123456789101112131415161718192021/* Files提供的简便方法适用于处理中等长度的文本文件 如果要处理的文件长度较大，或者二进制文件，那么还是应该使用经典的IO流 *///将文件所有内容读入byte数组中byte[] bytes = Files.readAllBytes(path); //传入Path对象//之后可以根据字符集构建字符串String content = new String(bytes, charset);//也可以直接当作行序列读入List&lt;String&gt; lines = Files.readAllLines(path, charset);//相反，也可以写一个字符串到文件中，默认是覆盖Files.write(path, content.getBytes(charset)); //传入byte[]//追加内容，根据参数决定追加等功能Files.write(path, content.getBytes(charset), StandardOpenOption.APPEND); //传入枚举对象，打开追加开关//将一个行String的集合List写出到文件中Files.write(path, lines); 2、复制、剪切、删除方法签名: 1234 static path copy(Path source, Path target, CopyOption... options) static path move(Path source, Path target, CopyOption... options)static void delete(Path path) //如果path不存在文件将抛出异常，此时调用下面的比较好 static boolean deleteIfExists(Path path) 这里只列举下面用到的方法，更多方法请看API文档… 其中CopyOption是个nio接口，StandardCopyOption是其枚举实现类，各枚举实例功能请查看API文档 其中有个ATOMIC_MOVE可以填入用来保证原子性操作，要么移动成功完成，要么源文件保持在原位置 12345678910//复制Files.copy(fromPath, toPath);//剪切Files.move(fromPath, toPath);/* 以上如果toPath已存在，那么操作失败， 如果要覆盖，需传入参数REPLACE_EXISTING 还要复制文件属性，传入COPY_ATTRIBUTES*/Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES); 3、创建文件和目录123456789101112//创建新目录，除了最后一个部件，其他必须是已存在的Files.createDirectory(path); //创建路径中的中间目录，能创建不存在的中间部件Files.createDirectories(path);/* 创建一个空文件，检查文件存在，如果已存在则抛出异常 而检查文件存在是原子性的，因此在此过程中无法执行文件创建操作*/Files.createFile(path);//添加前/后缀创建临时文件或临时目录Path newPath = Files.createTempFile(dir, prefix, suffix);Path newPath = Files.createTempDirectory(dir, prefix); 4、获取文件信息略，具体看API文档，或者corejava page51 5、迭代目录中的文件 旧的File类有两个方法获取目录中所有文件构成的字符串数组，String[] list() 和String[] list(FileFilter filter)，但是当目录中包含大量文件时，这两方法性能会非常低。 原因分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//File类list所有文件 public String[] list() &#123; SecurityManager security = System.getSecurityManager(); //文件系统权限获取 if (security != null) &#123; security.checkRead(path); &#125; if (isInvalid()) &#123; return null; &#125; return fs.list(this); //底层调用FileSystem的list &#125; //FileSystem抽象类的list //File类中定义fs是由DefaultFileSystem静态生成的private static final FileSystem fs = DefaultFileSystem.getFileSystem();//因此我们来看一下DefaultFileSystem类，发现是生成一个WinNtFileSystem对象class DefaultFileSystem &#123; /** * Return the FileSystem object for Windows platform. */ public static FileSystem getFileSystem() &#123; return new WinNTFileSystem(); &#125;&#125;//而WinNtFileSystem类继承于FileSystem抽象类，这里我们主要观察它的list(File file)方法 @Overridepublic native String[] list(File f);/*我们可以看到这是个native方法，说明list的操作是由操作系统的文件系统控制的，当目录中包含大量的文件时，这个方法的性能将会非常低。由此为了替代，NIO的Files类设计了newDirectoryStream(Path dir)及其重载方法，将生成Iterable对象（可用foreach迭代）*///~ //回调过滤 public String[] list(FilenameFilter filter) &#123; //采用接口回调 String names[] = list(); //调用list所有 if ((names == null) || (filter == null)) &#123; return names; &#125; List&lt;String&gt; v = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; names.length ; i++) &#123; if (filter.accept(this, names[i])) &#123; //回调FilenameFileter对象的accept方法 v.add(names[i]); &#125; &#125; return v.toArray(new String[v.size()]); &#125; 这时候高科技来了——Files获得可迭代的目录流，传入一个目录Path，遍历子孙目录返回一个目录Path的Stream，注意这里所有涉及的Path都是目录而不是文件！因此，Files类设计了newDirectoryStream(Path dir)及其重载方法，将生成Iterable对象（可用foreach迭代） 遍历目录得到一个可迭代的子孙文件集合 staticDirectoryStream&lt;Path&gt; newDirectoryStream(Path dir)Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. staticDirectoryStream&lt;Path&gt; newDirectoryStream(Path dir, DirectoryStream.Filter&lt;? superPath&gt; filter)Opens a directory, returning a DirectoryStream to iterate over the entries in the directory. staticDirectoryStream&lt;Path&gt; newDirectoryStream(Path dir, String glob) 返回一个 目录流 ，可以看成一个存放着全部Path的实现了Iterable的集合， 因此可用迭代器或foreach迭代，只是使用迭代器的时候要注意不能invoke另一个Iterator： While DirectoryStream extends Iterable, it is not a general-purpose Iterable as it supports only a single Iterator; invoking the iterator method to obtain a second or subsequent iterator throws IllegalStateException. 示例： 1234567try(DirectoryStream&lt;Path&gt; entries = Files.newDirectoryStream(dir))&#123; for(Path entry : entries) &#123; ... &#125;&#125; 可以传入glob参数，即使用glob模式来过滤文件（以取代list(FileFilter filter)：newDirectoryStream(Path dir, String glob) 注意是String类型 1234try(DirectoryStream&lt;Path&gt; entries = Files.newDirectoryStream(dir, "*.java")) //&#123; ...&#125; glob模式 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 1.星号 匹配路径组成部分0个或多个字符；例如 .java 匹配当前目录中的所有Java文件 2.两星号 匹配跨目录边界0个或多个字符；例如 .java 匹配在所有子目录中的Java文件 3.问号（?）只匹配一个字符；例如 ????.java 匹配所有四个字符的Java文件，不包括扩展名；使用?是因为*是通配符不指定数量 4.[…] 匹配一个字符集合，可以用连线 [0-9] 和取反符 [!0-9]；例如 Test[0-9A-F].java 匹配Testx.java，假设x是一个十六进制数字，[0-9A-F]是匹配单个字符为十六进制数字，比如B（十六进制不区分大小写） 如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 5.{…} 匹配由逗号隔开的多个可选项之中的一个；例如 *.{java,class} 匹配所有Java文件和类class文件 6.\ 转义上述任意模式中的字符；例如 ** 匹配所有子目录中文件名包含的文件，这里为 ** 转义，前面是匹配0个或多个字符 下面是网友总结的Glob模式： Glob模式 描述 *.txt 匹配所有扩展名为.txt的文件 *.{html,htm} 匹配所有扩展名为.html或.htm的文件。{ }用于组模式，它使用逗号分隔 ?.txt 匹配任何单个字符做文件名且扩展名为.txt的文件 . 匹配所有含扩展名的文件 C:\Users* 匹配所有在C盘Users目录下的文件。反斜线“\”用于对紧跟的字符进行转义 /home/** UNIX平台上匹配所有/home目录及子目录下的文件。**用于匹配当前目录及其所有子目录 [xyz].txt 匹配所有单个字符作为文件名，且单个字符只含“x”或“y”或“z”三种之一，且扩展名为.txt的文件。方括号[]用于指定一个集合 [a-c].txt 匹配所有单个字符作为文件名，且单个字符只含“a”或“b”或“c”三种之一，且扩展名为.txt的文件。减号“-”用于指定一个范围，且只能用在方括号[]内 [!a].txt 匹配所有单个字符作为文件名，且单个字符不能包含字母“a”，且扩展名为.txt的文件。叹号“!”用于否定 遍历得到某个目录的所有子孙文件集合再迭代不够爽？来，我们来直接遍历某个目录的所有子孙成员（包括目录和文件） 我们可以调用Files类的walkFileTree方法，并传入一个FileVisitor接口类型的对象（还有更多方法在API里等你发现……） 12345678910111213141516/*传入一个FileVisitor子类的匿名对象*/Files.walkFileTree(dir, new SimpleFileVisitor&lt;Path&gt;() &#123; //walkFileTree回调此方法来遍历所有子孙 public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException &#123; if(attrs.isDirectory()) //自定义的选择，属于业务代码，这和walkFileTree的宗旨(遍历所有子孙成员)无关 System.out.println(path); return FileVisitResult.CONTINUE; &#125; public FileVisitResult visitFileFailed(Path path, IOException exc) throws IOException &#123; return FileVisitResult.CONTINUE; &#125; &#125;); 咱们来总结一下，12Files.newDirectoryStream(Path dir) //遍历后返回一个可迭代的子孙文件集合；Files.walkFileTree(Path dir, FileVisitor fv) //是一个遍历子孙目录和文件的过程； ZIP文件系统 由上文知道，Paths类会在默认的文件系统中查找路径，即在用户本地磁盘中的文件。 其实，我们也可以有其他的文件系统，比如ZIP文件系统。 12 /*假设zipname是某个ZIP文件的名字*/FileSystem fs = FileSystems.newFileSystem(Paths.get(zipname), null); 上述代码将建立一个基于zipname的文件系统，它包含ZIP文档中的所有文件。 1）如果知道文件名（String类型），那么从这个ZIP文档中复制出这个文件就很容易： 1Files.copy(fs.getPath(fileName), targetPath); Q：fs.getPath是使用了ZIP文件系统来getPath，那么默认的文件系统能调用吗？ A：能。FileSystem类中有一个静态的getDefault()方法，返回一个默认的文件系统对象，同样可以由文件名getPath。 *具体getPath(String name)是遍历还是随机访问，有空再去看源码实现。 2）要列出ZIP文档中的所有文件，同样可以用walkFileTree遍历文件树 123456789FileSystem fs = FileSystems.newFileSystem(Paths.get(fileName), null);//walkFileTree需要传入一个要被遍历的目录Path，和一个FileVisitor对象Files.walkFileTree(fs.getPath("/"), newSimpleFileVisitor&lt;Path&gt;()&#123; public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws Exception&#123; System.out.println(file); return FileVisitResult.CONTINUE; &#125;);]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebUploader上传组件]]></title>
    <url>%2Fblog%2F41980.html</url>
    <content type="text"><![CDATA[大文件上传组件 基本用法$(function(){…}); jQuery(function($) {…}); $(document).ready(function(){…})这三个的作用是一样的，本人比较需要用第一种、书写简单。文档载入完成后执行的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//一个div用来存放文件上传时的信息//一个div用来存放上传相关的按钮&lt;link rel="stylesheet" type="text/css" href="./web-uploader/webuploader.css" /&gt;&lt;!--&lt;script style="text/javascript" src="./jQuery/jquery-2.2.3.min.js"&gt;&lt;/script&gt;--&gt;&lt;script type="text/javascript" src="./web-uploader/webuploader.js"&gt;&lt;/script&gt;&lt;div id="uploader" class="wu-example"&gt; &lt;!--用来存放文件信息--&gt; &lt;div id="thelist" class="uploader-list"&gt;&lt;/div&gt; &lt;div class="btns"&gt; &lt;div id="picker"&gt;选择文件&lt;/div&gt; &lt;button id="ctlBtn" class="btn btn-default"&gt;开始上传&lt;/button&gt; &lt;button id="goBack" class="btn btn-default"&gt;返回&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;/*1、首先用WebUploader.create创建一个 WebUploader对象 ，并在create中添加自定义配置项2、然后手动给WebUploader对象添加事件，用到的基本事件是 fileQueued 文件被添加进队列的时候，在thelist div 中显示文件信息 uploadProgress 文件上传过程中创建进度条实时显示 uploadSuccess uploadError uploadComplete 在文件上传完后都会触发uploadComplete事件3、最后 调用upload()方法实现上传，*/&lt;script&gt;var uploader = WebUploader.create(&#123; // swf文件路径 swf: '/js/Uploader.swf', formData:&#123;"dn":$("#requestDn").val()&#125;,//参数列表 // 文件接收服务端。 server: '/tp5/index/user/uploadFile', // 选择文件的按钮。可选。 // 内部根据当前运行是创建，可能是input元素，也可能是flash. pick: '#picker', // 不压缩image, 默认如果是jpeg，文件上传前会压缩一把再上传！ resize: false, // 只允许选择图片文件。 accept: &#123; title: 'file', extensions: 'cer'// mimeTypes: '.cer,' &#125;&#125;);var $list = $("#thelist");uploader.on( 'fileQueued', function( file ) &#123; $list.append( '&lt;div id="' + file.id + '" class="item"&gt;' + '&lt;h4 class="info"&gt;' + file.name + '&lt;/h4&gt;' + '&lt;p class="state"&gt;等待上传...&lt;/p&gt;' + '&lt;p class="progress progress-bar"&gt;上传进度...&lt;/p&gt;' + '&lt;/div&gt;' );&#125;);uploader.on( 'uploadSuccess', function( file ) &#123; $( '#'+file.id ).find('p.state').text('已上传');&#125;);// 文件上传过程中创建进度条实时显示。uploader.on( 'uploadProgress', function( file, percentage ) &#123; var $li = $( '#'+file.id ), $percent = $li.find('.progress .progress-bar'); // 避免重复创建 if ( !$percent.length ) &#123; $percent = $('&lt;div class="progress progress-striped active"&gt;' + '&lt;div class="progress-bar" role="progressbar" style="width: 0%"&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;').appendTo( $li ).find('.progress-bar'); &#125; $li.find('p.state').text('上传中'); $percent.css( 'width', percentage * 100 + '%' );&#125;);uploader.on( 'uploadError', function( file ) &#123; $( '#'+file.id ).find('p.state').text('上传出错');&#125;);uploader.on( 'uploadComplete', function( file ) &#123; $( '#'+file.id ).find('.progress').fadeOut();&#125;);$("#ctlBtn").on('click', function() &#123; uploader.upload();&#125;);$("#goBack").on('click', function() &#123; $("#uploadFileDiv").empty(); $("#uploadFile").removeClass("hidden");&#125;);&lt;/script&gt; 接口说明这里是简单介绍，具体接口参考 webuploader接口文档地址 Web Uploader内部类的详细说明，以下提及的功能类，都可以在 WebUploader 这个变量中访问到。 也就是说下面提到的 Base类 、Mediator类 、file类 、Queue类 都可以直接用 WebUploader 创建的变量直接访问， 例如下面创建的 uploader 变量，就可以直接访问 Base类 的 uploader.browser.ie //Demo中使用的是WebUploader.create方法来初始化的，实际上可直接访问WebUploader.Uploader Uploader类 上传入口类参数说明下面所有参数都是可选的，并且都有默认值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var uploader = WebUploader.Uploader(&#123; //几个常用的参数：swf,pick,formData,runtimeOrder //所有参数列表 swf: 'path_of_swf/Uploader.swf', dnd: '#dndArea', // [默认值：undefined] 指定Drag And Drop拖拽的容器，如果不指定，则不启动。 disableGlobalDnd: true,, // [默认值：false] 是否禁掉整个页面的拖拽功能，如果不禁用，图片拖进来的时候会默认被浏览器打开 paste: '#uploader', // [默认值：undefined] 指定监听paste事件的容器，如果不指定，不启用此功能。此功能为通过粘贴来添加截屏的图片。建议设置为document.body. pick:'#filePicker',//也可以用下面的方式详细配置 // &#123;Selector, Object&#125; [默认值：undefined] 指定选择文件的按钮容器，不指定则不创建按钮。 pick: &#123; id: '#filePicker',//Seletor|dom 指定选择文件的按钮容器，不指定则不创建按钮。注意 这里虽然写的是 id, 但是不是只支持 id, 还支持 class, 或者 dom 节点。 label: '点击选择图片',//请采用 innerHTML 代替 innerHTML: "点击选择图片",// 指定按钮文字。不指定时优先从指定的容器中看是否自带文字。 multiple:true //是否开起同时选择多个文件能力。 &#125;, //限制上传的文件类型 accept: &#123; title: 'Images',// &#123;String&#125; 文字描述 extensions: 'gif,jpg,jpeg,bmp,png,rar',// &#123;String&#125; 允许的文件后缀，不带点，多个用逗号分割。 mimeTypes: 'image/gif，image/jpg，image/jpeg，image/bmp，image/png，.rar'// 多个用逗号分割。 &#125;, // 设置缩略图。 thumb: &#123; width: 110, height: 110, // 图片质量，只有type为`image/jpeg`的时候才有效。 quality: 70, // 是否允许放大，如果想要生成小图的时候不失真，此选项应该设置为false. allowMagnify: true, // 是否允许裁剪。是否采用裁剪模式。如果采用这样可以避免空白内容。 crop: true, // 为空的话则保留原有图片格式。 // 否则强制转换成指定的类型。 type: 'image/jpeg' &#125;, // 配置压缩的图片的选项。如果此选项为false, 则图片在上传前不进行压缩。 compress: &#123; width: 1600, height: 1600, // 图片质量，只有type为`image/jpeg`的时候才有效。 quality: 90, // 是否允许放大，如果想要生成小图的时候不失真，此选项应该设置为false. allowMagnify: false, // 是否允许裁剪。 crop: false, // 是否保留头部meta信息。 preserveHeaders: true, // 如果发现压缩后文件大小比原来还大，则使用原来图片 // 此属性可能会影响图片自动纠正功能 noCompressIfLarger: false, // 单位字节，如果图片大小小于此值，不会采用压缩。 compressSize: 0 &#125;, auto: true, // [默认值：false] 设置为 true 后，不需要手动调用上传，有文件选择即开始上传。 runtimeOrder: 'flash', // [默认值：html5,flash] 指定运行时启动顺序。默认会想尝试 html5 是否支持，如果支持则使用 html5, 否则则使用 flash.可以将此值设置成 flash，来强制使用 flash 运行时。 prepareNextFile:false, // [默认值：false] 是否允许在文件传输时提前把下一个文件准备好。 对于一个文件的准备工作比较耗时，比如图片压缩，md5序列化。 如果能提前在当前文件传输期处理，可以节省总体耗时。 chunked:false, // [默认值：false] 是否要分片处理大文件上传。 chunkSize: 512 * 1024,// [默认值：5242880] 如果要分片，分多大一片？ 默认大小为5M. chunkRetry:2, // [默认值：2] 如果某个分片由于网络问题出错，允许自动重传多少次？ threads:3, // [默认值：3] 上传并发数。允许同时最大上传进程数。 formData: &#123;"data":"value","data":"value"&#125;, // [默认值：&#123;&#125;] 文件上传请求的参数表，每次发送都会发送此对象中的参数。 fileVal:"file", // [默认值：'file'] 设置文件上传域的name。 method :"POST", // [默认值：'POST'] 文件上传方式，POST或者GET。 sendAsBinary :false, // [默认值：false] 是否已二进制的流的方式发送文件，这样整个上传内容php://input都为文件内容， 其他参数在$_GET数组中。 fileNumLimit :10, // [默认值：undefined] 验证文件总数量, 超出则不允许加入队列。 fileSizeLimit : 200 * 1024 * 1024, // 200 M [默认值：undefined] 验证文件总大小是否超出限制, 超出则不允许加入队列。 fileSingleSizeLimit: 50 * 1024 * 1024, // 50 M [默认值：undefined] 验证单个文件大小是否超出限制, 超出则不允许加入队列。 duplicate :true, // [默认值：undefined] 去重， 根据文件名字、文件大小和最后修改时间来生成hash Key. disableWidgets: &#123;String, Array&#125;, // [默认值：undefined] 默认所有 Uploader.register 了的 widget 都会被加载，如果禁用某一部分，请通过此 option 指定黑名单。&#125;); uploader对象的选项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374751、option() //获取或者设置Uploader配置项。// 修改后图片上传前，尝试将图片压缩到1600 * 1600uploader.option( 'compress', &#123; width: 1600, height: 1600&#125;); 2、getStats() //获取文件统计信息。返回一个包含一下信息的对象。//successNum 上传成功的文件数//progressNum 上传中的文件数//cancelNum 被删除的文件数//invalidNum 无效的文件数//uploadFailNum 上传失败的文件数//queueNum 还在队列中的文件数//interruptNum 被暂停的文件数stats = uploader.getStats();if ( stats.successNum &amp;&amp; !stats.uploadFailNum ) &#123; setState( 'finish' ); return;&#125;3、destroy() //销毁 webuploader 实例4、addButton() //添加文件选择按钮，如果一个按钮不够，需要调用此方法来添加。参数跟options.pick一致。 uploader.addButton(&#123; id: '#filePicker2', label: '继续添加' &#125;);5、makeThumb() //生成缩略图，此过程为异步，所以需要传入callback。 通常情况在图片加入队里后调用此方法来生成预览图以增强交互效果。 //当 width 或者 height 的值介于 0 - 1 时，被当成百分比使用。 //callback中可以接收到两个参数。 //第一个为error，如果生成缩略图有错误，此error将为真。 //第二个为ret, 缩略图的Data URL值。 //注意 Date URL在IE6/7中不支持，所以不用调用此方法了，直接显示一张暂不支持预览图片好了。 也可以借助服务端，将 base64 数据传给服务端，生成一个临时文件供预览。 uploader.makeThumb( file, function( error, src ) &#123; var img; if ( error ) &#123; $wrap.text( '不能预览' ); return; &#125; if( isSupportBase64 ) &#123; img = $('&lt;img src="'+src+'"&gt;'); $wrap.empty().append( img ); &#125; else &#123; $.ajax('../../server/preview.php', &#123; method: 'POST', data: src, dataType:'json' &#125;).done(function( response ) &#123; if (response.result) &#123; img = $('&lt;img src="'+response.result+'"&gt;'); $wrap.empty().append( img ); &#125; else &#123; $wrap.text("预览出错"); &#125; &#125;); &#125;&#125;, thumbnailWidth, thumbnailHeight );6、md5File()// 计算文件 md5 值，返回一个 promise 对象，可以监听 progress 进度。7、addFiles() //添加文件到队列8、removeFile() //移除某一文件, 默认只会标记文件状态为已取消，如果第二个参数为 true 则会从 queue 中移除9、getFiles() //返回指定状态的文件集合，不传参数将返回所有状态的文件。10、retry() //重试上传，重试指定文件，或者从出错的文件开始重新上传。11、sort() //排序队列中的文件，在上传之前调整可以控制上传顺序。12、reset() //重置uploader。目前只重置了队列。13、predictRuntimeType() //预测Uploader将采用哪个Runtime14、upload() //开始上传。此方法可以从初始状态调用开始上传流程，也可以从暂停状态调用，继续上传流程。可以指定开始某一个文件15、stop() //暂停上传。第一个参数为是否中断上传当前正在上传的文件。如果第一个参数是文件，则只暂停指定文件。16、cancelFile() //标记文件状态为已取消, 同时将中断文件传输。17、isInProgress() //判断Uplaoder是否正在上传中。18、skipFile() //掉过一个文件上传，直接标记指定文件为已上传状态。19、request() //发送命令。当传入callback或者handler中返回promise时。返回一个当所有handler中的promise都完成后完成的新promise。20、Uploader.register() //添加组件21、Uploader.unRegister() //删除插件，只有在注册时指定了名字的才能被删除。 事件说明123456789101112131415161718192021dndAccept :// 阻止,此事件可以拒绝某些类型的文件拖入进来。目前只有 chrome 提供这样的 API，且只能通过 mime-type 验证。beforeFileQueued :// 当文件被加入队列之前触发，此事件的handler返回值为false，则此文件不会被添加进入队列。fileQueued :// 当文件被加入队列以后触发。filesQueued :// 当一批文件添加进队列以后触发。fileDequeued :// 当文件被移除队列后触发。reset :// 当 uploader 被重置的时候触发。startUpload :// 当开始上传流程时触发。stopUpload :// 当开始上传流程暂停时触发。uploadFinished :// 当所有文件上传结束时触发。uploadStart :// 某个文件开始上传前触发，一个文件只会触发一次。uploadBeforeSend :// 当某个文件的分块在发送前触发，主要用来询问是否要添加附带参数，大文件在开起分片上传的前提下此事件可能会触发多次。uploadAccept :// 当某个文件上传到服务端响应后，会派送此事件来询问服务端响应是否有效。如果此事件handler返回值为false, 则此文件将派送server类型的uploadError事件。uploadProgress :// 上传过程中触发，携带上传进度。uploadError :// 当文件上传出错时触发。uploadSuccess :// 当文件上传成功时触发。uploadComplete :// 不管成功或者失败，文件上传完成时触发。error :// 当validate不通过时，会以派送错误事件的形式通知调用者。通过upload.on('error', handler)可以捕获到此类错误，目前有以下错误会在特定的情况下派送错来。 //Q_EXCEED_NUM_LIMIT 在设置了fileNumLimit且尝试给uploader添加的文件数量超出这个值时派送。 //Q_EXCEED_SIZE_LIMIT 在设置了Q_EXCEED_SIZE_LIMIT且尝试给uploader添加的文件总大小超出这个值时派送。 //Q_TYPE_DENIED 当文件类型不满足时触发。。/*Web Uploader内部类的详细说明，以下提及的功能类，都可以在`WebUploader`这个变量中访问到。 即 Base类 Mediator类 File类都可以在`WebUploader`这个变量中访问到*/ Base类基础类方法 WebUploader 基础类，提供一些简单常用的方法 WebUploader.browser.ie 123456789101112131415create() //创建Uploader实例，等同于new Uploader( opts );version //当前版本号$//引用依赖的jQuery或者Zepto对象browser //简单的浏览器检查结果os android、iosinherits //实现类与类之间的继承noop //一个不做任何事情的方法。可以用来赋值给默认的callbackbindFn //返回一个新的方法，此方法将已指定的context来执行log //引用Console.log如果存在的话，否则引用一个空函数noop。slice //被uncurrythis的数组slice方法。 将用来将非数组对象转化成数组对象guid //生成唯一的IDformatSize //格式化文件大小, 输出成带单位的字符串Deferred //创建一个Deferred对象。 详细的Deferred用法说明，请参照jQuery的API文档。Deferred对象在钩子回掉函数中经常要用到，用来处理需要等待的异步操作。isPromise //判断传入的参数是否为一个 promise 对象。when //返回一个promise，此promise在所有传入的promise都完成了后完成 Mediator类事件处理类，可以独立使用，也可以扩展给对象使用 中介，它本身是个单例，但可以通过installTo方法，使任何对象具备事件行为。 主要目的是负责模块与模块之间的合作，降低耦合度 1on once off trigger installTo File类文件类 本类的一般在 UploadProgress 这些事件中的回调函数中变量使用比较多 12345678910111213141516171819name//文件名，包括扩展名（后缀）size//文件体积（字节）type//文件MIMETYPE类型，与文件类型的对应关系请参考http://t.cn/z8ZnFnylastModifiedDate//文件最后修改日期id//文件ID，每个对象具有唯一ID，与文件名无关ext//文件扩展名，通过文件名获取，例如test.png的扩展名为pngstatusText//状态文字说明。在不同的status语境下有不同的用途。setStatus//设置状态，状态变化时会触发change事件。setStatus( status[, statusText] );//参数:status &#123;File.Status, String&#125;文件状态值statusText //&#123;String&#125; [可选] [默认值: ''] 状态说明，常在error时使用，用http, abort,server等来标记是由于什么原因导致文件错误。File.Status//文件状态值，具体包括以下几种类型：inited //初始状态queued //已经进入队列, 等待上传progress //上传中complete //上传完成。error //上传出错，可重试interrupt //上传中断，可续传。invalid //文件不合格，不能重试上传。会自动从队列中移除。cancelled //文件被移除。 Queue 类文件队列, 用来存储各个状态中的文件 123456789101112131415stats//统计文件数。numOfQueue //队列中的文件数。numOfSuccess //上传成功的文件数numOfCancel //被取消的文件数numOfProgress //正在上传中的文件数numOfUploadFailed //上传错误的文件数。numOfInvalid //无效的文件数。numofDeleted //被移除的文件数。append//将新文件加入对队列尾部 prepend//将新文件加入对队列头部 getFile//获取文件对象 fetch//从队列中取出一个指定状态的文件。 sort//对队列进行排序，能够控制文件上传顺序。 getFiles//获取指定类型的文件列表, 列表中每一个成员为File对象。 removeFile//在队列中删除文件。 ​ github中的代码给的例子基本上可以实现想要的功能，如果有别的需求可以结合代码中的例子根据接口手册进行相应的修改。 ​ Web Uploader的所有代码都在一个内部闭包中，对外暴露了唯一的一个变量WebUploader，所以完全不用担心此框架会与其他框架冲突。Uploader实例具有Backbone同样的事件API：on，off，once，trigger。如同Document Element中的onEvent一样，他的执行比on添加的handler的要晚。如果那些handler里面，有一个return false了，此onEvent里面是不会执行到的 1234567uploader.on( 'fileQueued', function( file ) &#123; // do some things.&#125;);//或uploader.onFileQueued = function( file ) &#123; // do some things.&#125;; 断点上传实例准备：Uploader.swf、webuploader.css、webuploader.js，其中Uploader.swf只在初始化webUploader时用到，其余两个文件在页面引用即可。下载地址：https://github.com/fex-team/webuploader/releases Jsp代码：1234567891011121314151617181920&lt;!-- 断点续传 start--&gt;&lt;!-- 隐藏域 实时保存上传进度 --&gt;&lt;input id="jindutiao" type="hidden"/&gt;&lt;div id="uploader" class="wu-example"&gt; &lt;label class="text-right" style="font-weight:100;float:left;margin-left:15px;width:144px;margin-right:15px;"&gt;大文件：&lt;/label&gt; &lt;div class="btns"&gt; &lt;div id="picker" class="webuploader-container"&gt; &lt;div class="webuploader-pick"&gt;选择文件&lt;/div&gt; &lt;div id="rt_rt_1bchdejhrarjdvd11h41eoh1nt1" style="position: absolute; top: 0px; left: 0px; width: 88px; height: 35px; overflow: hidden; bottom: auto; right: auto;"&gt; &lt;input id="file_bp" name="file" class="webuploader-element-invisible" type="file" /&gt; &lt;label style="opacity: 0; width: 100%; height: 100%; display: block; cursor: pointer; background: rgb(255, 255, 255) none repeat scroll 0% 0%;"&gt;&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 文件列表：选择文件后在该div显示 --&gt; &lt;div id="thelist" class="uploader-list list-group-item clearfix ng-hide" style="margin-left:160px;"&gt;&lt;/div&gt; &lt;label class="text-right" style="font-weight:100;float:left;margin-left:15px;width:144px;margin-right:15px;"&gt;&lt;/label&gt; &lt;button class="btn m-b-xs btn-sm btn-info btn-addon" id="startOrStopBtn" style="padding:7px 50px;margin-top:20px;"&gt;开始上传&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 断点续传 end--&gt; js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302&lt;script type="text/javascript"&gt; jQuery(function() &#123; /*******************初始化参数*********************************/ var $list = $('#thelist'),//文件列表 $btn = $('#startOrStopBtn'),//开始上传按钮 state = 'pending',//初始按钮状态 uploader; //uploader对象 var fileMd5; //文件唯一标识 /******************下面的参数是自定义的*************************/ var fileName;//文件名称 var oldJindu;//如果该文件之前上传过 已经上传的进度是多少 var count=0;//当前正在上传的文件在数组中的下标，一次上传多个文件时使用 var filesArr=new Array();//文件数组：每当有文件被添加进队列的时候 就push到数组中 var map=&#123;&#125;;//key存储文件id，value存储该文件上传过的进度 /***************************************************** 监听分块上传过程中的三个时间点 start ***********************************************************/ WebUploader.Uploader.register(&#123; "before-send-file":"beforeSendFile",//整个文件上传前 "before-send":"beforeSend", //每个分片上传前 "after-send-file":"afterSendFile", //分片上传完毕 &#125;, &#123; //时间点1：所有分块进行上传之前调用此函数 beforeSendFile:function(file)&#123; var deferred = WebUploader.Deferred(); //1、计算文件的唯一标记fileMd5，用于断点续传 如果.md5File(file)方法里只写一个file参数则计算MD5值会很慢 所以加了后面的参数：10*1024*1024 (new WebUploader.Uploader()).md5File(file,0,10*1024*1024).progress(function(percentage)&#123; $('#'+file.id ).find('p.state').text('正在读取文件信息...'); &#125;) .then(function(val)&#123; $('#'+file.id ).find("p.state").text("成功获取文件信息..."); fileMd5=val; //获取文件信息后进入下一步 deferred.resolve(); &#125;); fileName=file.name; //为自定义参数文件名赋值 return deferred.promise(); &#125;, //时间点2：如果有分块上传，则每个分块上传之前调用此函数 beforeSend:function(block)&#123; var deferred = WebUploader.Deferred(); $.ajax(&#123; type:"POST", url:"$&#123;ctx&#125;/testController/mergeOrCheckChunks.do?param=checkChunk", //ajax验证每一个分片 data:&#123; fileName : fileName, jindutiao:$("#jindutiao").val(), fileMd5:fileMd5, //文件唯一标记 chunk:block.chunk, //当前分块下标 chunkSize:block.end-block.start//当前分块大小 &#125;, cache: false, async: false, // 与js同步 timeout: 1000, //todo 超时的话，只能认为该分片未上传过 dataType:"json", success:function(response)&#123; if(response.ifExist)&#123; //分块存在，跳过 deferred.reject(); &#125;else&#123; //分块不存在或不完整，重新发送该分块内容 deferred.resolve(); &#125; &#125; &#125;); this.owner.options.formData.fileMd5 = fileMd5; deferred.resolve(); return deferred.promise(); &#125;, //时间点3：所有分块上传成功后调用此函数 afterSendFile:function()&#123; //如果分块上传成功，则通知后台合并分块 $.ajax(&#123; type:"POST", url:"$&#123;ctx&#125;/testController/mergeOrCheckChunks.do?param=mergeChunks", //ajax将所有片段合并成整体 data:&#123; fileName : fileName, fileMd5:fileMd5, &#125;, success:function(data)&#123; count++; //每上传完成一个文件 count+1 if(count&lt;=filesArr.length-1)&#123; uploader.upload(filesArr[count].id);//上传文件列表中的下一个文件 &#125; //合并成功之后的操作 &#125; &#125;); &#125; &#125;); /***************************************************** 监听分块上传过程中的三个时间点 end **************************************************************/ /************************************************************ 初始化WebUploader start ******************************************************************/ uploader = WebUploader.create(&#123; auto:false,//选择文件后是否自动上传 chunked: true,//开启分片上传 chunkSize:10*1024*1024,// 如果要分片，分多大一片？默认大小为5M chunkRetry: 3,//如果某个分片由于网络问题出错，允许自动重传多少次 threads: 3,//上传并发数。允许同时最大上传进程数[默认值：3] duplicate : false,//是否重复上传（同时选择多个一样的文件），true可以重复上传 prepareNextFile: true,//上传当前分片时预处理下一分片 swf: '$&#123;ctx&#125;/resource/webuploader/Uploader.swf',// swf文件路径 server: '$&#123;ctx&#125;/testController/fileSave.do',// 文件接收服务端 fileSizeLimit:6*1024*1024*1024,//6G 验证文件总大小是否超出限制, 超出则不允许加入队列 fileSingleSizeLimit:3*1024*1024*1024, //3G 验证单个文件大小是否超出限制, 超出则不允许加入队列 pick: &#123; id: '#picker', //这个id是你要点击上传文件按钮的外层div的id multiple : false //是否可以批量上传，true可以同时选择多个文件 &#125;, resize: false, //不压缩image, 默认如果是jpeg，文件上传前会先压缩再上传！ accept: &#123; //允许上传的文件后缀，不带点，多个用逗号分割 extensions: "txt,jpg,jpeg,bmp,png,zip,rar,war,pdf,cebx,doc,docx,ppt,pptx,xls,xlsx", mimeTypes: '.txt,.jpg,.jpeg,.bmp,.png,.zip,.rar,.war,.pdf,.cebx,.doc,.docx,.ppt,.pptx,.xls,.xlsx', &#125; &#125;); /************************************************************ 初始化WebUploader end ********************************************************************/ //当有文件被添加进队列的时候（点击上传文件按钮，弹出文件选择框，选择完文件点击确定后触发的事件） uploader.on('fileQueued', function(file) &#123; //限制单个文件的大小 超出了提示 if(file.size&gt;3*1024*1024*1024)&#123; alert("单个文件大小不能超过3G"); return false; &#125; /*************如果一次只能选择一个文件，再次选择替换前一个，就增加如下代码*******************************/ //清空文件队列 $list.html(""); //清空文件数组 filesArr=[]; /*************如果一次只能选择一个文件，再次选择替换前一个，就增加以上代码*******************************/ //将选择的文件添加进文件数组 filesArr.push(file); $.ajax(&#123; type:"POST", url:"$&#123;ctx&#125;/testController/selectProgressByFileName.do", //先检查该文件是否上传过，如果上传过，上传进度是多少 data:&#123; fileName : file.name //文件名 &#125;, cache: false, async: false, // 同步 dataType:"json", success:function(data)&#123; //上传过 if(data&gt;0)&#123; //上传过的进度的百分比 oldJindu=data/100; //如果上传过 上传了多少 var jindutiaoStyle="width:"+data+"%"; $list.append( '&lt;div id="' + file.id + '" class="item"&gt;' + '&lt;h4 class="info"&gt;' + file.name + '&lt;/h4&gt;' + '&lt;p class="state"&gt;已上传'+data+'%&lt;/p&gt;' + '&lt;a href="javascript:void(0);" class="btn btn-primary file_btn btnRemoveFile"&gt;删除&lt;/a&gt;' + '&lt;div class="progress progress-striped active"&gt;' + '&lt;div class="progress-bar" role="progressbar" style="'+jindutiaoStyle+'"&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'+ '&lt;/div&gt;' ); //将上传过的进度存入map集合 map[file.id]=oldJindu; &#125;else&#123;//没有上传过 $list.append( '&lt;div id="' + file.id + '" class="item"&gt;' + '&lt;h4 class="info"&gt;' + file.name + '&lt;/h4&gt;' + '&lt;p class="state"&gt;等待上传...&lt;/p&gt;' + '&lt;a href="javascript:void(0);" class="btn btn-primary file_btn btnRemoveFile"&gt;删除&lt;/a&gt;' + '&lt;/div&gt;' ); &#125; &#125; &#125;); uploader.stop(true); //删除队列中的文件 $(".btnRemoveFile").bind("click", function() &#123; var fileItem = $(this).parent(); uploader.removeFile($(fileItem).attr("id"), true); $(fileItem).fadeOut(function() &#123; $(fileItem).remove(); &#125;); //数组中的文件也要删除 for(var i=0;i&lt;filesArr.length;i++)&#123; if(filesArr[i].id==$(fileItem).attr("id"))&#123; filesArr.splice(i,1);//i是要删除的元素在数组中的下标，1代表从下标位置开始连续删除一个元素 &#125; &#125; &#125;); &#125;); //文件上传过程中创建进度条实时显示 uploader.on('uploadProgress', function(file, percentage) &#123; var $li = $( '#'+file.id ), $percent = $li.find('.progress .progress-bar'); //避免重复创建 if (!$percent.length)&#123; $percent = $('&lt;div class="progress progress-striped active"&gt;' + '&lt;div class="progress-bar" role="progressbar" style="width: 0%"&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;').appendTo( $li ).find('.progress-bar'); &#125; //将实时进度存入隐藏域 $("#jindutiao").val(Math.round(percentage * 100)); //根据fielId获得当前要上传的文件的进度 var oldJinduValue = map[file.id]; if(percentage&lt;oldJinduValue &amp;&amp; oldJinduValue!=1)&#123; $li.find('p.state').text('上传中'+Math.round(oldJinduValue * 100) + '%'); $percent.css('width', oldJinduValue * 100 + '%'); &#125;else&#123; $li.find('p.state').text('上传中'+Math.round(percentage * 100) + '%'); $percent.css('width', percentage * 100 + '%'); &#125; &#125;); //上传成功后执行的方法 uploader.on('uploadSuccess', function( file ) &#123; //上传成功去掉进度条 $('#'+file.id).find('.progress').fadeOut(); //隐藏删除按钮 $(".btnRemoveFile").hide(); //隐藏上传按钮 $("#startOrStopBtn").hide(); $('#'+file.id).find('p.state').text('文件已上传成功，系统后台正在处理，请稍后...'); &#125;); //上传出错后执行的方法 uploader.on('uploadError', function( file ) &#123; errorUpload=true; $btn.text('开始上传'); uploader.stop(true); $('#'+file.id).find('p.state').text('上传出错，请检查网络连接'); &#125;); //文件上传成功失败都会走这个方法 uploader.on('uploadComplete', function( file ) &#123; &#125;); uploader.on('all', function(type)&#123; if (type === 'startUpload')&#123; state = 'uploading'; &#125;else if(type === 'stopUpload')&#123; state = 'paused'; &#125;else if(type === 'uploadFinished')&#123; state = 'done'; &#125; if (state === 'uploading')&#123; $btn.text('暂停上传'); &#125; else &#123; $btn.text('开始上传'); &#125; &#125;); //上传按钮的onclick时间 $btn.on('click', function()&#123; if (state === 'uploading')&#123; uploader.stop(true); &#125; else &#123; //当前上传文件的文件名 var currentFileName; //当前上传文件的文件id var currentFileId; //count=0 说明没开始传 默认从文件列表的第一个开始传 if(count==0)&#123; currentFileName=filesArr[0].name; currentFileId=filesArr[0].id; &#125;else&#123; if(count&lt;=filesArr.length-1)&#123; currentFileName=filesArr[count].name; currentFileId=filesArr[count].id; &#125; &#125; //先查询该文件是否上传过 如果上传过已经上传的进度是多少 $.ajax(&#123; type:"POST", url:"$&#123;ctx&#125;/testController/selectProgressByFileName.do", data:&#123; fileName : currentFileName//文件名 &#125;, cache: false, async: false, // 同步 dataType:"json", success:function(data)&#123; //如果上传过 将进度存入map if(data&gt;0)&#123; map[currentFileId]=data/100; &#125; //执行上传 uploader.upload(currentFileId); &#125; &#125;); &#125; &#125;);&#125;);&lt;/script&gt; Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236//合并、验证分片方法public void mergeOrCheckChunks(HttpServletRequest request, HttpServletResponse response) &#123; String param = request.getParameter("param"); String fileName = request.getParameter("fileName"); //当前登录用户信息 SysUser sysUser = (SysUser)request.getSession().getAttribute("user"); String newFilePath = sysUser.getUserId()+"_"+fileName; String savePath = request.getRealPath("/"); //文件上传的临时文件保存在项目的temp文件夹下 定时删除 savePath = new File(savePath) + "/upload/"; if(param.equals("mergeChunks"))&#123; //合并文件 Jedis jedis =null; try &#123; jedis =jedisPool.getResource(); //读取目录里的所有文件 File f = new File(savePath+"/"+jedis.get("fileName_"+fileName)); File[] fileArray = f.listFiles(new FileFilter()&#123; //排除目录只要文件 @Override public boolean accept(File pathname) &#123; if(pathname.isDirectory())&#123; return false; &#125; return true; &#125; &#125;); //转成集合，便于排序 List&lt;File&gt; fileList = new ArrayList&lt;File&gt;(Arrays.asList(fileArray)); Collections.sort(fileList,new Comparator&lt;File&gt;() &#123; @Override public int compare(File o1, File o2) &#123; if(Integer.parseInt(o1.getName()) &lt; Integer.parseInt(o2.getName()))&#123; return -1; &#125; return 1; &#125; &#125;); //截取文件名的后缀名 //最后一个"."的位置 int pointIndex=fileName.lastIndexOf("."); //后缀名 String suffix=fileName.substring(pointIndex); //合并后的文件 File outputFile = new File(savePath+"/"+jedis.get("fileName_"+fileName)+suffix); //创建文件 try &#123; outputFile.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //输出流 FileChannel outChnnel = new FileOutputStream(outputFile).getChannel(); //合并 FileChannel inChannel; for(File file : fileList)&#123; inChannel = new FileInputStream(file).getChannel(); try &#123; inChannel.transferTo(0, inChannel.size(), outChnnel); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; inChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //删除分片 file.delete(); &#125; try &#123; outChnnel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //清除文件夹 File tempFile = new File(savePath+"/"+jedis.get("fileName_"+fileName)); if(tempFile.isDirectory() &amp;&amp; tempFile.exists())&#123; tempFile.delete(); &#125; Map&lt;String, String&gt; resultMap=new HashMap&lt;&gt;(); //将文件的最后上传时间和生成的文件名返回 resultMap.put("lastUploadTime", jedis.get("lastUploadTime_"+newFilePath)); resultMap.put("pathFileName", jedis.get("fileName_"+fileName)+suffix); /****************清除redis中的相关信息**********************/ //合并成功后删除redis中的进度信息 jedis.del("jindutiao_"+newFilePath); //合并成功后删除redis中的最后上传时间，只存没上传完成的 jedis.del("lastUploadTime_"+newFilePath); //合并成功后删除文件名称与该文件上传时生成的存储分片的临时文件夹的名称在redis中的信息 key：上传文件的真实名称 value：存储分片的临时文件夹名称（由上传文件的MD5值+时间戳组成） //如果下次再上传同名文件 redis中将存储新的临时文件夹名称 没有上传完成的还要保留在redis中 直到定时任务生效 jedis.del("fileName_"+fileName); Gson gson=new Gson(); String json=gson.toJson(resultMap); PrintWriterJsonUtils.printWriter(response, json); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; jedisPool.returnResource(jedis); &#125; &#125;else if(param.equals("checkChunk"))&#123; /*************************检查当前分块是否上传成功**********************************/ String fileMd5 = request.getParameter("fileMd5"); String chunk = request.getParameter("chunk"); String chunkSize = request.getParameter("chunkSize"); String jindutiao=request.getParameter("jindutiao");//文件上传的实时进度 Jedis jedis =null; try &#123; jedis =jedisPool.getResource(); //将当前进度存入redis jedis.set("jindutiao_"+newFilePath, jindutiao); //将系统当前时间转换为字符串 Date date=new Date(); SimpleDateFormat formatter=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String lastUploadTime=formatter.format(date); //将最后上传时间以字符串形式存入redis jedis.set("lastUploadTime_"+newFilePath, lastUploadTime); //自定义文件名： 时间戳（13位） String tempFileName= String.valueOf(System.currentTimeMillis()); if(jedis.get("fileName_"+fileName)==null || "".equals(jedis.get("fileName_"+fileName)))&#123; //将文件名与该文件上传时生成的存储分片的临时文件夹的名称存入redis //文件上传时生成的存储分片的临时文件夹的名称由MD5和时间戳组成 jedis.set("fileName_"+fileName, fileMd5+tempFileName); &#125; File checkFile = new File(savePath+"/"+jedis.get("fileName_"+fileName)+"/"+chunk); response.setContentType("text/html;charset=utf-8"); //检查文件是否存在，且大小是否一致 if(checkFile.exists() &amp;&amp; checkFile.length()==Integer.parseInt(chunkSize))&#123; //上传过 try &#123; response.getWriter().write("&#123;\"ifExist\":1&#125;"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; //没有上传过 try &#123; response.getWriter().write("&#123;\"ifExist\":0&#125;"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; jedisPool.returnResource(jedis); &#125; &#125;&#125;//保存上传分片public void fileSave(HttpServletRequest request, HttpServletResponse response) &#123; DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload sfu = new ServletFileUpload(factory); sfu.setHeaderEncoding("utf-8"); String savePath = request.getRealPath("/"); savePath = new File(savePath) + "/upload/"; String fileMd5 = null; String chunk = null; String fileName=null; try &#123; List&lt;FileItem&gt; items = sfu.parseRequest(request); for(FileItem item:items)&#123; //上传文件的真实名称 fileName=item.getName(); if(item.isFormField())&#123; String fieldName = item.getFieldName(); if(fieldName.equals("fileMd5"))&#123; try &#123; fileMd5 = item.getString("utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; if(fieldName.equals("chunk"))&#123; try &#123; chunk = item.getString("utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125;else&#123; Jedis jedis =null; try &#123; jedis =jedisPool.getResource(); File file = new File(savePath+"/"+jedis.get("fileName_"+fileName)); if(!file.exists())&#123; file.mkdir(); &#125; File chunkFile = new File(savePath+"/"+jedis.get("fileName_"+fileName)+"/"+chunk); FileUtils.copyInputStreamToFile(item.getInputStream(), chunkFile); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; jedisPool.returnResource(jedis); &#125; &#125; &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; &#125;//当有文件添加进队列时 通过文件名查看该文件是否上传过 上传进度是多少public String selectProgressByFileName(String fileName) &#123; String jindutiao=""; Jedis jedis =null; try &#123; jedis =jedisPool.getResource(); if(null!=fileName &amp;&amp; !"".equals(fileName))&#123; jindutiao=jedis.get("jindutiao_"+fileName); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; jedisPool.returnResource(jedis); &#125; return jindutiao;&#125; 注：webUploader断点上传多个大文件时是按队列顺序上传的，即队列中的文件一个一个上传，前一个上传完成才会开始上传下一个，不能实现同时上传。]]></content>
      <categories>
        <category>WebUploader</category>
      </categories>
      <tags>
        <tag>WebUploader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目的tomcat配置]]></title>
    <url>%2Fblog%2F42040.html</url>
    <content type="text"><![CDATA[maven项目的tomcat配置 一、没有Tomcat情况 Run As--&gt;Maven build--&gt;tomcat:run (不支持jdk1.8+tomcat8;项目启动没问题,访问报错500;jdk1.7 可以正常访问) 二、war包形式 使用maven导出war包 Run As--&gt;Maven build... --&gt;package 成功后会提示生成的war包路径。一般在项目的target目录下。 (注：pom.xml的&lt;packaging/&gt;配置为war打包后的就是war包，配置为jar时打包后的就是jar包) 将war包部署至tomcat中 将war放到Tomcat的webapps目录下，配置conf\server.xml文件在&lt;Host&gt;中添加配置信息：(C:\Java\apache-tomcat-7.0.79\conf) ① path:启动项目后访问项目的路径 ② docBase:项目路径，可以使用绝对路径或相对路径，相对路径是相对于webapps ③ 你还可以在server.xml中配置你的端口号和项目名称，从而改变访问的url。 启动tomcat 注: 在部署项目的时候直接将web项目编译后的文件放在webapps也是同样的 JavaEE项目部署 `默认存放在webapp--&gt;WEB-INF--&gt;classes下面(如：C:\Java\apache-tomcat-7.0.79\webapps\mobile_scm\WEB-INF\classes)` maven项目部署 `默认存放在target下面(如：E:\MavenWorks\babasport\target)` 三、Tomcat启动项目发布 直接到webapps下 maven工程的tomcat热部署教程：tomcat热部署：webapps下的项目正在运行，直接把开发的新版本发布到正在运行的Tomcat下(不能关闭Tomcat再发布新版本 开发者本地将代码通过Git push到服务器端，服务器自动编译-打包-发布等等；也就是说发布到tomcat中后，不需要重启tomcat。 热部署前准备： 配置Tomcat登录的用户名和密码 热部署需要用户名和密码进行远程发布，修改user配置文件一是为了管理员进入tomcat管理页面并提高其安全性，二是为了在maven设置正确的用户名； `C:\Java\apache-tomcat-7.0.79\conf\tomcat-users.xml` 找到tomcat-user配置文件: 123456&lt;!-- 配置Tomcat登录的用户名和密码 --&gt;&lt;role rolename="manager-gui"/&gt;&lt;role rolename="manager-script"/&gt;&lt;role rolename="admin"/&gt;&lt;role rolename="manager"/&gt;&lt;user username="tomcat" password="123456" roles="manager-gui,manager-script,admin,manager"/&gt; 重启Tomcat，访问http://localhost:8080 进入tomcat服务器根目录，点击“manager app”输入用户名和密码，成功进入管理页面，说明第一步配置成功。 注：端口号改为80 可以默认不显示；访问项目应该隐藏项目名称； 热部署 Maven的Server的配置 在Maven的安装路径找到conf目录下的setting.xml文件(&quot;E:\software\apache-maven-3.5.0\conf&quot;)，在&lt;servers&gt;节点中添加tomcat7下配置的用户信息 12345&lt;server&gt; &lt;id&gt;tomcat&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;password&lt;/password&gt;&lt;/server&gt; 注：如果在pom.xml中没有配置用户名和密码，则使用setting里的配置，如果有的话，就是用pom里的配置（就近原则）配置完记得要Maven--&gt;Update projiect(刷新) pom.xml中添加tomcat插件 ① 可以在pom.xml中右键--&gt;Maven--&gt;Add Plugin--&gt;tomcat 自动添加插件 ② 可以手动配置插件和Tomcat的访问路径 12345678910111213141516171819202122232425262728293031&lt;build&gt;&lt;finalName&gt;babasport&lt;/finalName&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;!-- 本地jdk版本 --&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;!-- 配置tomcat的访问 --&gt; &lt;configuration&gt; &lt;!-- 访问路径 --&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;!-- 项目发布到根目录,覆盖ROOT，URL访问可以省略项目名称 --&gt; &lt;!-- &lt;path&gt;/&lt;/path&gt; --&gt; &lt;path&gt;/babasport&lt;/path&gt; &lt;server&gt;tomcat&lt;/server&gt; &lt;!-- 此处的名字必须和setting.xml中配置的ID一致--&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 最后来验证一下：启动tomcat服务器，保证里面没有发布任何项目 如果是eclipse 直接右键项目---run as ---maven bulid...输入“tomcat7:deploy”(二次发布以后输入&quot;tomcat7:redeploy&quot;) 如果使用的是命令行 直接输入“mvn tomcat7:redeploy” 测试通过，输入地址可以正常的访问！ server下设置tomcat发布位置maven项目发布后默认存放到target目录下(如：E:\MavenWorks\babasport\target)；开发web项目时，还需要手动复制到web服务器下(Tomcat) 如果能自动部署到Web服务器，而不用每次手动把target下编译好的war包拷贝到Tomcat下就更好了。 对servers设置： 修改发布路径到webapps下 修改timeout服务器启动和停止时间为300秒 发布到webapps下的根目录(项目访问URL不需要填写项目名， 取消勾选自动发布! 浏览器访问 http://localhost:8080/ (省略了项目名称) 注：如果用eclipse，http://localhost:8080/项目名称 也可以访问； 用myeclipse，只能访问`http://localhost:8080/` 注：如果不能成功发布到 / 目录下，或许需要做以下修改(一般默认完成，不用做修改) 1 删除webContext的发布 2 增加webapp发布到根目录下 3 增加Maven库(jar包)到WEB-INF/lib 下 四、控制台不输出log没有反应MyEclipse中Maven build…项目控制台不输出log 没有反应 一开始项目与都是可以通过maven build... 然后输入tomcat:run 跑起来的，后来忘记做了啥操作跑步起来了，控制台也不输出log了，总是一闪就过去了，后来也是试了各种方法，可能是自己换了当前项目的jdk版本，下面是解决方案 右击maven项目: Build Path ---&gt; configure Build Path... ---&gt; 先选中你当前的jdk remove掉 ，然后重新添加 ----&gt; Add Library ---&gt; 选择 JRE System Library ---&gt; 选择Alternate JRE---&gt; 然后点击installed JRES 进入界面后选择你要用的jdk版本 ---&gt; edit ---&gt; 在Default VM arguments 添加 :Dmaven.multiModuleProjectDirectory=$MAVEN_HOME 这样就可以，希望可以解决你的问题 !]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java basic knowledge]]></title>
    <url>%2Fblog%2F18967.html</url>
    <content type="text"><![CDATA[27天学完Java DAY001 DOS命令(理解)​ (1)切换盘符(掌握) d: 回车 ​ (2)显示某目录下的所有文件或者文件夹(掌握) dir 回车 ​ (3)创建文件夹 md 文件夹名称 回车 ​ (4)删除文件夹 rd 文件夹名称 回车 (5)进入目录(掌握 ) `单级进入 cd 目录名称` `多级进入 cd 目录名称1\目录名称2\...` (6)回退目录(掌握) `单级回退 cd..` `回退根目录 cd\` (7)删除文件 `del 文件名称` `*.txt 可以表示多个文件名称` (8)清屏(掌握) `cls` (9)退出 `exit` (10)删除带内容的文件夹 `rd /s 文件夹名称 会提示是否删除` `rd /q /s 文件夹名称 直接删除` path环境变量(理解)​ (1)为什么要配置path环境变量 为了让javac和java命令可以在任意目录下使用 (2)如何配置 A:方式1 直接修改path，在前面追加JDK的bin目录 B:方式2(掌握) 新建JAVA_HOME: JDK的安装目录 修改path: %JAVA_HOME%\bin;后面是以前的环境变量 classpath环境变量(理解)​ (1)为什么要配置classpath环境变量 为了让class文件可以在任意目录下运行 (2)如何配置 新建：classpath，把你想要在任意目录下运行的class文件所在目录配置过去即可。 注意：将来在执行的时候，有先后顺序关系 (3)path和classpath的区别 path是为了让exe文件可以在任意目录下运行 classpath是为了让class文件可以在任意目录下运行 注释(掌握)​ (1)注释:用于解释说明程序的文字 (2)分类： A:单行：//注释文字 B:多行：/ 注释文字 / C:文档注释：/* 注释文字 / (3)带注释的HelloWorld案例 (4)注释的作用： A:解释说明程序，提高程序的阅读性 B:帮助我们调试程序 关键字(掌握)​ (1)关键字:被Java赋予特定含义的单词 (2)特点:全部小写 (3)注意事项： A:goto和const作为保留字存在，目前不使用 B:类似于Editplus这样的高级记事本，会对关键字有特殊颜色标记，方便记忆 标识符(掌握)12345678910111213141516171819202122232425262728293031323334353637383940414243/* 标识符：就是给类,接口,方法,变量等起名字时使用的字符序列(字符串) 组成规则： A:英文字母大小写 B:数字 C:_和$ 注意事项： A:不能以数字开头 B:不能是Java中的关键字 C:区分大小写 Student,student 这是两个名称 常见的命名规则：见名知意 A:包 其实就是文件夹,用于解决相同类名问题 全部小写 单级：com 多级：cn.itcast B:类或者接口 一个单词：首字母大写 Student,Person,Teacher 多个单词：每个单词的首字母大写 HelloWorld,MyName,NameDemo C:方法或者变量 一个单词：全部小写 name,age,show() 多个单词：从第二个单词开始，每个单词首字母大写 myName,showAllStudentNames() D:常量 一个单词：全部大写 AGE 多个单词：每个单词都大写，用_连接 STUDENT_MAX_AGE*/class NameDemo &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; DAY002 常量(掌握)123456789101112131415161718192021222324252627282930313233343536373839/* 常量：在程序执行的过程中其值不可以发生改变 举例：π 分类： A:字面值常量 1，12.5 B:自定义常量(面向对象部分讲解) 字面值常量分类： A:字符串常量 用""括起来的内容 B:整数常量 所有的整数数据 C:小数常量 所有的带小数的数据 D:字符常量 用单引号括起来的内容 E:布尔常量 只有两个值：true和false F:空常量 null(数组部分去讲解)*/class ConstantDemo &#123; public static void main(String[] args) &#123; //字符串常量 System.out.println("HelloWorld"); //整数常量 System.out.println(100); //小数常量 System.out.println(12.345); //字符常量 System.out.println('A'); //下面的是错误的 //System.out.println('BC'); System.out.println('1'); //布尔常量 System.out.println(true); System.out.println(false); &#125;&#125; 进制(理解)​ (1)一种计数的方式。x进制表示逢x进1。 (2)进制转换 A:其他进制到十进制 系数*基数^权之和。 B:十进制到其他进制 除基取余,直到商为0,余数反转。 C:快速转换 a:二进制和十进制 8421码 b:二进制和八进制 三位组合 c:二进制和十六进制 四位组合 D:任意X进制到任意Y进制的转换 可以使用十进制作为桥梁即可。 有符号数据表示法(理解)​ (1)计算机中数据的存储和运算都是采用补码进行的。 (2)数据的有符号表示法 用0表示正号,1表示负号。 A:原码 正数:正常的二进制 负数:符号为为1的二进制 B:反码 正数:和原码相同 负数:和原码的区别是,符号位不变，数值位取反。1变0，0变1 C:补码 正数:和原码相同 负数:反码+1 (3)数据的有符号表示法练习 A:已知原码，求反码和补码 B:已知补码，求原码。 (4)补充：float浮点数在计算机中的表示 符号位 指数位 底数位 S E M 变量(掌握)​ (1)变量：在程序的运行过程中，其值发生改变的量。 (2)定义格式： A:数据类型 变量名 = 初始化值; B:数据类型 变量名; 变量名 = 初始化值; 数据类型(掌握)​ (1)数据类型分类 A:基本类型：4类8种 B:引用类型：类，接口，数组 (2)基本类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* 为了更好的表达现实世界的事物，Java针对不同的事物提供了不同的数据类型。 数据类型： 基本类型：4类8种 引用类型：类，接口，数组。(后面讲) 基本类型: 整数： 占用的内存空间 byte 1字节 01111111 10000000(1既表示符号位，又表示数值 -128) short 2字节 int 4字节 long 8字节 浮点数： float 4字节 double 8字节 字符： char 2字节 布尔： boolean 未知。1字节 面试题： Java中字符可以存储一个汉字吗? 可以。因为Java语言采用的是unicode编码， 而unicode编码的每个字符是两个字节， 所以，java中的字符可以存储一个汉字。 注意： 整数默认是int类型 浮点数默认是double类型 long类型的变量，要加l或者L。 float类型的变量，要加f或者F。 在同一对&#123;&#125;里面，是不能有同名的变量。*/class DataType &#123; public static void main(String[] args) &#123; //定义变量的格式： //数据类型 变量名 = 初始化值; //定义byte类型的变量 byte b = 1; System.out.println(1); System.out.println(b); //定义short类型的变量 short s = 100; System.out.println(s); //定义int类型的变量 int i = 100000; System.out.println(i); //报错 //int j = 2147483648; //System.out.println(j); //定义long类型的变量 long l = 2147483648L; System.out.println(l); //定义float类型的变量 float f = 12.34F; System.out.println(f); //定义double类型的变量 double d = 23.56; System.out.println(d); //定义char类型的变量 char ch = 'a'; System.out.println(ch); //定义boolean类型的变量 boolean flag = true; System.out.println(flag); &#125;&#125; 使用变量的注意事项​ A:作用域 每一个变量在它所属的大括号内有效，并且，同一个作用域不能定义同名的变量。 (for循环()中定义的变量与在for{}中定义有相同的作用域) B:初始化值 变量必须先声明，赋值，最后才能使用 C:在一行上定义的问题 可以在一行上定义多个变量，但是不建议。 类型转换(掌握)​ 注意： boolean类型不参与。 隐式转换：从小到大 byte,short,char --&gt; int --&gt; long --&gt; float --&gt; double long为什么可以到float呢? A:因为long和float的底层存储结构不同。 B:数据范围 long: 2^63 float: 3.4*10^38 3.4*10^38 &gt; 3.4*8^38 = 3.4*2^3^38 = 3.4*2^114 &gt; 2^63 强制转换：从大到小 一般不建议这样做，因为可能有精度的损失。 格式： 目标数据类型 变量名 = (目标数据类型)(被转换的数据); 运算符(理解) 运算：对常量和变量进行操作的过程称为运算。 运算符：对常量和变量进行操作的符号称为运算符 表达式：由运算符把常量和变量连接起来的式子 注意：表达式必须有结果 算术运算符(掌握) +,-,*,/,%,++,–` +: 正号 加法 字符串连接符 %和/的区别` `%：余数` `/：商` 整数相除，结果是整数。想得到小数，可以乘以或者除以1.0 %的结果的符号和前面的那个数一致。 ++,-- A:单独使用 放在数据的前面和后面效果一样。 B:参与操作使用 放在数据的前面，先数据变化，再参与运算。 放在数据的后面，先参与运算，再数据变化。 赋值运算符(掌握)12345678910111213141516/* 赋值运算符： 基本：= 复合：+=,-=,*=,/=,%=,...*/class OperatorDemo &#123; public static void main(String[] args) &#123; //把10赋值给int类型的变量a int a = 10; //复合的用法 int b = 10; b += 20; //结果等价于：b = b + 20; System.out.println(b); &#125;&#125; 关系运算符(掌握)123456789101112131415161718192021222324/* 关系运算符： ==,!=,&gt;,&gt;=,&lt;,&lt;= 特点： 无论表达式是简单还是复杂，结果肯定是boolean类型。 注意事项： 关系运算符“==”不能误写成“=” 。*/class OperatorDemo &#123; public static void main(String[] args) &#123; int a = 10; int b = 10; int c = 20; System.out.println(a == b); System.out.println(a == c); System.out.println((a + b*c) == (a*b + c)); System.out.println("----------------"); System.out.println(a = b); //把b的值赋值给a，把a的值作为结果留下来 System.out.println(a = c); &#125;&#125; 逻辑运算符(掌握)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* &amp;&amp;和&amp;的区别? 前者有短路效果，只要左边是false，右边不执行。而后者，全部执行。 ||和|的区别? 前者有短路效果，只要左边是true，右边不执行。而后者，全部执行。*/class OperatorDemo2 &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; int c = 30; //&amp;:逻辑与 有false则false System.out.println(a&gt;b &amp; a&gt;c); //false &amp; false = false System.out.println(a&gt;b &amp; a&lt;c); //false &amp; true = false System.out.println(a&lt;b &amp; a&gt;c); //true &amp; false = false System.out.println(a&lt;b &amp; a&lt;c); //true &amp; true = true System.out.println("--------"); //&amp;&amp;: System.out.println(a&gt;b &amp;&amp; a&gt;c); //false &amp;&amp; false = false System.out.println(a&gt;b &amp;&amp; a&lt;c); //false &amp;&amp; true = false System.out.println(a&lt;b &amp;&amp; a&gt;c); //true &amp;&amp; false = false System.out.println(a&lt;b &amp;&amp; a&lt;c); //true &amp;&amp; true = true System.out.println("--------"); //|:逻辑或 有true则true System.out.println(a&gt;b | a&gt;c); //false | false = false System.out.println(a&gt;b | a&lt;c); //false | true = true System.out.println(a&lt;b | a&gt;c); //true | false = true System.out.println(a&lt;b | a&lt;c); //true | true = true System.out.println("--------"); //||: System.out.println(a&gt;b || a&gt;c); //false || false = false System.out.println(a&gt;b || a&lt;c); //false || true = true System.out.println(a&lt;b || a&gt;c); //true || false = true System.out.println(a&lt;b || a&lt;c); //true || true = true System.out.println("--------"); int x = 3; int y = 4; //System.out.println((x++)&gt;3 &amp; (y++)&gt;4); //false &amp; false = false //System.out.println(x);//4 //System.out.println(y);//5 System.out.println((x++)&gt;3 &amp;&amp; (y++)&gt;4); System.out.println(x);//4 System.out.println(y);//4 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 逻辑运算符： &amp;,|,!,^ &amp;&amp;,|| 注意： 逻辑运算符连接的应该是一个布尔表达式。*/class OperatorDemo &#123; public static void main(String[] args) &#123; //&amp;,|,!,^ int a = 10; int b = 20; int c = 30; //&amp;:逻辑与 有false则false System.out.println(a&gt;b &amp; a&gt;c); //false &amp; false = false System.out.println(a&gt;b &amp; a&lt;c); //false &amp; true = false System.out.println(a&lt;b &amp; a&gt;c); //true &amp; false = false System.out.println(a&lt;b &amp; a&lt;c); //true &amp; true = true System.out.println("--------"); //|:逻辑或 有true则true System.out.println(a&gt;b | a&gt;c); //false | false = false System.out.println(a&gt;b | a&lt;c); //false | true = true System.out.println(a&lt;b | a&gt;c); //true | false = true System.out.println(a&lt;b | a&lt;c); //true | true = true System.out.println("--------"); //^:逻辑异或 相同false，不同true。 //情侣：男男，男女，女男，女女 System.out.println(a&gt;b ^ a&gt;c); //false ^ false = false System.out.println(a&gt;b ^ a&lt;c); //false ^ true = true System.out.println(a&lt;b ^ a&gt;c); //true ^ false = true System.out.println(a&lt;b ^ a&lt;c); //true ^ true = false System.out.println("--------"); //!:逻辑非 System.out.println((a&gt;b));//false System.out.println(!(a&gt;b));//true System.out.println(!!(a&gt;b));//false System.out.println(!!!(a&gt;b));//true System.out.println(!!!!(a&gt;b));//false &#125;&#125; 常用字符与ASCII代码对照表为了便于查询，以下列出ASCII**码表**：第128～255号为扩展字符（不常用） ASCII码 键盘 ASCII 码 键盘 ASCII 码 键盘 ASCII 码 键盘 27 ESC 32 SPACE 33 ! 34 “ 35 # 36 $ 37 % 38 &amp; 39 ‘ 40 ( 41 ) 42 * 43 + 44 ‘ 45 - 46 . 47 / 48 0 49 1 50 2 51 3 52 4 53 5 54 6 55 7 56 8 57 9 58 : 59 ; 60 &lt; 61 = 62 &gt; 63 ? 64 @ 65 A 66 B 67 C 68 D 69 E 70 F 71 G 72 H 73 I 74 J 75 K 76 L 77 M 78 N 79 O 80 P 81 Q 82 R 83 S 84 T 85 U 86 V 87 W 88 X 89 Y 90 Z 91 [ 92 \ 93 ] 94 ^ 95 _ 96 ` 97 a 98 b 99 c 100 d 101 e 102 f 103 g 104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o 112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w 120 x 121 y 122 z 123 { 124 \ 125 } 126 ~ 运算符的优先级（从高到低） 优先级 描述 运算符 1 括号 ()、[] 2 正负号 +、- 3 自增自减，非 ++、–、! 4 乘除，取余 *、/、% 5 加减 +、- 6 移位运算 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 7 大小关系 &gt;、&gt;=、&lt;、&lt;= 8 相等关系 ==、!= 9 按位与 &amp; 10 按位异或 ^ 11 按位或 \ 12 逻辑与 &amp;&amp; 13 逻辑或 \ \ 14 条件运算 ?: 15 赋值运算 =、+=、-=、*=、/=、%= 16 位赋值运算 &amp;=、\ =、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;= 如果在程序中，要改变运算顺序，可以使用()。 DAY003 位运算符(了解)123456789101112131415161718192021222324252627282930313233343536373839404142/* 位运算符：位运算符一定是先把数据转成二进制，然后再运算。 面试题：&amp;和&amp;&amp;的区别? A:&amp;和&amp;&amp;都可以作为逻辑运算，&amp;&amp;具有短路效果。 B:&amp;还可以作为位运算。*/class OperatorDemo &#123; public static void main(String[] args) &#123; //&amp;,|,^,~ System.out.println(3 &amp; 4); //0 System.out.println(3 | 4); //7 System.out.println(3 ^ 4); //7 System.out.println(~3); // &#125;&#125;/* A:计算出3，4的二进制 3的二进制：00000000 00000000 00000000 00000011 4的二进制：00000000 00000000 00000000 00000100 B:位&amp;运算 有0则0 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ------------------------------------ 00000000 00000000 00000000 00000000 C:位|运算 有1则1 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ------------------------------------ 00000000 00000000 00000000 00000111 D:位^运算 相同则0，不同则1 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ------------------------------------ 00000000 00000000 00000000 00000111 E:位~运算 把数据每个位都按位取反 00000000 00000000 00000000 00000011 ~11111111 11111111 11111111 11111100 反:11111111 11111111 11111111 11111011 原:10000000 00000000 00000000 00000100*/ 12345678910111213141516171819202122232425262728293031323334/* &lt;&lt;:左移，右边补0 &gt;&gt;:右移，根据最高位确定补齐是0还是1 &gt;&gt;&gt;:无符号右移 左边补0*/class OperatorDemo2 &#123; public static void main(String[] args) &#123; /* System.out.println(4 &lt;&lt; 2); //16 = 4 * 2^2 System.out.println(3 &lt;&lt; 3); //3 * 2 ^ 3 System.out.println(32 &gt;&gt; 2); //32 / 2^2 System.out.println(32 &gt;&gt;&gt; 2); */ System.out.println(-32 &gt;&gt; 2); System.out.println(-32 &gt;&gt;&gt; 2); &#125;&#125;/* A:&lt;&lt; 4的二进制： 00000000 00000000 00000000 00000100 (00)000000 00000000 00000000 0000010000 B:&gt;&gt;&gt; 原：10000000 00000000 00000000 00100000 反：11111111 11111111 11111111 11011111 补：11111111 11111111 11111111 11100000 &gt;&gt;&gt; 11111111 11111111 11111111 11100000 0011111111 11111111 11111111 111000(00)*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 位^运算符号：针对同一个数据异或两次，其值不变 面试题： 请把两个数据进行交换。 说明：如果我没有指定数据的类型，默认是int类型。适用于我讲课。*/class OperatorTest &#123; public static void main(String[] args) &#123; /* System.out.println(1 ^ 2 ^ 2);//1 System.out.println(1 ^ 1 ^ 2);//2 System.out.println(15 ^ 3 ^ 7 ^ 7 ^ 3);//15 */ //定义两个变量 int a = 10; int b = 20; //System.out.println(a+"---"+b); System.out.println("a="+a+",b="+b); //怎么做呢? //方式1：使用第三方变量。开发中常用此方案。 /* int temp = a; a = b; b = temp; System.out.println("a="+a+",b="+b); */ //方式2：不好，可能a+b已经超出范围了。 /* a = a + b; //a=30 b = a - b; //b=10 a = a - b; //a=20 System.out.println("a="+a+",b="+b); */ //方式3：不好，可能a+b已经超出范围了。 //a = (a+b) - (b=a); //一句话搞定 //System.out.println("a="+a+",b="+b); //方式4：面试 a = a ^ b; b = a ^ b; //b = a ^ b = a ^ b ^ b = a; a = a ^ b; //a = a ^ b = a ^ b ^ a = b; System.out.println("a="+a+",b="+b); //记忆：左边，a,b,a。右边a^b &#125;&#125; 三元运算符(掌握)​ 123456789101112131415161718192021222324252627282930313233343536/* 三元运算符： 格式 (关系表达式)?表达式1：表达式2； 执行流程： 计算关系表达式，看其返回值 true:表达式1就是整个表达式的值 false:表达式2就是整个表达式的值*/class OperatorDemo &#123; public static void main(String[] args) &#123; //获取两个数据中的较大值 int x = 3; int y = 4; int z = (x &gt; y)? x : y; System.out.println(z); //比较两个数是否相等 int a = 4; int b = 4; //boolean flag = (a==b)?true:false; boolean flag = (a == b); System.out.println(flag); //获取三个数据中的较大值 int c = 30; int d = 40; int e = 50; //int max = (c&gt;d)?(c&gt;e?c:e):(d&gt;e?d:e); int temp = (c&gt;d)?c:d; int max = (temp&gt;e)?temp:e; System.out.println(max); &#125;&#125; 键盘录入数据(掌握)123456789101112131415161718192021222324252627/* 为了程序的数据更加的灵活，我们决定加入键盘录入数据。 如何使用键盘录入数据呢?目前你就给我记住了。 A:导包 import java.util.Scanner; 在class的上面 B:创建对象 Scanner sc = new Scanner(System.in); C:获取数据 int i = sc.nextInt();*/import java.util.Scanner;class OperatorDemo &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println("请输入一个整数："); //获取数据 int i = sc.nextInt(); System.out.println("i:"+i); &#125;&#125; 流程控制(掌握)​ (1)流程控制语句： 顺序结构 1234567891011121314/* 是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序， 依次执行，程序中大多数的代码都是这样执行的。 总的来说：写在前面的先执行，写在后面的后执行*/class OrderDemo &#123; public static void main(String[] args) &#123; System.out.println("我爱林青霞"); System.out.println("我爱Java"); System.out.println("我爱张曼玉"); System.out.println("林青霞爱张曼玉"); &#125;&#125; ​ 选择结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* if语句的第二种格式和三元运算符的区别： 三元运算符： 关系表达式?表达式1:表达式2; if语句格式2： if(关系表达式)&#123; 语句体1; &#125;else &#123; 语句体2; &#125; 总结： 三元运算符能够实现的，if语句的第二种格式都可以实现。反之不成立。 什么时候不成立呢? 当if语句的语句体是一条输出语句时，就不成立。 因为三元运算符是一个运算符，要求有结果返回，而输出语句不能作为一个结果返回。*/import java.util.Scanner;class IfDemo4 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //获取键盘录入数据 System.out.println("请输入第一个数据："); int a = sc.nextInt(); System.out.println("请输入第二个数据："); int b = sc.nextInt(); //使用三元运算符实现 int c = (a&gt;b)?a:b; System.out.println("c:"+c); //用if语句格式2实现 int d; if(a &gt; b) &#123; d = a; &#125;else &#123; d = b; &#125; System.out.println("d:"+d); System.out.println("------------------"); //直接把结果输出 if(a &gt; b) &#123; System.out.println("a:"+a); &#125;else &#123; System.out.println("b:"+b); &#125; //用三元运算符改进 //(a&gt;b)?System.out.println("a:"+a):System.out.println("b:"+b); &#125;&#125; ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* if语句格式3： if(关系表达式1) &#123; 语句体1; &#125;else if (关系表达式2) &#123; 语句体2; &#125; … else &#123; 语句体n+1; &#125; 执行流程： 首先判断关系表达式1看其结果是true还是false 如果是true就执行语句体1 如果是false就继续判断关系表达式2看其结果是true还是false 如果是true就执行语句体2 如果是false就继续判断关系表达式…看其结果是true还是false … 如果没有任何关系表达式为true，就执行语句体n+1。 需求： 键盘录入学生成绩，根据成绩输出对于的评价。 90-100 优秀 80-90 好 70-80 良 60-70 及格 60以下 不及格*/import java.util.Scanner;class IfDemo5 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //键盘录入学生成绩 System.out.println("请输入成绩："); int score = sc.nextInt(); //校验数据的时候，一定要注意： //正确数据 //错误数据 //边界数据 /* if(score&gt;=90 &amp;&amp; score&lt;=100) &#123; System.out.println("优秀"); &#125;else if(score&gt;=80 &amp;&amp; score&lt;90) &#123; System.out.println("好"); &#125;else if(score&gt;=70 &amp;&amp; score&lt;80) &#123; System.out.println("良"); &#125;else if(score&gt;=60 &amp;&amp; score&lt;70) &#123; System.out.println("及格"); &#125;else &#123; System.out.println("不及格"); &#125; */ //这个时候，虽然可以满足要求了。但是没有考虑到错误数据的情况。 //所以，我们需要加一个判断 /* if(score&gt;=90 &amp;&amp; score&lt;=100) &#123; System.out.println("优秀"); &#125;else if(score&gt;=80 &amp;&amp; score&lt;90) &#123; System.out.println("好"); &#125;else if(score&gt;=70 &amp;&amp; score&lt;80) &#123; System.out.println("良"); &#125;else if(score&gt;=60 &amp;&amp; score&lt;70) &#123; System.out.println("及格"); &#125;else if(score&gt;=0 &amp;&amp; score&lt;60) &#123; System.out.println("不及格"); &#125;else &#123; System.out.println("输入的成绩有误"); &#125; */ //我们也可以先判断成绩是否有误 if(score&lt;0 || score&gt;100) &#123; System.out.println("输入的成绩有误"); &#125;else if(score&gt;=90 &amp;&amp; score&lt;=100) &#123; System.out.println("优秀"); &#125;else if(score&gt;=80 &amp;&amp; score&lt;90) &#123; System.out.println("好"); &#125;else if(score&gt;=70 &amp;&amp; score&lt;80) &#123; System.out.println("良"); &#125;else if(score&gt;=60 &amp;&amp; score&lt;70) &#123; System.out.println("及格"); &#125;else &#123; System.out.println("不及格"); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* switch语句格式： switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; &#125; 格式解释： A:switch表示这是switch语句 B:表达式的取值 byte,short,int,char JDK5以后可以是枚举类型。(enum) JDK7以后可以是字符串。(String) C:case后面跟的是要和表达式进行比较的值 D:语句体可以是多条语句 E:break表示中断，结束的意思，可以结束switch语句 F:default语句表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。 面试题： switch的表达式可以是byte类型吗?可以是long类型吗?可以是String类型吗? 可以。 不可以。 JDK7以后可以。 执行流程： A:首先计算出表达式的值 B:其次，和case依次比较，一旦有对应的值，就会执行相应的语句， 在执行的过程中，遇到break就会结束。 C:最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 需求：根据键盘录入的数值1，2，3，…7输出对应的星期一，星期二，星期三…星期日。 分析： A:键盘录入数据，用Scanner实现 B:对录入的数据进行判断，用switch实现 C:输出对应的结果 注意事项 A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 B:default可以省略吗 可以省略。一般不建议。除非判断的值是固定的。 C:break可以省略吗 可以。最后一个肯定是没有任何问题的。 中间的省略也是可以的，但是不建议，因为可能对我们想要的结果产生影响。 D:default的位置一定要在最后吗 不一定，可以在任何和case相对应的位置。 但是，这个时候，最好加上break。 E:switch语句的结束条件 a:遇到break。 b:执行到程序的末尾*/import java.util.Scanner;class SwitchDemo &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //键盘录入数据 System.out.println("请输入一个数据(1-7)："); int week = sc.nextInt(); //用switch语句实现 switch(week) &#123; case 1: System.out.println("星期一"); break; case 2: System.out.println("星期二"); break; case 3: System.out.println("星期三"); break; case 4: System.out.println("星期四"); break; case 5: System.out.println("星期五"); break; case 6: System.out.println("星期六"); break; case 7: System.out.println("星期日"); break; default: System.out.println("你输入的数据有误"); break; &#125; &#125;&#125; ​ 循环结构 123456789101112131415161718192021222324252627/* for和while的区别： 使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了， 而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。 原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。 场景区别： for循环适合针对一个范围判断进行操作 水仙花 while循环适合判断次数不明确操作 吃葡萄*/class WhileDemo2 &#123; public static void main(String[] args) &#123; int x = 0; while(x&lt;10) &#123; System.out.println(x); x++; &#125; System.out.println(x+"---"); System.out.println("-----------"); for(int y=0; y&lt;10; y++) &#123; System.out.println(y); &#125; //System.out.println(y+"---"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/* do...while格式： do &#123; 语句体; &#125;while(条件表达式); 变形格式： 初始化语句; do &#123; 循环体语句; 控制条件语句; &#125;while(判断条件语句); for(初始化语句;判断条件语句;控制条件语句) &#123; 循环体语句; &#125;*/class DoWhileDemo &#123; public static void main(String[] args) &#123; /* int sum = 0; for(int x=1; x&lt;=100; x++) &#123; sum+=x; &#125; System.out.println(sum); */ //do...while int sum = 0; int x = 1; do&#123; sum+=x; x++; &#125;while (x&lt;=100); System.out.println(sum); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/* 需求：在控制台输出九九乘法表。 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 ... 1*9=9 2*9=18 3*9=27 4*9=36 ... 转移字符： \t tab键的位置*/class ForForDemo3 &#123; public static void main(String[] args) &#123; //如果我们把每一行看作一颗* //那么这其实就是我们刚才的三角形 /* for(int x=1; x&lt;=9; x++) &#123; for(int y=1; y&lt;=x; y++) &#123; System.out.print("*"+"\t"); &#125; System.out.println(); &#125; */ //接下来，我们要把*替换为表达式 for(int x=1; x&lt;=9; x++) &#123; for(int y=1; y&lt;=x; y++) &#123; System.out.print(y+"*"+x+"="+(x*y)+"\t"); &#125; System.out.println(); &#125; &#125;&#125; DAY004 循环语句(掌握)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138 (1)for循环 for(初始化表达式;条件表达式;控制条件表达式)&#123; 循环体; &#125; 执行流程： A:首先执行初始化表达式 B:其次执行条件表达式，看其返回值 如果是true，就继续 如果是false，就结束循环 C:执行循环体; D:执行控制条件表达式 E:回到B(2)while循环 基本格式： while(条件表达式)&#123; 语句体; &#125; 变形： 初始化表达式; while(条件表达式)&#123; 循环体; 控制条件表达式; &#125;(3)do...while循环(理解) 基本格式： do &#123; 语句体; &#125;while(条件表达式); 变形: 初始化表达式; do&#123; 循环体; 控制条件表达式; &#125;while(条件表达式);(4)三种循环的区别 A:do...while至少执行一次循环体，而其他两种循环都是先判断在执行。 B:while和for循环是可以等价转换的。在使用的时候，优先选择for。 规则： a:如果控制条件表达式控制的那个变量，后面还要使用，只能使用while b:for适合范围的取值，while适合次数不明确的操作(5)注意事项： 死循环： for(;;)&#123;&#125; while(true)&#123;&#125;(6)案例： A:输出10次HelloWorld for(int x=0; x&lt;10; x++) &#123; System.out.println("HelloWorld"); &#125; B:输出1-10 for(int x=1; x&lt;=10; x++) &#123; System.out.println(x); &#125; C:输出10-1 for(int x=10; x&gt;0; x--) &#123; System.out.println(x); &#125; D:求1-10的和 int sum = 0; for(int x=1; x&lt;=10; x++) &#123; sum += x; &#125; System.out.println(sum); E:求1-100的偶数和(奇数自己写) //方式1： int sum = 0; for(int x=0; x&lt;=100; x+=2) &#123; sum += x; &#125; System.out.println(sum); //方式2： int sum = 0; for(int x=0; x&lt;=100; x++) &#123; if(x%2 == 0)&#123; sum += x; &#125; &#125; System.out.println(sum); F:输出水仙花的数 for(int x=100; x&lt;1000; x++) &#123; int ge = x%10; int shi = x/10%10; int bai = x/10/10%10; if(x == (ge*ge*ge+shi*shi*shi+bai*bai*bai)) &#123; System.out.println(x); &#125; &#125; G:统计水仙花的个数 int count = 0; for(int x=100; x&lt;1000; x++) &#123; int ge = x%10; int shi = x/10%10; int bai = x/10/10%10; if(x == (ge*ge*ge+shi*shi*shi+bai*bai*bai)) &#123; count++; &#125; &#125; System.out.println(count); H:输出满足条件的5位数 for(int x=10000; x&lt;100000; x++) &#123; int ge = x%10; int shi = x/10%10; int bai = x/10/10%10; int qian = x/10/10/10%10; int wan = x/10/10/10/10%10; if((ge==wan) &amp;&amp; (shi==qian) &amp;&amp; (bai==ge+shi+qian+wan)) &#123; System.out.println(x); &#125; &#125; I:统计满足条件的数据 int count = 0; for(int x=0; x&lt;1000; x++) &#123; if(x%3==2 &amp;&amp; x%5==3 &amp;&amp; x%7==2) &#123; count++; &#125; &#125; System.out.println(count); J:折叠次数 int start = 1; int end = 884800; int count = 0; while(start&lt;=end) &#123; count++; start*=2; &#125; System.out.println(count); K:小芳存钱的题目，自己把代码看懂即可。 控制跳转语句(掌握) break:中断 A:场景 switch 循环语句中 B:使用 退出单层循环 退出多层循环(带标签的使用) continue:继续 A:场景 循环语句中 B:使用 退出单层循环 退出多层循环(带标签的使用) break和continue的区别： break:退出整个循环 continue:退出一次循环，进行下一次 return:返回 返回，让方法结束。其实在void类型的方法，最后也有一个return。 只不过是：reutrn; . 在控制台输出多少次： &quot;Java基础班&quot; 方法(掌握)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 方法：完成特定功能的代码块 格式： 修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) &#123; 方法体; return 返回值; &#125; 修饰符：public static 返回值类型：功能最终的值的数据类型 方法名：是为了方便调用而起的一个名字 参数： 形式参数：用于接受实际参数的变量 实际参数：实际参与运算的数据 方法体：完成特定功能的代码 return 返回值：通过return把结果返回给调用者 我们虽然知道了方法的格式，那么我们该如何写一个方法呢? 两个明确： A:返回值类型 结果的数据类型 B:参数列表 有几个参数参加，并且每个参数的数据类型是什么 需求：求两个数据之和的案例 A:我没有说数据的类型，默认int类型。 B:求两个数据的和 说明有两个参数参加，并且默认都是int类型 C:两个int类型相加的结果是什么类型呢? 是int类型，所以返回值类型这里是int类型 方法的执行特点： 不调用不执行。 有明确返回值的方法的调用： A:单独调用，没有意义。 B:输出调用，不是很好，因为我们可能需要针对结果还要进行其他的操作。 C:赋值调用，推荐方式。 方法的注意事项： A:方法不调用不执行 B:方法与方法是平级关系，不能嵌套定义 C:方法定义的时候参数之间用逗号隔开 D:方法调用的时候不用在传递数据类型 可以传递变量，也可以常量。就是不能加数据类型 E:如果方法有明确的返回值，一定要有return带回一个值*/class MethodDemo &#123; public static void main(String[] args) &#123; //定义两个变量 int x = 10; int y = 20; //单独调用 //sum(x,y); //输出调用 System.out.println(sum(x,y)); //赋值调用 int result = sum(x,y); //result进行操作 System.out.println(result); &#125; //如果我自己要想写一个方法 public static int sum(int a,int b) &#123; int c = a + b; return c; &#125;&#125; DAY005方法重载(理解)​ 12345678910111213141516171819202122232425262728293031323334353637383940/* 方法重载： 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 和返回值类型无关。*/class MethodDemo &#123; public static void main(String[] args) &#123; //需求：请写一个功能，实现两个数据的求和 System.out.println(sum(10,20)); //需求：请写一个功能，实现三个数据的求和 //System.out.println(sum2(10,20,30)); System.out.println(sum(10,20,30)); System.out.println(sum(1.5,2.5)); &#125; public static int sum(int a,int b) &#123; return a + b; &#125; /* public static int sum2(int a,int b,int c) &#123; return a + b + c; //方法的嵌套调用 //return sum(sum(a,b),c); &#125; */ //由于方法名要表达的其实是该方法的作用 //所以，sum2这个名字不好，还是要用sum 比较好 public static int sum(int a,int b,int c) &#123; return a + b + c; &#125; public static double sum(double a,double b) &#123; return a + b; &#125;&#125; 一维数组(掌握) 数组:存储同一种数据类型的多个元素的集合 每个元素都有编号，从0开始。 最大编号是数组的长度-1 数组的格式： A:数据类型[] 数组名; B:数据类型 数组名[]; 数组的初始化： A:动态初始化 只给长度，不给元素 `int[] arr = new int[3];` B:静态初始化 不给长度，给元素 `int[] arr = new int[]{1,2,3};` `简化版：int[] arr = {1,2,3};` java中的内存分配 A:栈 存储局部变量 B:堆 new出来的 C:方法区 D:本地方法区 E:寄存器 两个常见小问题 A:数组越界 B:空指针异常 . 数组常见操作 获取数组长度：数组名.length A:数组遍历 B:获取最值 C:数组反转 D:查表法 E:查找指定元素第一次出现的索引 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* 数组：存储同一种数据类型的多个元素的集合。(也可以称为容器) 数组的定义格式： 格式1：数据类型[] 数组名; int[] arr; 格式2：数据类型 数组名[]; int arr[]; 推荐方式1。 现在的数组没有元素，使用是没有意义的。 接下来，我们要对数组进行初始化。 那么，我们如何对数组进行初始化呢? 动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 动态初始化： 数据类型[] 数组名 = new 数据类型[数组长度];*/class ArrayDemo &#123; public static void main(String[] args) &#123; //按照动态初始化数组的格式，我们来定义一个存储3个int类型元素的数组 int[] arr = new int[3]; /* 左边： int:说明数组中的元素的数据类型。 []:说明这是一个数组 arr:数组的名称 右边： new:为实体(对象)开辟内存空间 Scanner sc = new Scanner(System.in); int:说明数组中的元素的数据类型。 []:说明这是一个数组 3:说明的是数组中的元素个数 */ //我们如何获取里面的值呢? //数组名称 System.out.println(arr); //[I@778b3fee 地址值 //如何获取元素值呢? //数组为每个元素分配了一个编号，这个编号的专业叫法：索引。 //而且是从0开始编号的。也就是说数组的最大编号是长度-1。 //有了编号以后，我们就可以通过数组名和编号的配合取得数组元素 //格式：数组名[编号]; System.out.println(arr[0]); //0 System.out.println(arr[1]); //0 System.out.println(arr[2]); //0 &#125;&#125;/* 静态初始化格式： 数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,…&#125;; 简化版： 数据类型[] 数组名 = &#123;元素1,元素2,…&#125;;*/class ArrayDemo5 &#123; public static void main(String[] args) &#123; //定义一个数组 //int[] arr = new int[]&#123;1,2,3&#125;; //简化后 int[] arr = &#123;1,2,3&#125;; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125;/* 数组操作常见的两个小问题: A:数组索引越界 ArrayIndexOutOfBoundsException 因为我们访问了不存在的索引。 B:空指针异常 NullPointerException 因为数组已经不再指向堆内存，所以就不能再去访问堆内存的元素了。*/class ArrayDemo6 &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = &#123;1,2,3&#125;; //System.out.println(arr[3]); arr = null; //把arr指向堆内存给去掉了，arr没有指向了。 System.out.println(arr[0]); &#125;&#125; 二维数组(理解)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/* 二维数组：元素为一维数组的数组。 定义格式1： 数据类型[][] 变量名 = new 数据类型[m][n]; m:m表示这个二维数组有多少个一维数组 n:n表示每一个一维数组的元素个数 变形： 数据类型 变量名[][] = new 数据类型[m][n]; 数据类型[] 变量名[] = new 数据类型[m][n]; int[] x,y[];*/class Array2Demo &#123; public static void main(String[] args) &#123; //定义一个二维数组 int[][] arr = new int[3][2]; //表示arr这个二维数组有三个元素 //每个元素是一个一维数组 //每一个一维数组有2个元素 System.out.println(arr); //[[I@778b3fee System.out.println(arr[0]); //[I@57125f92 System.out.println(arr[1]); System.out.println(arr[2]); //如何输出元素呢? System.out.println(arr[0][1]); System.out.println(arr[2][2]); &#125;&#125;/* 定义格式2： 数据类型[][] 变量名 = new 数据类型[m][]; m:m表示这个二维数组有多少个一维数组*/class Array2Demo2 &#123; public static void main(String[] args) &#123; //定义一个数组 int[][] arr = new int[3][]; //这里我们仅仅知道这个二维数组有3个一维数组 //但是，每个一维数组有几个元素，我们是不知道的 System.out.println(arr); //[[I@7d3598c3 System.out.println(arr[0]); //null System.out.println(arr[1]); //null System.out.println(arr[2]); //null arr[0] = new int[3]; arr[1] = new int[1]; arr[2] = new int[2]; System.out.println(arr[0]); // System.out.println(arr[1]); // System.out.println(arr[2]); // arr[2][1] = 100; arr[1][3] = 200; &#125;&#125;/* 定义格式2： 数据类型[][] 变量名 = new 数据类型[][]&#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;; 变形格式： 数据类型[][] 变量名 = &#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;*/class Array2Demo3 &#123; public static void main(String[] args) &#123; //定义数组 //int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;8&#125;&#125;; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[0][0]); System.out.println(arr[0][1]); System.out.println(arr[1][1]); System.out.println(arr[2][1]); &#125;&#125; 两个思考题 java参数传递问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 看程序写结果，并总结基本类型和引用类型参数的传递问题(题目在备注部分) 基本类型：形式参数的改变对实际参数没有影响。 引用类型：形式参数的改变直接影响实际参数。 java中有没有引用传递? java中只有值传递。 地址值也是一个值。*/class ArgsDemo &#123; public static void main(String[] args)&#123; int a = 10; int b = 20; System.out.println("a:"+a+",b:"+b); //a:10,b:20 change(a,b); System.out.println("a:"+a+",b:"+b); //a:?,b:? int[] arr = &#123;1,2,3,4,5&#125;; change(arr); System.out.println(arr[1]); //? &#125; public static void change(int a,int b) //a=10,b=20 &#123; System.out.println("a:"+a+",b:"+b); //a:10,b:20 a = b; //a=20; b = a + b; //b=40; System.out.println("a:"+a+",b:"+b); //a:20,b:40 &#125; public static void change(int[] arr) //arr = &#123;1,2,3,4,5&#125; &#123; for(int x=0; x&lt;arr.length; x++) &#123; //如果是偶数，数据变为以前的2倍。 if(arr[x]%2==0) &#123; arr[x]*=2; &#125; &#125; //&#123;1,4,3,8,5&#125; &#125;&#125; ​ java中只有值传递。因为地址值也是一个值。 数据加密问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 某个公司采用公用电话传递数据信息，数据是小于8位的整数，为了确保安全， 在传递过程中需要加密，加密规则如下： 首先将数据倒序，然后将每位数字都加上5，再用和除以10的余数代替该数字， 最后将第一位和最后一位数字交换。 请任意给定一个小于8位的整数， 然后，把加密后的结果在控制台打印出来。 分析： A:数据是小于8位的整数 数据是变化的。(不以0开头) B:加密规则 假设数据为：123456 首先将数据倒序 654321 然后将每位数字都加上5，再用和除以10的余数代替该数字 109876 最后将第一位和最后一位数字交换 609871 C:输出结果 609871*/class JiaMiDemo&#123; public static void main(String[] args) &#123; //123456 //int[] arr = &#123;1,2,3,4,5,6&#125;; //定义数据 int number = 123456; //定义数组 int[] arr = new int[8]; //取得一个数据的任意位上的值 //6,5,4,3,2,1 /* arr[0] = number%10; arr[1] = number/10%10; arr[2] = number/10/10%10; ... */ //第一步 //定义一个索引变量 int index = 0; while(number&gt;0) &#123; arr[index] = number%10; //arr[0]=6,arr[1]=5,arr[2]=4,arr[3]=3,arr[4]=2,arr[5]=1 number/=10; //number=12345,number=1234,number=123,number=12,number=1,number=0 index++; //index=1,index=2,index=3,index=4,index=5,index=6 &#125; for(int x=0; x&lt;index; x++) &#123; System.out.print(arr[x]); &#125; System.out.println(); //第二步 for(int x=0; x&lt;index; x++) &#123; arr[x] += 5; arr[x] %= 10; &#125; for(int x=0; x&lt;index; x++) &#123; System.out.print(arr[x]); &#125; System.out.println(); //第三步 int temp = arr[0]; arr[0] = arr[index-1]; arr[index-1] = temp; for(int x=0; x&lt;index; x++) &#123; System.out.print(arr[x]); &#125; System.out.println(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* A:把实现的代码改进为功能实现 B:键盘录入版*/import java.util.Scanner;class JiaMiDemo2 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //键盘录入数据 System.out.println("请输入数据(小于8位的整数)："); int number = sc.nextInt(); jiaMi(number); &#125; public static void jiaMi(int number) &#123; int[] arr = new int[8]; //第一步 int index = 0; while(number&gt;0) &#123; arr[index++] = number%10; number /= 10; &#125; //第二步 for(int x=0; x&lt;index; x++) &#123; arr[x] += 5; arr[x] %= 10; &#125; //第三步 int temp = arr[0]; arr[0] = arr[index-1]; arr[index-1] = temp; //输出 for(int x=0; x&lt;index; x++) &#123; System.out.print(arr[x]); &#125; System.out.println(); &#125;&#125; ​ DAY006 面向对象：​ 面向对象是基于面向过程的编程思想 面向过程：自己一步步的完成操作，强调的是过程。 面向对象：调用别人的操作，强调的是结果。 面向对象的思想特点： A:是一种更符合我们思想习惯的思想 B:可以将复杂的事情简单化 C:将我们从执行者变成了指挥者 角色发生了转换 举例： A:洗衣服 面向过程：把盆子接水,放洗衣粉–&gt;把衣服扔进去浸泡–&gt;用手揉搓衣服–&gt;漂洗衣服–&gt;拧干–&gt;拿衣架晾起来 面向对象：把衣服扔到洗衣机，放洗衣粉,按下启动即可–&gt;拿衣架晾起来 B:吃饭 面向过程：去超市买菜,买米–&gt;洗菜,洗米–&gt;切菜,做饭–&gt;炒菜–&gt;端菜,盛饭–&gt;开吃 面向对象：去饭店–&gt;调用服务员的记菜功能–&gt;调用厨师的炒菜功能–&gt;调用服务员的端菜功能–&gt;开吃–&gt;付账 可以找一个对象帮我们做这些事情。 C:买电脑面向过程：查阅资料–&gt;坐公交–&gt;到赛格电脑城–&gt;各家比较–&gt;选中自己喜爱的并讨价还价–&gt;回家面向对象：查阅资料–&gt;京东–&gt;货到付账 写代码举例： 需求：把大象装进冰箱 步骤： A:打开冰箱门 B:塞进大象 C:关闭冰箱门 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283A:面向过程 a:打开冰箱门 b:塞进大象 c:关闭冰箱门 代码： class Demo &#123; public static void main(String[] args) &#123; //System.out.println("打开冰箱门"); //System.out.println("塞进大象"); //System.out.println("关闭冰箱门"); //可能打开冰箱门的操作需要做多次 //并且，打开冰箱门这个功能的代码比较多 //这个时候，其实我们应该用方法改进 //调用功能 open(); in(); close(); //open(); //open(); &#125; public static void open() &#123; System.out.println("打开冰箱门"); &#125; public static void in()&#123; System.out.println("塞进大象"); &#125; public static void close() &#123; System.out.println("关闭冰箱门"); &#125; &#125;B:面向对象 要想做到面向对象，请参照我的三句话： a:分析有哪些类存在 UML(统一建模语言) 名词提取法 b:分析每个类有哪些功能 c:分析类与类的关系 分析我们的问题： 把大象装进冰箱 a:分析有哪些类存在 大象 冰箱 测试类(带main方法的那个类) b:分析每个类有哪些功能 大象:进去 冰箱:打开,关闭 测试类:main c:分析类与类的关系 在测试类中调用冰箱类和大象类的功能 代码： class 大象 &#123; public static void in()&#123; System.out.println("塞进大象"); &#125; &#125; class 冰箱 &#123; public static void open() &#123; System.out.println("打开冰箱门"); &#125; public static void close() &#123; System.out.println("关闭冰箱门"); &#125; &#125; class 测试类 &#123; public static void main(String[] args) &#123; 冰箱的open(); 大象的in(); 冰箱的close(); &#125; &#125; 学完面向对象： 以后我们在完成一个需求的时候，请先找是否有对象完成了这个功能，有，我们就直接使用即可。 如果没有，我们就自己定义一个类，完成功能，将来还可以给别人用。 类与对象(掌握)我们学习编程语言，是为了把现实世界的事物给表达出来，实现信息化处理。 我们要想通过编程语言来描述事物，首先要知道，事物是如何表达的： 1. 事物： 属性 该事物的描述信息(外在特征) 行为 该事物能够做什么(内在行为) 我们学习的是java语言，而java语言最基本的单位是类。所以，我们要把事物通过类来体现。 2. 事物： 属性 该事物的描述信息(外在特征) 行为 该事物能够做什么(内在行为) ​ 3. 类： 成员变量 该事物的描述信息(外在特征) 成员方法 该事物能够做什么(内在行为) 类：是一组相关的属性和行为的集合对象：是该类事物的具体体现 举例： 学生是类 张三是对象 类的组成(掌握)​ (1)成员变量 其实就是变量，只不过定义在类中，方法外，并且可以不用初始化。 (2)成员方法 其实就是方法，只不过不需要static了 (3)案例： 123456789101112131415161718192021222324252627282930313233343536373839/* 第一步：分析事物 手机事物： 属性：品牌，价格，颜色 行为：打电话，发短信 第二步：把事物转换为类 手机类： 成员变量：品牌，价格，颜色 成员方法：打电话，发短信 第三步：把类用英文体现 Phone: 成员变量：brand，price，color 成员方法：call(String name)，sendMessage() 第四步：写代码体现 成员变量：其实就是一个变量，只不过定义在类中方法外，并且也可以不给初始化值。 成员方法：其实就是一个方法，只不过不需要static了。*///这是我的手机类class Phone &#123; //品牌 String brand; //价格 int price; //颜色 String color; //打电话的方法 public void call(String name) &#123; System.out.println("给"+name+"打电话"); &#125; //发短信的方法 public void sendMessage() &#123; System.out.println("群发短信"); &#125;&#125; 类的使用(掌握)​ (1)创建对象 格式：类名 对象名 = new 类名(); (2)使用成员 成员变量：对象名.变量名; 成员方法：对象名.方法名(…); 成员变量和局部变量的区别(理解)​ 12345678910111213141516171819202122232425262728293031/* 成员变量和局部变量的区别： A:在类中的位置不同 成员变量 类中方法外 局部变量 方法内或者方法声明上 B:在内存中的位置不同 成员变量 堆内存 局部变量 栈内存 C:生命周期不同 成员变量 随着对象的存在而存在，随着对象的消失而消失 局部变量 随着方法的调用而存在，随着方法的调用完毕而消失 D:初始化值不同 成员变量 有默认的初始化值 局部变量 没有默认的初始化值，必须先定义，赋值，才能使用。 注意： 如果有同名的变量，一般会采用就近原则。*/class VariableDemo &#123; //成员变量 int x; public static void main(String[] args) &#123; //局部变量 int y; //System.out.println(y); VariableDemo vd = new VariableDemo(); System.out.println(vd.x); &#125;&#125; 形式参数问题(理解)​ (1)基本类型 基本类型作为形式参数，需要的是该基本类型的值。 (2)引用类型 引用类型作为形式参数，需要的是该引用类型的地址值。(对象) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 匿名对象：没有名字的对象。 使用场景： A:调用方法,该方法仅仅被使用一次的时候适用。 B:作为实际参数传递*///定义学生类，写一个love方法class Student &#123; public void love() &#123; System.out.println("学生喜欢放假"); &#125;&#125;class StudentDemo &#123; public void test(Student s) &#123; s.love(); &#125;&#125;//测试类class NoNameObject &#123; public static void main(String[] args) &#123; /* //创建对象 Student s = new Student(); s.love(); s.love(); //匿名对象 new Student().love(); new Student().love(); */ //有名字的情况 //StudentDemo sd = new StudentDemo(); //Student s = new Student(); //sd.test(s); //没有名字的情况 //StudentDemo sd = new StudentDemo(); //sd.test(new Student()); //不妨在来一步 new StudentDemo().test(new Student()); &#125;&#125; 匿名对象(理解)​ (1)匿名对象：没有名字的对象。是对象的简化书写方式。 (2)使用场景 A:调用方法，仅仅只调用一次 B:作为实际参数传递 封装(掌握)​ (1)隐藏实现细节，提供公共的访问方式 (2)好处： A:隐藏实现细节，提供公共的访问方式 B:提高了代码的复用性 C:提高了代码的安全性 (3)使用原则 A:把成员变量隐藏 B:给出该成员变量对应的公共访问方式 private关键字(掌握)​ (1)是一个权限修饰符 (2)可以修饰类的成员(成员变量和成员方法) (3)仅仅在本类中可以访问 (4)标准代码： 123456789101112131415161718192021 class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; public void study() &#123;&#125;&#125; this关键字(掌握)​ (1)this：代表本类的对象 (2)应用场景： 解决了局部变量隐藏成员变量的问题。 其他用法和super一起讲。 (3)标准代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 我们曾经说过，起名字，要做到见名知意，而现在的n和a都不是一个好的变量名称。 由于变量在查找的时候，采用的是就近原则，所以，这个时候，就产生了问题。 本来想给成员变量赋值的，确赋值给了局部变量。 那么，我们该如何解决这个问题呢? java针对这种情况，就提供了一个关键字：this this：代表本类的对象 应用场景： 局部变量隐藏成员变量*/class Student &#123; private String name; private int age; /* public void setName(String n) &#123; name = n; &#125; */ public void setName(String name) &#123; //"林青霞" this.name = name; &#125; public String getName() &#123; return name; //其实这里隐含了this &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125;class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); //输出成员变量的值 System.out.println(s.getName()+"---"+s.getAge()); //给成员变量赋值 s.setName("林青霞"); s.setAge(28); //再次输出成员变量的值 System.out.println(s.getName()+"---"+s.getAge()); &#125; &#125; DAY007 构造方法(掌握)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* 构造方法作用：给对象的数据进行初始化 特点： A:方法名与类名相同 B:没有返回值类型，连void都没有 C:没有具体的返回值 构造方法的格式： 修饰符 类名(...) &#123; &#125; 构造方法的注意事项： A:如果你不提供构造方法，系统会给出默认无参构造方法 B:如果你提供了构造方法，系统将不再提供默认无参构造方法 这个时候，如果你还想继续使用无参构造方法，只能自己给出。 推荐：永远自己给出无参构造方法。 C:构造方法也是可以重载的 D:构造方法中可以有return语句吗? 可以。只不过是return;*/class Student &#123; //成员变量 private String name; private int age; //构造方法 public Student() &#123; System.out.println("我是无参构造方法"); //return; &#125; public Student(String name) &#123; this.name = name; &#125; public Student(int age) &#123; this.age = age; &#125; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; //getXxx()/setXxx()方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; //显示所有成员变量的方法 public void show() &#123; System.out.println("姓名是："+name+",年龄是："+age); &#125;&#125;class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); s.show(); //创建对象 Student s2 = new Student("林青霞"); s2.show(); //创建对象 Student s3 = new Student(28); s3.show(); //创建对象 Student s4 = new Student("林青霞",28); s4.show(); &#125;&#125; 对象的初始化过程(理解) Student s = new Student();做了哪些事情 A:加载Student.class文件进内存 B:在栈中为s开辟空间 C:在堆中为学生对象开辟空间 D:为学生对象的成员变量赋默认值 E:为学生对象的成员变量赋显示值 F:通过构造方法给成员变量赋值 G:对象构造完毕，把地址赋值给s变量 面向对象的练习(掌握) (1)写一个类Demo,里面有一个求和功能。并测试。 (2)写一个长方形的类，里面有求周长和面积的功能。并测试。 (3)自己分析员工类，实现，并测试。 (4)自己写一个包含了加减乘除运算的类，并测试。 static关键字(掌握) (1)是一个状态修饰符。静态的意思 (2)它可以修饰成员变量和成员方法 (3)特点： A:随着类的加载而加载 B:优先于对象存在 C:被所有对象共享 这也是判断我们是不是该使用静态的条件 举例：饮水机和水杯例子。 D:可以通过类名调用 静态修饰的内容，可以通过类名调用，也可以通过对象名调用 (4)方法访问特点 ​ A:普通成员方法 ​ 可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法 ​ B:静态成员方法 ​ 只能访问静态成员变量，静态成员方法 简记：静态只能访问静态 注意： 静态中是不能有this的。 先进内存的不能访问后进内存的。反之可以。 ​ 静态成员变量和普通成员变量的区别(理解)​ (1)所属不同 静态属于类的，称为类变量 非静态属于对象的，称为对象变量，实例变量 (2)内存空间不同 静态在方法区的静态区 非静态在堆内存 (3)生命周期不同 静态随着类的加载而加载，随着类的消失而消失 非静态随着对象的创建而存在，随着对象的消失而消失 (4)调用不同 静态可以通过类名调用，也可以通过对象名调用。建议通过类名调用 非静态只能通过对象名调用 main方法是静态的(理解)​ public static void main(String[] args) 制作帮助文档(了解)​ (1)写代码 (2)加文档注释 (3)通过javadoc工具生成说明书 1234567891011121314151617181920212223242526//因为这个数组的工具类并没有使用非静态的成员。//为了方便调用，我们就把这个方法改进为静态修饰的/* 制作一个说明书的过程： A:写代码 B:加入文档注释 C:通过javadoc工具生成说明书 格式：javadoc -d 目录 -author -version ArrayTool.java javadoc -d doc -author -version ArrayTool.java 注意：javadoc: 错误 - 找不到可以文档化的公共或受保护的类。 说明类的权限不够大，用public修饰即可*/class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;56,38,91,72,40&#125;; //需求：遍历数组 //ArrayTool at = new ArrayTool(); //at.printArray(arr); ArrayTool.printArray(arr); //需求：我要获取数组中的最大值 &#125;&#125; 使用帮助文档(掌握) 找到帮助文档，并打开帮助文档 找到显示，点击索引，看到输入框 在输入框里面输入你要查找的类，并回车即可Scanner 看类在哪个包下 如果类在java.lang包下，是不需要导包的。 如果类不在java.lang包下，是需要导包的。 格式：import java.util.Scanner; 看类的解释说明 看类的结构和说明书的匹配情况 字段摘要 – 成员变量 构造方法摘要 – 构造方法 方法摘要 – 成员方法 看类的构造方法 因为看懂了构造方法，我们就可以创建对象了。 12345678910public Scanner(InputStream source) &#123;...&#125;System: public static final InputStream in; //成员变量 InputStream is = System.in;注意： 不是所有的类都能看到构造方法。 一般来说，没有构造方法的类的成员基本上都是静态的。 看类的方法 `public int nextInt()` 左边： 是否静态：说明该方法可以通过类名调用 返回值类型：人家返回什么类型，你就用什么类型接收右边： 方法名称：方法名不能写错了，写错了就用不了了。 参数列表：看参数的个数，以及参数的数据类型。 人家要几个，你就给几个，人家要什么类型，你就给什么类型。 学习Math类(掌握)​ (1)Math:针对数学进行运算的类 (2)特点：没有构造方法，因为它的成员都是静态的 (3)产生随机数： public static double random(): 产生随机数，范围[0.0,1.0) (4)产生1-100之间的随机数 int number = (int)(Math.random()*100)+1; (5)猜数字小游戏案例 123456789101112131415161718192021222324252627282930313233343536373839/* 需求：猜数字小游戏 分析： A:系统产生一个1-100之间的随机数。 int number = (int)(Math.random()*100)+1; B:键盘录入数据,用Scanner实现 C:用这两个数据进行比较 大 提示大了 小 提示小了 等 恭喜你，猜中了 D:为了保证我们能够猜中，我们就加入循环，实现多次猜。直到猜中。*/import java.util.Scanner;class GuessNumberDemo &#123; public static void main(String[] args) &#123; //系统产生一个1-100之间的随机数。 int number = (int)(Math.random()*100)+1; while(true) &#123; //键盘录入数据,用Scanner实现 Scanner sc = new Scanner(System.in); System.out.println("请输入一个数据：(1-100)"); int guessNumber = sc.nextInt(); //用这两个数据进行比较 if(guessNumber &gt; number) &#123; System.out.println("你猜的数据"+guessNumber+"大了"); &#125;else if(guessNumber &lt; number) &#123; System.out.println("你猜的数据"+guessNumber+"小了"); &#125;else &#123; System.out.println("恭喜你，猜中了"); break; &#125; &#125; &#125;&#125; 代码块(理解)​ (1)在java中用{}起来的代码 (2)分类： 局部代码块：在方法中。限定变量生命周期，及早释放，提高内存使用率 构造代码块：在类中方法外。 把多个构造中的相同代码用一个构造代码块体现，每次创建对象都会自动调用。 静态代码块：在类中方法外，用static修饰。 对类中的数据进行初始化。仅仅执行一次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* 代码块：在Java中，使用&#123;&#125;括起来的代码被称为代码块。 根据其位置和声明的不同，可以分为 局部代码块：在方法中出现；限定变量生命周期，及早释放，提高内存利用率 构造代码块：在类中方法外出现； 多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 静态代码块：在类中方法外出现，加了static修饰。 用于给类进行初始化，在加载的时候就执行，并且只执行一次。*///局部代码块/*class Code &#123; public void show() &#123; //局部代码块 &#123; int x = 10; System.out.println(x); &#125; //System.out.println(x); //... 1000行,x在这1000行代码中没有被使用 int y = 100; System.out.println(y); &#125;&#125;*///构造代码块/*class Code &#123; //构造代码块 &#123; System.out.println("AAAAA"); &#125; public Code() &#123; //System.out.println("AAAAA"); //假如这个代码的内容比较多，并且在每个构造中都会出现 &#125; public Code(String s) &#123; //System.out.println("AAAAA"); System.out.println(s); &#125;&#125;*///静态代码块class Code &#123; //静态代码块 static &#123; System.out.println("AAAAA"); &#125; /* public Code() &#123; &#125; public Code(String s) &#123; System.out.println(s); &#125; */&#125;class CodeDemo &#123; static &#123; System.out.println("BBBBB"); &#125; public static void main(String[] args) &#123; Code c = new Code(); //c.show(); //Code c2 = new Code("hello"); System.out.println("CCCCC"); &#125;&#125; DAY008 继承(掌握)​ (1)把多个类中相同的属性和行为提取出来，定义到一个类中， 然后让这多个类和这一个类产生一个关系，这多个类就具备这一个类的属性和行为了。 这种关系叫：继承。 12345678910111213141516171819/* java中的继承特点： A:Java只支持单继承，不支持多继承。 B:Java支持多层继承(继承体系)*/class A &#123;&#125;class B extends A &#123;&#125;/*class C extends A,B &#123;&#125;*/class C extends B &#123;&#125;class ExtendsDemo &#123; public static void main(String[] args) &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* java中的继承注意事项： A:子类只能继承父类所有非私有的成员(成员方法和成员变量) B:子类不能继承父类的构造方法，但是可以通过super(后面讲)关键字去访问父类构造方法。 C:不要为了部分功能而去继承 class A &#123; public void show()&#123;&#125; public void show2()&#123;&#125; &#125; class B extends A &#123; //public void show()&#123;&#125; public void show3()&#123;&#125; &#125; 那么，我们什么时候考虑使用继承呢? 继承中类之间体现的是：”is a”的关系。 如果两个类满足这个关系：xxx is a yyy，那么他们就可以使用继承。 举例：类A和类B，如果类A is a 类B或者类B is a 类A 能念通过，就可以考虑使用继承。 否则不可以。 Student,Person Dog,Animal Dog,Pig*/class Fu &#123; private int num = 100; public int num2 = 200; private void show() &#123; System.out.println("show"); &#125; public void show2() &#123; System.out.println("show2"); &#125;&#125;class Zi extends Fu &#123;&#125;class ExtendsDemo2 &#123; public static void main(String[] args) &#123; //创建子类对象 Zi z = new Zi(); //System.out.println(z.num); System.out.println(z.num2); //z.show(); z.show2(); //看Fu行不行 //Fu f = new Fu(); //System.out.println(f.num); //System.out.println(f.num2); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/* 继承间的成员变量关系： 名字不同：非常的简单，一看就知道使用的是谁。 名字相同：就近原则。 使用变量的时候，会先找局部范围。 如果想直接使用成员变量，加关键字：this即可。 如果想直接使用父类的成员变量，加关键字：super即可。*/class Father &#123; public int age = 40;&#125;class Son extends Father &#123; public int num = 100; public int age = 20; public void show() &#123; int age = 60; System.out.println(age); //局部范围 System.out.println(this.age); //本类成员范围 System.out.println(super.age); //父类成员范围 System.out.println(num); &#125;&#125;class ExtendsDemo3 &#123; public static void main(String[] args) &#123; Son s = new Son(); //System.out.println(s.age); //System.out.println(s.num); s.show(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 继承中的构造方法关系： 子类中所有的构造方法默认都会访问父类中空参数的构造方法 为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。 所以，子类初始化之前，一定要先完成父类数据的初始化。 那么，我可不可以访问父亲的带参构造方法呢? 可以。通过super(...) 注意事项： A:每一个构造方法的第一条语句默认都是：super() B:super(...)这样的形式在构造方法中只能出现一次。 C:如果父类没有无参构造方法，那么，我们只能 a:通过super去访问父类的带参构造方法。 b:通过this去访问本类的其他构造方法。*/class Fu &#123; /* public Fu() &#123; System.out.println("Fu()"); &#125; */ public Fu(String name) &#123; System.out.println("hello"); &#125;&#125;class Zi extends Fu &#123; public Zi() &#123; //super(); //super("aaa"); //this("aaa"); System.out.println("zi()"); &#125; public Zi(String name) &#123; //super(); //super(name); //this(); System.out.println("world"); &#125;&#125;class ExtendsDemo4 &#123; public static void main(String[] args) &#123; //创建子类对象 Zi z = new Zi(); System.out.println("-------------"); Zi z2 = new Zi("java"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990需求1：写一个学生类，包含姓名和年龄 class Student &#123; private String name; private int age; public Student()&#123;&#125; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; //getXxx()/setXxx() &#125;需求2：写一个教师类，包含姓名和年龄 class Teacher &#123; private String name; private int age; public Teacher() &#123;&#125; public Teacher(String name,int age) &#123; this.name = name; this.age = age; &#125; //getXxx()/setXxx() &#125;需求3：写一个工人类，包含姓名和年龄 class Worker &#123; private String name; private int age; public Worker() &#123;&#125; public Worker(String name,int age) &#123; this.name = name; this.age = age; &#125; //getXxx()/setXxx() &#125;需求4：...通过上面的代码，我们发现各个类中相同的东西比较多。并且，如果我们对每个类要添加或者删除相同的东西，也比较麻烦，因为我们要操作很多类。那么，我们就在想，有没有比较好的方式解决这个问题呢?如何解决呢? 思想：我可以把这多个类中相同的内容给提前出来定义到类A中。 然后让这些类和A类产生一个关系，有了这个关系后，这些 类就具备了A类的成员。 当然是可以的了，java提供了继承技术来解决这个问题。按照这种思想我们来改进代码： class Person &#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; //getXxx()/setXxx() &#125;这个关系如何表达呢? 格式：class 子类名 extends 父类名 &#123;&#125; class Student extends Person &#123; public Student()&#123;&#125; public Student(String name,int age) &#123; ??? &#125; &#125; class Teacher extends Person &#123; public Teacher()&#123;&#125; public Teacher(String name,int age) &#123; ??? &#125; &#125;称呼： Person：父类，基类，超类 Student,Teacher：子类，派生类 java中的继承的好处和弊端 A:好处 a:提高了代码的复用性 b:提高了代码的可维护性 c:让类与类之间产生了一个关系，是多态的前提 B:弊端 让类与类的耦合增强了。这样一个类的改动会直接影响另一个类。 设计原则：高内聚，低耦合。 java中的继承的注意事项： A:私有成员不能被继承 B:构造方法不能被继承，想访问，通过super关键字 C:不能为了部分功能而去使用继承 继承中的成员关系： A:成员变量 不同名：特别简单，一看就知道用的是谁。 同名：就近原则 访问自己的用this 访问父亲的用super B:构造方法 a:子类的所有构造方法默认都是访问父类的无参构造方法 b:如果父类没有无参构造方法，怎么办呢? 通过super(...)访问父类带参构造方法 通过this(...)访问本类其他构造方法。(一定要有一个访问了父类的构造方法) 注意：super或者this只能出现一个，并且只能在语句的第一条语句。 为什么呢? 因为子类可能会访问父类的数据，所以，在子类初始化之前，要先把父类数据初始化完毕。 C:成员方法 不同名：特别简单，一看就知道用的是谁。 同名：就近原则 访问自己的用this 访问父亲的用super this和super的区别及应用场景 A:区别 this：本类对象的引用 super：父类存储空间的标识。可以理解为父类对象的引用。 B:应用场景 a:成员变量 this.变量 本类的成员变量 super.变量 父类的成员变量 b:构造方法 this(…) 本类的构造方法 super(…) 父类的构造方法 c:成员方法 this.方法名(…) 本类的成员方法 super.方法名(…) 父类的成员方法 方法重写(掌握) 描述：在子类中，出现了和父类中一模一样的方法声明的现象。 作用：可以使用父类功能，还可以增强该功能。 面试题：Overload和Override的区别。Overload的方法是否可以改变返回值的类型? Overload：重载 同一个类中，方法名相同，参数列表不同。与返回值类型无关。 Override：重写 存在于子父类，或者子父接口中，方法声明相同。 Overload的方法可以改变返回值的类型，因为它与返回值类型无关。 方法重写的注意事项： A:父类私有方法不能被重写 B:子类重写方法的访问权限不能比父类的方法低 C:静态只能重写静态。(其实这算不上重写) final关键字(掌握)​ (1)final:最终的意思 (2)作用：可以修饰类，修饰成员变量，修饰成员方法 (3)特点： A:修饰类 类不能被继承 B:修饰成员变量 变量变成了常量 C:修饰成员方法 方法不能被重写 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 很多时候，我们可能不想让子类修改我的内容。这个时候该怎么半呢? 针对这种情况，java又提供了一个状态修饰符：final。 final:最终的意思。 作用： 可以修饰类，成员变量，成员方法。 特点： 类：类被final修饰，说明该类是最终类，不能被继承。 成员变量：变量被final修饰后，就变成了常量。值不能被修改。 成员方法：方法不能被子类重写。*/final class Fu &#123; public int num = 10; public final int num2 = 20; public final void getResource() &#123; System.out.println("这里是绝密的资源,可以看,不可以改"); &#125; public void show() &#123; num = 100; System.out.println(num); //num2 = 200; System.out.println(num2); &#125;&#125;class Zi extends Fu &#123; /* public void getResource() &#123; System.out.println("这里我想干什么就干什么"); &#125; */&#125;class FinalDemo &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.getResource(); z.show(); &#125;&#125; ​ (4)面试题： A:final修饰局部变量 a:基本类型 值不能发生改变 b:引用类型 地址值不能发送改变，对象的内容是可以改变的 B:final的初始化时机 a:在定义时就赋值 b:在构造方法完毕前赋值 多态(掌握)​ (1)多态：同一个对象，在不同时刻表现出来的多种状态 举例：水，猫和动物 1234567891011121314151617181920212223242526272829303132333435363738394041/* 多态：同一个对象在不同时刻表现出现的不同状态。 举例： A:水(水，冰，水蒸气) B:猫和动物。 把右边的值赋值给左边，如果能读通过，就说明可以。 动物 d = new 动物(); 动物 dd = new 猫(); 猫 m = new 猫(); 猫 mm = new 动物(); 错误 动物 dd = new 猫(); 代码如何体现呢? A:有继承关系 B:有方法重写 C:有父类引用指向子类对象*/class Animal &#123; public void eat() &#123; System.out.println("动物吃饭"); &#125;&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println("狗吃肉"); &#125;&#125;class DuoTaiDemo &#123; public static void main(String[] args) &#123; //Animal a = new Animal(); //Dog d = new Dog(); //多态 Animal a = new Dog(); &#125;&#125; ​ (2)多态的前提： A:有继承关系 B:有方法重写 C:有父类引用指向子类对象 (3)多态中的成员访问特点： A:成员变量 编译看左边，运行看左边 B:成员方法 编译看左边，运行看右边 C:静态方法 编译看左边，运行看左边 为什么： 因为方法有重写，而变量没有。静态方法没有重写一说。 DAY009 多态(掌握)​ (1)同一个事物在不同时刻表现出现的多种状态。 举例：水，猫和动物 (2)前提 A:有继承或者实现关系 B:有方法重写 因为抽象类中的抽象方法以及接口中的方法都必须被子类重写，调用才有意义。 C:有父类或者父接口引用指向子类对象 (3)多态中的成员访问特点 Fu f = new Zi(); A:成员变量 编译看左边，运行看左边 B:成员方法 编译看左边，运行看右边 C:静态方法 编译看左边，运行看左边 (4)好处和弊端 A:好处 提高了代码的维护性 提高了代码的扩展性 B:弊端 不能访问子类特有功能 (5)如何访问子类特有功能 A:创建子类对象 B:向下转型 (6)多态中的转型 A:向上转型 子到父 B:向下转型 父到子(加强制转换) (7)孔子装爹案例 抽象类(掌握)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 抽象类概述：动物不是一个具体的事物，只有猫，狗才是具体的个体。 并且，在动物中我们针对吃的功能，也不应该给出具体的体现， 因为不同的动物吃的内容是不一样的，我们应该让具体的动物自己去实现自己吃的功能。 而一个功能如果没有具体的体现，就是一个抽象的内容。如何表示呢? 格式： 修饰符 返回值类型 方法名(参数列表...); 为了表示这是一个抽象的东西，java提供了一个标识的关键字：abstract 格式： 修饰符 abstract 返回值类型 方法名(参数列表...); 而一个类中的方法如果是抽象的类，那么，该类就必须定义为抽象类。 抽象类的特点： A:抽象类和抽象方法必须用abstract关键字修饰 B:抽象类的子类 a:要么是抽象类 b:要么重写抽象类中的所有抽象方法 C:抽象类不一定有抽象方法，有抽象方法的类一定是抽象类 D:抽象类不能实例化 那么如何使用抽象类的功能呢? 按照多态的方式使用。抽象类多态。 回顾： 多态前提为什么要有方法重写呢? 因为父类的方法可能是抽象的。*/abstract class Animal &#123; //这个方法是有方法体的，只不过内容为空 //public void eat() &#123;&#125; //抽象方法 public abstract void eat();&#125;abstract class Dog extends Animal &#123;&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println("猫吃鱼"); &#125;&#125;class AbstractDemo &#123; public static void main(String[] args) &#123; //Animal a = new Animal(); //无法实例化 //Dog d = new Dog(); //无法实例化 //Cat c = new Cat(); //多态 Animal a = new Cat(); a.eat(); &#125;&#125; ​ 有些时候，我们对事物不能用具体的东西来描述，这个时候就应该把事物定义为抽象类。 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 抽象类的成员特点： A:成员变量 可以是变量，也可以是常量 B:构造方法 有构造方法。但是不能实例化。 问题：构造方法有什么用呢? 用于子类访问父类数据的初始化 C:成员方法 可是有抽象方法，也可以有非抽象方法。 抽象方法：强制要求子类做某些事情。 非抽象方法：用于给子类直接使用，提高了代码的复用性。*/abstract class Animal &#123; int num = 10; final int num2 = 20; public Animal() &#123;&#125; public void method() &#123; System.out.println("method"); &#125; public abstract void function();&#125;class Dog extends Animal &#123; public void show() &#123; num = 100; System.out.println(num); //num2 = 200; System.out.println(num2); &#125; public void function() &#123;&#125;&#125;class AbstractDemo2 &#123; public static void main(String[] args) &#123; Dog d = new Dog(); d.show(); &#125;&#125; 两个小问题 A:如果你看到一个抽象类中居然没有抽象方法,这个抽象类的意义何在? 不让别人创建 B:abstract不能和哪些关键字共存? a:private 冲突 b:final 冲突 c:static 无意义 接口(掌握)​ (1)有些时候，不是事物本身具备的功能，我们就考虑使用接口来扩展。 (2)接口的特点： A:定义接口用关键字interface 格式是：interface 接口名 {} B:类实现接口用关键字implements 格式是：class 类名 implements 接口名 {} C:接口不能实例化 D:接口的子类 a:要么是抽象类 b:要么重写接口中的所有方法 (3)接口的成员特点 A:成员变量 只能是常量。 默认修饰符：public static final B:成员方法 只能是抽象方法。 默认修饰符：public abstract 推荐： 建议自己写接口的时候，把默认修饰符加上。 (4)类与接口的关系 A:类与类 继承关系，只能单继承，可以多层继承。 B:类与接口 实现关系，可以单实现，也可以多实现。 还可以在继承一个类的同时实现多个接口。 C:接口与接口 继承关系，可以单继承，也可以多继承。 (5)抽象类和接口的区别? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511：成员区别 抽象类： 成员变量：可以是变量，也可以是常量 构造方法：有 成员方法：可以是抽象的，也可以是非抽象的 接口： 成员变量：只能是常量。 默认修饰符：public static final 成员方法：只能是抽象的 默认修饰符：public abstract2：关系区别 类与类： 继承关系，只能单继承。可以多层继承。 类与接口： 实现关系，可以单实现，也可以多实现。 还可以在继承一个类的同时实现多个接口。 接口与接口： 继承关系，可以单继承，也可以多继承。3：设计理念区别 抽象类：被继承体现的是：”is a”的关系。在抽象类中定义的一般是共性功能 接口：被实现体现的是：”like a”的关系。在接口中定义的一般是扩展功能 A:成员区别 B:关系区别 C:设计理念区别 抽象类：父抽象类，里面定义的是共性内容。 接口：父接口，里面定义的是扩展内容。 DAY0101：形式参数和返回值问题(掌握) (1)形式参数： 基本类型：需要的是对应的值 引用类型： 类：该类的对象 抽象类：该类的子类对象 接口：该接口的实现类对象 (2)返回值问题： 基本类型：返回的是对应的值 引用类型： 类：该类的对象 抽象类：该类的子类对象 接口：该接口的实现类对象 (3)链式编程 new A().b().c().d(); 2：包(理解) (1)其实就是文件夹 (2)对类进行分类管理 (3)格式： package 包名; (4)注意事项 A:package是程序中的第一条可执行语句 B:在类中package是唯一的 C:没有package，默认是无包名 (5)带包的类的编译和运行 3：导包(理解) (1)为了方便使用不同包下的类，需要导包 (2)格式： import 包名.报名…类名; 注意：可以导入到*,但是不建议 (3)package，import，class在类中有没有顺序关系呢? 有。 package --&gt; import --&gt; class 4：修饰符(理解) (1)4种权限修饰符 本类 同一个包下 不同包下的子类 不同包下的其他类 private Y 默认 Y Y protected Y Y Y public Y Y Y Y (2)常见的修饰 A:类 public B:成员变量 private C:构造方法 public D:成员方法 public 5：内部类(理解) (1)把类A定义在类B内部，类A就被称为内部类 (2)访问特点： A:内部类可以直接访问外部类的成员，包括私有 B:外部类要想访问内部类的成员，必须创建对象 (3)内部类的分类： A:成员内部类 B:局部内部类 (4)成员内部类 A:private B:static 面试题： num this.num Outer.this.num (5)局部内部类 A:面试题 局部内部类访问局部变量，必须加final修饰 (6)匿名内部类(掌握) A:没有名字的内部类 B:前提 存在一个类或者接口 C:格式 new 类名或者接口名() { 重写方法(); }; 本质：是一个匿名子类对象 (7)开发中如何使用 不用在定义一个新的类了。直接通过匿名内部类的格式就可以搞定 interface Person { public abstract void show(); } class PersonDemo { public void method(Person p) { p.show(); } } PersonDemo pd = new PersonDemo(); pd.method(new Person(){ public void show(){...} }); (8)面试题 补齐代码，在控制台输出HelloWorld interface Inter { public abstract void show(); } class Outer { //补齐代码 public static Inter method() { return new Inter(){ public void show() { System.out.println(&quot;helloworld&quot;); } }; } } class OuterDemo { public static void main(String[] args) { Outer.method().show(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端CDNJS国内加速服务]]></title>
    <url>%2Fblog%2F40397.html</url>
    <content type="text"><![CDATA[前端 CDNJS 库及 Google Fonts、Ajax 和 Gravatar 国内加速服务 由于某些众所周知的原因，好多开源的 JS 库采用的国外 CDN 托管方式在国内访问速度不如人意。所以我们特意制作了这个公益项目，托管了 CDNJS 的所有开源 JS 库以及反代了 Google Fonts、Ajax 和 Gravatar，并且全部支持 http 和 https 1、CDNJS 开源 JS 库我们采用的方法是每天定时同步 CDNJS 的 Github 所有的 JS/CSS 库可以在这儿找到您需要的链接 https://cdnjs.loli.net/ajax/libs/ 如果您使用 cdnjs.com 只需要替换 cdnjs.cloudflare.com 为 cdnjs.loli.net 即可，如 1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; 替换成 1&lt;script src=&quot;https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; CDNJS 的 API 开发文档请摸这里 2、Google Fonts我们采用的方法是万能的 Nginx 反代 + 关键词替换 使用的时候，您只需要替换 fonts.googleapis.com 为 fonts.loli.net 即可，如 1&lt;link href=&apos;https://fonts.googleapis.com/css?family=Open+Sans&apos; rel=&apos;stylesheet&apos;&gt; 替换成 1&lt;link href=&apos;https://fonts.loli.net/css?family=Open+Sans&apos; rel=&apos;stylesheet&apos;&gt; 如果需要 Material icons ，把 1&lt;link href=&apos;https://fonts.googleapis.com/icon?family=Material+Icons&apos; rel=&apos;stylesheet&apos;&gt; 替换成 1&lt;link href=&apos;https://fonts.loli.net/icon?family=Material+Icons&apos; rel=&apos;stylesheet&apos;&gt; 如果需要 Early Access，把 1@import url(https://fonts.googleapis.com/earlyaccess/notosanskannada.css); 替换成 1@import url(https://fonts.loli.net/earlyaccess/notosanskannada.css); 如果需要下载单个字体，您只需要把 fonts.gstatic.com 替换成 gstatic.loli.net 或 themes.googleusercontent.com 替换成 themes.loli.net 即可 比如 1https://fonts.gstatic.com/s/opensans/v14/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2 替换成 1https://gstatic.loli.net/s/opensans/v14/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2 或者 1https://themes.googleusercontent.com/static/fonts/anonymouspro/v3/Zhfjj_gat3waL4JSju74E-V_5zh5b-_HiooIRUBwn1A.ttf 替换成 1https://themes.loli.net/static/fonts/anonymouspro/v3/Zhfjj_gat3waL4JSju74E-V_5zh5b-_HiooIRUBwn1A.ttf Google Fonts 的 API 文档请摸这里 3、Google 前端公共库方法同上，直接替换 ajax.googleapis.com 为 ajax.loli.net 即可，如 1&lt;script type=&apos;text/javascript&apos; src=&apos;https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js&apos;&gt;&lt;/script&gt; 替换成 1&lt;script type=&apos;text/javascript&apos; src=&apos;https://ajax.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js&apos;&gt;&lt;/script&gt; Google 前端库 API 开发文档摸这儿 4、Gravatar 头像方法还是同上，直接替换 *.gravatar.com 为 gravatar.loli.net 即可，如 1https://secure.gravatar.com/avatar/8406d089bc81b664a2610b8d214c1428 替换成 1https://gravatar.loli.net/avatar/8406d089bc81b664a2610b8d214c1428 5、赞助商国内外 CDN， GeoDNS、域名等基础服务均由 xTom赞助 SSL 证书由 SSL.DO赞助 6、旧域名替换由于更换了赞助商，并且因为最新的国内域名备案政策，旧的域名均采用 301 跳转形式 cdn.css.net 跳转到本文 cdn.css.net/libs/ 和 cdnjs.cat.net/ajax/libs/ 跳转到 cdnjs.loli.net/ajax/libs/ cdn.css.net/fonts/ 和 fonts.cat.net 和 fonts.css.network 跳转到 fonts.loli.net cdn.css.net/ajax/ 和 ajax.cat.net 和 ajax.css.network 跳转到 ajax.loli.net cdn.css.net/avatar/ 和 gravatar.cat.net 和 gravatar.css.network 跳转到 gravatar.loli.net 另外由于 jsdelivr 已不再提供 Github 同步，并且这货自己也有网宿的国内 CDN ，所以 cdn.css.net/files/ 跳转到 cdn.jsdelivr.net 并且不再提供 jsdelivr 的国内加速服务 所有国内加速服务的域名列表如下，您只需要修改程序里的原域名即可 原域名 加速域名 制作方法 cdnjs.cloudflare.com cdnjs.loli.net 每日同步 Github ajax.googleapis.com ajax.loli.net Nginx 反代 fonts.googleapis.com fonts.loli.net Nginx 反代 fonts.gstatic.com gstatic.loli.net Nginx 反代 themes.googleusercontent.com themes.loli.net Nginx 反代 secure.gravatar.com gravatar.loli.net Nginx 反代]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github搜索技巧]]></title>
    <url>%2Fblog%2F6321.html</url>
    <content type="text"><![CDATA[github搜索技巧 1. Search 如何查看一门语言的 Repository 排行榜（按 stars 数量排）？如图所示，以 Objective-C 为例，直接在输入框中输入 language:Objective-C stars:&gt;0， 然后再在右侧排名选项中选择 Most stars。 按 stars 数量排名(以 Objective-C 为例).png 为什么有些数据模糊搜索不到？比如，输入搜索关键字 “collectionView”，然后在左侧边栏 Languages 中选择 Objective-C ，发现搜索结果中没有 “PSTCollectionView” 这个Repository，实际上，如果搜索的是 “PSTCollectionView” 的话，确实是能搜索到的。从搜索结果中来看，“collectionView” 是被作为一个单词整体来进行搜索的，所以搜到的结果都是 Repository name 或者 description 中出现以 “collectionView” 开头或者包含 “-collectionView” 的单词的 Repository。所以为了能搜索到更多想要的结果，我们最好以单词为单位，用 OR 将各个关键字拼接起来进行搜索，例如，搜 “CollectionView OR UICollectionView OR collection” 而不是 “collectionView”。下面是两种搜索词的结果对比。 Github 有高级搜索吗？在上图中，我们可以看到左侧边栏的下方有两个可点击的选项 Advanced search 和 Cheat sheet，点击 Advanced search 即可进行自定义条件的高级搜索了，点击 Cheat sheet 则可以查看一些有关搜索的帮助信息。哪里不会点哪里，妈妈再也不用担心我的学习了！ 2.Trending作为一枚程序猿，除了有目的的搜索之外，我们有时也需要去“瞎逛逛”，开阔一下眼界。如果你有空，不妨去 Github 的 Trending 看看最近发生了什么。See what the GitHub community is most excited about today! 在这里你可以看到各种不同开发语言的每天/周/月的最热门的 Repositories 和 Developers。比如前一段时间走红的 YYKit，苹果最近开源的 CareKit，等等。 3.制定搜索方式：我默认检索的关键词都是android 按照文件搜索 1android in:file 按照路径检索 1andrioid in:path 按照语言检索 1android language:java 按照文件大小 1android size:&gt;100 按照后缀名检索 1android extention:css 按照是否被fork过 1android fork:true 按照地域检索（这个猎头和hr应该用得着） 1android location:beijing]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对象复制Clone技术]]></title>
    <url>%2Fblog%2F38422.html</url>
    <content type="text"><![CDATA[在编码过程经常会碰到将一个对象传递给另一个对象，java中对于基本型变量采用的是值传递，而对于对象比如bean传递时采用的是引用传递也就是地址传递，而很多时候对于对象传递我们也希望能够象值传递一样，使得传递之前和之后有不同的内存地址，在这种情况下就可以clone一个新的对象来用. 什么时候使用克隆对象技术如：有一个对象A，在某一时刻A中已经包含了一些有效值，A是用来保存从数据库得到很多数据的一个对象。此时可能会需要一个和A完全相同新对象B，B用来修改A里面的某一个属性的值，仅仅是用来负责显示一下，不需要使得A.也受到影响。并且此函数的返回类型是A类型的。并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在Java语言中，用简单的赋值语句是不能满足这种需求的。实现clone（）方法是不错的选择。 Java的所有类都默认继承java.lang.Object类，在java.lang.Object类中有一个方法clone()。该方法将返回Object对象的一个拷贝。要说明的有两点： 一是拷贝对象返回的是一个新对象，而不是一个引用。 二是拷贝对象与用 new 操作符返回的新对象的区别就是这个拷贝已经包含了一些原来对象的信息，而不是对象的初始信息。 怎样应用clone()方法？ 实现clone方法的步骤（） 实现Cloneable接口 重载Object类中的clone()方法，重载时需定义为public 在重载方法中，调用super.clone() 123456789101112class CloneClass implements Cloneable&#123; public int aInt; public Object clone()&#123; CloneClass o = null; try&#123; o = (CloneClass)super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return o; &#125;｝ 浅克隆与深克隆（影子克隆）​ 克隆(默认就是浅克隆)就是复制一个对象的复本.若只需要复制对象的字段值（对于基本数据类型,如:int,long,float等，则复制值；对于复合数据类型仅复制该字段值，如数组变量则复制地址，对于对象变量则复制对象的reference。 下面的例子包含三个类UnCloneA，CloneB，CloneMain。 CloneB类包含了一个UnCloneA的实例和一个int类型变量，并且重载clone()方法。 CloneMain类初始化CloneB 类的一个实例b1，然后调用clone()方法生成了一个b1的拷贝b2。最后考察一下b1和b2的输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243package clone;class UnCloneA &#123; private int i; public UnCloneA(int ii) &#123; i = ii; &#125; public void doubleValue() &#123; i *= 2; &#125; public String toString() &#123; return Integer.toString(i); &#125;&#125;class CloneB implements Cloneable&#123; public int aInt; public UnCloneA unCA = new UnCloneA(111); publicCloneB clone()&#123; CloneB o = null; try&#123; o = (CloneB)super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return o; &#125;&#125;public class CloneMain &#123; public static void main(String[] a)&#123; CloneB b1 = new CloneB(); b1.aInt = 11; System.out.println("before clone,b1.aInt = "+ b1.aInt); System.out.println("before clone,b1.unCA = "+ b1.unCA); CloneB b2 = (CloneB)b1.clone(); b2.aInt = 22; b2.unCA.doubleValue(); System.out.println("================================="); System.out.println("after clone,b1.aInt = "+ b1.aInt); System.out.println("after clone,b1.unCA = "+ b1.unCA); System.out.println("================================="); System.out.println("after clone,b2.aInt = "+ b2.aInt); System.out.println("after clone,b2.unCA = "+ b2.unCA); &#125;&#125; 12345678/ RUN RESULT:before clone,b1.aInt = 11before clone,b1.unCA = 111after clone,b1.aInt = 11after clone,b1.unCA = 222after clone,b2.aInt = 22after clone,b2.unCA = 222*/ 输出的结果说明int类型的变量aInt和UnCloneA的实例对象unCA的clone结果不一致， int类型是真正的被clone了，因为改变了b2中的aInt变量，对b1的aInt没有产生影响， 也就是说，b2.aInt与b1.aInt已经占据了不同的内存空间，b2.aInt是b1.aInt的一个真正拷贝。 相反，对b2.unCA的改变同时改变了b1.unCA，很明显，b2.unCA和b1.unCA是仅仅指向同一个对象的不同引用！（也就是对对象中的对象克隆失败） 从中可以看出，调用Object类中clone()方法产生的效果是：先在内存中开辟一块和原始对象一样的空间，然后原样拷贝原始对象中的内容。 123456789101112public Channel copy(Integer cid,String solution, String mobileSolution, Integer siteId, Map&lt;String, String&gt; pathMap)&#123; Channel c=findById(cid);//旧 Channel channel=new Channel();//新 if(c!=null)&#123; ChannelExt ext=new ChannelExt(); ChannelTxt channelTxt=new ChannelTxt(); channel=(Channel) c.clone(); ext=(ChannelExt) c.getChannelExt().clone(); if(c.getChannelTxt()!=null)&#123; channelTxt=(ChannelTxt) c.getChannelTxt().clone(); &#125; 对基本数据类型，这样的操作是没有问题的，但对非基本类型变量，我们知道它们保存的仅仅是对象的引用，这也导致clone后的非基本类型变量和原始对象中相应的变量指向的是同一个对象。也就没有达到克隆的效果。 大多时候，这种clone的结果往往不是我们所希望的结果，这种clone也被称为”影子clone”。要想让b2.unCA指向与b2.unCA不同的对象，而且b2.unCA中还要包含b1.unCA中的信息作为初始信息，就要实现深度clone。 怎么进行深度clone？深克隆与浅克隆的区别在于对复合数据类型的复制。若对象中的某个字段为复合类型，在克隆对象的时候，需要为该字段重新创建一个对象。 把上面的例子改成深度clone很简单，需要两个改变：一是让UnCloneA类也实现和CloneB类一样的clone功能（实现Cloneable接口，重载clone()方法）。二是在CloneB的clone()方法中加入一句o.unCA = (UnCloneA)unCA.clone() 程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class UnCloneA implements Cloneable&#123; private int i; public UnCloneA(int ii) &#123; i = ii; &#125; public void doubleValue() &#123; i *= 2; &#125; public String toString() &#123; return Integer.toString(i); &#125; public Object clone()&#123; UnCloneA o = null; try&#123; o = (UnCloneA)super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return o; &#125;&#125;class CloneB implements Cloneable&#123; public int aInt; public UnCloneA unCA = new UnCloneA(111); public Object clone()&#123; CloneB o = null; try&#123; o = (CloneB)super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; o.unCA = (UnCloneA)unCA.clone(); return o; &#125;&#125;public class CloneMain &#123; public static void main(String[] a)&#123; CloneB b1 = new CloneB(); b1.aInt = 11; System.out.println("before clone,b1.aInt = "+ b1.aInt); System.out.println("before clone,b1.unCA = "+ b1.unCA); CloneB b2 = (CloneB)b1.clone(); b2.aInt = 22; b2.unCA.doubleValue(); System.out.println("========="); System.out.println("after clone,b1.aInt = "+ b1.aInt); System.out.println("after clone,b1.unCA = "+ b1.unCA); System.out.println("========="); System.out.println("after clone,b2.aInt = "+ b2.aInt); System.out.println("after clone,b2.unCA = "+ b2.unCA); &#125;&#125; 12345678/ RUN RESULT:before clone,b1.aInt = 11before clone,b1.unCA = 111after clone,b1.aInt = 11after clone,b1.unCA = 111after clone,b2.aInt = 22after clone,b2.unCA = 222*/ 可以看出，现在b2.unCA的改变对b1.unCA没有产生影响。此时b1.unCA与b2.unCA指向了两个不同的UnCloneA实例，而且在CloneB b2 = (CloneB)b1.clone();调用的那一刻b1和b2拥有相同的值，在这里，b1.i = b2.i = 11。 注意不是所有的类都能实现深度clone的。例如，如果把上面的CloneB类中的UnCloneA类型变量改成StringBuffer类型，看一下JDK API中关于StringBuffer的说明，StringBuffer没有重载clone()方法，更为严重的是StringBuffer还是一个final类，这也是说我们也不能用继承的办法间接实现StringBuffer的clone。如果一个类中包含有StringBuffer类型对象或和StringBuffer相似类的对象，我们有两种选择：要么只能实现影子clone，要么就在类的clone()方法中加一句（假设是SringBuffer对象，而且变量名仍是unCA）： o.unCA = new StringBuffer(unCA.toString()); //原来的是：o.unCA = (UnCloneA)unCA.clone(); 还要知道的是除了基本数据类型能自动实现深度clone以外，String对象是一个例外，它clone后的表现好象也实现了深度clone，虽然这只是一个假象，但却大大方便了我们的编程。通过以上我们可以看出在某些情况下，我们可以利用clone方法来实现对象只见的复制，但对于比较复杂的对象（比如对象中包含其他对象，其他对象又包含别的对象…..）这样我们必须进行层层深度clone，每个对象需要实现cloneable接口。 Java集合的深克隆下面例子有一个Employee集合，Employee是可变对象，成员变量name和designation。它们存储在HashSet中。使用java.util.Collection接口的addAll()方法创建集合拷贝。然后修改存储在原始集合每个Employee对象的designation值。理想情况下这个改变不会影响克隆集合，因为克隆集合和原始集合应该相互独立，但是克隆集合也被改变了。修正这个问题的方法是对存储在Collection类中的元素深克隆。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Collection; import java.util.HashSet;import java.util.Iterator;import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * Java program to demonstrate copy constructor of Collection provides shallow * copy and techniques to deep clone Collection by iterating over them. * @author http://javarevisited.blogspot.com */public class CollectionCloningTest &#123; private static final Logger logger = LoggerFactory.getLogger(CollectionCloningclass); public static void main(String args[]) &#123; // deep cloning Collection in Java Collection&lt;Employee&gt; org = new HashSet&lt;&gt;(); org.add(new Employee("Joe", "Manager")); org.add(new Employee("Tim", "Developer")); org.add(new Employee("Frank", "Developer")); // creating copy of Collection using copy constructor Collection&lt;Employee&gt; copy = new HashSet&lt;&gt;(org); logger.debug("Original Collection &#123;&#125;", org); logger.debug("Copy of Collection &#123;&#125;", copy ); Iterator&lt;Employee&gt; itr = org.iterator(); while(itr.hasNext())&#123; itr.next().setDesignation("staff"); &#125; logger.debug("Original Collection after modification &#123;&#125;", org); logger.debug("Copy of Collection without modification &#123;&#125;", copy ); // deep Cloning List in Java &#125; &#125; class Employee &#123; private String name; private String designation; public Employee(String name, String designation) &#123; this.name = name; this.designation = designation; &#125; public String getDesignation() &#123; return designation; &#125; public void setDesignation(String designation) &#123; this.designation = designation; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return String.format("%s: %s", name, designation ); &#125; &#125; 输出： 1234- Original Collection [Joe: Manager, Frank: Developer, Tim: Developer] - Copy of Collection [Joe: Manager, Frank: Developer, Tim: Developer] - Original Collection after modification [Joe: staff, Frank: staff, Tim: staff] - Copy of Collection without modification [Joe: staff, Frank: staff, Tim: staff] 可以看到改变原始Collection中Employee对象(改变designation为”staff“)在克隆集合中也有所反映，因为克隆是浅拷贝，指向堆中相同的Employee对象。为了修正这个问题，需要遍历集合，深克隆Employee对象，在这之前，要重写Employee对象的clone方法。 Employee实现Cloneable接口 为Employee类增加下面的clone()方法 123456789101112@Override protected Employee clone() &#123; Employee clone = null; try&#123; clone = (Employee) super.clone(); &#125;catch(CloneNotSupportedException e)&#123; throw new RuntimeException(e); // won't happen &#125; return clone; &#125; 不使用拷贝构造函数，使用下面的代码来深拷贝集合 123456Collection&lt;Employee&gt; copy = new HashSet&lt;Employee&gt;(org.size()); Iterator&lt;Employee&gt; iterator = org.iterator(); while(iterator.hasNext())&#123; copy.add(iterator.next().clone()); &#125; 运行相同的代码更改原始集合，克隆集合不会也被更改。 12 可以看到克隆集合和原始集合相互独立，它们指向不同的对象。 这就是Java中如何克隆集合的内容。现在我们知道拷贝构造函数或者List或Set等各种集合类的addAll()方法仅仅创建了集合的浅拷贝，而且原始集合和克隆集合指向相同的对象。为避免这个问题，应该深克隆集合，遍历集合克隆每个元素。尽管这要求集合中的对象必须支持深克隆操作。 后面这些话是比较重要的：(易于理解) 各个集合类提供的拷贝构造函数作为克隆List，Set，ArrayList，HashSet或者其他集合实现的方法。需要记住的是，Java集合的拷贝构造函数只提供浅拷贝而不是深拷贝，这意味着存储在原始List和克隆List中的对象是相同的，指向Java堆内存中相同的位置。 简单注意 在克隆java对象的时候不会调用构造器 java提供一种叫浅拷贝（shallow copy）的默认方式实现clone，创建好对象的副本后然后通过赋值拷贝内容，意味着如果你的类包含引用类型，那么原始对象和克隆都将指向相同的引用内容，这是很危险的，因为发生在可变的字段上任何改变将反应到他们所引用的共同内容上。为了避免这种情况，需要对引用的内容进行深度克隆。 克隆方法用于创建对象的拷贝，为了使用clone方法，类必须实现java.lang.Cloneable接口重写protected方法clone，如果没有实现Clonebale接口会抛出CloneNotSupportedException. Hibernate异常Found shared references的解决办法 在项目中的续签模块中，由于在谈判成功后要新建一份合同，并要将原合同中的站点信息设置到新合同中去，在合同的Entity中有一个list&lt;站点&gt;来关联的，一份合同可以有多少站点！ 在新增合同的代码如下： 123456789RenewalItem item = renewalItemDao.findById(id); PropertyContract pc = item.getPropertyContract();//旧合同 PropertyContract newPc = new PropertyContract();//新合同 List&lt;BSProperty&gt; bsList = pc.getBsProperty(); if(null!=bsList &amp;&amp; !bsList.isEmpty())&#123; newPc.setBsProperty(bsList);//将旧合同中的关联站点设置到新合同中去。 &#125; .... renewalItemDao.merge(item); 此时会报：org.hibernate.HibernateException: Found shared references to a collection，这样的异常信息，意思是指发现共享引用集合，经过上网GOOGLE,有一帖子说： 解决方法： 在拷贝后，新建一个集合，将原来的集合元素添加进去，并赋值给新拷贝的实体 12345678910111213RenewalItem item = renewalItemDao.findById(id); PropertyContract pc = item.getPropertyContract();//旧合同 PropertyContract newPc = new PropertyContract();//新合同 List&lt;BSProperty&gt; bsList = pc.getBsProperty(); if(null!=bsList &amp;&amp; !bsList.isEmpty())&#123; List&lt;BSProperty&gt; newBsList = new ArrayList&lt;BSProperty&gt;(bsList.size()); for(BSProperty bs : bsList)&#123; newBsList.add(bs); &#125; newPc.setBsProperty(newBsList);//将旧合同中的关联站点设置到新合同中去。 &#125; .... renewalItemDao.merge(item);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码生成Tools]]></title>
    <url>%2Fblog%2F50510.html</url>
    <content type="text"><![CDATA[技术点：采用SpringMVC3+Spring3+Hibernate3+Freemarker主流技术架构 生成入口方法1234567891011package com.jeecms.cms.template;public class CmsModuleGenerator &#123; private static String packName = "com.jeecms.cms.template"; private static String fileName = "jeecms.properties"; public static void main(String[] args) &#123; new ModuleGenerator(packName, fileName).generate(); &#125;&#125; 生成方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207package com.jeecms.cms.template;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;import java.util.Set;import org.apache.commons.io.FileUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 模块生成器 * * &lt;p&gt; * 用于生成JEE模块。 * &lt;p&gt; * 包括JAVA类：action,dao,dao.impl,manager,manager.impl； * 配置文件：action配置,spring配置；ftl页面：list.html,add.html,edit.html。 * 数据验证文件：Act-Com_save * -validation.xml,Act-Com_edit-validation.xml,Act-Com_update-validation.xml * &lt;p&gt; * 可设置的参数有：模块实体类名、java类包地址、配置文件地址、ftl页面地址。 */public class ModuleGenerator &#123; private static final Logger log = LoggerFactory .getLogger(ModuleGenerator.class); public static final String SPT = File.separator; public static final String ENCODING = "UTF-8"; private Properties prop = new Properties(); private String packName; private String fileName; private File daoImplFile; private File daoFile; private File managerFile; private File managerImplFile; private File actionFile; private File pageListFile; private File pageEditFile; private File pageAddFile; private File daoImplTpl; private File daoTpl; private File managerTpl; private File managerImplTpl; private File actionTpl; private File pageListTpl; private File pageEditTpl; private File pageAddTpl; public ModuleGenerator(String packName, String fileName) &#123; this.packName = packName; this.fileName = fileName; &#125; @SuppressWarnings("unchecked") private void loadProperties() &#123; try &#123; log.debug("packName=" + packName); log.debug("fileName=" + fileName); FileInputStream fileInput = new FileInputStream(getFilePath( packName, fileName)); prop.load(fileInput); String entityUp = prop.getProperty("Entity"); log.debug("entityUp:" + entityUp); if (entityUp == null || entityUp.trim().equals("")) &#123; log.warn("Entity not specified, exit!"); return; &#125; String entityLow = entityUp.substring(0, 1).toLowerCase() + entityUp.substring(1); log.debug("entityLow:" + entityLow); prop.put("entity", entityLow); if (log.isDebugEnabled()) &#123; Set ps = prop.keySet(); for (Object o : ps) &#123; log.debug(o + "=" + prop.get(o)); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void prepareFile() &#123; String daoImplFilePath = getFilePath(prop.getProperty("dao_impl_p"), prop.getProperty("Entity") + "DaoImpl.java"); daoImplFile = new File(daoImplFilePath); log.debug("daoImplFile:" + daoImplFile.getAbsolutePath()); String daoFilePath = getFilePath(prop.getProperty("dao_p"), prop .getProperty("Entity") + "Dao.java"); daoFile = new File(daoFilePath); log.debug("daoFile:" + daoFile.getAbsolutePath()); String managerFilePath = getFilePath(prop.getProperty("manager_p"), prop.getProperty("Entity") + "Mng.java"); managerFile = new File(managerFilePath); log.debug("managerFile:" + managerFile.getAbsolutePath()); String managerImplFilePath = getFilePath(prop .getProperty("manager_impl_p"), prop.getProperty("Entity") + "MngImpl.java"); managerImplFile = new File(managerImplFilePath); log.debug("managerImplFile:" + managerImplFile.getAbsolutePath()); String actionFilePath = getFilePath(prop.getProperty("action_p"), prop .getProperty("Entity") + "Act.java"); actionFile = new File(actionFilePath); log.debug("actionFile:" + actionFile.getAbsolutePath()); String pagePath = "WebContent/WEB-INF/" + prop.getProperty("config_sys") + "/" + prop.getProperty("config_entity") + "/"; pageListFile = new File(pagePath + "list.html"); log.debug("pageListFile:" + pageListFile.getAbsolutePath()); pageEditFile = new File(pagePath + "edit.html"); log.debug("pageEditFile:" + pageEditFile.getAbsolutePath()); pageAddFile = new File(pagePath + "add.html"); log.debug("pageAddFile:" + pageAddFile.getAbsolutePath()); &#125; private void prepareTemplate() &#123; String tplPack = prop.getProperty("template_dir"); log.debug("tplPack:" + tplPack); daoImplTpl = new File(getFilePath(tplPack, "dao_impl.txt")); daoTpl = new File(getFilePath(tplPack, "dao.txt")); managerImplTpl = new File(getFilePath(tplPack, "manager_impl.txt")); managerTpl = new File(getFilePath(tplPack, "manager.txt")); actionTpl = new File(getFilePath(tplPack, "action.txt")); pageListTpl = new File(getFilePath(tplPack, "page_list.txt")); pageAddTpl = new File(getFilePath(tplPack, "page_add.txt")); pageEditTpl = new File(getFilePath(tplPack, "page_edit.txt")); &#125; private static void stringToFile(File file, String s) throws IOException &#123; FileUtils.writeStringToFile(file, s, ENCODING); &#125; private void writeFile() &#123; try &#123; if ("true".equals(prop.getProperty("is_dao"))) &#123; stringToFile(daoImplFile, readTpl(daoImplTpl)); stringToFile(daoFile, readTpl(daoTpl)); &#125; if ("true".equals(prop.getProperty("is_manager"))) &#123; stringToFile(managerImplFile, readTpl(managerImplTpl)); stringToFile(managerFile, readTpl(managerTpl)); &#125; if ("true".equals(prop.getProperty("is_action"))) &#123; stringToFile(actionFile, readTpl(actionTpl)); &#125; if ("true".equals(prop.getProperty("is_page"))) &#123; stringToFile(pageListFile, readTpl(pageListTpl)); stringToFile(pageAddFile, readTpl(pageAddTpl)); stringToFile(pageEditFile, readTpl(pageEditTpl)); &#125; &#125; catch (IOException e) &#123; log.warn("write file faild! " + e.getMessage()); &#125; &#125; private String readTpl(File tpl) &#123; String content = null; try &#123; content = FileUtils.readFileToString(tpl, ENCODING); Set&lt;Object&gt; ps = prop.keySet(); for (Object o : ps) &#123; String key = (String) o; String value = prop.getProperty(key); content = content.replaceAll("\\#\\&#123;" + key + "\\&#125;", value); &#125; &#125; catch (IOException e) &#123; log.warn("read file faild. " + e.getMessage()); &#125; return content; &#125; private String getFilePath(String packageName, String name) &#123; log.debug("replace:" + packageName); String path = packageName.replaceAll("\\.", "/"); log.debug("after relpace:" + path); return "src/" + path + "/" + name; &#125; public void generate() &#123; loadProperties(); prepareFile(); prepareTemplate(); writeFile(); &#125; public static void main(String[] args) &#123; String packName = "com.jeecms.common.developer.template"; String fileName = "template.properties"; new ModuleGenerator(packName, fileName).generate(); &#125;&#125; Entity模板使用hibernateMapping插件生成 Dao模板​ dao.txt 1234567891011121314151617package #&#123;dao_p&#125;;import com.jeecms.common.hibernate4.Updater;import com.jeecms.common.page.Pagination;import #&#123;entity_p&#125;.#&#123;Entity&#125;;public interface #&#123;Entity&#125;Dao &#123; public Pagination getPage(int pageNo, int pageSize); public #&#123;Entity&#125; findById(Integer id); public #&#123;Entity&#125; save(#&#123;Entity&#125; bean); public #&#123;Entity&#125; updateByUpdater(Updater&lt;#&#123;Entity&#125;&gt; updater); public #&#123;Entity&#125; deleteById(Integer id);&#125; DaoImpl模板​ dao_impl.txt 1234567891011121314151617181920212223242526272829303132333435363738394041package #&#123;dao_impl_p&#125;;import org.hibernate.Criteria;import org.springframework.stereotype.Repository;import com.jeecms.common.hibernate4.HibernateBaseDao;import com.jeecms.common.page.Pagination;import #&#123;dao_p&#125;.#&#123;Entity&#125;Dao;import #&#123;entity_p&#125;.#&#123;Entity&#125;;@Repositorypublic class #&#123;Entity&#125;DaoImpl extends HibernateBaseDao&lt;#&#123;Entity&#125;, Integer&gt; implements #&#123;Entity&#125;Dao &#123; public Pagination getPage(int pageNo, int pageSize) &#123; Criteria crit = createCriteria(); Pagination page = findByCriteria(crit, pageNo, pageSize); return page; &#125; public #&#123;Entity&#125; findById(Integer id) &#123; #&#123;Entity&#125; entity = get(id); return entity; &#125; public #&#123;Entity&#125; save(#&#123;Entity&#125; bean) &#123; getSession().save(bean); return bean; &#125; public #&#123;Entity&#125; deleteById(Integer id) &#123; #&#123;Entity&#125; entity = super.get(id); if (entity != null) &#123; getSession().delete(entity); &#125; return entity; &#125; @Override protected Class&lt;#&#123;Entity&#125;&gt; getEntityClass() &#123; return #&#123;Entity&#125;.class; &#125;&#125; Manager模板​ manager.txt 123456789101112131415161718package #&#123;manager_p&#125;;import com.jeecms.common.page.Pagination;import #&#123;entity_p&#125;.#&#123;Entity&#125;;public interface #&#123;Entity&#125;Mng &#123; public Pagination getPage(int pageNo, int pageSize); public #&#123;Entity&#125; findById(Integer id); public #&#123;Entity&#125; save(#&#123;Entity&#125; bean); public #&#123;Entity&#125; update(#&#123;Entity&#125; bean); public #&#123;Entity&#125; deleteById(Integer id); public #&#123;Entity&#125;[] deleteByIds(Integer[] ids);&#125; ManagerImpl模板​ manager_impl.txt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package #&#123;manager_impl_p&#125;;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.jeecms.common.hibernate4.Updater;import com.jeecms.common.page.Pagination;import #&#123;dao_p&#125;.#&#123;Entity&#125;Dao;import #&#123;entity_p&#125;.#&#123;Entity&#125;;import #&#123;manager_p&#125;.#&#123;Entity&#125;Mng;@Service@Transactionalpublic class #&#123;Entity&#125;MngImpl implements #&#123;Entity&#125;Mng &#123; @Transactional(readOnly = true) public Pagination getPage(int pageNo, int pageSize) &#123; Pagination page = dao.getPage(pageNo, pageSize); return page; &#125; @Transactional(readOnly = true) public #&#123;Entity&#125; findById(Integer id) &#123; #&#123;Entity&#125; entity = dao.findById(id); return entity; &#125; public #&#123;Entity&#125; save(#&#123;Entity&#125; bean) &#123; dao.save(bean); return bean; &#125; public #&#123;Entity&#125; update(#&#123;Entity&#125; bean) &#123; Updater&lt;#&#123;Entity&#125;&gt; updater = new Updater&lt;#&#123;Entity&#125;&gt;(bean); bean = dao.updateByUpdater(updater); return bean; &#125; public #&#123;Entity&#125; deleteById(Integer id) &#123; #&#123;Entity&#125; bean = dao.deleteById(id); return bean; &#125; public #&#123;Entity&#125;[] deleteByIds(Integer[] ids) &#123; #&#123;Entity&#125;[] beans = new #&#123;Entity&#125;[ids.length]; for (int i = 0,len = ids.length; i &lt; len; i++) &#123; beans[i] = deleteById(ids[i]); &#125; return beans; &#125; private #&#123;Entity&#125;Dao dao; @Autowired public void setDao(#&#123;Entity&#125;Dao dao) &#123; this.dao = dao; &#125;&#125; Action模板​ action.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package #&#123;action_p&#125;;import static com.jeecms.common.page.SimplePage.cpn;import javax.servlet.http.HttpServletRequest;import org.apache.shiro.authz.annotation.RequiresPermissions;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import #&#123;entity_p&#125;.#&#123;Entity&#125;;import com.jeecms.core.entity.CmsSite;import #&#123;manager_p&#125;.#&#123;Entity&#125;Mng;import com.jeecms.core.web.util.CmsUtils;import com.jeecms.core.web.WebErrors;import com.jeecms.common.page.Pagination;import com.jeecms.common.web.CookieUtils;@Controllerpublic class #&#123;Entity&#125;Act &#123; private static final Logger log = LoggerFactory.getLogger(#&#123;Entity&#125;Act.class); @RequiresPermissions("#&#123;config_entity&#125;:v_list") @RequestMapping("/#&#123;config_entity&#125;/v_list.do") public String list(Integer pageNo, HttpServletRequest request, ModelMap model) &#123; Pagination pagination = manager.getPage(cpn(pageNo), CookieUtils .getPageSize(request)); model.addAttribute("pagination",pagination); model.addAttribute("pageNo",pagination.getPageNo()); return "#&#123;config_entity&#125;/list"; &#125; @RequiresPermissions("#&#123;config_entity&#125;:v_add") @RequestMapping("/#&#123;config_entity&#125;/v_add.do") public String add(ModelMap model) &#123; return "#&#123;config_entity&#125;/add"; &#125; @RequiresPermissions("#&#123;config_entity&#125;:v_edit") @RequestMapping("/#&#123;config_entity&#125;/v_edit.do") public String edit(Integer id, Integer pageNo, HttpServletRequest request, ModelMap model) &#123; WebErrors errors = validateEdit(id, request); if (errors.hasErrors()) &#123; return errors.showErrorPage(model); &#125; model.addAttribute("#&#123;entity&#125;", manager.findById(id)); model.addAttribute("pageNo",pageNo); return "#&#123;config_entity&#125;/edit"; &#125; @RequiresPermissions("#&#123;config_entity&#125;:o_save") @RequestMapping("/#&#123;config_entity&#125;/o_save.do") public String save(#&#123;Entity&#125; bean, HttpServletRequest request, ModelMap model) &#123; WebErrors errors = validateSave(bean, request); if (errors.hasErrors()) &#123; return errors.showErrorPage(model); &#125; bean = manager.save(bean); log.info("save #&#123;Entity&#125; id=&#123;&#125;", bean.getId()); return "redirect:v_list.do"; &#125; @RequiresPermissions("#&#123;config_entity&#125;:o_update") @RequestMapping("/#&#123;config_entity&#125;/o_update.do") public String update(#&#123;Entity&#125; bean, Integer pageNo, HttpServletRequest request, ModelMap model) &#123; WebErrors errors = validateUpdate(bean.getId(), request); if (errors.hasErrors()) &#123; return errors.showErrorPage(model); &#125; bean = manager.update(bean); log.info("update #&#123;Entity&#125; id=&#123;&#125;.", bean.getId()); return list(pageNo, request, model); &#125; @RequiresPermissions("#&#123;config_entity&#125;:o_delete") @RequestMapping("/#&#123;config_entity&#125;/o_delete.do") public String delete(Integer[] ids, Integer pageNo, HttpServletRequest request, ModelMap model) &#123; WebErrors errors = validateDelete(ids, request); if (errors.hasErrors()) &#123; return errors.showErrorPage(model); &#125; #&#123;Entity&#125;[] beans = manager.deleteByIds(ids); for (#&#123;Entity&#125; bean : beans) &#123; log.info("delete #&#123;Entity&#125; id=&#123;&#125;", bean.getId()); &#125; return list(pageNo, request, model); &#125; private WebErrors validateSave(#&#123;Entity&#125; bean, HttpServletRequest request) &#123; WebErrors errors = WebErrors.create(request); CmsSite site = CmsUtils.getSite(request); bean.setSite(site); return errors; &#125; private WebErrors validateEdit(Integer id, HttpServletRequest request) &#123; WebErrors errors = WebErrors.create(request); CmsSite site = CmsUtils.getSite(request); if (vldExist(id, site.getId(), errors)) &#123; return errors; &#125; return errors; &#125; private WebErrors validateUpdate(Integer id, HttpServletRequest request) &#123; WebErrors errors = WebErrors.create(request); CmsSite site = CmsUtils.getSite(request); if (vldExist(id, site.getId(), errors)) &#123; return errors; &#125; return errors; &#125; private WebErrors validateDelete(Integer[] ids, HttpServletRequest request) &#123; WebErrors errors = WebErrors.create(request); CmsSite site = CmsUtils.getSite(request); if (errors.ifEmpty(ids, "ids")) &#123; return errors; &#125; for (Integer id : ids) &#123; vldExist(id, site.getId(), errors); &#125; return errors; &#125; private boolean vldExist(Integer id, Integer siteId, WebErrors errors) &#123; if (errors.ifNull(id, "id")) &#123; return true; &#125; #&#123;Entity&#125; entity = manager.findById(id); if(errors.ifNotExist(entity, #&#123;Entity&#125;.class, id)) &#123; return true; &#125; if (!entity.getSite().getId().equals(siteId)) &#123; errors.notInSite(#&#123;Entity&#125;.class, id); return true; &#125; return false; &#125; @Autowired private #&#123;Entity&#125;Mng manager;&#125; 页面增加模板​ page_add.txt 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/&gt;&lt;title&gt;&lt;/title&gt;&lt;#include "/#&#123;config_sys&#125;/head.html"/&gt;&lt;script type="text/javascript"&gt;$(function() &#123; $("#jvForm").validate();&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box-positon"&gt; &lt;div class="rpos"&gt;&lt;@s.m "global.position"/&gt;: &lt;@s.m "#&#123;entity&#125;.function"/&gt; - &lt;@s.m "global.add"/&gt;&lt;/div&gt; &lt;form class="ropt"&gt; &lt;input class="return-button" type="submit" value="&lt;@s.m "global.backToList"/&gt;" onclick="this.form.action='v_list.do';"/&gt; &lt;/form&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="body-box"&gt;&lt;@p.form id="jvForm" action="o_save.do"&gt;&lt;@p.text label="#&#123;entity&#125;.name" name="name" required="true" class="required" maxlength="100"/&gt;&lt;@p.td&gt;&lt;@p.submit code="global.submit"/&gt; &amp;nbsp; &lt;@p.reset code="global.reset"/&gt;&lt;/@p.td&gt;&lt;/@p.form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 页面修改模板​ page_edit.txt 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/&gt;&lt;title&gt;&lt;/title&gt;&lt;#include "/#&#123;config_sys&#125;/head.html"/&gt;&lt;script type="text/javascript"&gt;$(function() &#123; $("#jvForm").validate();&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box-positon"&gt; &lt;div class="rpos"&gt;&lt;@s.m "global.position"/&gt;: &lt;@s.m "#&#123;entity&#125;.function"/&gt; - &lt;@s.m "global.edit"/&gt;&lt;/div&gt; &lt;form class="ropt"&gt; &lt;input class="return-button" type="submit" value="&lt;@s.m "global.backToList"/&gt;" onclick="this.form.action='v_list.do';"/&gt; &lt;/form&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="body-box"&gt;&lt;@p.form id="jvForm" action="o_update.do"&gt;&lt;@p.text label="#&#123;entity&#125;.name" name="name" value=#&#123;entity&#125;.name required="true" class="required" maxlength="100"/&gt;&lt;@p.td&gt;&lt;@p.hidden name="id" value=#&#123;entity&#125;.id/&gt;&lt;@p.submit code="global.submit"/&gt; &amp;nbsp; &lt;@p.reset code="global.reset"/&gt;&lt;/@p.td&gt;&lt;/@p.form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 页面列表模板​ page_list.txt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/&gt;&lt;title&gt;&lt;/title&gt;&lt;#include "/#&#123;config_sys&#125;/head.html"/&gt;&lt;script type="text/javascript"&gt;function getTableForm() &#123; return document.getElementById('tableForm');&#125;function optDelete() &#123; if(Pn.checkedCount('ids')&lt;=0) &#123; $.alert("&lt;@s.m 'global.prompt'/&gt;","&lt;@s.m 'error.checkRecord'/&gt;"); return; &#125; $.confirm(doDelete,"&lt;@s.m 'global.confirm'/&gt;","&lt;@s.m 'global.confirm.delete'/&gt;");&#125;function doDelete()&#123; var f = getTableForm(); f.action="o_delete.do"; f.submit();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box-positon"&gt; &lt;div class="rpos"&gt;&lt;@s.m "global.position"/&gt;: &lt;@s.m "#&#123;entity&#125;.function"/&gt; - &lt;@s.m "global.list"/&gt;&lt;/div&gt; &lt;form class="ropt"&gt; &lt;input class="add" type="submit" value="&lt;@s.m "global.add"/&gt;" onclick="this.form.action='v_add.do';"/&gt; &lt;/form&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="body-box"&gt;&lt;form id="tableForm" method="post"&gt;&lt;input type="hidden" name="pageNo" value="$&#123;pageNo!&#125;"/&gt;&lt;@p.table value=pagination;#&#123;entity&#125;,i,has_next&gt;&lt;#rt/&gt; &lt;@p.column title="&lt;input type='checkbox' onclick='Pn.checkbox(\"ids\",this.checked)'/&gt;" width="20"&gt; &lt;input type='checkbox' name='ids' value='$&#123;#&#123;entity&#125;.id&#125;'/&gt;&lt;#t/&gt; &lt;/@p.column&gt;&lt;#t/&gt; &lt;@p.column title="ID"&gt;$&#123;#&#123;entity&#125;.id&#125;&lt;/@p.column&gt;&lt;#t/&gt; &lt;@p.column code="#&#123;entity&#125;.name"&gt;$&#123;#&#123;entity&#125;.name&#125;&lt;/@p.column&gt;&lt;#t/&gt; &lt;@p.column code="global.operate" align="center"&gt; &lt;a href="v_edit.do?id=$&#123;#&#123;entity&#125;.id&#125;&amp;pageNo=$&#123;pageNo!&#125;" class="pn-opt"&gt;&lt;@s.m "global.edit"/&gt;&lt;/a&gt; | &lt;#rt/&gt; &lt;a href="o_delete.do?ids=$&#123;#&#123;entity&#125;.id&#125;&amp;pageNo=$&#123;pageNo!&#125;" onclick="if(!$.confirmToUrl(this.href)) &#123;return false;&#125;" class="pn-opt"&gt;&lt;@s.m "global.delete"/&gt;&lt;/a&gt;&lt;#t/&gt; &lt;/@p.column&gt;&lt;#t/&gt;&lt;/@p.table&gt;&lt;div&gt;&lt;input class="del-button" type="button" value="&lt;@s.m "global.delete"/&gt;" onclick="optDelete();"/&gt;&lt;/div&gt;&lt;/form&gt;&lt;/div&gt;&lt;#include "/common/alert_message.html"/&gt;&lt;/body&gt;&lt;/html&gt; 使用com.jeecms.cms.template.CmsModuleGenerator.java打开后Run As—java application]]></content>
      <categories>
        <category>CMS</category>
      </categories>
      <tags>
        <tag>CMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logback日志组件的使用]]></title>
    <url>%2Fblog%2F17154.html</url>
    <content type="text"><![CDATA[Logback是由log4j创始人设计的又一个开源日志组件。 一. logback的介绍​ logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个 改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging。logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能。 Logback是要与SLF4J结合起来用两个组件的官方网站如下： ​ logback的官方网站： http://logback.qos.ch ​ SLF4J的官方网站：http://www.slf4j.org ​ 本文章用到的组件如下：请自行到官方网站下载！ ​ logback-access-1.0.0.jar ​ logback-classic-1.0.0.jar ​logback-core-1.0.0.jar ​slf4j-api-1.6.0.jar 二. logback取代 log4j的理由：​ Logback和log4j是非常相似的，如果你对log4j很熟悉，那对logback很快就会得心应手。下面列了logback相对于log4j的一些优点： ​ 1. 更快的实现 Logback的内核重写了，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小了。 ​ 2. 非常充分的测试 Logback经过了几年，数不清小时的测试。Logback的测试完全不同级别的。在作者的观点，这是简单重要的原因选择logback而不是log4j。 ​ 3. Logback-classic非常自然实现了SLF4j Logback-classic实现了 SLF4j。在使用SLF4j中，你都感觉不到logback-classic。而且因为logback-classic非常自然地实现了SLF4J， 所 以切换到log4j或者其他，非常容易，只需要提供成另一个jar包就OK，根本不需要去动那些通过SLF4JAPI实现的代码。 ​ 4. 非常充分的文档 官方网站有两百多页的文档。 ​ 5. 自动重新加载配置文件 当配置文件修改了，Logback-classic能自动重新加载配置文件。扫描过程快且安全，它并不需要另外创建一个扫描线程。这个技术充分保证了应用程序能跑得很欢在JEE环境里面。 ​ 6. Lilith Lilith是log事件的观察者，和log4j的chainsaw类似。而lilith还能处理大数量的log数据 。 ​ 7. 谨慎的模式和非常友好的恢复 在谨慎模式下，多个FileAppender实例跑在多个JVM下，能 够安全地写道同一个日志文件。RollingFileAppender会有些限制。Logback的FileAppender和它的子类包括 RollingFileAppender能够非常友好地从I/O异常中恢复。 ​ 8. 配置文件可以处理不同的情况 开发人员经常需要判断不同的Logback配置文件在不同的环境下（开发，测试，生产）。而这些配置文件仅仅只有一些很小的不同，可以通过,和来实现，这样一个配置文件就可以适应多个环境。 ​ 9. Filters（过滤器） 有些时候，需要诊断一个问题，需要打出日志。在log4j，只有降低日志级别，不过这样会打出大量的日志，会影响应用性能。在Logback，你可以继续 保持那个日志级别而除掉某种特殊情况，如alice这个用户登录，她的日志将打在DEBUG级别而其他用户可以继续打在WARN级别。要实现这个功能只需 加4行XML配置。可以参考MDCFIlter 。 SiftingAppender（一个非常多功能的Appender） 它可以用来分割日志文件根据任何一个给定的运行参数。如，SiftingAppender能够区别日志事件跟进用户的Session，然后每个用户会有一个日志文件。 自动压缩已经打出来的log RollingFileAppender在产生新文件的时候，会自动压缩已经打出来的日志文件。压缩是个异步过程，所以甚至对于大的日志文件，在压缩过程中应用不会受任何影响。 堆栈树带有包版本 Logback在打出堆栈树日志时，会带上包的数据。 自动去除旧的日志文件 通过设置TimeBasedRollingPolicy或者SizeAndTimeBasedFNATP的maxHistory属性，你可以控制已经产生日志文件的最大数量。如果设置maxHistory 12，那那些log文件超过12个月的都会被自动移除。 ​ 总之，logback比log4j太优秀了，让我们的应用全部建立logback上吧 ！ 三. Logback的配置介绍​ 1. Logger. appender及layout ​ Logger作为日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型. 级别。 ​ Appender主要用于指定日志输出的目的地，目的地可以是控制台. 文件. 远程套接字服务器. MySQL. PostreSQL. Oracle和其他数据库. JMS和远程UNIX Syslog守护进程等。 ​ Layout 负责把事件转换成字符串，格式化的日志信息的输出。 ​ 2. logger context ​ 各个logger 都被关联到一个 LoggerContext，LoggerContext负责制造logger，也负责以树结构排列各logger。其他所有logger也通过org.slf4j.LoggerFactory 类的静态方法getLogger取得。 getLogger方法以 logger 名称为参数。用同一名字调用LoggerFactory.getLogger 方法所得到的永远都是同一个logger对象的引用。 有效级别及级别的继承 ​ Logger 可以被分配级别。级别包括：TRACE. DEBUG. INFO. WARN 和 ERROR，定义于ch.qos.logback.classic.Level类。如果 logger没有被分配级别，那么它将从有被分配级别的最近的祖先那里继承级别。root logger 默认级别是 DEBUG。 打印方法与基本的选择规则 ​ 打印方法决定记录请求的级别。例如，如果 L 是一个 logger 实例，那么，语句 L.info(“..”)是一条级别为 INFO 的记录语句。记录请求的级别在高于或等于其 logger 的有效级别时被称为被启用，否则，称为被禁用。记录请求级别为 p，其 logger的有效级别为 q，只有则当 p&gt;=q时，该请求才会被执行。 ​ 该规则是 logback 的核心。级别排序为： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR。 四. Logback的默认配置​ 如果配置文件 logback-test.xml 和 logback.xml 都不存在，那么 logback 默认地会调用BasicConfigurator ，创建一个最小化配置。最小化配置由一个关联到根 logger 的ConsoleAppender 组成。输出用模式为%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n 的PatternLayoutEncoder 进行格式化。root logger 默认级别是 DEBUG。 ​ 1. Logback的配置文件 ​ Logback 配置文件的语法非常灵活。正因为灵活，所以无法用 DTD 或 XML schema 进行定义。尽管如此，可以这样描述配置文件的基本结构：以&lt;configuration&gt;开头，后面有零个或多个&lt;appender&gt;元素，有零个或多个&lt;logger&gt;元素，有最多一个&lt;root&gt;元素。 ​ 2. Logback默认配置的步骤 ​ (1). 尝试在 classpath 下查找文件 logback-test.xml； ​ (2). 如果文件不存在，则查找文件 logback.xml； ​ (3). 如果两个文件都不存在，logback 用 Bas icConfigurator 自动对自己进行配置，这会导致记录输出到控制台。 ​ 3. Logback.xml 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt; &lt;property name="LOG_HOME" value="c:/log" /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出编码 --&gt; &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/myApp.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!-- show parameters for hibernate sql 专为 Hibernate 定制 --&gt; &lt;logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE" /&gt; &lt;logger name="org.hibernate.type.descriptor.sql.BasicExtractor" level="DEBUG" /&gt; &lt;logger name="org.hibernate.SQL" level="DEBUG" /&gt; &lt;logger name="org.hibernate.engine.QueryParameters" level="DEBUG" /&gt; &lt;logger name="org.hibernate.engine.query.HQLQueryPlan" level="DEBUG" /&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt; &lt;!--日志异步到数据库 --&gt; &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender"&gt; &lt;!--日志异步到数据库 --&gt; &lt;connectionSource class="ch.qos.logback.core.db.DriverManagerConnectionSource"&gt; &lt;!--连接池 --&gt; &lt;dataSource class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;driverClass&gt;com.mysql.jdbc.Driver&lt;/driverClass&gt; &lt;url&gt;jdbc:mysql://127.0.0.1:3306/databaseName&lt;/url&gt; &lt;user&gt;root&lt;/user&gt; &lt;password&gt;root&lt;/password&gt; &lt;/dataSource&gt; &lt;/connectionSource&gt; &lt;/appender&gt; --&gt;&lt;/configuration&gt; 五. 在程序用引用Logback12345678910111213141516package com.stu.system.action; import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class BlogAction&#123; //定义一个全局的记录器，通过LoggerFactory获取 private final static Logger logger = LoggerFactory.getLogger(BlogAction.class); / * @param args */ public static void main(String[] args) &#123; logger.info("logback 成功了"); logger.error("logback 成功了"); &#125;&#125; Logback手册.pdf (3.6 MB)]]></content>
      <categories>
        <category>Log</category>
      </categories>
      <tags>
        <tag>Log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[库内新增对象的流程及其他技巧]]></title>
    <url>%2Fblog%2F38066.html</url>
    <content type="text"><![CDATA[cms开发 ———— 库内新增对象Products的流程说明及其他技巧 第一步：Entity com.jeecms.cms.entity.assist.base下建立模型基础类BaseCmsProducts.java com.jeecms.cms.entity.assist 下建立对象类继承继承模型CmsProducts.java com.jeecms.cms.entity.assist.hbm 配置hibernate对象映射CmsProducts.hbm.xml src .ehcache-hibernate.xml 缓存对象配置： 12 &lt;cache name="com.jeecms.cms.entity.assist.CmsProducts" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true"/&gt; 第二步：Dao com.jeecms.cms.dao.assist数据库交互持久层DAO接口和实现ProductsDao.java ProductsDaoImpl.java 配置WebRoot/WEB-INF/config/jeecms-context.xml文件: 12&lt;bean id="cmsproductsDao" class="com.jeecms.cms.dao.assist.impl.CmsProductsDaoImpl"/&gt; 第三步：Service com.jeecms.cms.manager.assist业务层接口和实现，ProductsMng.java , ProductsMngImpl.java 配置WebRoot/WEB-INF/config/jeecms-context.xml文件: 12&lt;bean id="cmsProductsMng" class="com.jeecms.cms.manager.assist.impl.CmsProductsMngImpl"/&gt; 第四步：Action com.jeecms.cms.action.front 写Action与前台对接，ProductsAct.java XML配置：jeecms-servlet-front-action.xml 12&lt;bean id="productsAct" class="com.jeecms.cms.action.front.ProductsAct"/&gt; com.jeecms.cms.action.admin.assist （加、删、改）写Action与后台对接CmsProductsAct.java XML配置：jeecms-servlet-admin-action.xml 12&lt;bean id="cmsProductsAct" class="com.jeecms.cms.action.admin.assist.CmsProductsAct"/&gt; 第五步：Directive com.jeecms.cms.action.directive (设置并返回标签对象[@cms_products_page]) 配置WebRoot/WEB-INF/config/jeecms-context.xml文件: 123456789101112131415&lt;bean id="cms_products_page" class="com.jeecms.cms.action.directive.CmsProductsDirective"/&gt;&lt;bean id="staticPageSvc" class="com.jeecms.cms.staticpage.StaticPageSvcImpl"&gt; &lt;property name="tplMessageSource" ref="tplMessageSource"/&gt; &lt;property name="freeMarkerConfigurer"&gt; &lt;bean class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="freemarkerVariables"&gt; &lt;map&gt; 此处添加标签的配置信息： 1&lt;entry key="cms_products_page" value-ref="cms_products_page"/&gt; 配置WebRoot/WEB-INF/config/ Jeecms-servlet-front.xml文件: 123&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="freemarkerVariables"&gt; &lt;map&gt; 此处添加标签的配置信息： 1&lt;entry key="cms_products_page" value-ref="cms_products_page" /&gt; 特别注意点： 对象模板位置控制：com.jeecms.cms.action.front.ProductsAct.java 1234// 方案路径site.getSolutionPath()=”/WEB-INF/t/cms/www/default”// TPLDIR_SPECIAL="special" 模板位置// PRODUCTS_INDEX= "tpl.productsIndex"; 模板名称return FrontUtils.getTplPath(request, site.getSolutionPath(),TPLDIR_SPECIAL, PRODUCTS_INDEX); PRODUCTS_INDEX对象需要在国际化处进行设置：WebRoot/WEB-INF/languages/jeecms_tpl/messages_zh_CN.properties ： 1tpl.productsIndex=products_index 国际化文件说明： WEB-INF/languages/fck 友情提示 WEB-INF/languages/jeecms_admin (后台)功能页面，如：首页》内容统计 statistic.function.content=内容统计 WEB-INF/languages/jeecms_front (前台)友情提示，如：验证码错误。 WEB-INF/languages/jeecms_tpl (前台)功能页面，如：投票内容页， tpl.tagDetail=voteIndex WEB-INF/languages/jeecore_admin 功能按钮、提示信息，如：global.submit=提交，global.confirm.logout=您确定退出吗？ 修改后台访问地址将jeeadmin/jeecms/index.do 改为admin/index.do为例 修改WebContent\WEB-INF\web.xml 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsAdmin&lt;/servlet-name&gt; &lt;url-pattern&gt;/jeeadmin/jeecms/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 改为 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsAdmin&lt;/servlet-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 修改WebContent\WEB-INF\config\jeecms-servlet-admin.xml 1&lt;entry key="appBase" value="/jeeadmin/jeecms"/&gt; 改为 1&lt;entry key="appBase" value="/admin"/&gt; 修改WebContent\WEB-INF\config\shiro-context.xml 把 12345678910*.jspx = anon *.jhtml = anon /member/forgot_password.jspx = anon /member/password_reset.jspx = anon /login.jspx = authc /logout.jspx = logout /member/** = user /jeeadmin/jeecms/login.do = authc /jeeadmin/jeecms/logout.do = logout /jeeadmin/jeecms/** =user 改为 12345678910*.jspx = anon *.jhtml = anon /member/forgot_password.jspx = anon /member/password_reset.jspx = anon /login.jspx = authc /logout.jspx = logout /member/** = user /admin/login.do = authc /admin/logout.do = logout /admin/** =user 把 12&lt;property name="adminLogin" value="/jeeadmin/jeecms/login.do"/&gt; &lt;property name="adminPrefix" value="/jeeadmin/jeecms/"/&gt; 改为 12&lt;property name="adminLogin" value="/admin/login.do"/&gt; &lt;property name="adminPrefix" value="/admin/"/&gt; 把 1&lt;property name="adminIndex" value="/jeeadmin/jeecms/index.do"/&gt; 改为 1&lt;property name="adminIndex" value="/admin/index.do"/&gt; 修改\src\com\jeecms\cms\web\AdminContextInterceptor.java 把 1234567891011121314151617 private static String getURI(HttpServletRequest request) throws IllegalStateException &#123; UrlPathHelper helper = new UrlPathHelper(); String uri = helper.getOriginatingRequestUri(request); String ctxPath = helper.getOriginatingContextPath(request); int start = 0, i = 0, count = 2 if (!StringUtils.isBlank(ctxPath)) &#123; count++; &#125; while (i &lt; count &amp;&amp; start != -1) &#123; start = uri.indexOf('/', start + 1); i++; &#125; if (start &lt;= 0) &#123; throw new IllegalStateException("admin access path not like '/jeeadmin/jeecms/...' pattern: " + uri); &#125; return uri.substring(start); &#125; 改为 123456789101112131415161718private static String getURI(HttpServletRequest request) throws IllegalStateException &#123; UrlPathHelper helper = new UrlPathHelper(); String uri = helper.getOriginatingRequestUri(request); String ctxPath = helper.getOriginatingContextPath(request); // int start = 0, i = 0, count = 2;修改 int start = 0, i = 0, count = 1; if (!StringUtils.isBlank(ctxPath)) &#123; count++; &#125; while (i &lt; count &amp;&amp; start != -1) &#123; start = uri.indexOf('/', start + 1); i++; &#125; if (start &lt;= 0) &#123; throw new IllegalStateException("admin access path not like '/admin/...' pattern: " + uri); &#125; return uri.substring(start); &#125; 通过数据库修改密码 通过数据库修改admin密码 12select * from core_user;| 1 | admin | jobar | 0230504dd5de96d2f6784d45d1bc7633 | 密码已经是被加密过的了。 密码加密类：com.ponyjava.common.util.Md5PwdEncoder 例如我想将密码设为“zhaozh”,就先用这个类加密，然后更新数据库就ok了。 123456public class Test &#123; public static void main(String[] args) &#123; Md5PwdEncoder encoder = new Md5PwdEncoder(); System.out.println(encoder.encodePassword("zhaozh")); &#125;&#125; 输出为：f06238ff925a61f9c62de7d64c64bad3 mysql&gt; 1update core_user set password='f06238ff925a61f9c62de7d64c64bad3' where user_id='1'; 再次登录就ok了。]]></content>
      <categories>
        <category>cms</category>
      </categories>
      <tags>
        <tag>cms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API开发规范]]></title>
    <url>%2Fblog%2F51267.html</url>
    <content type="text"><![CDATA[API开发规范 整体规范建议采用RESTful 方式来实施。1. 协议API与用户的通信协议，总是使用HTTPs协议，确保交互数据的传输安全。 2. 域名应该尽量将API部署在专用域名之下。 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1https://example.org/api/ 3. api版本控制应该将API的版本号放入URL。 1https://api.example.com/v&#123;n&#125;/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 采用多版本并存，增量发布的方式 v{n} n代表版本号,分为整形和浮点型 整形的版本号: 大功能版本发布形式；具有当前版本状态下的所有API接口 ,例如：v1,v2 浮点型：为小版本号，只具备补充api的功能，其他api都默认调用对应大版本号的api 例如：v1.1 v2.2 4. API 路径规则路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 12345https://api.example.com/v1/productshttps://api.example.com/v1/usershttps://api.example.com/v1/employees 5. HTTP请求方式对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面四个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 DELETE（DELETE）：从服务器删除资源。 下面是一些例子。 GET /product：列出所有商品 POST /product：新建一个商品 GET /product/ID：获取某个指定商品的信息 PUT /product/ID：更新某个指定商品的信息 DELETE /product/ID：删除某个商品 GET /product/ID/purchase ：列出某个指定商品的所有投资者 get /product/ID/purchase/ID：获取某个指定商品的指定投资者信息 6. 过滤信息如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?producy_type=1：指定筛选条件 7. API 传入参数传入参数分为4种类型： 地址栏参数 * restful 地址栏参数 /api/v1/product/122 122为产品编号，获取产品为122的信息 * get方式的查询字串 见过滤信息小节 请求body数据 cookie request header cookie和header 一般都是用于OAuth认证的2种途径 8. 返回数据只要api接口成功接到请求，就不能返回200以外的HTTP状态。 为了保障前后端的数据交互的顺畅，建议规范数据的返回，并采用固定的数据格式封装。 接口返回模板： 1234567&#123; status:0, data:&#123;&#125;||[], msg:’’&#125; status: 接口的执行的状态 =0表示成功 &lt;0 表示有异常=”” Data 接口的主数据 可以根据实际返回数组或JSON对象 Msg 信息 当status!=0 都应该有错误信息 9. 非Restful Api的需求由于实际业务开展过程中，可能会出现各种的api不是简单的restful 规范能实现的，因此，需要有一些api突破restful规范原则。特别是移动互联网的api设计，更需要有一些特定的api来优化数据请求的交互。 9.1 页面级的api把当前页面中需要用到的所有数据通过一个接口一次性返回全部数据 举例 api/v1/get-home-data 返回首页用到的所有数据 这类API有一个非常不好的地址，只要业务需求变动，这个api就需要跟着变更。 9.2 自定义组合api把当前用户需要在第一时间内容加载的多个接口合并成一个请求发送到服务端，服务端根据请求内容，一次性把所有数据合并返回,相比于页面级api，具备更高的灵活性，同时又能很容易的实现页面级的api功能。 规范 地址：api/v1/batApi 传入参数： 123456789data:[ &#123;url:&apos;api1&apos;,type:&apos;get&apos;,data:&#123;...&#125;&#125;, &#123;url:&apos;api2&apos;,type:&apos;get&apos;,data:&#123;...&#125;&#125;, &#123;url:&apos;api3&apos;,type:&apos;get&apos;,data:&#123;...&#125;&#125;, &#123;url:&apos;api4&apos;,type:&apos;get&apos;,data:&#123;...&#125;&#125;] 返回数据 12345678910111213&#123; status:0, msg:&apos;&apos;, data:[ &#123;status:0,msg:&apos;&apos;,data:[]&#125;, &#123;status:-1,msg:&apos;&apos;,data:&#123;&#125;&#125;, &#123;status:1,msg:&apos;&apos;,data:&#123;&#125;&#125;, &#123;status:0,msg:&apos;&apos;,data:[]&#125;, ]&#125; 10. Api共建平台RAP是一个GUI的WEB接口管理工具。在RAP中，您可定义接口的URL、请求&amp;响应细节格式等等。通过分析这些数据，RAP提供MOCK服务、测试服务等自动化工具。RAP同时提供大量企业级功能，帮助企业和团队高效的工作。 10.1 什么是RAP?在前后端分离的开发模式下，我们通常需要定义一份接口文档来规范接口的具体信息。如一个请求的地址、有几个参数、参数名称及类型含义等等。RAP 首先方便团队录入、查看和管理这些接口文档，并通过分析结构化的文档数据，重复利用并生成自测数据、提供自测控制台等等… 大幅度提升开发效率。 10.2 RAP的特色强大的GUI工具 给力的用户体验，你将会爱上使用RAP来管理您的API文档。 完善的MOCK服务 文档定义好的瞬间，所有接口已经准备就绪。有了MockJS，无论您的业务模型有多复杂，它都能很好的满足。 庞大的用户群 RAP在阿里巴巴有200多个大型项目在使用，也有许多著名的公司、开源人士在使用。RAP跟随这些业务的成行而成长，专注细节，把握质量，经得住考验。 免费 + 专业的技术支持 RAP是免费的，而且你的技术咨询都将在24小时内得到答复。大多数情况，在1小时内会得到答复。 RAP是一个可视化接口管理工具 通过分析接口结构，动态生成模拟数据，校验真实接口正确性， 围绕接口定义，通过一系列自动化工具提升我们的协作效率。我们的口号：提高效率，回家吃晚饭！ 11. RESTful接口规范URIURI规范 不用大写； 用中杠 - 不用下杠 _ ； 参数列表要encode； URI中的名词表示资源集合，使用复数形式。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词（特殊情况可以使用动词），而且所用的名词往往与数据库的表格名对应。 资源集合 vs单个资源 URI表示资源的两种方式：资源集合、单个资源。 资源集合： /zoos //所有动物园 /zoos/1/animals //id为1的动物园中的所有动物 单个资源： /zoos/1//id为1的动物园 /zoos/1;2;3//id为1，2，3的动物园 避免层级过深的URI 在url中表达层级，用于 按实体关联关系进行对象导航 ，一般根据id导航。 过深的导航容易导致url膨胀，不易维护，如 GET /zoos/1/areas/3/animals/4 ，尽量使用查询参数代替路径中的实体导航，如 GET/animals?zoo=1&amp;area=3 ； 版本应该将API的版本号放入到URI中 ​ https://api.example.com/v1/zoos RequestHTTP方法 通过标准HTTP方法对资源CRUD： GET：查询（从服务器取出资源一项或多项） GET /zoos GET /zoos/1 GET/zoos/1/employees POST：创建单个新资源。 POST一般向“资源集合”型uri发起 POST/animals //新增动物 POST/zoos/1/employees //为id为1的动物园雇佣员工 PUT：更新单个资源（全量），客户端提供完整的更新后的资源。与之对应的是 PATCH，PATCH负责部分更新，客户端提供要更新的那些字段。 PUT/PATCH一般向“单个资源”型uri发起 PUT/animals/1 PUT /zoos/1 DELETE：删除 DELETE/zoos/1/employees/2 DELETE/zoos/1/employees/2;4;5 DELETE/zoos/1/animals //删除id为1的动物园内的所有动物 HEAD / OPTION/ PATCH用的不多，就不多解释了。 HEAD：获取资源的元数据 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的 PATCH：在服务器更新资源（客户端提供改变的属性） 安全性和幂等性 安全性 ：不会改变资源状态，可以理解为只读的； 幂等性 ：执行1次和执行N次，对资源状态改变的效果是等价的。 . 安全性 幂等性 GET √ √ POST × × PUT × √ DELETE × √ 安全性和幂等性均不保证反复请求能拿到相同的response。以 DELETE为例，第一次DELETE返回200表示删除成功，第二次返回404提示资源不存在，这是允许的。 复杂查询 查询可以捎带以下参数： . 示例 备注 过滤条件 ?type=1&amp;age=16 允许一定的uri冗余，如 /zoos/1 与 /zoos?id=1 排序 ?sort=age&amp;order=asc 指定返回结果按照哪个属性排序，以及排序顺序 投影 ?whitelist=id,name,email 分页 ? page=2&amp;per_page=100 指定第几页，以及每页的记录数 Bookmarker 经常使用的、复杂的查询标签化，降低维护成本。 如：GET /trades?status=closed&amp;sort=created,desc 快捷方式：GET /trades#recently-closed或者GET /trades/recently-closed 状态码 服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 §200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 §201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 §202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） §204 NO CONTENT - [DELETE]：用户删除数据成功。 §400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 §401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 §403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 §404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 §406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 §410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 §422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 §500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 状态码的完全列表参见这里 URI失效 随着系统发展，总有一些API失效或者迁移，对失效的API，返回404 not found 或 410 gone；对迁移的API，返回 301重定向。 Response 不要包装： response的 body 直接就是数据，不要做多余的包装。错误示例： { “success”:true, “data”:{“id”:1,”name”:”xiaotuan”}, } 各HTTP方法成功处理后的数据格式： · response 格式 GET 单个对象、集合 POST 新增成功的对象 PUT/PATCH 更新成功的对象 DELETE 空 错误处理 不要发生了错误但给2xx响应，客户端可能会缓存成功的http请求； 正确设置http状态码，不要自定义； Response body提供 即:返回的信息中将error作为键名，出错信息作为键值即可 1)错误的代码（日志/问题追查）； 2)错误的描述文本（展示给用户）。 对第三点的实现稍微多说一点： Java服务器端一般用异常表示 RESTful API的错误。API 可能抛出两类异常：业务异常和非业务异常。 业务异常 由自己的业务代码抛出，表示一个用例的前置条件不满足、业务规则冲突等，比如参数校验不通过、权限校验失败。 非业务类异常 表示不在预期内的问题，通常由类库、框架抛出，或由于自己的代码逻辑错误导致，比如数据库连接失败、空指针异常、除0错误等等。 业务类异常必须提供2种信息： 如果抛出该类异常，HTTP响应状态码应该设成什么； 异常的文本描述； 在Controller层使用统一的异常拦截器： 设置 HTTP响应状态码：对业务类异常，用它指定的 HTTPcode；对非业务类异常，统一500； Response Body的错误码：异常类名 Response Body的错误描述：对业务类异常，用它指定的错误文本；对非业务类异常，线上可以统一文案如“服务器端错误，请稍后再试”，开发或测试环境中用异常的 stacktrace，服务器端提供该行为的开关。 常用的http状态码及使用场景： 状态码 使用场景 400 bad request 常用在参数校验 401 unauthorized 未经验证的用户，常见于未登录。如果经过验证后依然没权限，应该 403（即 authentication和 authorization的区别）。 403 forbidden 无权限 404 not found 资源不存在 500 internal server error 非业务类异常 503 service unavaliable 由容器抛出，自己的代码不要抛这个异常 其他（1）API的身份认证应该使用OAuth2.0框架 （2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML （3）比较复杂的接口不能确定是使用POST还是PUT时，要看具体的业务层代码，看看接口产生的结果是否幂等，如果幂等用PUT，相反用POST ​ 如：接口接收到一资源，资源存在更新，不存在插入新数据，这个接口就要用PUT]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cms开发资料]]></title>
    <url>%2Fblog%2F48599.html</url>
    <content type="text"><![CDATA[开发文档 1. 系统架构概述本系统核心架构为FreeMarker+hibernate+Spirng的mvc分层架构。 1.1分层架构模型 1.2数据流转模型(前端) 2.框架目录介绍2.1Cms包介绍 具体包名 相关功能描述 com\mi\cms 常量包 com\mi\cms\action 通用action抽象类包 com\mi\cms\action\directive cms自定义标签包,公用部分继承于abs包 com\mi\cms\action\directive\abs 公用部分自定义标签的抽象包 com\mi\cms\action\front 前台action包 com\mi\cms\action\member 会员中心包 com\mi\cms\api com\mi\cms\api\admin\assist Api辅助包 com\mi\cms\api\admin\main Api主要controller包 com\mi\cms\api\front API前端包 com\mi\cms\api\member Api会员中心包 com\mi\cms\dao\assist 辅助dao的接口层 com\mi\cms\dao\assist\impl 辅助dao的接口实现层 com\mi\cms\dao\main 核心的dao接口层 com\mi\cms\dao\main\impl 核心的dao接口实现层 com\mi\cms\entity\assist cms辅助实体类子类 com\mi\cms\entity\assist\base cms辅助实体类基类 com\mi\cms\entity\assist\hbm hibernate辅助实体类的关系映射文件 com\mi\cms\entity\back cms备份实体类子类 com\mi\cms\entity\back\base cms备份实体类基类 com\mi\cms\entity\back\hbm hibernate备份实体类类的关系映射文件 com\mi\cms\entity\main cms核心实体类子类 com\mi\cms\entity\main\base cms核心实体类基类 com\mi\cms\entity\main\hbm hibernate核心实体类的关系映射文件 com\mi\cms\lucene 搜索引擎封装包 com\mi\cms\manager\assist 辅助的service接口层 com\mi\cms\manager\assist\impl 辅助的service接口实现层 com\mi\cms\manager\main 核心的service接口层 com\mi\cms\manager\main\impl 核心的service接口实现层 com\mi\cms\service service封装层 com\mi\cms\staticpage 静态页的封装包包 com\mi\cms\staticpage\exception 静态页的异常处理类型 com\mi\cms\statistic 内容发布统计包 com\mi\cms\statistic\workload 流量统计包 com\mi\cms\web 拦截器包 com\mi\cms\task 任务包 com\mi\cms\task\job 具体任务包 2.2Common包介绍 具体包名 相关功能描述 com\mi\common\captcha 验证码封装包 com\mi\common\dic 分词 com\mi\common\email 邮件包 com\mi\common\fck fck编辑器封装包 com\mi\common\file 文件操作封装包 com\mi\common\hibernate4 hibeinate封装包 com\mi\common\image 图片的封装包 com\mi\common\ipseek ip地址库封装 com\mi\common\lucene 收索引擎的基础包 com\mi\common\office 文档转换相关工具类 com\mi\common\page jeecms分页封装包 com\mi\common\security 安全认证相关的包 com\mi\common\security\annotation com\mi\common\security\encoder com\mi\common\security\rememberme com\mi\common\security\userdetails com\mi\common\upload 上传封装包 com\mi\common\util 工具包 com\mi\common\web 常量包 com\mi\common\web\freemarker freemarker视图封装包 com\mi\common\web\session session包 com\mi\common\web\session\cache session缓存包 com\mi\common\web\springmvc springMVC的简单封装 com\mi\cms\manager\main 核心的service接口层 com\mi\cms\manager\main\impl 核心的service接口实现层 com\mi\cms\service service封装层 com\mi\cms\staticpage 静态页的封装包 com\mi\cms\staticpage\exception 静态页的异常处理类型 com\mi\cms\statistic 流量统计包 com\mi\cms\statistic\workload 内容发布统计包 com\mi\cms\web 拦截器包 2.3Core包介绍 具体包名 相关功能描述 com\mi\core 一般常量和异常处理 com\mi\core\action\front 核心前台的action com\mi\core\dao 核心dao的接口 com\mi\core\dao\impl 核心dao的接口实现类 com\mi\core\entity 登录认证和核心用户的实体子类 com\mi\core\entity\base 登录认证和核心用户的实体基类 com\mi\core\entity\hbm 相关的hibernate的映射文件 com\mi\core\manager 核心的service接口层 com\mi\core\manager\impl 核心的service接口实现层 com\mi\core\security 认证登录、退出相关 com\mi\core\tpl 模板接口和相关service层 com\mi\core\web 定义内容显示的接口，工具类，和错误页面的指定 com\mi\core\web\util uri帮助类 2.4页面资源介绍 具体包名 相关功能描述 WebContent r 前台资源文件，如css、img、js等 jeeadmin 后台页面和资源文件（由vue源码工程打包） thirdparty 第三方插件（ckeditor编辑器、swf上传、My97DatePicker日期选择） u 默认的用户上传资源目录 WebContent/WEB-INF cache 缓存文件 common 通用页面 config 核心的配置文件，如果action，service,manager,dao,bean等 plug为插件配置文件目录 directive 标签向导模板文件 error 错误页面 ftl 自定义的freemark宏文件 ispeek ip地址库 languages 国际化配置 jeecms/admin 后台 jeecms/front 前台 jeecms/tpl 模版 jeecore/admin 公用国际化 jeecms/adminapi API接口消息国际化 plug 插件国际化配置 lucene lucene文件夹 t/cms 前台模板页面 t/cms/www 站点资源目录 t/cms/www/default 站点方案 3. 开发流程指导3.1展现层3.1.1Freemarer介绍FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java 等。 3.1.2后台页面后台管理页面全部采用vue工程开发，参考 4.后台管理页面vue工程开发](#_4.后台管理页面vue工程开发) 3.1.3前台模版页面 在default目录相应的文件夹添加html，在html文件中引入freemark机制控制control层传输对象的显示。 3.2控制层3.2.1SpringMVC简介Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，通过策略接口，Spring 框架是高度可配置的，而且包含多种视图技术，例如 FreeMarker、JavaServer Pages（JSP）技术、Velocity、Tiles、iText和 POI。Spring MVC 框架并不知道使用的视图，所以不会强迫您只使用 JSP 技术。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 3.2.2控制层实现3.2.2.1配置SpringMVC支持Web.xml配置Spring后台核心调度器 1234567891011121314151617181920212223242526272829&lt;servlet&gt; &lt;servlet-name&gt;JeeCmsAdminApi&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;dispatchOptionsRequest&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/config/jeecms-servlet-admin-api.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; &lt;/servlet&gt; Web.xml配置Spring后台核心调度器匹配路径 1234567&lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsAdminApi&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/admin/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Web.xml配置Spring前台核心调度器 1234567891011121314151617181920212223&lt;servlet&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/config/jeecms-servlet-front.xml /WEB-INF/config/plug/*/-servlet-front-action.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; Web.xml配置Spring前台核心调度器匹配路径 12345678910111213141516171819202122232425262728293031&lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3.2.2.2Spring Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103com.mi.cms.api.admin.main核心管理模块Controllercom.mi.cms.api.admin.assist辅助管理模块Controller@Controllerpublic class CmsLogApiAct &#123; @RequestMapping("/log/operating_list") publicvoid list(String queryUsername, String queryTitle,Integer category, StringqueryIp, Integer pageNo, Integer pageSize,HttpServletRequest request, HttpServletResponseresponse)&#123; Stringbody = "\"\""; Stringmessage = Constants.API_MESSAGE_SUCCESS; Stringcode = ResponseCode.API_CODE_CALL_SUCCESS; if(pageNo==null) &#123; pageNo=1; &#125; if(pageSize==null) &#123; pageSize=10; &#125; if(category==null) &#123; category=CmsLog.OPERATING; &#125; Paginationpage =null; CmsSitesite = CmsUtils.getSite(request); WebErrorserrors = WebErrors.create(request); if(category.equals(CmsLog.OPERATING)) &#123; page= manager.getPage(CmsLog.OPERATING, site.getId(),queryUsername, queryTitle,queryIp, pageNo, pageSize); &#125;elseif (category.equals(CmsLog.LOGIN_SUCCESS)) &#123; page= manager.getPage(CmsLog.LOGIN_SUCCESS, null,queryUsername, queryTitle,queryIp, pageNo, pageSize); &#125;elseif (category.equals(CmsLog.LOGIN_FAILURE)) &#123; page= manager.getPage(CmsLog.LOGIN_FAILURE, null,null, queryTitle, queryIp, pageNo,pageSize); &#125;else&#123; errors.addErrorString(Constants.API_MESSAGE_PARAM_ERROR); &#125; if(errors.hasErrors()) &#123; message= errors.getErrors().get(0); code= ResponseCode.API_CODE_PARAM_ERROR; &#125;else&#123; inttotalCount = page.getTotalCount(); List&lt;CmsLog&gt;list = (List&lt;CmsLog&gt;) page.getList(); JSONArrayjsonArray = new JSONArray(); if(list!=null&amp;&amp;list.size()&gt;0) &#123; for(int i = 0; i &lt; list.size(); i++) &#123; jsonArray.put(i,list.get(i).convertToJson()); &#125; &#125; body= jsonArray.toString()+",\"totalCount\":"+totalCount; &#125; ApiResponseapiResponse = new ApiResponse(request, body, message, code); ResponseUtils.renderApiJson(response,request, apiResponse); &#125; //自动装配对象 @Autowired privateCmsLogMng manager;&#125;//统一返回JSON对象ApiResponse apiResponse = newApiResponse(request, body, message, code);ResponseUtils.renderApiJson(response,request, apiResponse); 另外一个例子 //需要签名认证（建议保存、修改、删除类方法添加签名注解） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@SignValidate@RequestMapping("/group/save")public void save(CmsGroup bean,StringviewChannelIds,String contriChannelIds, HttpServletRequestrequest,HttpServletResponse response)&#123; Stringbody = "\"\""; Stringmessage = Constants.API_MESSAGE_PARAM_REQUIRED; Stringcode = ResponseCode.API_CODE_PARAM_REQUIRED; WebErrorserrors = WebErrors.create(request); //通用认证必填参数 errors= ApiValidate.validateRequiredParams(request, errors, bean.getName(),bean.getPriority(), bean.getAllowMaxFile(),bean.getAllowPerDay(),bean.getAllowFileSize(),bean.getAllowFileTotal()); if(!errors.hasErrors()) &#123; Integer[]viewChannel = StrUtils.getInts(viewChannelIds); Integer[]contriChannel = StrUtils.getInts(contriChannelIds); errors= validateArrayLength(errors, viewChannel, contriChannel); if(errors.hasErrors()) &#123; message= errors.getErrors().get(0); code= ResponseCode.API_CODE_PARAM_ERROR; &#125;else&#123; bean.init(); bean= manager.save(bean, viewChannel, contriChannel); log.info("saveCmsGroup id=&#123;&#125;", bean.getId()); cmsLogMng.operating(request,"cmsGroup.log.save", "id=" + bean.getId() +";name=" + bean.getName()); body="&#123;\"id\":"+"\""+bean.getId()+"\"&#125;"; message =Constants.API_MESSAGE_SUCCESS; code= ResponseCode.API_CODE_CALL_SUCCESS; &#125; &#125; ApiResponseapiResponse = new ApiResponse(request, body, message, code); ResponseUtils.renderApiJson(response,request, apiResponse); &#125; 3.2.2.3SpringMVC扩展配置jeecms-servlet-admin-api.xml后台Spring国际化、拦截器、SpringMVC视图解析器配置 jeecms-servlet-front.xml前台Spring国际化、拦截器、SpringMVC视图解析器配置 jeecms-servlet-admin-api-action.xml 后台action配置文件 jeecms-servlet-front-action.xml前台action配置文件 配置action bean 1&lt;bean id="ftpApiAct"class="com.mi.cms.api.admin.main.FtpApiAct"&gt;&lt;/bean&gt; 3.3逻辑层3.3.1类存放包介绍com.mi.cms.manager.main.impl核心service层 com.mi.cms.manager.assist.impl 辅助service层 com.mi.cms.service 采集、栏目、内容、流量公用service包 3.3.2service类代码编写样例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Service@Transactionalpublic class CmsConfigMngImplimplements CmsConfigMng &#123; @Transactional(readOnly= true) publicCmsConfig get() &#123; CmsConfigentity = dao.findById(1); returnentity; &#125; publicvoid updateCountCopyTime(Date d) &#123; dao.findById(1).setCountCopyTime(d); &#125; publicvoid updateCountClearTime(Date d) &#123; dao.findById(1).setCountClearTime(d); &#125; publicCmsConfig update(CmsConfig bean) &#123; Updater&lt;CmsConfig&gt;updater = new Updater&lt;CmsConfig&gt;(bean); CmsConfigentity = dao.updateByUpdater(updater); entity.blankToNull(); returnentity; &#125; publicMarkConfig updateMarkConfig(MarkConfig mark) &#123; get().setMarkConfig(mark); returnmark; &#125; publicvoid updateMemberConfig(MemberConfig memberConfig) &#123; get().getAttr().putAll(memberConfig.getAttr()); &#125; privateCmsConfigDao dao; //自动装配dao层 @Autowired publicvoid setDao(CmsConfigDao dao) &#123; this.dao= dao; &#125;&#125; 需要@Service@Transactional 注解标志该类为业务逻辑层，所有的service层均采用接口开发模式 @Transactional(readOnly = true)只读事物 3.3.3配置service beanjeecms-context.xml中增加servicebean的配置 1&lt;bean id="cmsConfigMng"class="com.mi.cms.manager.main.impl.CmsConfigMngImpl"/&gt; 3.4持久层3.4.1Hibernate4简介Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操作数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用 3.4.2DAO类代码编写样例持久层采用Hibernate4，缓存采用Ehcache com.mi.cms.dao.main.impl 核心DAO层 com.mi.cms.dao.assist.impl 辅助DAO层 12345678910111213141516171819202122@Repositorypublic class CmsConfigDaoImplextends HibernateBaseDao&lt;CmsConfig, Integer&gt; implementsCmsConfigDao &#123; publicCmsConfig findById(Integer id) &#123; CmsConfigentity = get(id); returnentity; &#125; //重写getEntityClass方法 @Override protectedClass&lt;CmsConfig&gt; getEntityClass() &#123; returnCmsConfig.class; &#125;&#125; @Repository注解标志该类是DAO层组件，可以选择继承HibernateBaseDao基础类，需要实现接口。 3.4.3配置DAO beanjeecms-context.xml中增加dao bean的配置 1&lt;beanid="cmsConfigDao"class="com.mi.cms.dao.main.impl.CmsConfigDaoImpl"/&gt; 3.4.4POJOcom.mi.cms.entity.main核心功能包的pojo com.mi.cms.entity.main.base 辅助功能包的pojo基础类 com.mi.cms.entity.main.hbm 辅助功能包Hibernate实体映射文件 com.mi.cms.entity.assist辅助功能包的pojo com.mi.cms.entity.assist.base辅助功能包的pojo基础类 com.mi.cms.entity.assist.hbm辅助功能包Hibernate实体映射文件 3.5自定义标签3.5.1定义标签类​ 自定义标签类所属包com.mi.cms.action.directive ​ 标签类需要实现Freemarker内置接口TemplateDirectiveModel ​ 获取标签参数可以用DirectiveUtils工具类获取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public classChannelDirective implements TemplateDirectiveModel &#123; /** * 输入参数，栏目ID。 */ publicstatic final String PARAM_ID = "id"; /** * 输入参数，栏目路径。 */ public static final String PARAM_PATH ="path"; /** * 输入参数，站点ID。存在时，获取该站点栏目，不存在时获取当前站点栏目。 */ publicstatic final String PARAM_SITE_ID = "siteId"; @SuppressWarnings("unchecked") publicvoid execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBodybody) throws TemplateException, IOException &#123; CmsSitesite = FrontUtils.getSite(env); //getrequired params from directive Integerid = DirectiveUtils.getInt(PARAM_ID, params); Channelchannel; if(id != null) &#123; channel= channelMng.findById(id); &#125;else &#123; Stringpath = DirectiveUtils.getString(PARAM_PATH, params); if(StringUtils.isBlank(path)) &#123; //如果path不存在，那么id必须存在。 thrownew ParamsRequiredException(PARAM_ID); &#125; IntegersiteId = DirectiveUtils.getInt(PARAM_SITE_ID, params); if(siteId == null) &#123; siteId= site.getId(); &#125; channel= channelMng.findByPathForTag(path, siteId); &#125; Map&lt;String,TemplateModel&gt; paramWrap = new HashMap&lt;String, TemplateModel&gt;( params); //putresult to view paramWrap.put(OUT_BEAN,DEFAULT_WRAPPER.wrap(channel)); Map&lt;String,TemplateModel&gt; origMap = DirectiveUtils .addParamsToVariable(env,paramWrap); //render result to response body.render(env.getOut()); DirectiveUtils.removeParamsFromVariable(env,paramWrap, origMap); &#125; //装配所需service @Autowired privateChannelMng channelMng;&#125; 3.5.2配置标签1.jeecms-context.xml配置Spring bean 1&lt;bean id="cms_content_list"class="com.mi.cms.action.directive.ContentListDirective"/&gt; 2.jeecms-context 文件中jeecms.properties文件中引入自定义标签bean directive.cms_channel_list=cms_channel_list 3.5.3标签应用123456789[@cms_content_list count='9'titLen='15' orderBy='8' channelOption='1' channelId='1'] [#list tag_list as a] &lt;li&gt;&lt;ahref="$&#123;a.url&#125;" title="$&#123;a.title&#125;"target="_blank"&gt;[@text_cut s=a.title len=titLenappend=append/]&lt;/a&gt;&lt;/li&gt; [/#list] [/@cms_content_list] cms_content_list标签名称count、titLen、orderBy、channelOption、channelId标签参数 tag_list标签结果 a循环变量 ${a.url}输出a对象的url属性 4.后台管理页面vue工程开发4.1环境准备Vue简介 Vue.js提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目： 推荐查阅官方文档https://cn.vuejs.org/v2/guide/installation.html 1、安装必要环境Node.js 下载地址 http://nodejs.cn/. 安装最新版本Npm（最新版node自带） 2、开发环境安装和启动 使用命令行执行以下命令 执行安装node包 cd 项目路径（vue工程路径） npminstall （推荐使用cnpm install，http://npm.taobao.org/ 加快依赖下载速度） npmrun dev; 4.2工程包介绍目录结构： 一级目录说明： build webpack打包配置文件 config 全局配置文件api域名 appid配置 node_modules:node依赖文件夹 src项目源代码 static 全局资源文件夹（css images js） index.html 入口文件 二级目录说明: \1. config／dev.env.js 开发环境配置文件，修改源代码时会读取此文件中的配置项 config／prod.env.js 生产环境配置文件，打包完成时会读取使用此文件中的配置项 以上图（config／dev.env.js）为例，定义了6个属性 NODE_ENV :标识当前环境 （当前环境为开发者环境） BaseUrl：项目的api资源 地址 Appid：项目的appid aesKey：项目的aesKey (加密用) ivKey：项目的ivKey (加密用) appKey：项目的appKey (加密用) 配置好相应的属性 即可在任意js文件中使用该变量，调用方式为 process.env.xxx process.env.baseUrl 2. src/api api以及全局拦截器 src/assets 源码中的资源文件（JS,CSS,iamges） src/components 自定义组件目录 src/directive 自定义指令目录 src/mixins 自定义混合目录 src/plugs 第三方插件目录（jquery相关的插件可存放在此） src/router 路由，角色目录 src/store vuex 定义目录 src/untils 全局方法，签名，加密函数存放目录 src/views 功能页面目录 src/APP.vue 根组件（无需修改） src/config.js 项目路径配置文件 src/main.js 页面入口文件 src/permissions.js 全局路由钩子配置文件 4.3新增功能模块讲解4.3.1新增页面后台管理页面采用单页组件化开发 功能模块统一存放在src／views目录下，推荐以导航树层级管理页面，例如下图 1功能某块统一以单文件组件的形式构造，命名以.vue结尾，单文件组件开发详情查看https://cn.vuejs.org/v2/guide/single-file-components.html 2.页面基础样式框架基于element-ui2.x版本 3.页面详解： 此处以用户列表功能为事例说明 用户功能列表路径为src/views/userMange/list.vue 4.3.2数据交互后台数据交互采用axios,更多 https://www.npmjs.com/package/axios（推荐） https://www.kancloud.cn/yunye/axios/234845（汉化文档） 1.创建数据请求方法 (请求方法统一存放在src/api.js文件下) 2.将所有的接口地址统一存放在src/api.js下如图 如图：api.js 定义了一个setAdminApi函数 用于拼接重复的api地址 api文档中以/api/admin/为路径的则可使用该函数 ，否则直接填写完整路径 例如 bsaeUpload:’/api/member/upload/o_upload’,//普通文件上传 3．数据请求示例 1.普通未封装请求接口示例 在页面的&lt;script&gt;下引用 axios ![img](http://ovi3ob9p4.bkt.clouddn.com/cms/cms026.png) 然后在需要的方法中调用axios请求 此处以created方法中调用为示例 （具体功能，请根据自身情况修改使用） 12345678910111213axios.post(this.$api.memberList,this.params) .then(res=&gt;&#123;~! //此处为请求成功的回调 &#125;) .catch(error=&gt;&#123; //此处为请求失败的回调 &#125;) 说明：axios.post()方法可以发送一个post 请求，其他请求类型有 get ，put ，delete等，具体参考axios文档 this.$api.memberList 此参数为api地址 在页面中使用 this.​$api.XXX 即可调用src/api中的 地址变量 此方法为获取所有用户列表信息，传递了一个参数对象params: {//只需要业务参数 ​ 12345678910111213queryUsername: "", queryEmail: "", queryGroupId: "", queryStatus: "", pageNo: "", pageSize: "" &#125; 在成功的回调函数中，可以将列表数据赋值给自定义的一个变量，在页面中调用该变量即可， 2 列表封装接口示例 本系统封装了一个list和一个form 混合 此类文件的作用为 将一些公用的方法和变量插入页面组件中，在页面则可直接使用该变量以及方法 以src/views/userMange/list.vue为例 在页面&lt;script&gt;&lt;/script&gt;中引入mixins 此处引入了 list.js 此文件预先定义了基础列表所需要的变量以及方法，简单的列表查询及操作，可直接使用该混合文件，具体变量及方法，查看文件内注释 在页面中的created方法中 调用了 created(){ this.initTableData(this.$api.memberList,this.params); } 该方法为混合方法，作用为初始化列表信息，第一个参数传递的为api接口地址，第二个参数为自定义参数对象，调用该函数后会自动初始化列表以及赋值，在页面上直接使用tableData属性即可 数据加密方法介绍 如业务参数需要加密，则需要在页面组件中引用src/untils/aes.js 调用示例： 1234567import &#123; Encrypt &#125; from &quot;../untils/aes&quot;; let aesKey = this.$store.state.aesKey letivKey = this.$store.state.ivKey; letaesPassword = Encrypt(this.params.pwd, aesKey, ivKey); 4.3.3将组件添加至路由表页面编写完成后需要将组件注册到路由中 关于路由采用的是vue-router，更多详细：https://router.vuejs.org/zh-cn/index.html 路由表文件为src/router/routes.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; path:'/', name:'用户管理', //用户管理 component: body, iconCls: 'icon-user', meta:&#123; isLink: true &#125;, children: [&#123; path:'/user', name:'会员管理', //会员管理 component: childView, isParent: true, redirect: '/user/list', children: [&#123; path: '/user/list', //会员列表 name: '会员列表', component:resolve =&gt; &#123; require(['@/views/user/userMange/list.vue'], resolve) &#125;, &#125;, &#123; path: '/user/save', //会员添加 name: '会员添加', component:resolve =&gt; &#123; require(['@/views/user/userMange/add.vue'], resolve) &#125;, hidden: true &#125;, &#123; path: '/user/update', //会员添加 name: '会员修改', component:resolve =&gt; &#123; require(['@/views/user/userMange/edit.vue'], resolve) &#125;, hidden: true &#125; ] &#125;, &#123; path：访问地址（唯一不可重复） meta：{role:’xxxx’}角色权限名,不可重复，而且不同板块前缀要不同，比如用户模块叫user 另外会员管理叫userMember 这样是不行的 name:’路由名称’, 【也就是菜单名】 component: component:resolve =&gt; { require([&#39;@/views/user/userMange/list.vue&#39;], resolve) }, 懒加载页面组件，在点击该功能时才加载文件 children:子路由 4.3.4权限控制权限文件为src/routers/roles.js 角色权限编是一个按照路由层级来构造的json对象（自定义添加时，也保持同样的规则） 以用户列表角色为例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; name:'用户管理', role:'userlist', api:[ '/api/admin/user/list', '/api/admin/user/get' ], children: [&#123; name:'添加', role:'useradd', api:[ '/api/admin/user/save' ], &#125;, &#123; name:'修改', role:'useredit', api:['/api/admin/user/update'], &#125;, &#123; name:'删除', role:'userdelete', api:[ '/api/admin/user/delete' ], &#125;, ] name：角色权限名称（角色管理中树状结构的名字） role：页面显示权限（就是路由表中的meta：{role:’xxxx’}） api：页面组件所拥有的调用后台api的地址 4.3.5 组件使用vue是一个组件化开发的js 一切皆为组件 在本系统中页面基础组件采用了element2.0组件库 (页面中以el-xxxx开头) 自定义组件为自行封装（页面中以cms-xxxx开头） 自定义组件存放在 开发中，一些公用的功能可以封装为自定义组件 此处以cms-input组件为例 组件页面与功能页面结构完全相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt; template&gt; &lt;divclass="cms-inline-input"&gt; &lt;labelfor=""class="cms-inline-label"&gt;&#123;&#123;label&#125;&#125;:&lt;/label&gt; &lt;el-input :value="currentValue"@input="handleInput" :style="&#123;width:width+'px'&#125;" &gt;&lt;/el-input&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;exportdefault &#123; name:'cms-input', props:&#123; value:'', label:&#123; type:String, default:'label' &#125;, width:&#123; type:Number, default:160 &#125; &#125;, data()&#123; return&#123; currentValue:this.value &#125; &#125;, methods:&#123; handleInput(value)&#123; this.$emit('input',value);//触发input 事件，并传入新值 &#125; &#125;&#125;&lt;/script&gt; &lt;stylescoped lang="scss"&gt; .cms-inline-input&#123; display:inline-block; position:relative; margin-left:12px; &#125; .cms-inline-label&#123; font-size:14px; color:#5a5e66; &#125;&lt;/style&gt; 此处封装了一个标签和输入框，对外props 暴露了3个属性 value label width 在页面上使用方法为 &lt;cms-inputlabel=’标签名’ width=’120’ v-model=’xxx’&gt;&lt;/cms-input&gt; 通过this.$emit(&#39;input&#39;,value);//触发input 事件，并传入新值 向使用者传递返回值 4.4 后台页面发布后台源码的开发文件不可直接运行在浏览器中，需要通过命令打包将源码生成为静态文件 1.使用命令行工具进入 工程目录 项目工程中如果没有node_modules文件夹，则执行 npminstall （推荐使用cnpm install，http://npm.taobao.org/ 加快依赖下载速度） 如果有则忽略此步骤 3.执行命令npm run build 出现building for production 则成功执行，等待命令完成完成后会出现下图 出现上图，说明打包编译完成，在项目中会有一个dist文件夹 dist文件夹中有两个文件 4、将index.html改名为index.do后，将index.do和static文件夹放到ROOT下的/jeeadmin/jeecms文件夹下，eclipse下放到/WebContent/jeeadmin/jeecms下 4.5修改后台地址1.带部署路径和端口的此类情况无须修改，如下 http://xxx.jeecms.com/jeeadmin/jeecms/index.do http://xxx.jeecms.com/project/jeeadmin/jeecms/index.do \2. 需要调整后台路径此类情况须要修改 http://xxx.jeecms.com/admin/jeecms/index.do http://xxx.jeecms.com/project/admin/jeecms/index.do 此处修改源码工程中的src/config.js 将jeeadmin文件夹重命名为admin即可]]></content>
      <categories>
        <category>cms</category>
      </categories>
      <tags>
        <tag>cms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据交互axios的使用]]></title>
    <url>%2Fblog%2F12277.html</url>
    <content type="text"><![CDATA[Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 ##Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 Features 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 ** ** ** ** ** ** Latest ✔ Latest ✔ Latest ✔ Latest ✔ Latest ✔ 8+ ✔ 安装使用 npm: 1$ npm install axios 使用 bower: 1$ bower install axios 使用 cdn: 1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; Example执行 GET 请求 123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行 POST 请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); axios API可以通过向 axios 传递相关配置来创建请求 axios(config)123456789// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); axios(url[, config])12// 发送 GET 请求（默认的方法）axios('/user/12345'); 请求方法的别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])NOTE在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发处理并发请求的助手函数 axios.all(iterable)axios.spread(callback)创建实例可以使用自定义配置新建一个 axios 实例 axios.create([config])12345var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应结构某个请求的响应包含以下信息 12345678910111213141516&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 服务器响应的头 headers: &#123;&#125;, // `config` 是为请求提供的配置信息 config: &#123;&#125;&#125; 使用 then 时，你将接收下面这样的响应： 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 配置的默认值/defaults你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567// 创建实例时设置配置的默认值var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 拦截器在请求或响应被 then 或 catch 处理前拦截它们。 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如果你想在稍后移除拦截器，可以这样： 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理12345678910111213axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else &#123; // Something happened in setting up the request that triggered an Error console.log('Error', error.message); &#125; console.log(error.config); &#125;); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 状态码在大于或等于500时才会 reject &#125;&#125;) 取消使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： 123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： 123456789101112var CancelToken = axios.CancelToken;var cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); Note : 可以使用同一个 cancel token 取消多个请求 SemverUntil axios reaches a 1.0 release, breaking changes will be released with a new minor version. For example 0.5.1, and 0.5.4 will have the same API, but 0.6.0 will have breaking changes. Promisesaxios 依赖原生的 ES6 Promise 实现而被支持.如果你的环境不支持 ES6 Promise，你可以使用 polyfill. TypeScriptaxios includes TypeScript definitions. 12import axios from &apos;axios&apos;;axios.get(&apos;/user?ID=12345&apos;); Resources Changelog Upgrade Guide Ecosystem Contributing Guide Code of Conduct Creditsaxios is heavily inspired by the $http service provided in Angular. Ultimately axios is an effort to provide a standalone $http-like service for use outside of Angular. 升级指南Upgrade Guide0.13.x -&gt; 0.14.0TypeScript DefinitionsThe axios TypeScript definitions have been updated to match the axios API and use the ES2015 module syntax. Please use the following import statement to import axios in TypeScript: 12345import axios from 'axios';axios.get('/foo') .then(response =&gt; console.log(response)) .catch(error =&gt; console.log(error)); agent Config OptionThe agent config option has been replaced with two new options: httpAgent and httpsAgent. Please use them instead. 123456&#123; // Define a custom agent for HTTP httpAgent: new http.Agent(&#123; keepAlive: true &#125;), // Define a custom agent for HTTPS httpsAgent: new https.Agent(&#123; keepAlive: true &#125;)&#125; progress Config OptionThe progress config option has been replaced with the onUploadProgress and onDownloadProgress options. 1234567891011&#123; // Define a handler for upload progress events onUploadProgress: function (progressEvent) &#123; // ... &#125;, // Define a handler for download progress events onDownloadProgress: function (progressEvent) &#123; // ... &#125;&#125; 0.12.x -&gt; 0.13.0The 0.13.0 release contains several changes to custom adapters and error handling. Error HandlingPrevious to this release an error could either be a server response with bad status code or an actual Error. With this release Promise will always reject with an Error. In the case that a response was received, the Error will also include the response. 1234567axios.get('/user/12345') .catch((error) =&gt; &#123; console.log(error.message); console.log(error.code); // Not always specified console.log(error.config); // The config that was used to make the request console.log(error.response); // Only available if response was received from the server &#125;); Request AdaptersThis release changes a few things about how request adapters work. Please take note if you are using your own custom adapter. Response transformer is now called outside of adapter. Request adapter returns a Promise. This means that you no longer need to invoke transformData on response data. You will also no longer receive resolve and reject as arguments in your adapter. Previous code: 12345678910111213function myAdapter(resolve, reject, config) &#123; var response = &#123; data: transformData( responseData, responseHeaders, config.transformResponse ), status: request.status, statusText: request.statusText, headers: responseHeaders &#125;; settle(resolve, reject, response);&#125; New code: 1234567891011function myAdapter(config) &#123; return new Promise(function (resolve, reject) &#123; var response = &#123; data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders &#125;; settle(resolve, reject, response); &#125;);&#125; See the related commits for more details: Response transformers Request adapter Promise 0.5.x -&gt; 0.6.0The 0.6.0 release contains mostly bug fixes, but there are a couple things to be aware of when upgrading. ES6 Promise PolyfillUp until the 0.6.0 release ES6 Promise was being polyfilled using es6-promise. With this release, the polyfill has been removed, and you will need to supply it yourself if your environment needs it. 12require(&apos;es6-promise&apos;).polyfill();var axios = require(&apos;axios&apos;); This will polyfill the global environment, and only needs to be done once. axios.success/axios.errorThe success, and error aliases were deprectated in 0.4.0. As of this release they have been removed entirely. Instead please use axios.then, and axios.catch respectively. 1234567axios.get('some/url') .then(function (res) &#123; /* ... */ &#125;) .catch(function (err) &#123; /* ... */ &#125;); UMDPrevious versions of axios shipped with an AMD, CommonJS, and Global build. This has all been rolled into a single UMD build. 1234567// AMDrequire([&apos;bower_components/axios/dist/axios&apos;], function (axios) &#123; /* ... */&#125;);// CommonJSvar axios = require(&apos;axios/dist/axios&apos;); 生态系统EcosystemThis is a list of axios related libraries and resources. If you have a suggestion on what to add, please don’t hesitate to submit a PR. Libraries moxios - Mock axios requests for testing axios-response-logger - Axios interceptor which logs responses axios-mock-adapter — Axios adapter that allows to easily mock requests redux-axios-middleware - Redux middleware for fetching data with axios HTTP client axios-vcr - Record and Replay Axios requests @3846masa/axios-cookiejar-support - Add tough-cookie support to axios vue-axios - A small wrapper for integrating axios to Vuejs]]></content>
      <categories>
        <category>nodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli本地环境API代理设置和解决跨域]]></title>
    <url>%2Fblog%2F48205.html</url>
    <content type="text"><![CDATA[前言我们在使用vue-cli启动项目的时候npm run dev便可以启动我们的项目了，通常我们的请求地址是以localhost:8080来请求接口数据的，localhost是没有办法设置cookie的。 我们可以在vue-cli配置文件里面设置一个代理，跨域的方法有很多，通常需要后台来进行配置。我们可以直接通过node.js代理服务器来实现跨域请求。 vue proxyTable接口跨域请求调试在vue-cli项目中的config文件夹下的index.js配置文件中，dev长这样子： 123456789dev: &#123; env: require(&apos;./dev.env&apos;), port: 8080, autoOpenBrowser: true, assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, proxyTable: &#123;&#125;, cssSourceMap: false &#125; 服务器提供的接口如果长这样https://www.exaple.com/server_new/login，我们把域名提取出来如https://www.exaple.com； 在config中新建一个文件命名为proxyConfig.js: 1234567891011module.exports = &#123; proxy: &#123; &apos;/apis&apos;: &#123; //将www.exaple.com印射为/apis target: &apos;https://www.exaple.com&apos;, // 接口域名 changeOrigin: true, //是否跨域 pathRewrite: &#123; &apos;^/apis&apos;: &apos;&apos; //需要rewrite的, &#125; &#125; &#125;&#125; config文件夹下的index.js引入proxyConfig.js： 1var proxyConfig = require(&apos;./proxyConfig&apos;) config文件夹下的index.js中的dev改成: 123456789dev: &#123; env: require(&apos;./dev.env&apos;), port: 8080, autoOpenBrowser: true, assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, proxyTable: proxyConfig.proxy, cssSourceMap: false &#125; 重启项目npm run dev： 你会发现出现了这个 这个时候我们已经设置好了本地API代理了 修改本地hosts文件文件路径一般是C:\Window\System32\drivers\etc，打开hosts文件，在这一段下面把localhost设置进去 1234567891011# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost127.0.0.1 activate.adobe.com127.0.0.1 practivate.adobe.com127.0.0.1 lmlicenses.wip4.adobe.com127.0.0.1 lm.licenses.adobe.com127.0.0.1 na1r.services.adobe.com127.0.0.1 hlrcv.stage.adobe.comlocalhost www.exaple.com 搞定此时我们已经完全解决了跨域问题，以及本地测试后台无法向我们本地环境设置cookie的情况了。]]></content>
      <categories>
        <category>vueJs</category>
      </categories>
      <tags>
        <tag>vueJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指office题解]]></title>
    <url>%2Fblog%2F5502.html</url>
    <content type="text"><![CDATA[Java面试笔记 第二章 面试需要的基础知识2. 实现 Singleton 单例模式 3. 数组中重复的数字题目描述 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。 解题思路 这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素放到第 i 个位置上。 12345678910111213141516171819public boolean duplicate(int[] numbers, int length, int[] duplication) &#123; if(numbers == null || length &lt;= 0) return false; for (int i = 0; i &lt; length; i++) &#123; while (numbers[i] != i &amp;&amp; numbers[i] != numbers[numbers[i]]) &#123; swap(numbers, i, numbers[i]); &#125; if (numbers[i] != i &amp;&amp; numbers[i] == numbers[numbers[i]]) &#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false;&#125;private void swap(int[] numbers, int i, int j) &#123; int t = numbers[i]; numbers[i] = numbers[j]; numbers[j] = t;&#125; 4. 二维数组中的查找题目描述 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路 从右上角开始查找。因为矩阵中的一个数，它左边的数都比它来的小，下边的数都比它来的大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来改变行和列的下标，从而缩小查找区间。 1234567891011public boolean Find(int target, int [][] array) &#123; if (array == null || array.length == 0 || array[0].length == 0) return false; int m = array.length, n = array[0].length; int row = 0, col = n - 1; while (row &lt; m &amp;&amp; col &gt;= 0) &#123; if (target == array[row][col]) return true; else if (target &lt; array[row][col]) col--; else row++; &#125; return false;&#125; 5. 替换空格题目描述 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy. 则经过替换之后的字符串为 We%20Are%20Happy。 题目要求 以 O(1) 的空间复杂度和 O(n) 的空间复杂度来求解。 解题思路 从后向前改变字符串。 1234567891011121314151617181920public String replaceSpace(StringBuffer str) &#123; int n = str.length(); for (int i = 0; i &lt; n; i++) &#123; if (str.charAt(i) == ' ') str.append(" "); // 尾部填充两个 &#125; int idxOfOriginal = n - 1; int idxOfNew = str.length() - 1; while (idxOfOriginal &gt;= 0 &amp;&amp; idxOfNew &gt; idxOfOriginal) &#123; if (str.charAt(idxOfOriginal) == ' ') &#123; str.setCharAt(idxOfNew--, '0'); str.setCharAt(idxOfNew--, '2'); str.setCharAt(idxOfNew--, '%'); &#125; else &#123; str.setCharAt(idxOfNew--, str.charAt(idxOfOriginal)); &#125; idxOfOriginal--; &#125; return str.toString();&#125; 6. 从尾到头打印链表正向遍历然后调用 Collections.reverse()。 123456789public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); while (listNode != null) &#123; ret.add(listNode.val); listNode = listNode.next; &#125; Collections.reverse(ret); return ret;&#125; 使用 Stack 123456789101112public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.add(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; ret.add(stack.pop()); &#125; return ret;&#125; 递归 12345678public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(listNode != null) &#123; ret.addAll(printListFromTailToHead(listNode.next)); ret.add(listNode.val); &#125; return ret;&#125; 不使用库函数，并且不使用递归的迭代实现，利用链表的头插法为逆序的特性。 1234567891011121314151617public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ListNode head = new ListNode(-1); // 头结点 ListNode cur = listNode; while (cur != null) &#123; ListNode next = cur.next; cur.next = head.next; head.next = cur; cur = next; &#125; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); head = head.next; while (head != null) &#123; ret.add(head.val); head = head.next; &#125; return ret;&#125; 7. 重建二叉树题目描述 根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。 123456789101112131415public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; return reConstructBinaryTree(pre, 0, pre.length - 1, in, 0, in.length - 1);&#125;private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int[] in, int inL, int inR) &#123; if (preL == preR) return new TreeNode(pre[preL]); if (preL &gt; preR || inL &gt; inR) return null; TreeNode root = new TreeNode(pre[preL]); int midIdx = inL; while (midIdx &lt;= inR &amp;&amp; in[midIdx] != root.val) midIdx++; int leftTreeSize = midIdx - inL; root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeSize, in, inL, inL + leftTreeSize - 1); root.right = reConstructBinaryTree(pre, preL + leftTreeSize + 1, preR, in, inL + leftTreeSize + 1, inR); return root;&#125; 8. 二叉树的下一个结点题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路 如果一个节点有右子树不为空，那么该节点的下一个节点是右子树的最左节点； 否则，向上找第一个左链接指向的树包含该节点的祖先节点。 12345678910111213141516public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) return null; if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) pNode = pNode.left; return pNode; &#125; else &#123; TreeLinkNode parent = pNode.next; while (parent != null) &#123; if (parent.left == pNode) return parent; pNode = pNode.next; parent = pNode.next; &#125; &#125; return null;&#125; 9. 用两个栈实现队列解题思路 添加到栈中的序列顺序会被反转，如果进行两次反转，那么得到的序列依然是正向的。因此，添加的数据需要同时压入两个栈之后才能出栈，这样就能保证出栈的顺序为先进先出。 123456789101112131415Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();public void push(int node) &#123; stack1.push(node);&#125;public int pop() &#123; if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop();&#125; 10.1 斐波那契数列12345678910111213private int[] fib = new int[40];public Solution() &#123; fib[1] = 1; fib[2] = 2; for (int i = 2; i &lt; fib.length; i++) &#123; fib[i] = fib[i - 1] + fib[i - 2]; &#125;&#125;public int Fibonacci(int n) &#123; return fib[n];&#125; 10.2 跳台阶12345678910public int JumpFloor(int target) &#123; if (target == 1) return 1; int[] dp = new int[target]; dp[0] = 1; dp[1] = 2; for (int i = 2; i &lt; dp.length; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[target - 1];&#125; 10.3 变态跳台阶12345678910public int JumpFloorII(int target) &#123; int[] dp = new int[target]; Arrays.fill(dp, 1); for (int i = 1; i &lt; target; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] += dp[j]; &#125; &#125; return dp[target - 1];&#125; 10.4 矩形覆盖题目描述 我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 1234public int RectCover(int target) &#123; if (target &lt;= 2) return target; return RectCover(target - 1) + RectCover(target - 2);&#125; 11. 旋转数组的最小数字题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。 O(N) 时间复杂度解法： 1234567public int minNumberInRotateArray(int[] array) &#123; if (array.length == 0) return 0; for (int i = 0; i &lt; array.length - 1; i++) &#123; if (array[i] &gt; array[i + 1]) return array[i + 1]; &#125; return 0;&#125; O(lgN) 时间复杂度解法： 123456789101112public int minNumberInRotateArray(int[] array) &#123; if (array.length == 0) return 0; int l = 0, r = array.length - 1; int mid = -1; while (array[l] &gt;= array[r]) &#123; if (r - l == 1) return array[r]; mid = l + (r - l) / 2; if (array[mid] &gt;= array[l]) l = mid; else if (array[mid] &lt;= array[r]) r = mid; &#125; return array[mid];&#125; 12. 矩阵中的路径题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如 a b c e s f c s a d e e 矩阵中包含一条字符串 “bcced” 的路径，但是矩阵中不包含 “abcb” 路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 123456789101112131415161718192021222324252627282930313233343536private int[][] next = &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;private int rows;private int cols;public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (rows == 0 || cols == 0) return false; this.rows = rows; this.cols = cols; // 一维数组重建二维矩阵 char[][] newMatrix = new char[rows][cols]; for (int i = 0, idx = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; newMatrix[i][j] = matrix[idx++]; &#125; &#125; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (backtracking(newMatrix, str, new boolean[rows][cols], 0, i, j)) return true; &#125; &#125; return false;&#125;private boolean backtracking(char[][] matrix, char[] str, boolean[][] used, int pathLen, int curR, int curC) &#123; if (pathLen == str.length) return true; if (curR &lt; 0 || curR &gt;= rows || curC &lt; 0 || curC &gt;= cols) return false; if (matrix[curR][curC] != str[pathLen]) return false; if (used[curR][curC]) return false; used[curR][curC] = true; for (int i = 0; i &lt; next.length; i++) &#123; if (backtracking(matrix, str, used, pathLen + 1, curR + next[i][0], curC + next[i][1])) return true; &#125; used[curR][curC] = false; return false;&#125; 13. 机器人的运动范围题目描述 地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格（35, 37），因为 3+5+3+7=18。但是，它不能进入方格（35, 38），因为 3+5+3+8=19。请问该机器人能够达到多少个格子？ 12345678910111213141516171819202122232425262728293031323334353637private int cnt = 0;private int[][] next = &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;private int[][] digitSum;public int movingCount(int threshold, int rows, int cols) &#123; initDigitSum(rows, cols); dfs(new boolean[rows][cols], threshold, rows, cols, 0, 0); return cnt;&#125;private void dfs(boolean[][] visited, int threshold, int rows, int cols, int r, int c) &#123; if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols) return; if (visited[r][c]) return; visited[r][c] = true; if (this.digitSum[r][c] &gt; threshold) return; this.cnt++; for (int i = 0; i &lt; this.next.length; i++) &#123; dfs(visited, threshold, rows, cols, r + next[i][0], c + next[i][1]); &#125;&#125;private void initDigitSum(int rows, int cols) &#123; int[] digitSumOne = new int[Math.max(rows, cols)]; for (int i = 0; i &lt; digitSumOne.length; i++) &#123; int n = i; while (n &gt; 0) &#123; digitSumOne[i] += n % 10; n /= 10; &#125; &#125; this.digitSum = new int[rows][cols]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; this.digitSum[i][j] = digitSumOne[i] + digitSumOne[j]; &#125; &#125;&#125; 14. 剪绳子题目描述 把一根绳子剪成多段，并且使得每段的长度乘积最大。 动态规划解法 分割整数 贪心解法 尽可能多得剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现，如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。 123456789int maxProductAfterCuttin(int length) &#123; if (length &lt; 2) return 0; if (length == 2) return 1; if (length == 3) return 2; int timesOf3 = length / 3; if (length - timesOf3 * 3 == 1) timesOf3--; int timesOf2 = (length - timesOf3 * 3) / 2; return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));&#125; 15. 二进制中 1 的个数使用库函数： 123public int NumberOf1(int n) &#123; return Integer.bitCount(n);&#125; O(lgM) 时间复杂度解法，其中 M 表示 1 的个数： n&amp;(n-1) 该位运算是去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000。 12345678public int NumberOf1(int n) &#123; int cnt = 0; while (n != 0) &#123; cnt++; n &amp;= (n - 1); &#125; return cnt;&#125; 第三章 高质量的代码16. 数值的整数次方123456789101112public double Power(double base, int exponent) &#123; if (exponent == 0) return 1; if (exponent == 1) return base; boolean isNegative = false; if (exponent &lt; 0) &#123; exponent = -exponent; isNegative = true; &#125; double pow = Power(base * base, exponent / 2); if (exponent % 2 != 0) pow = pow * base; return isNegative ? 1 / pow : pow;&#125; 17. 打印从 1 到最大的 n 位数12345678910111213141516171819202122232425public void print1ToMaxOfNDigits(int n) &#123; if (n &lt; 0) return; char[] number = new char[n]; print1ToMaxOfNDigits(number, -1);&#125;private void print1ToMaxOfNDigits(char[] number, int idx) &#123; if (idx == number.length - 1) &#123; printNumber(number); return; &#125; for (int i = 0; i &lt; 10; i++) &#123; number[idx + 1] = (char) (i + '0'); print1ToMaxOfNDigits(number, idx + 1); &#125;&#125;private void printNumber(char[] number) &#123; boolean isBeginWith0 = true; for (char c : number) &#123; if (isBeginWith0 &amp;&amp; c != '0') isBeginWith0 = false; if(!isBeginWith0) System.out.print(c); &#125; System.out.println();&#125; 18.1 在 O(1) 时间内删除链表节点1234567891011121314public ListNode deleteNode(ListNode head, ListNode tobeDelete) &#123; if (head == null || head.next == null || tobeDelete == null) return null; if (tobeDelete.next != null) &#123; // 要删除的节点不是尾节点 ListNode next = tobeDelete.next; tobeDelete.val = next.val; tobeDelete.next = next.next; &#125; else &#123; ListNode cur = head; while (cur.next != tobeDelete) cur = cur.next; cur.next = null; &#125; return head;&#125; 18.2 删除链表中重复的结点1234567891011121314public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null) return null; if (pHead.next == null) return pHead; if (pHead.val == pHead.next.val) &#123; ListNode next = pHead.next; while (next != null &amp;&amp; pHead.val == next.val) &#123; next = next.next; &#125; return deleteDuplication(next); &#125; else &#123; pHead.next = deleteDuplication(pHead.next); return pHead; &#125;&#125; 19. 正则表达式匹配题目描述 请实现一个函数用来匹配包括 ‘.’ 和 ‘*‘ 的正则表达式。模式中的字符 ‘.’ 表示任意一个字符，而 ‘*‘ 表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab*ac*a” 匹配，但是与 “aa.a” 和 “ab*a” 均不匹配 123456789101112131415161718public boolean match(char[] str, char[] pattern) &#123; int n = str.length, m = pattern.length; boolean[][] dp = new boolean[n + 1][m + 1]; dp[0][0] = true; for (int i = 1; i &lt;= m; i++) &#123; if (pattern[i - 1] == '*') dp[0][i] = dp[0][i - 2]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (str[i - 1] == pattern[j - 1] || pattern[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1]; else if (pattern[j - 1] == '*') &#123; if (pattern[j - 2] != str[i - 1] &amp;&amp; pattern[j - 2] != '.') dp[i][j] = dp[i][j - 2]; else dp[i][j] = dp[i][j - 1] || dp[i][j - 2] || dp[i - 1][j]; &#125; &#125; &#125; return dp[n][m];&#125; 20. 表示数值的字符串题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 “+100”,”5e2”,”-123”,”3.1416” 和 “-1E-16” 都表示数值。 但是 “12e”,”1a3.14”,”1.2.3”,”+-5” 和 “12e+4.3” 都不是。 1234public boolean isNumeric(char[] str) &#123; String string = String.valueOf(str); return string.matches("[\\+-]?[0-9]*(\\.[0-9]*)?([eE][\\+-]?[0-9]+)?");&#125; 21. 调整数组顺序使奇数位于偶数前面题目要求 保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。 时间复杂度 : O(n2)空间复杂度 : O(1) 123456789101112131415public void reOrderArray(int[] array) &#123; int n = array.length; for (int i = 0; i &lt; n; i++) &#123; if (array[i] % 2 == 0) &#123; int nextOddIdx = i + 1; while (nextOddIdx &lt; n &amp;&amp; array[nextOddIdx] % 2 == 0) nextOddIdx++; if (nextOddIdx == n) break; int nextOddVal = array[nextOddIdx]; for (int j = nextOddIdx; j &gt; i; j--) &#123; array[j] = array[j - 1]; &#125; array[i] = nextOddVal; &#125; &#125;&#125; 时间复杂度 : O(n)空间复杂度 : O(n) 12345678910public void reOrderArray(int[] array) &#123; int oddCnt = 0; for (int num : array) if (num % 2 == 1) oddCnt++; int[] copy = array.clone(); int i = 0, j = oddCnt; for (int num : copy) &#123; if (num % 2 == 1) array[i++] = num; else array[j++] = num; &#125;&#125; 22. 链表中倒数第 k 个结点123456789101112public ListNode FindKthToTail(ListNode head, int k) &#123; if (head == null) return null; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; k-- &gt; 0) fast = fast.next; if (k &gt; 0) return null; while (fast != null) &#123; fast = fast.next; slow = slow.next; &#125; return slow;&#125; 23. 链表中环的入口结点1234567891011121314151617public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if (pHead == null) return null; ListNode slow = pHead, fast = pHead; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (slow == fast) &#123; fast = pHead; while (slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; return slow; &#125; &#125; return null;&#125; 24. 反转链表12345678910public ListNode ReverseList(ListNode head) &#123; ListNode newList = new ListNode(-1); while (head != null) &#123; ListNode next = head.next; head.next = newList.next; newList.next = head; head = next; &#125; return newList.next;&#125; 25. 合并两个排序的链表1234567891011121314151617public ListNode Merge(ListNode list1, ListNode list2) &#123; ListNode head = new ListNode(-1); ListNode cur = head; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt; list2.val) &#123; cur.next = list1; list1 = list1.next; &#125; else &#123; cur.next = list2; list2 = list2.next; &#125; cur = cur.next; &#125; if (list1 != null) cur.next = list1; if (list2 != null) cur.next = list2; return head.next;&#125; 26. 树的子结构123456789101112public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; if (root1 == null || root2 == null) return false; return isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);&#125;private boolean isSubtree(TreeNode root1, TreeNode root2) &#123; if (root1 == null &amp;&amp; root2 == null) return true; if (root1 == null) return false; if (root2 == null) return true; if (root1.val != root2.val) return false; return isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right);&#125; 第四章 解决面试题的思路27. 二叉树的镜像12345678public void Mirror(TreeNode root) &#123; if (root == null) return; TreeNode t = root.left; root.left = root.right; root.right = t; Mirror(root.left); Mirror(root.right);&#125; 28.1 对称的二叉树1234567891011boolean isSymmetrical(TreeNode pRoot) &#123; if (pRoot == null) return true; return isSymmetrical(pRoot.left, pRoot.right);&#125;boolean isSymmetrical(TreeNode t1, TreeNode t2) &#123; if (t1 == null &amp;&amp; t2 == null) return true; if (t1 == null || t2 == null) return false; if (t1.val != t2.val) return false; return isSymmetrical(t1.left, t2.right) &amp;&amp; isSymmetrical(t1.right, t2.left);&#125; 28.2 平衡二叉树1234567891011121314private boolean isBalanced = true;public boolean IsBalanced_Solution(TreeNode root) &#123; height(root); return isBalanced;&#125;private int height(TreeNode root) &#123; if (root == null) return 0; int left = height(root.left); int right = height(root.right); if (Math.abs(left - right) &gt; 1) isBalanced = false; return 1 + Math.max(left, right);&#125; 29. 顺时针打印矩阵123456789101112public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1; while (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123; for (int i = c1; i &lt;= c2; i++) ret.add(matrix[r1][i]); for (int i = r1 + 1; i &lt;= r2; i++) ret.add(matrix[i][c2]); if (r1 != r2) for (int i = c2 - 1; i &gt;= c1; i--) ret.add(matrix[r2][i]); if (c1 != c2) for (int i = r2 - 1; i &gt; r1; i--) ret.add(matrix[i][c1]); r1++; r2--; c1++; c2--; &#125; return ret;&#125; 30. 包含 min 函数的栈1234567891011121314151617181920212223private Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();private Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();private int min = Integer.MAX_VALUE;public void push(int node) &#123; stack.push(node); if (min &gt; node) min = node; minStack.push(min);&#125;public void pop() &#123; stack.pop(); minStack.pop(); min = minStack.peek();&#125;public int top() &#123; return stack.peek();&#125;public int min() &#123; return minStack.peek();&#125; 31. 栈的压入、弹出序列123456789101112public boolean IsPopOrder(int[] pushA, int[] popA) &#123; int n = pushA.length; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0, j = 0; i &lt; n; i++) &#123; stack.push(pushA[i]); while (j &lt; n &amp;&amp; stack.peek() == popA[j]) &#123; stack.pop(); j++; &#125; &#125; return stack.isEmpty();&#125; 32.1 从上往下打印二叉树12345678910111213141516public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) return ret; queue.add(root); while (!queue.isEmpty()) &#123; int cnt = queue.size(); for (int i = 0; i &lt; cnt; i++) &#123; TreeNode t = queue.poll(); if (t.left != null) queue.add(t.left); if (t.right != null) queue.add(t.right); ret.add(t.val); &#125; &#125; return ret;&#125; 32.3 把二叉树打印成多行123456789101112131415161718ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if (pRoot == null) return ret; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); while (!queue.isEmpty()) &#123; int cnt = queue.size(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; cnt; i++) &#123; TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; ret.add(list); &#125; return ret;&#125; 32.3 按之字形顺序打印二叉树12345678910111213141516171819202122232425public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if (pRoot == null) return ret; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); boolean reverse = false; while (!queue.isEmpty()) &#123; int cnt = queue.size(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; cnt; i++) &#123; TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; if (reverse) &#123; Collections.reverse(list); reverse = false; &#125; else &#123; reverse = true; &#125; ret.add(list); &#125; return ret;&#125; 33. 二叉搜索树的后序遍历序列123456789101112131415161718public boolean VerifySquenceOfBST(int[] sequence) &#123; if (sequence.length == 0) return false; return verify(sequence, 0, sequence.length - 1);&#125;private boolean verify(int[] sequence, int start, int end) &#123; if (end - start &lt;= 1) return true; int rootVal = sequence[end]; int cutIdx = start; while (cutIdx &lt; end) &#123; if (sequence[cutIdx] &gt; rootVal) break; cutIdx++; &#125; for (int i = cutIdx + 1; i &lt; end; i++) &#123; if (sequence[i] &lt; rootVal) return false; &#125; return verify(sequence, start, cutIdx - 1) &amp;&amp; verify(sequence, cutIdx, end - 1);&#125; 34. 二叉树中和为某一值的路径12345678910111213141516171819private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; dfs(root, target, 0, new ArrayList&lt;&gt;()); return ret;&#125;private void dfs(TreeNode node, int target, int curSum, ArrayList&lt;Integer&gt; path) &#123; if (node == null) return; curSum += node.val; path.add(node.val); if (curSum == target &amp;&amp; node.left == null &amp;&amp; node.right == null) &#123; ret.add(new ArrayList(path)); &#125; else &#123; dfs(node.left, target, curSum, path); dfs(node.right, target, curSum, path); &#125; path.remove(path.size() - 1);&#125; 35. 复杂链表的复制题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 第一步，在每个节点的后面插入复制的节点。 第二步，对复制节点的 random 链接进行赋值。 第三步，拆分。 1234567891011121314151617181920212223242526272829public RandomListNode Clone(RandomListNode pHead) &#123; if (pHead == null) return null; // 插入新节点 RandomListNode cur = pHead; while (cur != null) &#123; RandomListNode node = new RandomListNode(cur.label); node.next = cur.next; cur.next = node; cur = node.next; &#125; // 建立 random 链接 cur = pHead; while (cur != null) &#123; RandomListNode clone = cur.next; if (cur.random != null) &#123; clone.random = cur.random.next; &#125; cur = clone.next; &#125; // 拆分 RandomListNode pCloneHead = pHead.next; cur = pHead; while (cur.next != null) &#123; RandomListNode t = cur.next; cur.next = t.next; cur = t; &#125; return pCloneHead;&#125; 36. 二叉搜索树与双向链表题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 12345678910111213141516private TreeNode pre = null;public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree == null) return null; inOrder(pRootOfTree); while(pRootOfTree.left != null) pRootOfTree = pRootOfTree.left; return pRootOfTree;&#125;private void inOrder(TreeNode node) &#123; if(node == null) return; inOrder(node.left); node.left = pre; if(pre != null) pre.right = node; pre = node; inOrder(node.right);&#125; 37. 序列化二叉树12345678910111213141516171819202122232425262728private String serizeString = "";String Serialize(TreeNode root) &#123; if (root == null) return "#"; return root.val + " " + Serialize(root.left) + " " + Serialize(root.right);&#125;TreeNode Deserialize(String str) &#123; this.serizeString = str; return Deserialize();&#125;private TreeNode Deserialize() &#123; if (this.serizeString.length() == 0) return null; int idx = this.serizeString.indexOf(" "); if (idx == -1) return null; String sub = this.serizeString.substring(0, idx); this.serizeString = this.serizeString.substring(idx + 1); if (sub.equals("#")) &#123; return null; &#125; int val = Integer.valueOf(sub); TreeNode t = new TreeNode(val); t.left = Deserialize(); t.right = Deserialize(); return t;&#125; 38. 字符串的排列题目描述 输入一个字符串 , 按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc, 则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。 1234567891011121314151617181920212223private ArrayList&lt;String&gt; ret = new ArrayList&lt;&gt;();public ArrayList&lt;String&gt; Permutation(String str) &#123; if (str.length() == 0) return new ArrayList&lt;&gt;(); char[] chars = str.toCharArray(); Arrays.sort(chars); backtracking(chars, new boolean[chars.length], ""); return ret;&#125;private void backtracking(char[] chars, boolean[] used, String s) &#123; if (s.length() == chars.length) &#123; ret.add(s); return; &#125; for (int i = 0; i &lt; chars.length; i++) &#123; if (used[i]) continue; if (i != 0 &amp;&amp; chars[i] == chars[i - 1] &amp;&amp; !used[i - 1]) continue; // 保证不重复 used[i] = true; backtracking(chars, used, s + chars[i]); used[i] = false; &#125;&#125; 第五章 优化时间和空间效率39. 数组中出现次数超过一半的数字12345678910111213141516public int MoreThanHalfNum_Solution(int[] array) &#123; int cnt = 1, num = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] == num) cnt++; else cnt--; if (cnt == 0) &#123; num = array[i]; cnt = 1; &#125; &#125; cnt = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (num == array[i]) cnt++; &#125; return cnt &gt; array.length / 2 ? num : 0;&#125; 40. 最小的 K 个数构建大小为 k 的小顶堆。 时间复杂度：O(nlgk)空间复杂度：O(k) 123456789101112public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; if (k &gt; input.length || k &lt;= 0) return new ArrayList&lt;&gt;(); PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1); for (int num : input) &#123; pq.add(num); if (pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(pq); return ret;&#125; 利用快速选择 时间复杂度：O(n)空间复杂度：O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; if (k &gt; input.length || k &lt;= 0) return new ArrayList&lt;&gt;(); int kthSmallest = findKthSmallest(input, k - 1); ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for (int num : input) &#123; if(num &lt;= kthSmallest &amp;&amp; ret.size() &lt; k) ret.add(num); &#125; return ret;&#125;public int findKthSmallest(int[] nums, int k) &#123; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) &#123; int j = partition(nums, lo, hi); if (j &lt; k) &#123; lo = j + 1; &#125; else if (j &gt; k) &#123; hi = j - 1; &#125; else &#123; break; &#125; &#125; return nums[k];&#125;private int partition(int[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; while (true) &#123; while (i &lt; hi &amp;&amp; less(a[++i], a[lo])) ; while (j &gt; lo &amp;&amp; less(a[lo], a[--j])) ; if (i &gt;= j) &#123; break; &#125; exch(a, i, j); &#125; exch(a, lo, j); return j;&#125;private void exch(int[] a, int i, int j) &#123; final int tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125;private boolean less(int v, int w) &#123; return v &lt; w;&#125; 41.1 数据流中的中位数题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 123456789101112131415161718192021222324private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2-o1); // 实现左边部分private PriorityQueue&lt;Integer&gt; minHeep = new PriorityQueue&lt;&gt;(); // 实现右边部分，右边部分所有元素大于左边部分private int cnt = 0;public void Insert(Integer num) &#123; // 插入要保证两个堆存于平衡状态 if(cnt % 2 == 0) &#123; // 为偶数的情况下插入到最小堆，先经过最大堆筛选，这样就能保证最大堆中的元素都小于最小堆中的元素 maxHeap.add(num); minHeep.add(maxHeap.poll()); &#125; else &#123; minHeep.add(num); maxHeap.add(minHeep.poll()); &#125; cnt++;&#125;public Double GetMedian() &#123; if(cnt % 2 == 0) &#123; return (maxHeap.peek() + minHeep.peek()) / 2.0; &#125; else &#123; return (double) minHeep.peek(); &#125;&#125; 41.2 字符流中第一个不重复的字符题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g”。当从该字符流中读出前六个字符“google” 时，第一个只出现一次的字符是 “l”。 1234567891011121314151617//Insert one char from stringstreamprivate int[] cnts = new int[256];private Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;();public void Insert(char ch) &#123; cnts[ch]++; queue.add(ch); while (!queue.isEmpty() &amp;&amp; cnts[queue.peek()] &gt; 1) &#123; queue.poll(); &#125;&#125;//return the first appearence once char in current stringstreampublic char FirstAppearingOnce() &#123; if (queue.isEmpty()) return '#'; return queue.peek();&#125; 42. 连续子数组的最大和1234567891011public int FindGreatestSumOfSubArray(int[] array) &#123; if(array.length == 0) return 0; int ret = Integer.MIN_VALUE; int sum = 0; for(int num : array) &#123; if(sum &lt;= 0) sum = num; else sum += num; ret = Math.max(ret, sum); &#125; return ret;&#125; 43. 从 1 到 n 整数中 1 出现的次数解题参考：Leetcode : 233. Number of Digit One-C++JavaPython) 12345678public int NumberOf1Between1AndN_Solution(int n) &#123; int cnt = 0; for (int m = 1; m &lt;= n; m *= 10) &#123; int a = n / m, b = n % m; cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0); &#125; return cnt;&#125; 44. 数字序列中的某一位数字题目描述 数字以 0123456789101112131415… 的格式序列化到一个字符串中，求这个字符串的第 index 位。 1234567891011121314151617181920212223242526272829303132int digitAtIndex(int index) &#123; if (index &lt; 0) return -1; int digit = 1; while (true) &#123; int amount = getAmountOfDigit(digit); int totalAmount = amount * digit; if (index &lt; totalAmount) return digitAtIndex(index, digit); index -= totalAmount; digit++; &#125;&#125;private int getAmountOfDigit(int digit) &#123; if (digit == 1) return 10; return (int) Math.pow(10, digit - 1);&#125;private int digitAtIndex(int index, int digits) &#123; int number = beginNumber(digits) + index / digits; int remain = index % digits; return (number + "").charAt(remain) - '0';&#125;private int beginNumber(int digits) &#123; if (digits == 1) return 0; return (int) Math.pow(10, digits - 1);&#125;public static void main(String[] args) &#123; Solution solution = new Solution(); System.out.println(solution.digitAtIndex(1001));&#125; 45. 把数组排成最小的数题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。 123456789public String PrintMinNumber(int[] numbers) &#123; int n = numbers.length; String[] nums = new String[n]; for (int i = 0; i &lt; n; i++) nums[i] = numbers[i] + ""; Arrays.sort(nums, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1)); String ret = ""; for (String str : nums) ret += str; return ret;&#125; 46. 把数字翻译成字符串题目描述 给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”…25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。 12345678910111213public int getTranslationCount(String number) &#123; int n = number.length(); int[] counts = new int[n + 1]; counts[n - 1] = counts[n] = 1; for (int i = n - 2; i &gt;= 0; i--) &#123; counts[i] = counts[i + 1]; int converted = Integer.valueOf(number.substring(i, i + 2)); if (converted &gt;= 10 &amp;&amp; converted &lt;= 25) &#123; counts[i] += counts[i + 2]; &#125; &#125; return counts[0];&#125; 47. 礼物的最大价值题目描述 在一个 m * n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘 12341 10 3 812 2 9 65 7 4 113 7 16 5 礼物的最大价值为 1+12+5+7+7+16+5=53。 解题思路 应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。 12345678910111213public int getMaxValue(int[][] values) &#123; if (values == null || values.length == 0 || values[0].length == 0) return 0; int m = values.length; int n = values[0].length; int[] dp = new int[n]; for (int i = 0; i &lt; m; i++) &#123; dp[0] += values[i][0]; for (int j = 1; j &lt; n; j++) &#123; dp[j] = Math.max(dp[j], dp[j - 1]) + values[i][j]; &#125; &#125; return dp[n - 1];&#125; 48. 最长不含重复字符的子字符串题目描述 输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。 1234567891011121314151617public int longestSubStringWithoutDuplication(String str) &#123; int curLen = 0; int maxLen = 0; int[] position = new int[26]; for (int i = 0; i &lt; str.length(); i++) &#123; int c = str.charAt(i) - 'a'; int preIndex = position[c]; if (preIndex == -1 || i - preIndex &gt; curLen) curLen++; else &#123; maxLen = Math.max(maxLen, curLen); curLen = i - preIndex; &#125; position[c] = i; &#125; maxLen = Math.max(maxLen, curLen); return maxLen;&#125; 49. 丑数题目描述 把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。 习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。 12345678910111213141516public int GetUglyNumber_Solution(int index) &#123; if (index &lt;= 6) return index; int i2 = 0, i3 = 0, i5 = 0; int cnt = 1; int[] dp = new int[index]; dp[0] = 1; while (cnt &lt; index) &#123; int n2 = dp[i2] * 2, n3 = dp[i3] * 3, n5 = dp[i5] * 5; int tmp = Math.min(n2, Math.min(n3, n5)); dp[cnt++] = tmp; if (tmp == n2) i2++; if (tmp == n3) i3++; if (tmp == n5) i5++; &#125; return dp[index - 1];&#125; 50. 第一个只出现一次的字符位置123456public int FirstNotRepeatingChar(String str) &#123; int[] cnts = new int[256]; for (int i = 0; i &lt; str.length(); i++) cnts[str.charAt(i)]++; for (int i = 0; i &lt; str.length(); i++) if (cnts[str.charAt(i)] == 1) return i; return -1;&#125; 51. 数组中的逆序对123456789101112131415161718192021222324252627282930313233private long cnt = 0;public int InversePairs(int[] array) &#123; mergeSortUp2Down(array, 0, array.length - 1); return (int) (cnt % 1000000007);&#125;private void mergeSortUp2Down(int[] a, int start, int end) &#123; if (end - start &lt; 1) return; int mid = start + (end - start) / 2; mergeSortUp2Down(a, start, mid); mergeSortUp2Down(a, mid + 1, end); merge(a, start, mid, end);&#125;private void merge(int[] a, int start, int mid, int end) &#123; int[] tmp = new int[end - start + 1]; int i = start, j = mid + 1, k = 0; while (i &lt;= mid || j &lt;= end) &#123; if (i &gt; mid) tmp[k] = a[j++]; else if (j &gt; end) tmp[k] = a[i++]; else if (a[i] &lt; a[j]) tmp[k] = a[i++]; else &#123; tmp[k] = a[j++]; this.cnt += mid - i + 1; // a[i] &gt; a[j] ，说明 a[i...mid] 都大于 a[j] &#125; k++; &#125; for (k = 0; k &lt; tmp.length; k++) &#123; a[start + k] = tmp[k]; &#125;&#125; 52. 两个链表的第一个公共结点12345678910public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode l1 = pHead1, l2 = pHead2; while (l1 != l2) &#123; if (l1 == null) l1 = pHead2; else l1 = l1.next; if (l2 == null) l2 = pHead1; else l2 = l2.next; &#125; return l1;&#125; 第六章 面试中的各项能力53 数字在排序数组中出现的次数1234567891011public int GetNumberOfK(int[] array, int k) &#123; int l = 0, h = array.length - 1; while (l &lt;= h) &#123; int m = l + (h - l) / 2; if (array[m] &gt;= k) h = m - 1; else l = m + 1; &#125; int cnt = 0; while (l &lt; array.length &amp;&amp; array[l++] == k) cnt++; return cnt;&#125; 54. 二叉搜索树的第 k 个结点12345678910111213141516TreeNode ret;int cnt = 0;TreeNode KthNode(TreeNode pRoot, int k) &#123; inorder(pRoot, k); return ret;&#125;private void inorder(TreeNode root, int k) &#123; if (root == null) return; if (cnt &gt; k) return; inorder(root.left, k); cnt++; if (cnt == k) ret = root; inorder(root.right, k);&#125; 55 二叉树的深度1234public int TreeDepth(TreeNode root) &#123; if (root == null) return 0; return 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));&#125; 56. 数组中只出现一次的数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。 解题思路 两个不相等的元素在位级表示上必定会有一位存在不同。 将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。 diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。 12345678910public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123; int diff = 0; for (int num : array) diff ^= num; // 得到最右一位 diff &amp;= -diff; for (int num : array) &#123; if ((num &amp; diff) == 0) num1[0] ^= num; else num2[0] ^= num; &#125;&#125; 57.1 和为 S 的两个数字题目描述 输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。 12345678910public ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) &#123; int i = 0, j = array.length - 1; while (i &lt; j) &#123; int cur = array[i] + array[j]; if (cur == sum) return new ArrayList&lt;Integer&gt;(Arrays.asList(array[i], array[j])); else if (cur &lt; sum) i++; else j--; &#125; return new ArrayList&lt;Integer&gt;();&#125; 57.2 和为 S 的连续正数序列题目描述 和为 100 的连续序列有 18, 19, 20, 21, 22 1234567891011121314151617181920212223242526public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int start = 1, end = 2; int mid = sum / 2; int curSum = 3; while (start &lt;= mid &amp;&amp; end &lt; sum) &#123; if (curSum &gt; sum) &#123; curSum -= start; start++; &#125; else if (curSum &lt; sum) &#123; end++; curSum += end; &#125; else &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = start; i &lt;= end; i++) &#123; list.add(i); &#125; ret.add(list); curSum -= start; start++; end++; curSum += end; &#125; &#125; return ret;&#125; 58.1 翻转单词顺序列题目描述 输入：”I am a student.” 输出：”student. a am I” 12345678910111213141516171819202122232425public String ReverseSentence(String str) &#123; if (str.length() == 0) return str; int n = str.length(); char[] chars = str.toCharArray(); int start = 0, end = 0; while (end &lt;= n) &#123; if (end == n || chars[end] == ' ') &#123; reverse(chars, start, end - 1); start = end + 1; &#125; end++; &#125; reverse(chars, 0, n - 1); return new String(chars);&#125;private void reverse(char[] c, int start, int end) &#123; while (start &lt; end) &#123; char t = c[start]; c[start] = c[end]; c[end] = t; start++; end--; &#125;&#125; 58.2 左旋转字符串题目描述 对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”, 要求输出循环左移 3 位后的结果，即“XYZdefabc”。 123456789101112131415161718public String LeftRotateString(String str, int n) &#123; if (str.length() == 0) return ""; char[] c = str.toCharArray(); reverse(c, 0, n - 1); reverse(c, n, c.length - 1); reverse(c, 0, c.length - 1); return new String(c);&#125;private void reverse(char[] c, int i, int j) &#123; while (i &lt; j) &#123; char t = c[i]; c[i] = c[j]; c[j] = t; i++; j--; &#125;&#125; 59. 滑动窗口的最大值题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}； 12345678910111213public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (size &gt; num.length || size &lt; 1) return ret; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;((o1, o2) -&gt; o2 - o1); for (int i = 0; i &lt; size; i++) heap.add(num[i]); ret.add(heap.peek()); for (int i = 1; i + size - 1 &lt; num.length; i++) &#123; heap.remove(num[i - 1]); heap.add(num[i + size - 1]); ret.add(heap.peek()); &#125; return ret;&#125; 60. n 个骰子的点数题目描述 把 n 个骰子仍在地上，求点数和为 s 的概率。 最直观的动态规划解法，O(n2) 的空间复杂度。 123456789101112131415161718192021private static int face = 6;public double countProbability(int n, int s) &#123; if (n &lt; 1 || s &lt; n) return 0.0; int pointNum = face * n; int[][] dp = new int[n][pointNum]; for (int i = 0; i &lt; face; i++) &#123; dp[0][i] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &lt; pointNum; j++) &#123; // 使用 i 个骰子最小点数为 i for (int k = 1; k &lt;= face; k++) &#123; if (j - k &lt; 0) continue; dp[i][j] += dp[i - 1][j - k]; &#125; &#125; &#125; int totalNum = (int) Math.pow(6, n); return (double) dp[n - 1][s - 1] / totalNum;&#125; 使用旋转数组将空间复杂度降低为 O(n) 12345678910111213141516171819202122private static int face = 6;public double countProbability(int n, int s) &#123; if (n &lt; 1 || s &lt; n) return 0.0; int pointNum = face * n; int[][] dp = new int[2][pointNum]; for (int i = 0; i &lt; face; i++) &#123; dp[0][i] = 1; &#125; int flag = 1; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &lt; pointNum; j++) &#123; // 使用 i 个骰子最小点数为 i for (int k = 1; k &lt;= face; k++) &#123; if (j - k &lt; 0) continue; dp[flag][j] += dp[1 - flag][j - k]; &#125; &#125; &#125; int totalNum = (int) Math.pow(6, n); return (double) dp[n - 1][s - 1] / totalNum;&#125; 61. 扑克牌顺子题目描述 五张牌，其中大小鬼为癞子，牌面大小为 0。判断是否能组成顺子。 12345678910111213public boolean isContinuous(int[] numbers) &#123; if (numbers.length &lt; 5) return false; Arrays.sort(numbers); int cnt = 0; for (int num : numbers) if (num == 0) cnt++; for (int i = cnt; i &lt; numbers.length - 1; i++) &#123; if (numbers[i + 1] == numbers[i]) return false; int cut = numbers[i + 1] - numbers[i] - 1; if (cut &gt; cnt) return false; cnt -= cut; &#125; return true;&#125; 62. 圆圈中最后剩下的数题目描述 让小朋友们围成一个大圈。然后 , 他随机指定一个数 m, 让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌 , 然后可以在礼品箱中任意的挑选礼物 , 并且不再回到圈中 , 从他的下一个小朋友开始 , 继续 0…m-1 报数 …. 这样下去 …. 直到剩下最后一个小朋友 , 可以不用表演。 解题思路 约瑟夫环 12345public int LastRemaining_Solution(int n, int m) &#123; if (n == 0) return -1; if (n == 1) return 0; return (LastRemaining_Solution(n - 1, m) + m) % n;&#125; 63. 股票的最大利润题目描述 可以有一次买入和一次卖出，买入必须在前。求最大收益。 1234567891011public int maxProfit(int[] prices) &#123; int n = prices.length; if(n == 0) return 0; int soFarMin = prices[0]; int max = 0; for(int i = 1; i &lt; n; i++) &#123; if(soFarMin &gt; prices[i]) soFarMin = prices[i]; else max = Math.max(max, prices[i] - soFarMin); &#125; return max;&#125; 64. 求 1+2+3+…+n题目描述 求 1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C） 12345public int Sum_Solution(int n) &#123; int sum = n; boolean b = (n &gt; 0) &amp;&amp; ((sum += Sum_Solution(n - 1)) &gt; 0); return sum;&#125; 65. 不用加减乘除做加法a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。 1234public int Add(int num1, int num2) &#123; if(num2 == 0) return num1; return Add(num1 ^ num2, (num1 &amp; num2) &lt;&lt; 1);&#125; 66. 构建乘积数组题目描述 给定一个数组 A[0, 1,…, n-1], 请构建一个数组 B[0, 1,…, n-1], 其中 B 中的元素 B[i]=A[0]*A[1]*…*A[i-1]*A[i+1]*…*A[n-1]。不能使用除法。 1234567891011121314151617181920public int[] multiply(int[] A) &#123; int n = A.length; int[][] dp = new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; dp[i][i] = A[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; dp[i][j] = dp[i][j - 1] * A[j]; &#125; &#125; int[] B = new int[n]; Arrays.fill(B, 1); for (int i = 0; i &lt; n; i++) &#123; if (i != 0) B[i] *= dp[0][i - 1]; if (i != n - 1) B[i] *= dp[i + 1][n - 1]; &#125; return B;&#125; 第七章 两个面试案例67. 把字符串转换成整数123456789101112public int StrToInt(String str) &#123; if (str.length() == 0) return 0; char[] chars = str.toCharArray(); boolean isNegative = chars[0] == '-'; int ret = 0; for (int i = 0; i &lt; chars.length; i++) &#123; if (i == 0 &amp;&amp; (chars[i] == '+' || chars[i] == '-')) continue; if (chars[i] &lt; '0' || chars[i] &gt; '9') return 0; ret = ret * 10 + (chars[i] - '0'); &#125; return isNegative ? -ret : ret;&#125; 68. 树中两个节点的最低公共祖先树是二叉查找树的最低公共祖先问题： 12345public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root;&#125;]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码风格规范]]></title>
    <url>%2Fblog%2F2937.html</url>
    <content type="text"><![CDATA[Java面试笔记 Google Java Style Guide http://www.hawstein.com/posts/google-java-style.html http://google.github.io/styleguide/javaguide.html Google C++ Style Guide http://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/ http://google.github.io/styleguide/cppguide.html Google Python Style Guide http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/ http://google.github.io/styleguide/pyguide.html]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库]]></title>
    <url>%2Fblog%2F37198.html</url>
    <content type="text"><![CDATA[Java面试笔记 存储引擎1. InnoDBInnoDB 是 MySQL 的默认事务型引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读。 表是基于聚簇索引建立的，它对主键的查询性能有很高的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。 通过一些机制和工具支持真正的热备份。 2. MyISAMMyISAM 提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等。但 MyISAM 不支持事务和行级锁，而且奔溃后无法安全恢复。 只能对整张表加锁，而不是针对行。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及奔溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 可以包含动态或者静态的行。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机奔溃时会造成索引损坏，需要执行修复操作。 如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表适合采用 MyISAM 压缩表。 对于只读数据，或者表比较小、可以容忍修复操作，则依然可以继续使用 MyISAM。 MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。 3. InnoDB 与 MyISAM 的比较事务 InnoDB 是事务型的。 备份 InnoDB 支持在线热备份。 奔溃恢复 MyISAM 奔溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 并发 MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 其它特性 MyISAM 支持全文索引，地理空间索引； 数据类型1. 整型TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32,, 64 位存储空间，一般情况下越小的列越好。 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。 2. 浮点数FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 3. 字符串主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作，MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。 4. 时间和日期MySQL 提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。 DATATIME 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATATIME 值，例如“2008-01016 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 TIMESTAMP 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。 它和时区有关。 MySQL 提供了 FROM_UNIXTIME() 函数把 Unxi 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 Unix 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 索引能够轻易将查询性能提升几个数量级。 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。对于中到大型的表，索引就非常有效。但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 1. 索引分类1.1 B-Tree 索引B-Tree 索引是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。 可以指定多个列作为索引列，多个索引列共同组成键。B-Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。 除了用于查找，还可以用于排序和分组。 如果不是按照索引列的顺序进行查找，则无法使用索引。 1.2 哈希索引基于哈希表实现，优点是查找非常快。 在 MySQL 中只有 Memory 引擎显式支持哈希索引。 InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 限制：哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显；无法用于分组与排序；只支持精确查找，无法用于部分查找和范围查找；如果哈希冲突很多，查找速度会变得很慢。 1.3. 空间索引数据（R-Tree）MyISAM 存储引擎支持空间索引，可以用于地理数据存储。 空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 1.4 全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。 使用 MATCH AGAINST，而不是普通的 WHERE。 2. 索引的优点 大大减少了服务器需要扫描的数据量； 帮助服务器避免进行排序和创建临时表； 将随机 I/O 变为顺序 I/O。 3. 索引优化3.1 独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 3.2 前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 对于前缀长度的选取需要根据 索引选择性 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1 ，此时每个记录都有唯一的索引与其对应。 3.3 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 file_id 设置为多列索引。 12SELECT file_id, actor_ id FROM sakila.film_actorWhERE actor_id = 1 OR film_id = 1; 3.4 索引列的顺序让选择性最强的索引列放在前面，例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment; 123 staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 3.5 聚簇索引 聚簇索引并不是一种索引类型，而是一种数据存储方式。 术语“聚簇”表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引的数据行存放在 B-Tree 的叶子页中。 因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 优点 可以把相关数据保存在一起，减少 I/O 操作； 因为数据保存在 B-Tree 中，因此数据访问更快。 缺点 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。 更新操作代价很高，因为每个被更新的行都会移动到新的位置。 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。 3.6 覆盖索引索引包含所有需要查询的字段的值。 4. B-Tree 和 B+Tree 原理4. 1 B-Tree 为了描述 B-Tree，首先定义一条数据记录为一个二元组 [key, data]，key 为记录的键，data 为数据记录除 key 外的数据。 B-Tree 是满足下列条件的数据结构： 所有叶节点具有相同的深度，也就是说 B-Tree 是平衡的； 一个节点中的 key 从左到右非递减排列； 如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于 keyi 且小于 keyi+1。 在 B-Tree 中按 key 检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针，前者查找成功，后者查找失败。 由于插入删除新的数据记录会破坏 B-Tree 的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持 B-Tree 性质。 4.2 B+Tree 与 B-Tree 相比，B+Tree 有以下不同点： 每个节点的指针上限为 2d 而不是 2d+1； 内节点不存储 data，只存储 key，叶子节点不存储指针。 4.3 带有顺序访问指针的 B+Tree 一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 基础上进行了优化，在叶子节点增加了顺序访问指针，做这个优化的目的是为了提高区间访问的性能。 4.4 为什么使用 B-Tree 和 B+Tree红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构。 页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为 4k），主存和磁盘以页为单位交换数据。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。B-Tree 中一次检索最多需要 h-1 次 I/O（根节点常驻内存），渐进复杂度为 O(h)=O(logdN)。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。而红黑树这种结构，h 明显要深的多。并且于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，效率明显比 B-Tree 差很多。 B+Tree 更适合外存索引，原因和内节点出度 d 有关。由于 B+Tree 内节点去掉了 data 域，因此可以拥有更大的出度，拥有更好的性能。 查询性能优化1. Explain用来分析 SQL 语句，分析结果中比较重要的字段有： select_type : 查询类型，有简单查询、联合查询和子查询 key : 使用的索引 rows : 扫描的行数 2. 减少返回的列慢查询主要是因为访问了过多数据，除了访问过多行之外，也包括访问过多列。 最好不要使用 SELECT * 语句，要根据需要选择查询的列。 3. 减少返回的行最好使用 LIMIT 语句来取出想要的那些行。 还可以建立索引来减少条件语句的全表扫描。例如对于下面的语句，不适用索引的情况下需要进行全表扫描，而使用索引只需要扫描几行记录即可，使用 Explain 语句可以通过观察 rows 字段来看出这种差异。 1SELECT * FROM sakila.film_actor WHERE film_id = 1; 4. 拆分大的 DELETE 或 INSERT 语句如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 1DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH); 12345rows_affected = 0do &#123; rows_affected = do_query( "DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")&#125; while rows_affected &gt; 0 分库与分表1. 分表与分区的不同 分表，就是讲一张表分成多个小表，这些小表拥有不同的表名；而分区是将一张表的数据分为多个区块，这些区块可以存储在同一个磁盘上，也可以存储在不同的磁盘上，这种方式下表仍然只有一个。 2. 使用分库与分表的原因 随着时间和业务的发展，数据库中的表会越来越多，并且表中的数据量也会越来越大，那么读写操作的开销也会随着增大。 3. 垂直切分 将表按功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立商品数据库 payDB、用户数据库 userDB 等，分别用来存储项目与商品有关的表和与用户有关的表。 4. 水平切分 把表中的数据按照某种规则存储到多个结构相同的表中，例如按 id 的散列值、性别等进行划分， 5. 垂直切分与水平切分的选择 如果数据库中的表太多，并且项目各项业务逻辑清晰，那么垂直切分是首选。 如果数据库的表不多，但是单表的数据量很大，应该选择水平切分。 6. 水平切分的实现方式 最简单的是使用 merge 存储引擎。 7. 分库与分表存在的问题 (1) 事务问题 在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。 (2) 跨库跨表连接问题 在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上。这时，表的连接操作将受到限制，我们无法连接位于不同分库的表，也无法连接分表粒度不同的表，导致原本只需要一次查询就能够完成的业务需要进行多次才能完成。 故障转移和故障恢复故障转移也叫做切换，当主库出现故障时就切换到备库，使备库成为主库。故障恢复顾名思义就是从故障中恢复过来，并且保证数据的正确性。 1. 故障转移1.1 提升备库或切换角色 提升一台备库为主库，或者在一个主-主复制结构中调整主动和被动角色。 1.2 虚拟 IP 地址和 IP 托管 为 MySQL 实例指定一个逻辑 IP 地址，当 MySQL 实例失效时，可以将 IP 地址转移到另一台 MySQL 服务器上。 1.3 中间件解决方案 通过代理，可以路由流量到可以使用的服务器上。 1.4 在应用中处理故障转移 将故障转移整合到应用中可能导致应用变得太过笨拙。 2. 故障恢复参考资料 高性能 MySQL MySQL 索引背后的数据结构及算法原理 MySQL 索引优化全攻略 20+ 条 MySQL 性能优化的最佳经验]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码可读性的重要性]]></title>
    <url>%2Fblog%2F51915.html</url>
    <content type="text"><![CDATA[Java面试笔记 可读性的重要性编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。 可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。 只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。 用名字表达代码含义一些比较有表达力的单词： 单词 可替代单词 send deliver、dispatch、announce、distribute、route find search、extract、locate、recover start launch、create、begin、open make create、set up、build、generate、compose、add、new 使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高 为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。 名字不能带来歧义起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。 用 min、max 表示数量范围；用 first、last 表示访问空间的包含范围，begin、end 表示访问空间的排除范围，即 end 不包含尾部。 布尔相关的命名加上 is、can、should、has 等前缀。 良好的代码风格适当的空行和缩进。 排列整齐的注释： 123int a = 1; // 注释int b = 11; // 注释int c = 111; // 注释 语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致； 把相关的代码按块组织起来放在一起。 编写注释阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是并不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。 不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。 可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。 注释用来提醒一些特殊情况。 用 TODO 等做标记： 标记 用法 TODO 待做 FIXME 待修复 HACH 粗糙的解决方案 XXX 危险！这里有重要的问题 如何编写注释尽量简洁明了： 123// The first String is student&apos;s name// The Second Integer is student&apos;s scoreMap&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;(); 12// Student&apos; name -&gt; Student&apos;s scoreMap&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;(); 添加测试用例来说明： 12345//...// Example: add(1, 2), return 3int add(int x, int y) &#123; return x + y;&#125; 在很复杂的函数调用中对每个参数标上名字： 123int a = 1;int b = 2;int num = add(\* x = *\ a, \* y = *\ b); 使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。 提高控制流的可读性条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确： 12if(len &lt; 10)if(10 &gt; len) if / else 条件语句，逻辑的处理顺序为：① 正逻辑；② 关键逻辑；③ 简单逻辑。12345if(a == b) &#123; // 正逻辑&#125; else&#123; // 反逻辑&#125; 只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else； do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。 如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。 在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。 拆分长表达式长表达式的可读性很差，可以引入一些解释变量从而拆分表达式： 12if line.split(&apos;:&apos;)[0].strip() == &quot;root&quot;: ... 123username = line.split(&apos;:&apos;)[0].strip()if username == &quot;root&quot;: ... 使用摩根定理简化一些逻辑表达式： 123if(!a &amp;&amp; !b) &#123; ...&#125; 123if(a || b) &#123; ...&#125; 变量与可读性去除控制流变量。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。 12345678boolean done = false;while(/* condition */ &amp;&amp; !done) &#123; ... if(...) &#123; done = true; continue; &#125;&#125; 123456while(/* condition */) &#123; ... if(...) &#123; break; &#125;&#125; 减小变量作用域。作用域越小，越容易定位到变量所有使用的地方。 JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。 1234567submitted = false;var submit_form = function(form_name) &#123; if(submitted) &#123; return; &#125; submitted = true;&#125;; 123456789var submit_form = (function() &#123; var submitted = false; return function(form_name) &#123; if(submitted) &#123; return; &#125; submitted = true; &#125;&#125;()); // () 使得外层匿名函数立即执行 JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。 变量定义的位置应当离它使用的位置最近。 实例解析 在一个网页中有以下文本输入字段： 1234&lt;input type = &quot;text&quot; id = &quot;input1&quot; value = &quot;a&quot;&gt;&lt;input type = &quot;text&quot; id = &quot;input2&quot; value = &quot;b&quot;&gt;&lt;input type = &quot;text&quot; id = &quot;input3&quot; value = &quot;&quot;&gt;&lt;input type = &quot;text&quot; id = &quot;input4&quot; value = &quot;d&quot;&gt; 现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下： 123456789101112131415var setFirstEmptyInput = function(new_alue) &#123; var found = false; var i = 1; var elem = document.getElementById(&apos;input&apos; + i); while(elem != null) &#123; if(elem.value === &apos;&apos;) &#123; found = true; break; &#125; i++; elem = document.getElementById(&apos;input&apos; + i); &#125; if(found) elem.value = new_value; return elem;&#125; 以上实现有以下问题： found 可以去除； elem 作用域过大； 可以用 for 循环代替 while 循环； 123456789101112var setFirstEmptyInput = function(new_value) &#123; for(var i = 1; true; i++) &#123; var elem = document.getElementById(&apos;input&apos; + i); if(elem === null) &#123; return null; &#125; if(elem.value === &apos;&apos;) &#123; elem.value = new_value; return elem; &#125; &#125;&#125;; 抽取函数工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。 首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。 介绍性的代码： 12345678910111213141516int findClostElement(int[] arr) &#123; int clostIdx; int clostDist = Interger.MAX_VALUE; for(int i = 0; i &lt; arr.length; i++) &#123; int x = ...; int y = ...; int z = ...; int value = x * y * z; int dist = Math.sqrt(Math.pow(value, 2), Math.pow(arr[i], 2)); if(dist &lt; clostDist) &#123; clostIdx = i; clostDist = value; &#125; &#125; return clostIdx;&#125; 以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。 123456789101112public int findClostElement(int[] arr) &#123; int clostIdx; int clostDist = Interger.MAX_VALUE; for(int i = 0; i &lt; arr.length; i++) &#123; int dist = computDist(arr, i); if(dist &lt; clostDist) &#123; clostIdx = i; clostDist = value; &#125; &#125; return clostIdx;&#125; 并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。 函数抽取也用于减小代码的冗余。 一次只做一件事只做一件事的代码很容易让人知道其要做的事； 基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。 用自然语言表述代码先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。 减少代码量不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。 多用标准库实现。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2Fblog%2F38943.html</url>
    <content type="text"><![CDATA[Java面试笔记 关键字1. final数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变；对于引用对象，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 方法 声明方法不能被子类覆盖。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是覆盖基类方法，而是重载了。 类 声明类不允许被继承。 2. static变量 静态变量在内存中只存在一份，只在类第一次实例化时初始化一次，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。 但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。 方法 静态方法在类加载的时候就存在了，它不依赖于任何实例，所以 static 方法必须实现，也就是说他不能是抽象方法 abstract。 静态语句块 静态语句块和静态变量一样在类第一次实例化时运行一次。 初始化顺序 静态数据优先于其它数据的初始化，静态变量和静态语句块哪个先运行取决于它们在代码中的顺序。 1public static String staticField = " 静态变量 "; 123static &#123; System.out.println(" 静态初始化块 ");&#125; 实例变量和普通语句块的初始化在静态变量和静态语句块初始化结束之后。 1public String field = " 变量 "; 123&#123; System.out.println(" 初始化块 ");&#125; 最后才是构造函数中的数据进行初始化 123public InitialOrderTest() &#123; System.out.println(" 构造器 ");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态初始化块） 子类（静态变量、静态初始化块） 父类（变量、初始化块） 父类（构造器） 子类（变量、初始化块） 子类（构造器） Object 通用方法1. 概览 public final native Class&lt;?&gt; getClass() public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException protected void finalize() throws Throwable { } 2. clone()浅拷贝 引用类型引用的是同一个对象，clone() 方法默认就是浅拷贝实现。 深拷贝 可以使用序列化实现。 How do I copy an object in Java? 3. equals() 对于基本类型，== 就是判断两个值是否相等； 对于引用类型，== 是判断两个引用是否引用同一个对象，而 equals() 是判断引用的对象是否等价。 等价性： 散列 继承1. 访问权限Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。 可以对类或类中的成员（字段以及方法）加上访问修饰符。成员可见表示其它类可以用成员所在类的对象访问到该成员；类可见表示其它类可以用这个类创建对象，可以把类当做包中的一个成员，然后包表示一个类，这样就好理解了。 protected 用于修饰成员，表示在继承体系中成员对于子类可见。但是这个访问修饰符对于类没有意义，因为包没有继承体系。 更详细的内容： 浅析 Java 中的访问权限控制 2. 抽象类与接口的区别抽象类至少包含一个抽象方法，该抽象方法必须在子类中实现。由于抽象类没有抽象方法的具体实现，因此不能对抽象类进行实例化。 123456789public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123; // abstract method abstract void service(ServletRequest req, ServletResponse res); void init() &#123; // Its implementation &#125; // other method related to Servlet&#125; 接口定义了一组方法，但是接口都没有方法的实现，也就是说这些方法都是抽象方法。 123456public interface Externalizable extends Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 更详细的内容：Java 抽象类与接口的区别 3. super()用来访问父类的构造函数父类的方法，第二种情况中，子类需要重载父类的方法。 1234567891011public class Subclass extends Superclass &#123; // overrides printMethod in Superclass public void printMethod() &#123; super.printMethod(); System.out.println("Printed in Subclass"); &#125; public static void main(String[] args) &#123; Subclass s = new Subclass(); s.printMethod(); &#125;&#125; Using the Keyword super String1. String, StringBuffer and StringBuilder是否可变 String 不可变，StringBuffer 和 StringBuilder 可变。 是否线程安全 String 不可变，因此是线程安全的。 StringBuilder 不是线程安全的；StringBuffer 是线程安全的，使用 synchronized 来同步。 String, StringBuffer, and StringBuilder 2. String 不可变的原因可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 等。不可变的特性可以使得 hash 值也不可变，因此就只需要进行一次计算。 String Pool 的需要 如果 String 已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 安全性 String 经常作为参数，例如网络连接参数等，在作为网络连接参数的情况下，如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。String 不可变性可以保证参数不可变。 线程安全 String 不可变性天生具备线程安全，可以在多个线程中使用。 Why String is immutable in Java? 3. String.intern()使用 String.intern() 可以保证所有相同内容的字符串变量引用相同的内存对象。 更详细的内容： 揭开 String.intern() 那神秘的面纱 基本类型与运算1. 包装类型八个基本类型：boolean 1 byte 8 char 16 short 16 int 32 float 32 long 64 double 64 基本类型都有对应的包装类型，它们之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 new Integer(123) 与 Integer.valueOf(123) 的区别在于，Integer.valueOf(123) 可能会使用缓存对象，因此多次使用 Integer.valueOf(123) 会取得同一个对象的引用。 12345678910111213public static void main(String[] args) &#123; Integer a = new Integer(1); Integer b = new Integer(1); System.out.println("a==b? " + (a==b)); Integer c = Integer.valueOf(1); Integer d = Integer.valueOf(1); System.out.println("c==d? " + (c==d)); &#125; 12a==b? falsec==d? true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。 1234567public static Integer valueOf(int i) &#123; final int offset = 128; if (i &gt;= -128 &amp;&amp; i &lt;= 127) &#123; // must cache return IntegerCache.cache[i + offset]; &#125; return new Integer(i);&#125; The following is the list of primitives stored as immutable objects: boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 自动装箱过程编译器会调用 valueOf() 方法，因此多个 Integer 对象使用装箱来创建并且值相同，那么就会引用相同的对象，这样做很显然是为了节省内存开销。 123Integer x = 1;Integer y = 1;System.out.println(c==d); // true Differences between new Integer(123), Integer.valueOf(123) and just 123 2. switchA switch works with the byte, short, char, and int primitive data types. It also works with enumerated types (discussed in Classes and Inheritance) and a few special classes that “wrap” certain primitive types: Character, Byte, Short, and Integer (discussed in Simple Data Objects). In the JDK 7 release, you can use a String object in the expression of a switch statement. switch 不支持 long，是因为 swicth 的设计初衷是为那些只需要对少数几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。 Why can’t your switch statement data type be long, Java? switch 使用查找表的方式来实现，JVM 中使用的指令是 lookupswitch。 12345678910111213141516171819public static void main(String... args) &#123; switch (1) &#123; case 1: break; case 2: break; &#125;&#125;public static void main(java.lang.String[]); Code: Stack=1, Locals=1, Args_size=1 0: iconst_1 1: lookupswitch&#123; //2 1: 28; 2: 31; default: 31 &#125; 28: goto 31 31: return How does Java’s switch work under the hood? 反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(‘com.mysql.jdbc.Driver.class’) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库包含了 Field、Method 以及 Constructor 类。可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段，可以使用 invoke() 方法调用与 Method 对象关联的方法，可以用 Constructor 创建新的对象。 IDE 使用反射机制获取类的信息，在使用一个类的对象时，能够把类的字段、方法和构造函数等信息列出来供用户选择。 更详细的内容： 深入解析 Java 反射（1）- 基础 异常Throwable 可以用来表示任何可以作为异常抛出的类，分为两种：Error 和 Exception，其中 Error 用来表示编译时系统错误。 Exception 分为两种：受检异常 和 非受检异常。受检异常需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；非受检异常是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序奔溃并且无法恢复。 更详细的内容： Java 入门之异常处理 Java 异常的面试问题及答案 -Part 1 泛型泛型提供了编译时的类型检测机制，该机制允许程序员在编译时检测到非法的类型。泛型是 Java 中一个非常重要的知识点，在 Java 集合类框架中泛型被广泛应用。 123456public class Box&lt;T&gt; &#123; // T stands for "Type" private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 更详细的内容： Java 泛型详解 10 道 Java 泛型面试题 特性1. 三大特性 封装、继承、多态 2. Java 各版本的新特性New highlights in Java SE 8 Lambda Expressions Pipelines and Streams Date and Time API Default Methods Type Annotations Nashhorn JavaScript Engine Concurrent Accumulators Parallel operations PermGen Error Removed New highlights in Java SE 7 Strings in Switch Statement Type Inference for Generic Instance Creation Multiple Exception Handling Support for Dynamic Languages Try with Resources Java nio Package Binary Literals, Underscore in literals Diamond Syntax Difference between Java 1.8 and Java 1.7? 更详细的内容：Java 8 特性 3. Java 与 C++ 的区别Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 比较详细的内容： Java C++ Java does not support pointers, templates, unions, operator overloading, structures etc. The Java language promoters initially said “No pointers!”, but when many programmers questioned how you can work without pointers, the promoters began saying “Restricted pointers.” Java supports what it calls “references”. References act a lot like pointers in C++ languages but you cannot perform arithmetic on pointers in Java. References have types, and they’re type-safe. These references cannot be interpreted as raw address and unsafe conversion is not allowed. C++ supports structures, unions, templates, operator overloading, pointers and pointer arithmetic. Java support automatic garbage collection. It does not support destructors as C++ does. C++ support destructors, which is automatically invoked when the object is destroyed. Java does not support conditional compilation and inclusion. Conditional inclusion (#ifdef #ifndef type) is one of the main features of C++. Java has built in support for threads. In Java, there is a Thread class that you inherit to create a new thread and override the run() method. C++ has no built in support for threads. C++ relies on non-standard third-party libraries for thread support. Java does not support default arguments. There is no scope resolution operator (::) in Java. The method definitions must always occur within a class, so there is no need for scope resolution there either. C++ supports default arguments. C++ has scope resolution operator (::) which is used to to define a method outside a class and to access a global variable within from the scope where a local variable also exists with the same name. There is no goto statement in Java. The keywords const and goto are reserved, even though they are not used. C++ has goto statement. However, it is not considered good practice to use of goto statement. Java doesn’t provide multiple inheritance, at least not in the same sense that C++ does. C++ does support multiple inheritance. The keyword virtual is used to resolve ambiguities during multiple inheritance if there is any. Exception handling in Java is different because there are no destructors. Also, in Java, try/catch must be defined if the function declares that it may throw an exception. While in C++, you may not include the try/catch even if the function throws an exception. Java has method overloading, but no operator overloading. The String class does use the + and += operators to concatenate strings and Stringexpressions use automatic type conversion, but that’s a special built-in case. C++ supports both method overloading and operator overloading. Java has built-in support for documentation comments (/** ... */); therefore, Java source files can contain their own documentation, which is read by a separate tool usually javadoc and reformatted into HTML. This helps keeping documentation maintained in easy way. C++ does not support documentation comments. Java is interpreted for the most part and hence platform independent. C++ generates object code and the same code may not run on different platforms. What are the main differences between Java and C++? 4. JRE or JDK JRE is the JVM program, Java application need to run on JRE. JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler “javac”]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器]]></title>
    <url>%2Fblog%2F1744.html</url>
    <content type="text"><![CDATA[Java面试笔记 概览 容器主要包括 Collection 和 Map 两种，Collection 又包含了 List、Set 以及 Queue。 1. List ArrayList：基于动态数组实现，支持随机访问； LinkedList：基于双向循环链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双端队列。 2. Set HashSet：基于 Hash 实现，支持快速查找，但是失去有序性； TreeSet：基于红黑树实现，保持有序，但是查找效率不如 HashSet； LinkedListHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序，因此具有有序性。 3. Queue只有两个实现：LinkedList 和 PriorityQueue，其中 LinkedList 支持双向队列，PriorityQueue 是基于堆结构实现。 4. Map HashMap：基于 Hash 实现 LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序 TreeMap：基于红黑树实现 ConcurrentHashMap：线程安全 Map，不涉及类似于 HashTable 的同步加锁 5. Java 1.0/1.1 容器对于旧的容器，我们决不应该使用它们，只需要对它们进行了解。 Vector：和 ArrayList 类似，但它是线程安全的 HashTable：和 HashMap 类似，但它是线程安全的 容器中的设计模式1. 迭代器模式从概览图可以看到，每个集合类都有一个 Iterator 对象，可以通过这个迭代器对象来遍历集合中的元素。 Java 中的迭代器模式 2. 适配器模式java.util.Arrays#asList() 可以把数组类型转换为 List 类型。 123List list = Arrays.asList(1, 2, 3);int[] arr = &#123;1, 2, 3&#125;;list = Arrays.asList(arr); 散列使用 hasCode() 来返回散列值，使用的是对象的地址。 而 equals() 是用来判断两个对象是否相等的，相等的两个对象散列值一定要相同，但是散列值相同的两个对象不一定相等。 相等必须满足以下五个性质： 自反性 对称性 传递性 一致性（多次调用 x.equals(y)，结果不变） 对任何不是 null 的对象 x 调用 x.equals(nul) 结果都为 false 源码分析建议先阅读 算法 - 查找 部分，对集合类源码的理解有很大帮助。 源码下载：OpenJDK 1.7 1. ArraListArraList.java 实现了 RandomAccess 接口，因此支持随机访问，这是理所当然的，因为 ArrayList 是基于数组实现的。 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 基于数组实现，保存元素的数组使用 transient 修饰，这是因为该数组不一定所有位置都占满元素，因此也就没必要全部都进行序列化。需要重写 writeObject() 和 readObject()。 1private transient Object[] elementData; 数组的默认大小为 10 12345678910public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity];&#125;public ArrayList() &#123; this(10);&#125; 删除元素时调用 System.arraycopy() 对元素进行复制，因此删除操作成本很高，最好在创建时就指定大概的容量大小，减少复制操作的执行次数。 12345678910111213public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue;&#125; 添加元素时使用 ensureCapacity() 方法来保证容量足够，如果不够时，需要进行扩容，使得新容量为旧容量的 1.5 倍。 modCount 用来记录 ArrayList 发生变化的次数，因为每次在进行 add() 和 addAll() 时都需要调用 ensureCapacity()，因此直接在 ensureCapacity() 中对 modCount 进行修改。 123456789101112131415161718192021222324252627282930313233public void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) ensureCapacityInternal(minCapacity);&#125;private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out array length s.writeInt(elementData.length); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 和 Vector 的区别 Vector 和 ArrayList 几乎是完全相同的，唯一的区别在于 Vector 是同步的，因此开销就比 ArrayList 要大，访问要慢。最好使用 ArrayList 而不是 Vector，因为同步完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 为了使用线程安全的 ArrayList，可以使用 Collections.synchronizedList(new ArrayList&lt;&gt;()); 返回一个线程安全的 ArrayList，也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类； 和 LinkedList 的区别 ArrayList 基于动态数组实现，LinkedList 基于双向循环链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 2. Vector 与 StackVector.java 3. LinkedListLinkedList.java 4. TreeMapTreeMap.java 5. HashMapHashMap.java 使用拉链法来解决冲突。 默认容量 capacity 为 16，需要注意的是容量必须保证为 2 的次方。容量就是 Entry[] table 数组的长度，size 是数组的实际使用量。 threshold 规定了一个 size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。 threshold = capacity * load_factor，其中 load_factor 为 table 数组能够使用的比例，load_factor 过大会导致聚簇的出现，从而影响查询和插入的效率，详见算法笔记。 123456789101112131415static final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount; 从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。 123456void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); if (size++ &gt;= threshold) resize(2 * table.length);&#125; Entry 用来表示一个键值对元素，其中的 next 指针在序列化时会使用。 123456static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash;&#125; get() 操作需要分成两种情况，key 为 null 和 不为 null，从中可以看出 HashMap 允许插入 null 作为键。 1234567891011public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; put() 操作也需要根据 key 是否为 null 做不同的处理，需要注意的是如果本来没有 key 为 null 的键值对，新插入一个 key 为 null 的键值对时默认是放在数组的 0 位置，这是因为 null 不能计算 hash 值，也就无法知道应该放在哪个链表上。 12345678910111213141516171819public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 12345678910111213private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; 6. LinkedHashMapLinkedHashMap.java 7. ConcurrentHashMapConcurrentHashMap.java 探索 ConcurrentHashMap 高并发性的实现机制 参考资料 Java 编程思想]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO]]></title>
    <url>%2Fblog%2F11330.html</url>
    <content type="text"><![CDATA[Java面试笔记 概览Java 的 I/O 大概可以分成以下几类 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 非阻塞式 IO：NIO 磁盘操作File 类可以用于表示文件和目录，但是它只用于表示文件的信息，而不表示文件的内容。 字节操作 Java I/O 使用了装饰者模式来实现。以 InputStream 为例，InputStream 是抽象组件，FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作。FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能，例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。 1BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。 批量读入文件中的内容到字节数组中 123456byte[] buf = new byte[20*1024];int bytes = 0;// 最多读取 buf.length 个字节，返回的是实际读取的个数，返回 -1 的时候表示读到 eof，即文件尾while((bytes = in.read(buf, 0 , buf.length)) != -1) &#123; // ...&#125; 字符操作不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是在程序中操作的数据通常是字符形式，因此需要提供对字符进行操作的方法。 InputStreamReader 实现从文本文件的字节流解码成字符流；OutputStreamWriter 实现字符流编码成为文本文件的字节流。它们都继承自 Reader 和 Writer。 编码就是把字符转换为字节，而解码是把字节重新组合成字符。 12byte[] bytes = str.getBytes(encoding); // 编码String str = new String(bytes, encoding)； // 解码 GBK 编码中，中文占 2 个字节，英文占 1 个字节；UTF-8 编码中，中文占 3 个字节，英文占 1 个字节；Java 使用双字节编码 UTF-16be，中文和英文都占 2 个字节。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 对象操作序列化就是将一个对象转换成字节序列，方便存储和传输。 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() 序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现。 transient 关键字可以使一些属性不会被序列化。 ArrayList 序列化和反序列化的实现：ArrayList 中存储数据的数组是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。 1private transient Object[] elementData; 网络操作Java 中的网络支持： InetAddress：用于表示网络上的硬件资源，即 IP 地址； URL：统一资源定位符，通过 URL 可以直接读取或者写入网络上的数据； Sockets：使用 TCP 协议实现网络通信； Datagram：使用 UDP 协议实现网络通信。 1. InetAddress没有公有构造函数，只能通过静态方法来创建实例，比如 InetAddress.getByName(String host)、InetAddress.getByAddress(byte[] addr)。 2. URL可以直接从 URL 中读取字节流数据 123456789101112URL url = new URL("http://www.baidu.com");InputStream is = url.openStream(); // 字节流InputStreamReader isr = new InputStreamReader(is, "utf-8"); // 字符流BufferedReader br = new BufferedReader(isr);String line = br.readLine();while (line != null) &#123; System.out.println(line); line = br.readLine();&#125;br.close();isr.close();is.close(); 3. SocketsSocket 通信模型 ServerSocket：服务器端类 Socket：客户端类 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。 4. Datagram DatagramPacket：数据包类 DatagramSocket：通信类 NIONIO 将最耗时的 I/O 操作 ( 即填充和提取缓冲区 ) 转移回操作系统，因而 不需要程序员去控制就可以极大地提高运行速度。 1. 流与块I/O 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I/O 一次一个字节进行处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。 一个面向块的 I/O 系统以块的形式处理数据，每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如， java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在更面向流的系统中，处理速度也会更快。 2. 通道与缓冲区2.1 通道通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。 通道与流的不同之处在于，流只能在一个方向上移动，(一个流必须是 InputStream 或者 OutputStream 的子类)， 而通道是双向的，可以用于读、写或者同时用于读写。 通道包括以下类型： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 2.2 缓冲区发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是先经过缓冲区。 缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。 缓冲区包括以下类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 3. 缓冲区状态变量 capacity：最大容量； position：当前已经读写的字节数； limit：还可以读写的字节数。 状态变量的改变过程： 1. 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit == capacity == 9。capacity 变量不会改变，下面的讨论会忽略它。 2. 从输入通道中读取 3 个字节数据写入缓冲区中，此时 position 移动设为 3，limit 保持不变。 3. 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。 4. 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。 5. 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。 4. 读写文件实例1. 为要读取的文件创建 FileInputStream，之后通过 FileInputStream 获取输入 FileChannel； 12FileInputStream fin = new FileInputStream("readandshow.txt");FileChannel fic = fin.getChannel(); 2. 创建一个容量为 1024 的 Buffer 1ByteBuffer buffer = ByteBuffer.allocate(1024); 3. 将数据从输入 FileChannel 写入到 Buffer 中，如果没有数据的话， read() 方法会返回 -1 1234int r = fcin.read(buffer);if (r == -1) &#123; break;&#125; 4. 为要写入的文件创建 FileOutputStream，之后通过 FileOutputStream 获取输出 FileChannel 12FileOutputStream fout = new FileOutputStream("writesomebytes.txt");FileChannel foc = fout.getChannel(); 5. 调用 flip() 切换读写 1buffer.flip(); 6. 把 Buffer 中的数据读取到输出 FileChannel 中 1foc.write(buffer); 7. 最后调用 clear() 重置缓冲区 1buffer.clear(); 5. 阻塞与非阻塞应当注意，FileChannel 不能切换到非阻塞模式，套接字 Channel 可以。 5.1 阻塞式 I/O阻塞式 I/O 在调用 InputStream.read() 方法时会一直等到数据到来时（或超时）才会返回，在调用 ServerSocket.accept() 方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。 5.2 非阻塞式 I/O由一个专门的线程来处理所有的 I/O 事件，并负责分发。 事件驱动机制：事件到的时候触发，而不是同步的去监视事件。 线程通信：线程之间通过 wait()、notify() 等方式通信，保证每次上下文切换都是有意义的，减少无谓的线程切换。 6. 套接字实例6.1 ServerSocketChannel每一个端口都需要有一个 ServerSocketChannel 用来监听连接。 123456ServerSocketChannel ssc = ServerSocketChannel.open();ssc.configureBlocking(false); // 设置为非阻塞ServerSocket ss = ssc.socket();InetSocketAddress address = new InetSocketAddress(ports[i]);ss.bind(address); // 绑定端口号 6.2 Selectors异步 I/O 通过 Selector 注册对特定 I/O 事件的兴趣 ― 可读的数据的到达、新的套接字连接等等，在发生这样的事件时，系统将会发送通知。 创建 Selectors 之后，就可以对不同的通道对象调用 register() 方法。register() 的第一个参数总是这个 Selector。第二个参数是 OP_ACCEPT，这里它指定我们想要监听 accept 事件，也就是在新的连接建立时所发生的事件。 SelectionKey 代表这个通道在此 Selector 上的这个注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。 12Selector selector = Selector.open();SelectionKey key = ssc.register(selector, SelectionKey.OP_ACCEPT); 6.3 主循环首先，我们调用 Selector 的 select() 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， select() 方法将返回所发生的事件的数量。 接下来，我们调用 Selector 的 selectedKeys() 方法，它返回发生了事件的 SelectionKey 对象的一个 集合 。 我们通过迭代 SelectionKeys 并依次处理每个 SelectionKey 来处理事件。对于每一个 SelectionKey，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。 123456789int num = selector.select(); Set selectedKeys = selector.selectedKeys();Iterator it = selectedKeys.iterator(); while (it.hasNext()) &#123; SelectionKey key = (SelectionKey)it.next(); // ... deal with I/O event ...&#125; 6.4 监听新连接程序执行到这里，我们仅注册了 ServerSocketChannel，并且仅注册它们“接收”事件。为确认这一点，我们对 SelectionKey 调用 readyOps() 方法，并检查发生了什么类型的事件： 12345if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123; // Accept the new connection // ...&#125; 可以肯定地说， readOps() 方法告诉我们该事件是新的连接。 6.5 接受新的连接因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 accept() 操作会阻塞： 12ServerSocketChannel ssc = (ServerSocketChannel)key.channel();SocketChannel sc = ssc.accept(); 下一步是将新连接的 SocketChannel 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 SocketChannel 注册到 Selector上，如下所示： 12sc.configureBlocking( false );SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ ); 注意我们使用 register() 的 OP_READ 参数，将 SocketChannel 注册用于 读取 而不是 接受 新连接。 6.6 删除处理过的 SelectionKey在处理 SelectionKey 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的 remove() 方法来删除处理过的 SelectionKey： 1it.remove(); 现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的 I/O 事件)了。 6.7 传入的 I/O当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 Selector.select()，并返回一个或者多个 I/O 事件。这一次， SelectionKey 将被标记为 OP_READ 事件，如下所示： 123456&#125; else if ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123; // Read the data SocketChannel sc = (SocketChannel)key.channel(); // ...&#125; 参考资料 Eckel B, 埃克尔 , 昊鹏 , 等 . Java 编程思想 [M]. 机械工业出版社 , 2002. IBM: NIO 入门 深入分析 Java I/O 的工作机制 NIO 与传统 IO 的区别]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2Fblog%2F41682.html</url>
    <content type="text"><![CDATA[Java面试笔记 第一章 设计模式入门1. 设计模式概念 设计模式不是代码，而是解决问题的方案，学习现有的设计模式可以做到经验复用。 拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。 2. 问题描述 设计不同种类的鸭子拥有不同的叫声和飞行方式。 3. 简单实现方案 使用继承的解决方案如下，这种方案代码无法复用，如果两个鸭子类拥有同样的飞行方式，就有两份重复的代码。 4. 设计原则 封装变化在这里变化的是鸭子叫和飞行的行为方式。 针对接口编程，而不是针对实现编程 变量声明的类型为父类，而不是具体的某个子类。父类中的方法实现不在父类，而是在各个子类。程序在运行时可以动态改变变量所指向的子类类型。 运用这一原则，将叫和飞行的行为抽象出来，实现多种不同的叫和飞行的子类，让子类去实现具体的叫和飞行方式。 多用组合，少用继承 组合也就是 has-a 关系，通过组合，可以在运行时动态改变实现，只要通过改变父类对象具体指向哪个子类即可。而继承就不能做到这些，继承体系在创建类时就已经确定。 运用这一原则，在 Duck 类中组合 FlyBehavior 和 QuackBehavior 类，performQuack() 和 performFly() 方法委托给这两个类去处理。通过这种方式，一个 Duck 子类可以根据需要去实例化 FlyBehavior 和 QuackBehavior 的子类对象，并且也可以动态地进行改变。 5. 整体设计图 6. 模式定义 策略模式 ：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 7. 实现代码 1234567891011121314151617181920212223public abstract class Duck &#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck()&#123; &#125; public void performFly()&#123; flyBehavior.fly(); &#125; public void setFlyBehavior(FlyBehavior fb)&#123; flyBehavior = fb; &#125; public void performQuack()&#123; quackBehavior.quack(); &#125; public void setQuackBehavior(QuackBehavior qb)&#123; quackBehavior = qb; &#125;&#125; 123456public class MallarDuck extends Duck&#123; public MallarDuck()&#123; flyBehavior = new FlyWithWings(); quackBehavior = new Quack(); &#125;&#125; 123public interface FlyBehavior &#123; void fly();&#125; 123456public class FlyNoWay implements FlyBehavior&#123; @Override public void fly() &#123; System.out.println("FlyBehavior.FlyNoWay"); &#125;&#125; 123456public class FlyWithWings implements FlyBehavior&#123; @Override public void fly() &#123; System.out.println("FlyBehavior.FlyWithWings"); &#125;&#125; 123public interface QuackBehavior &#123; void quack();&#125; 123456public class Quack implements QuackBehavior&#123; @Override public void quack() &#123; System.out.println("QuackBehavior.Quack"); &#125;&#125; 123456public class MuteQuack implements QuackBehavior&#123; @Override public void quack() &#123; System.out.println("QuackBehavior.MuteQuack"); &#125;&#125; 123456public class Squeak implements QuackBehavior&#123; @Override public void quack() &#123; System.out.println("QuackBehavior.Squeak"); &#125;&#125; 123456789public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck mallarDuck = new MallarDuck(); mallarDuck.performQuack(); mallarDuck.performFly(); mallarDuck.setFlyBehavior(new FlyNoWay()); mallarDuck.performFly(); &#125;&#125; 执行结果123QuackBehavior.QuackFlyBehavior.FlyWithWingsFlyBehavior.FlyNoWay 第二章 观察者模式1. 模式定义 定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新。主题（Subject）是被观察的对象，而其所有依赖者（Observer）成为观察者。 2. 模式类图 主题中具有注册和移除观察者，并通知所有注册者的功能，主题是通过维护一张观察者列表来实现这些操作的。 观察者拥有一个主题对象的引用，因为注册、移除还有数据都在主题当中，必须通过操作主题才能完成相应功能。 3. 问题描述 天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。 4. 解决方案类图 5. 设计原则 为交互对象之间的松耦合设计而努力 当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。由于松耦合的两个对象之间互相依赖程度很低，因此系统具有弹性，能够应对变化。 6. 实现代码 12345public interface Subject &#123; public void resisterObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.List;public class WeatherData implements Subject &#123; private List&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;&gt;(); &#125; @Override public void resisterObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; @Override public void notifyObserver() &#123; for (Observer o : observers) &#123; o.update(temperature, humidity, pressure); &#125; &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); &#125;&#125; 123public interface Observer &#123; public void update(float temp, float humidity, float pressure);&#125; 12345678910111213public class CurrentConditionsDisplay implements Observer &#123; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.resisterObserver(this); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; System.out.println("CurrentConditionsDisplay.update:" + temp + " " + humidity + " " + pressure); &#125;&#125; 12345678910111213public class StatisticsDisplay implements Observer &#123; private Subject weatherData; public StatisticsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.resisterObserver(this); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; System.out.println("StatisticsDisplay.update:" + temp + " " + humidity + " " + pressure); &#125;&#125; 12345678910public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); weatherData.setMeasurements(0, 0, 0); weatherData.setMeasurements(1, 1, 1); &#125;&#125; 执行结果1234CurrentConditionsDisplay.update:0.0 0.0 0.0StatisticsDisplay.update:0.0 0.0 0.0CurrentConditionsDisplay.update:1.0 1.0 1.0StatisticsDisplay.update:1.0 1.0 1.0 第三章 装饰模式1. 问题描述 设计不同种类的饮料，并且每种饮料可以动态添加新的材料，比如可以添加牛奶。计算一种饮料的价格。 2. 模式定义 动态地将责任附加到对象上。在扩展功能上，装饰者提供了比继承更有弹性的替代方案。 下图中 DarkRoast 对象被 Mocha 包裹，Mocha 对象又被 Whip 包裹，并且他们都继承自相同父类，都有 cost() 方法，但是外层对象的 cost() 方法实现调用了内层对象的 cost() 方法。因此，如果要在 DarkRoast 上添加 Mocha，那么只需要用 Mocha 包裹 DarkRoast，如果还需要 Whip ，就用 Whip 包裹 Mocha，最后调用 cost() 方法能把三种对象的价格都包含进去。 3. 模式类图 装饰者和具体组件都继承自组件类型，其中具体组件的方法实现不需要依赖于其它对象，而装饰者拥有一个组件类型对象，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰的对象之外，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件有直接实现而不需要委托给其它对象去处理。 4. 问题解决方案的类图 5. 设计原则 类应该对扩展开放，对修改关闭。 也就是添加新功能时不需要修改代码。在本章问题中该原则体现在，在饮料中添加新的材料，而不需要去修改饮料的代码。观察则模式也符合这个原则。不可能所有类都能实现这个原则，应当把该原则应用于设计中最有可能改变的地方。 6. Java I/O 中的装饰者模式 7. 代码实现 123public interface Beverage &#123; public double cost();&#125; 123456public class HouseBlend implements Beverage&#123; @Override public double cost() &#123; return 1; &#125;&#125; 123456public class DarkRoast implements Beverage&#123; @Override public double cost() &#123; return 1; &#125;&#125; 123public abstract class CondimentDecorator implements Beverage&#123; protected Beverage beverage;&#125; 1234567891011public class Mocha extends CondimentDecorator &#123; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double cost() &#123; return 1 + beverage.cost(); &#125;&#125; 1234567891011public class Milk extends CondimentDecorator &#123; public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double cost() &#123; return 1 + beverage.cost(); &#125;&#125; 12345678public class StartbuzzCoffee &#123; public static void main(String[] args) &#123; Beverage beverage = new HouseBlend(); beverage = new Mocha(beverage); beverage = new Milk(beverage); System.out.println(beverage.cost()); &#125;&#125; 输出 13.0 第四章 工厂模式1. 简单工厂1. 问题描述 有不同的 Pizza，根据不同的情况用不同的子类实例化一个 Pizza 对象。 2. 定义 简单工厂不是设计模式，更像是一种编程习惯。在实例化一个超类的对象时，可以用它的所有子类来进行实例化，要根据具体需求来决定使用哪个子类。在这种情况下，把实例化的操作放到工厂来中，让工厂类来决定应该用哪个子类来实例化。这样做把客户对象和具体子类的实现解耦，客户对象不再需要知道有哪些子类以及实例化哪个子类。因为客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节，一旦子类发生改变，例如增加子类，那么所有的客户类都要发生改变。 3. 解决方案类图 4. 代码实现 123public interface Pizza &#123; public void make();&#125; 123456public class CheesePizza implements Pizza&#123; @Override public void make() &#123; System.out.println("CheesePizza"); &#125;&#125; 123456public class GreekPizza implements Pizza&#123; @Override public void make() &#123; System.out.println("GreekPizza"); &#125;&#125; 1234567891011public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; if (type.equals("cheese")) &#123; return new CheesePizza(); &#125; else if (type.equals("greek")) &#123; return new GreekPizza(); &#125; else &#123; throw new UnsupportedOperationException(); &#125; &#125;&#125; 1234567public class PizzaStore &#123; public static void main(String[] args) &#123; SimplePizzaFactory simplePizzaFactory = new SimplePizzaFactory(); Pizza pizza = simplePizzaFactory.createPizza("cheese"); pizza.make(); &#125;&#125; 运行结果 1CheesePizza 2. 工厂方法模式1. 问题描述 每个地区的 Pizza 店虽然种类相同，但是都有自己的风味，需要单独区分。例如，一个客户点了纽约的 cheese 种类的 Pizza 和在芝加哥点的相同种类的 Pizza 是不同的。 2. 模式定义 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 3. 模式类图 在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。下图中，Creator 有一个 anOperation() 方法，这个方法需要用到一组产品类，这组产品类由每个子类来创建。 可以为每个子类创建单独的简单工厂来创建每一个产品类，但是把简单工厂中创建对象的代码放到子类中来可以减少类的数目，因为子类不算是产品类，因此完全可以这么做。 4. 解决方案类图 5. 代码实现 123public interface Pizza &#123; public void make();&#125; 123public interface PizzaStore &#123; public Pizza orderPizza(String item);&#125; 123456public class NYStyleCheesePizza implements Pizza&#123; @Override public void make() &#123; System.out.println("NYStyleCheesePizza is making.."); &#125;&#125; 123456public class NYStyleVeggiePizza implements Pizza &#123; @Override public void make() &#123; System.out.println("NYStyleVeggiePizza is making.."); &#125;&#125; 123456public class ChicagoStyleCheesePizza implements Pizza&#123; @Override public void make() &#123; System.out.println("ChicagoStyleCheesePizza is making.."); &#125;&#125; 123456public class ChicagoStyleVeggiePizza implements Pizza&#123; @Override public void make() &#123; System.out.println("ChicagoStyleVeggiePizza is making.."); &#125;&#125; 123456789101112131415public class NYPizzaStore implements PizzaStore &#123; @Override public Pizza orderPizza(String item) &#123; Pizza pizza = null; if (item.equals("cheese")) &#123; pizza = new NYStyleCheesePizza(); &#125; else if (item.equals("veggie")) &#123; pizza = new NYStyleVeggiePizza(); &#125; else &#123; throw new UnsupportedOperationException(); &#125; pizza.make(); return pizza; &#125;&#125; 123456789101112131415public class ChicagoPizzaStore implements PizzaStore &#123; @Override public Pizza orderPizza(String item) &#123; Pizza pizza = null; if (item.equals("cheese")) &#123; pizza = new ChicagoStyleCheesePizza(); &#125; else if (item.equals("veggie")) &#123; pizza = new ChicagoStyleVeggiePizza(); &#125; else &#123; throw new UnsupportedOperationException(); &#125; pizza.make(); return pizza; &#125;&#125; 12345678public class PizzaTestDrive &#123; public static void main(String[] args) &#123; PizzaStore nyStore = new NYPizzaStore(); nyStore.orderPizza("cheese"); PizzaStore chicagoStore = new ChicagoPizzaStore(); chicagoStore.orderPizza("cheese"); &#125;&#125; 运行结果 12NYStyleCheesePizza is making..ChicagoStyleCheesePizza is making.. 3. 抽象工厂模式1. 设计原则 依赖倒置原则：要依赖抽象，不要依赖具体类。听起来像是针对接口编程，不针对实现编程，但是这个原则说明了：不能让高层组件依赖底层组件，而且，不管高层或底层组件，两者都应该依赖于抽象。例如，下图中 PizzaStore 属于高层组件，它依赖的是 Pizza 的抽象类，这样就可以不用关心 Pizza 的具体实现细节。 2. 模式定义 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 3. 模式类图 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂模式只是用于创建一个对象，这和抽象工厂模式有很大不同。并且，抽象工厂模式也用到了工厂模式来创建单一对象，在类图左部，AbstractFactory 中的 CreateProductA 和 CreateProductB 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂模式的定义。至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要这两个对象的协作才能完成任务。从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory ，而工厂模式使用了继承。 4. 解决方案类图 5. 代码实现 123public interface Dough &#123; public String doughType();&#125; 1234567public class ThickCrustDough implements Dough&#123; @Override public String doughType() &#123; return "ThickCrustDough"; &#125;&#125; 123456public class ThinCrustDough implements Dough &#123; @Override public String doughType() &#123; return "ThinCrustDough"; &#125;&#125; 123public interface Sauce &#123; public String sauceType();&#125; 123456public class MarinaraSauce implements Sauce &#123; @Override public String sauceType() &#123; return "MarinaraSauce"; &#125;&#125; 123456public class PlumTomatoSauce implements Sauce &#123; @Override public String sauceType() &#123; return "PlumTomatoSauce"; &#125;&#125; 1234public interface PizzaIngredientFactory &#123; public Dough createDough(); public Sauce createSauce();&#125; 1234567891011public class NYPizzaIngredientFactory implements PizzaIngredientFactory&#123; @Override public Dough createDough() &#123; return new ThickCrustDough(); &#125; @Override public Sauce createSauce() &#123; return new MarinaraSauce(); &#125;&#125; 1234567891011public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory&#123; @Override public Dough createDough() &#123; return new ThinCrustDough(); &#125; @Override public Sauce createSauce() &#123; return new PlumTomatoSauce(); &#125;&#125; 1234567891011121314public class NYPizzaStore &#123; private PizzaIngredientFactory ingredientFactory; public NYPizzaStore() &#123; ingredientFactory = new NYPizzaIngredientFactory(); &#125; public void makePizza() &#123; Dough dough = ingredientFactory.createDough(); Sauce sauce = ingredientFactory.createSauce(); System.out.println(dough.doughType()); System.out.println(sauce.sauceType()); &#125;&#125; 123456public class NYPizzaStoreTestDrive &#123; public static void main(String[] args) &#123; NYPizzaStore nyPizzaStore = new NYPizzaStore(); nyPizzaStore.makePizza(); &#125;&#125; 运行结果 12ThickCrustDoughMarinaraSauce 第五章 单件模式1. 模式定义 确保一个类只有一个实例，并提供了一个全局访问点。 2. 模式类图 单件模式的 Java 实现用一个私有构造器、一个私有静态变量以及一个公有静态函数，该函数返回私有变量，使得所有通过该函数获取的对象都指向这个唯一的私有静态变量。 3. 经典实现 以下实现中，私有静态变量被延迟化实例化，这样做的好处是，如果没有用到该类，那么就不会创建该私有静态变量，从而节约资源。这个实现在多线程环境下是不安全的，因为多个线程能够同时进入 if(uniqueInstance == null) 内的语句块，那么就会多次实例化 uniqueInstance 私有静态变量。 1234567891011121314public class Singleton &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 4. 线程不安全问题的解决方案一 只需要对 getUniqueInstance() 方法加锁，就能让该方法一次只能一个线程访问，从而避免了对 uniqueInstance 变量进行多次实例化的问题。但是这样有一个问题是一次只能一个线程进入，性能上会有一定的浪费。 123456public static synchronized Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance;&#125; 5. 线程不安全问题的解决方案二 不用延迟实例化，采用直接实例化。 1private static Singleton uniqueInstance = new Singleton(); 6. 线程不安全问题的解决方案三 考虑第一个解决方案，它是直接对 getUniqueInstance() 方法进行加锁，而实际上只需要对 uniqueInstance = new Singleton(); 这条语句加锁即可。使用两个条件语句来判断 uniqueInstance 是否已经实例化，如果没有实例化才需要加锁。 123456789101112131415161718public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 第六章 命令模式1. 问题描述 设计一个遥控器，它有很多按钮，每个按钮可以发起一个命令，让一个家电完成相应操作。有非常多的家电，并且也会增加家电。 2. 模式定义 将命令封装成对象，以便使用不同的命令来参数化其它对象。 3. 模式类图 4. 解决方案类图 Invoker 是遥控器，它可以设置命令，并且调用命令对象的 execute() 方法。Receiver 是电灯，是命令真正的执行者。ConcreteCommand 类组合了一个 Receiver 对象，命令的执行委托给 Receiver 对象来处理，也就是 LightOnCommand 命令的 excute 方法委托给 Light 对象来处理，Light 对象通过调用 on() 方法来完成操作。Invoker 不是 Client 对象，是因为命令的创建不是在 Invoker 中完成的，因此需要额外的 Client 对象来处理这些操作。 5. 代码实现 123public interface Command &#123; public void execute();&#125; 12345678910public class Light &#123; public void on() &#123; System.out.println("Light is on!"); &#125; public void off() &#123; System.out.println("Light is off!"); &#125;&#125; 123456789101112public class LightOnCommand implements Command&#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125;&#125; 12345678910111213141516171819/** * 遥控器类 */public class SimpleRemoteControl &#123; Command slot; public SimpleRemoteControl() &#123; &#125; public void setCommand(Command command) &#123; this.slot = command; &#125; public void buttonWasPressed() &#123; slot.execute(); &#125;&#125; 123456789public class RemoteLoader &#123; public static void main(String[] args) &#123; SimpleRemoteControl remote = new SimpleRemoteControl(); Light light = new Light(); LightOnCommand lightOnCommand = new LightOnCommand(light); remote.setCommand(lightOnCommand); remote.buttonWasPressed(); &#125;&#125; 输出 1Light is on! 第七章 适配器模式与外观模式1. 适配器模式1. 模式定义 将一个类的接口，转换为客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。 2. 模式类图 有两种适配器模式的实现，一种是对象方式，一种是类方式。对象方式是通过组合的方法，让适配器类（Adapter）拥有一个待适配的对象（Adaptee），从而把相应的处理委托给待适配的对象。类方式用到多重继承，Adapter 可以看成 Target 和 Adaptee 类型，先把它当成 Adaptee 类型然后实例化一个 Adapter 对象，再把它当成 Target 类型的，这样 Client 就可以把这个对象当成 Target 的对象来处理。 3. 问题描述 让鸭子（Duck）适配火鸡（Turkey），Duck 有 quack() 方法，而 Turkey 只有 gobble() 方法。也就是要让 Turkey 也有 Duck 的 quack() 方法。 4. 解决方案类图 5. 代码实现 1234public interface Duck &#123; public void quack(); public void fly();&#125; 1234public interface Turkey &#123; public void gobble(); public void fly();&#125; 1234567891011public class WildTurkey implements Turkey&#123; @Override public void gobble() &#123; System.out.println("gobble!"); &#125; @Override public void fly() &#123; System.out.println("fly!"); &#125;&#125; 1234567891011121314151617public class TurkeyAdapter implements Duck&#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; turkey.gobble(); &#125; @Override public void fly() &#123; turkey.fly(); &#125;&#125; 12345678public class DuckTestDrive &#123; public static void main(String[] args) &#123; Turkey turkey = new WildTurkey(); Duck duck = new TurkeyAdapter(turkey); duck.quack(); duck.fly(); &#125;&#125; 运行结果12gobble!fly! 2. 外观模式1. 模式定义 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 2. 模式类图 3. 问题描述 家庭影院中有众多电器，当要进行观看电影时需要对很多电器进行操作。要求简化这些操作，使得家庭影院类只提供一个简化的接口，例如提供一个看电影的接口而不用具体操作众多电器。 4. 解决方案类图 5. 设计原则 最少知识原则：只和你的密友谈话。也就是应当使得客户对象所需要交互的对象应当尽可能少。 第八章 模板方法模式1. 模式定义 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 2. 模式类图 模板方法 templateMethod() 定义了算法的骨架，确定了 primitiveOperation1() 和 primitiveOperation2() 方法执行的顺序，而 primitiveOperation1() 和 primitiveOperation2() 让子类去具体实现。 3. 问题描述 冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样。 4. 解决方案类图 5. 设计原则 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。这一原则可以防止依赖腐败，即防止高层组件依赖底层组件，底层组件又依赖高层组件。该原则在模板方法的体现为，只有父类会调用子类，子类不会调用父类。 6. 钩子 钩子（hock）：某些步骤在不同实现中可有可无，可以先定义一个什么都不做的方法，把它加到模板方法 templteMethod() 中，如果子类需要它就覆盖默认实现并加上自己的实现。 7. 代码实现 123456789101112131415161718192021public abstract class CaffeineBeverage &#123; final void prepareRecipe()&#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; abstract void brew(); abstract void addCondiments(); void boilWater()&#123; System.out.println("boilWater"); &#125; void pourInCup()&#123; System.out.println("pourInCup"); &#125;&#125; 1234567891011public class Coffee extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println("Coffee.brew"); &#125; @Override void addCondiments() &#123; System.out.println("Coffee.addCondiments"); &#125;&#125; 1234567891011public class Tea extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println("Tea.brew"); &#125; @Override void addCondiments() &#123; System.out.println("Tea.addCondiments"); &#125;&#125; 123456789public class CaffeineBeverageTestDrive &#123; public static void main(String[] args) &#123; CaffeineBeverage caffeineBeverage = new Coffee(); caffeineBeverage.prepareRecipe(); System.out.println("-----------"); caffeineBeverage = new Tea(); caffeineBeverage.prepareRecipe(); &#125;&#125; 运行结果 123456789boilWaterCoffee.brewpourInCupCoffee.addCondiments-----------boilWaterTea.brewpourInCupTea.addCondiments 第九章 迭代器和组合模式1. 迭代器模式1. 模式定义 提供一种顺序访问一个聚合对象中的各个元素的方法，而又不暴露其内部的表示。 2. 模式类图 客户类拥有一个聚合对象和迭代器对象，迭代器对象是聚合对象生成的。只需要迭代器定义好移动的操作，就可以让聚合对象能够顺序遍历。 3. 代码实现 12345678910111213141516public class Aggregate &#123; private int[] items; public Aggregate() &#123; items = new int[10]; for (int i = 0; i &lt; items.length; i++) &#123; items[i] = i; &#125; &#125; public Iterator createIterator() &#123; return new ConcreteIterator(items); &#125;&#125; 1234public interface Iterator &#123; boolean hasNext(); int next();&#125; 12345678910111213141516171819public class ConcreteIterator implements Iterator &#123; private int[] items; private int position = 0; public ConcreteIterator(int[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; return position &lt; items.length; &#125; @Override public int next() &#123; return items[position++]; &#125;&#125; 123456789public class Client &#123; public static void main(String[] args) &#123; Aggregate aggregate = new Aggregate(); Iterator iterator = aggregate.createIterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 运行结果123456789100123456789 2. Java 内置的迭代器1. 实现接口 Java 中已经有了 Iterator 接口，在使用 Java 实现时，需要让聚合对象实现 Iterable 接口，该接口有一个 iterator() 方法会返回一个 Iterator 对象。使用 Java 内置的迭代器实现，客户对象可以使用 foreach 循环来遍历聚合对象中的每个元素。 2. 代码实现 123456789101112131415161718import java.util.Iterator;public class Aggregate implements Iterable&lt;Integer&gt;&#123; private int[] items; public Aggregate() &#123; items = new int[10]; for (int i = 0; i &lt; items.length; i++) &#123; items[i] = i; &#125; &#125; @Override public Iterator&lt;Integer&gt; iterator() &#123; return new ConcreteIterator(items); &#125;&#125; 123456789101112131415161718192021import java.util.Iterator;public class ConcreteIterator implements Iterator&lt;Integer&gt; &#123; private int[] items; private int position = 0; public ConcreteIterator(int[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; return position &lt; items.length; &#125; @Override public Integer next() &#123; return items[position++]; &#125;&#125; 12345678public class Client &#123; public static void main(String[] args) &#123; Aggregate aggregate = new Aggregate(); for (int item : aggregate) &#123; System.out.println(item); &#125; &#125;&#125; 3. 组合模式1. 设计原则 一个类应该只有一个引起改变的原因。 2. 模式定义 允许将对象组合成树形结构来表现“整体 / 部分”层次结构。 组合能让客户以一致的方式处理个别对象以及对象组合。 3. 模式类图 由于组合（Composite）类拥有一个组件（Component）对象，因此组合对象位于树形结构的中间，它还可以继续操作这个组件对象，并忽略组件对象的具体类型。 4. 代码实现 123456789101112131415public abstract class Component &#123; protected String name; public Component(String name) &#123; this.name = name; &#125; abstract public void addChild(Component component); public void print() &#123; print(0); &#125; abstract protected void print(int level);&#125; 123456789101112131415161718public class Leaf extends Component &#123; public Leaf(String name) &#123; super(name); &#125; @Override public void addChild(Component component) &#123; throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则 , 这样就不用考虑是叶子节点还是组合节点 &#125; @Override protected void print(int level) &#123; for (int i = 0; i &lt; level; i++) &#123; System.out.print("--"); &#125; System.out.println("left:" + name); &#125;&#125; 12345678910111213141516171819202122232425262728import java.util.ArrayList;import java.util.List;public class Composite extends Component &#123; private List&lt;Component&gt; childs; public Composite(String name) &#123; super(name); childs = new ArrayList&lt;&gt;(); &#125; @Override public void addChild(Component component) &#123; childs.add(component); &#125; @Override protected void print(int level) &#123; for (int i = 0; i &lt; level; i++) &#123; System.out.print("--"); &#125; System.out.println("Composite:" + name); for (Component component : childs) &#123; component.print(level + 1); &#125; &#125;&#125; 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; Composite root = new Composite("root"); Component node1 = new Leaf("1"); Component node2 = new Composite("2"); Component node3 = new Leaf("3"); root.addChild(node1); root.addChild(node2); root.addChild(node3); Component node21 = new Leaf("21"); Component node22 = new Composite("22"); node2.addChild(node21); node2.addChild(node22); Component node221 = new Leaf("221"); node22.addChild(node221); root.print(); &#125;&#125; 运行结果 1234567Composite:root--left:1--Composite:2----left:21----Composite:22------left:221--left:3 第十章 状态模式1. 模式定义 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 状态模式的类图和策略模式一样，并且都是能够动态改变对象的行为。但是状态模式是通过状态对象的状态转移来改变客户对象组合的状态对象，而策略模式是通过客户对象本身的决策来改变组合的策略对象。例如，状态模式下，客户对象委托状态对象进行一个处理操作，那么状态对象有可能发生状态转移，使得客户对象拥有的状态对象发生改变。状态对象组合了客户对象，状态转移是状态对象通过改变客户对象所组合的状态对象实现的。 2. 模式类图 3. 问题描述 糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。 4. 直接解决方案 在糖果机的每个操作函数里面，判断当前的状态，根据不同的状态进行不同的处理，并且发生不同的状态转移。这种解决方案把所有的实现细节都放到客户类，这样在新增状态的时候就要去修改客户类的代码。 5. 使用状态模式的解决方案 状态的转移被移到状态类里面，客户类的每个操作只需要委托给状态类即可，而不需要知道当前是什么状态以及状态时如何进行转移的。 6. 代码实现 123456789101112131415161718192021public interface State &#123; /** * 投入25 分钱 */ void insertQuarter(); /** * 退回25 分钱 */ void ejectQuarter(); /** * 转动曲柄 */ void turnCrank(); /** * 发放糖果 */ void dispense();&#125; 1234567891011121314151617181920212223242526272829public class HasQuarterState implements State&#123; private GumballMachine gumballMachine; public HasQuarterState(GumballMachine gumballMachine)&#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println("You can't insert another quarter"); &#125; @Override public void ejectQuarter() &#123; System.out.println("Quarter returned"); gumballMachine.setState(gumballMachine.getNoQuarterState()); &#125; @Override public void turnCrank() &#123; System.out.println("You turned..."); gumballMachine.setState(gumballMachine.getSoldState()); &#125; @Override public void dispense() &#123; System.out.println("No gumball dispensed"); &#125;&#125; 12345678910111213141516171819202122232425262728public class NoQuarterState implements State &#123; GumballMachine gumballMachine; public NoQuarterState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println("You insert a quarter"); gumballMachine.setState(gumballMachine.getHasQuarterState()); &#125; @Override public void ejectQuarter() &#123; System.out.println("You haven't insert a quarter"); &#125; @Override public void turnCrank() &#123; System.out.println("You turned, but there's no quarter"); &#125; @Override public void dispense() &#123; System.out.println("You need to pay first"); &#125;&#125; 12345678910111213141516171819202122232425262728public class SoldOutState implements State &#123; GumballMachine gumballMachine; public SoldOutState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println("You can't insert a quarter, the machine is sold out"); &#125; @Override public void ejectQuarter() &#123; System.out.println("You can't eject, you haven't inserted a quarter yet"); &#125; @Override public void turnCrank() &#123; System.out.println("You turned, but there are no gumballs"); &#125; @Override public void dispense() &#123; System.out.println("No gumball dispensed"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class SoldState implements State &#123; GumballMachine gumballMachine; public SoldState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println("Please wait, we're already giving you a gumball"); &#125; @Override public void ejectQuarter() &#123; System.out.println("Sorry, you already turned the crank"); &#125; @Override public void turnCrank() &#123; System.out.println("Turning twice doesn't get you another gumball!"); &#125; @Override public void dispense() &#123; gumballMachine.releaseBall(); if(gumballMachine.getCount()&gt;0)&#123; gumballMachine.setState(gumballMachine.getNoQuarterState()); &#125; else&#123; System.out.println("Oops, out of gumballs"); gumballMachine.setState(gumballMachine.getSoldOutState()); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class GumballMachine &#123; private State soldOutState; private State noQuarterState; private State hasQuarterState; private State soldState; private State state; private int count = 0; public GumballMachine(int numberGumballs) &#123; count = numberGumballs; soldOutState = new SoldOutState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); soldState = new SoldState(this); if (numberGumballs &gt; 0) &#123; state = noQuarterState; &#125; else &#123; state = soldOutState; &#125; &#125; public void insertQuarter() &#123; state.insertQuarter(); &#125; public void ejectQuarter() &#123; state.ejectQuarter(); &#125; public void turnCrank() &#123; state.turnCrank(); state.dispense(); &#125; public void setState(State state) &#123; this.state = state; &#125; public void releaseBall() &#123; System.out.println("A gumball comes rolling out the slot..."); if (count != 0) &#123; count -= 1; &#125; &#125; public State getSoldOutState() &#123; return soldOutState; &#125; public State getNoQuarterState() &#123; return noQuarterState; &#125; public State getHasQuarterState() &#123; return hasQuarterState; &#125; public State getSoldState() &#123; return soldState; &#125; public int getCount() &#123; return count; &#125;&#125; 1234567891011121314151617181920212223242526public class GumballMachineTestDrive &#123; public static void main(String[] args) &#123; GumballMachine gumballMachine = new GumballMachine(5); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.ejectQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.ejectQuarter(); gumballMachine.insertQuarter(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); &#125;&#125; 运行结果12345678910111213141516171819202122232425You insert a quarterYou turned...A gumball comes rolling out the slot...You insert a quarterQuarter returnedYou turned, but there's no quarterYou need to pay firstYou insert a quarterYou turned...A gumball comes rolling out the slot...You insert a quarterYou turned...A gumball comes rolling out the slot...You haven't insert a quarterYou insert a quarterYou can't insert another quarterYou turned...A gumball comes rolling out the slot...You insert a quarterYou turned...A gumball comes rolling out the slot...Oops, out of gumballsYou can't insert a quarter, the machine is sold outYou turned, but there are no gumballsNo gumball dispensed 第十一章 代理模式第十二章 复合模式MVC传统 MVC 视图使用组合模式，模型使用了观察者模式，控制器使用了策略模式。 Web 中的 MVC 模式不再使用观察者模式。 第十三章 与设计模式相处定义：在某 情境 下，针对某 问题 的某种 解决方案。 过度使用设计模式可能导致代码被过度工程化，应该总是用最简单的解决方案完成工作，并在真正需要模式的地方才使用它。 反模式：不好的解决方案来解决一个问题。主要作用是为了警告不要使用这些解决方案。 模式分类： 第十四章 剩下的模式]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2Fblog%2F28758.html</url>
    <content type="text"><![CDATA[Java面试笔记 第一章 概述网络的网络网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。 互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。 互联网的组成 边缘部分：所有连接在互联网上的主机，用户可以直接使用； 核心部分：由大量的网络和连接这些网络的路由器组成，为边缘部分的主机提供服务。 主机之间的通信方式1. 客户-服务器（C/S） 客户是服务的请求方，服务器是服务的提供方。 2. 对等（P2P） 不区分客户和服务器。 电路交换与分组交换 1. 电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 报文交换报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。 3. 分组交换分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。 存储转发允许在一条传输线路上传送多个主机的分组，因此两个用户之间的通信不需要占用端到端的线路资源。 相比于报文交换，由于分组比报文更小，因此分组交换的存储转发速度更加快速。 时延总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 1. 发送时延主机或路由器发送数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示发送速率。 2. 传播时延电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。 其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。 3. 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部，从分组中提取数据部分等。 4. 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 计算机网络体系结构* 1. 七层协议如图 a 所示，其中表示层和会话层用途如下： 表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩； 会话层：不同机器上的用户之间建立及管理会话。 2. 五层协议 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层：为主机之间提供服务，而不是像运输层协议那样是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组来进行传输。 数据链路层：网络层针对的还是主机之间，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组封装成帧。 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使物理层上的数据链路层感觉不到这些差异。 3. 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 4. TCP/IP 体系结构它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。 第二章 物理层通信方式 单向通信，又称为单工通信； 双向交替通信，又称为半双工通信； 双向同时通信，又称为全双工通信。 带通调制模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 信道复用技术1. 频分复用、时分复用频分复用的所有用户在相同的时间占用不同的频率带宽资源；时分复用的所有用户在不同的时间占用相同的频率带宽资源。 使用这两种方式进行通信，在通信的过程中用户会一直占用一部分信道资源。但是由于计算机数据的突发性质，没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。 2. 统计时分复用是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 3. 波分复用光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 4. 码分复用为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 和 有 为了方便，取 m=8，设码片 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。 在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到 其中 为 的反码。 利用上面的式子我们知道，当接收端使用码片 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。 码分复用需要发送的数据量为原先的 m 倍。 第三章 数据链路层三个基本问题1. 封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2. 透明传输透明表示一个实际存在的事物看起来好像不存在一样。 帧中有首部和尾部，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据中出现首部尾部相同的内容前面插入转义字符，如果需要传输的内容正好就是转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3. 差错检测目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 点对点信道 - PPP 协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 在 PPP 的帧中 F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 局域网的拓扑 广播信道 - CSMA/CD 协议*在广播信道上，同一时间只能允许一台计算机发送数据。 CSMA/CD 表示载波监听多点接入 / 碰撞检测。 多点接入：说明这是总线型网络，许多计算机以多点的方式连接到总线上。 载波监听：每个站都必须不停地检听信道。在发送前，如果检听信道正在使用，就必须等待。 碰撞检测：在发送中，如果检听到信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经检听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定，从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 集线器从表面上看，使用集线器的局域网在物理上是一个星型网。但是集线器使用电子器件来模拟实际缆线的工作，逻辑上仍是一个总线网，整个系统仍像一个传统以太网那样运行。 MAC 层*MAC 地址是 6 字节（48 位）的地址，用于唯一表示网络适配器（网卡），一台主机拥有多少个适配器就有多少个 MAC 地址，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。 类型：标记上层使用的协议； 数据：长度在 46-1500 之间，如果太小则需要填充； FCS：帧检验序列，使用的是 CRC 检验方法； 前同步码：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。 虚拟局域网虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息，例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 第四章 网络层*网际协议 IP 概述因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选部分的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 IP 地址编址IP 地址的编址方式经历了三个历史阶段： 分类； 子网划分； 无分类。 1. 分类由两部分组成，网络号和主机号，其中不同类别具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在网络号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 000000，也就是 255.255.192.0。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 IP 地址和 MAC 地址网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 地址解析协议 ARP实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，存放映射表。如果一个 IP 地址到 MAC 地址的映射不在该表中，主机通过广播的方式发送 ARP 请求分组，匹配 IP 地址的主机会发送 ARP 响应分组告知其 MAC 地址。 路由器的结构路由器从功能上可以划分为两大部分：路由选择和分组转发。 分组转发部分由三部分组成：交换结构、一组输入端口和一组输出端口。 交换结构的交换网络有以下三种实现方式： 交换机与路由器的区别 交换机工作于数据链路层，能识别 MAC 地址，根据 MAC 地址转发链路层数据帧。具有自学机制来维护 IP 地址与 MAC 地址的映射。 路由器位于网络层，能识别 IP 地址并根据 IP 地址转发分组。维护着路由表，根据路由表选择最佳路线。 路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。（路由表项是网络号而不是 IP 地址，这样做大大减少了路由表条目数量） 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 路由选择协议互联网使用的路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类： 内部网关协议 IGP（Interior Gateway Protocol）：在 AS 内部使用，如 RIP 和 OSPF。 外部网关协议 EGP（External Gateway Protocol）：在 AS 之间使用，如 BGP。 1. 内部网关协议 RIPRIP 是一种分布式的基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP 协议实现简单，开销小，但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPAS 之间的路由选择很困难，主要是互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。它采用路径向量路由选择协议。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 分组网间探测 PINGPING 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 PING 的过程： PING 同一个网段的主机：查找目的主机的 MAC 地址，然后直接交付。如果无法查找到 MAC 地址，就要进行一次 ARP 请求。 PING 不同网段的主机：发送到网关让其进行转发。同样要发送到网关也需要通过查找网关的 MAC 地址，根据 MAC 地址进行转发。 IP 多播在一对多的通信中，多播不需要将分组复制多份，从而大大节约网络资源。 虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信部经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 第五章 运输层*网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。 运输层提供了应用进程间的逻辑通信。运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据包协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。 传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和而临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文段，FIN=1； B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据； 当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1； A 收到后发出确认，此时连接释放。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间。这么做有两个理由： 确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。 可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次连接之外，需要等待一段时间。 TCP 滑动窗口 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 超时时间 RTO 应该略大于 RRTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差，它与新的 RRT 和 RRTs 有关。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。例如将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护有一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快重传与快恢复在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。 在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 第六章 应用层*域名系统 DNS把主机名解析为 IP 地址。 被设计成分布式系统。 1. 层次结构一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。 域名服务器可以分为以下四类： 根域名服务器：解析顶级域名； 顶级域名服务器：解析二级域名； 权限域名服务器：解析区内的域名； 本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。 区和域的概念不同，可以在一个域中划分多个区。图 b 在域 abc.com 中划分了两个区：abc.com 和 y.abc.com 因此就需要两个权限域名服务器： 2. 解析过程主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。 迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归地方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。 文件传输协议 FTPFTP 在运输层使用 TCP，并且需要建立两个并行的 TCP 连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开，而数据连接在数据传送完毕之后就关闭。控制连接使用端口号 21，数据连接使用端口号 20。 远程终端协议 TELNETTELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 万维网 WWWHTTP 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 POP3POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 IMAPIMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。 SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则。 动态主机配置协议 DHCPDHCP 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。 工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。 点对点传输 P2P把某个文件分发的所有对等集合称为一个洪流。文件的数据单元称为文件块，它的大小是固定的。一个新的对等方加入某个洪流，一开始并没有文件块，但是能够从其它对等方中逐渐地下载到一些文件块，与此同时，它也为别的对等方上传一些文件块。 每个洪流都有一个基础设施，称为追踪器。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。可以在任何时间加入和退出某个洪流。 一个新的对等方加入洪流时，追踪器会随机从洪流中选择若干个对等方，并让新对等方与这些对等方建立连接，把这些对等方称为相邻对等方。接收和发送文件块都是在相邻对等方中进行。 当一个对等方需要很多文件块时，通过使用最稀有优先的策略来取得文件块，也就是一个文件块在相邻对等方中副本最少，那么就优先请求这个文件块。 当很多对等方向同一个对等方请求文件块时，该对等方优先选择以最高速率向其发送文件块的对等方。 P2P 是一个分布式系统，任何时候都有对等方加入或者退出。使用分布式散列表 DHT，可以查找洪流中的资源和 IP 地址映射。 Web 页面请求过程 向 DNS 服务器发送 DNS 查询报文来解析域名。 开始进行 HTTP 会话，需要先建立 TCP 连接。 在运输层的传输过程中，HTTP 报文被封装进 TCP 中。HTTP 请求报文使用端口号 80，因为服务器监听的是 80 端口。连接建立之后，服务器会随机分配一个端口号给特定的客户端，之后的 TCP 传输都是用这个分配的端口号。 在网络层的传输过程中，TCP 报文段会被封装进 IP 分组中，IP 分组经过路由选择，最后到达目的地。 在链路层，IP 分组会被封装进 MAC 帧中，IP 地址解析成 MAC 地址需要使用 ARP。 客户端发送 HTTP 请求报文，请求获取页面。 服务器发送 HTTP 相应报文，客户端从而获取该页面。 浏览器得到页面内容之后，解析并渲染，向用户展示页面。 常用端口 应用层协议 端口号 运输层协议 DNS 53 UDP FTP 控制连接 21，数据连接 20 TCP TELNET 23 TCP DHCP 67 68 UDP HTTP 80 TCP SMTP 25 TCP POP3 110 TCP IMAP 143 TCP 参考资料 计算机网络 第七版 计算机网络 自顶向下方法]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构思想]]></title>
    <url>%2Fblog%2F52460.html</url>
    <content type="text"><![CDATA[Java面试笔记 第一章 第一个案例如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构这个程序。 在重构前，需要先构建好可靠的测试环境，确保安全地重构。 重构是以微小的步伐修改程序，如果犯下错误，很容易便可以发现它。 案例分析 影片出租店应用程序，包括三个类：Movie、Rental 和 Customer，Rental 包含租赁的 Movie 以及天数。 最开始的实现是把所有的计费代码都放在 Customer 类中，在变化发生时，需要对这部分代码进行更改。本案例中可能发生的变化有：一种类别的计费方式发生改变；添加新的电影类别。考虑到计费代码可能存在于多处，一旦发生改变时，就需要对所有计费代码进行修改。 以下是继承 Movie 的多态方案。但是由于一部 Movie 的类别会动态改变，因此这种方案不可行。 引入 Price 来反应类别信息，通过组合的方式在 Movie 中加入 Price 对象，这样每种类别的计费方式都封装在不同的 Price 子类中，并且 Movie 对象也可以动态改变类别。这种方式可以很好地适应上述提到的变化。 重构后的时序图和类图： 第二章 重构原则重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 重构的好处：改进软件设计；使软件更容易理解；帮助找到 bug；提高编程速度。 三次法则：第一次做某件事时只管去做；第二次做类似事情时可以去做；第三次再做类似的事，就应该重构。 间接层与重构：计算机科学中的很多问题可以通过增加一个间接层来解决，间接层具有以下价值：允许逻辑共享；分开解释意图和实现；隔离变化；封装条件逻辑。重构可以理解为在适当的位置插入间接层以及在不需要时移除间接层。 修改接口：可以保留旧接口，让旧接口去调用新接口，并且使用 Java 提供的 @deprecation 将旧接口标记为弃用。除非真有必要，不要发布接口，并且不要过早发布接口。 当现有代码过于混乱时，应当重写而不是重构。一个折中的办法是，将代码封装成一个个组件，然后对各个组件做重写或者重构的决定。 软件开发无法预先设计，因为开发过程有很多变化发生，在最开始不可能都把所有情况考虑进去。重构可以简化设计，重构在一个简单的设计上进行修修改改，当变化发生时，以一种灵活的方式去应对变化，进而带来更好的设计。 为了软代码更容易理解，重构可能会导致性能减低。在编写代码时，不用对性能过多关注，只有在最后性能优化阶段再考虑性能问题。应当只关注关键代码的性能，因为只有一小部分的代码是关键代码。 第三章 代码的坏味道1. Duplicated Code（重复代码）同一个类的两个函数有相同表达式，则用 Extract Method 提取出重复代码； 两个互为兄弟的子类含有相同的表达式，先使用 Extract Method，然后把提取出来的函数 Pull Up Method 推入超类。 如果只是部分相同，用 Extract Method 分离出相似部分和差异部分，然后使用 Form Template Method 这种模板方法设计模式。 如果两个毫不相关的类出现重复代码，则使用 Extract Class 方法将重复代码提取到一个独立类中。 2. Long Method（过长函数）间接层的价值：解释能力、共享能力、选择能力； 分解函数的原则：当需要用注释来说明一段代码时，就需要把这部分代码写入一个独立的函数中。 Extract Method 会把很多参数和临时变量都当做参数，可以用 Replace Temp with Query 消除临时变量，Introduce Parameter Object 和 Preserve Whole Object 可以将过长的参数列变得更简洁。 条件和循环往往也需要提取到新的函数中。 3. Large Class（过大的类）过大的类做了过多事情，需要使用 Extract Class 或 Extract Subclass。 先确定客户端如何使用它们，然后运用 Extract Interface 为每一种使用方式提取出一个接口。 4. Long Parameter List（过长的参数列）5. Divergent Change（发散式变化）一个类受到多种变化的影响； 针对某种原因的变化，使用 Extract Class 将它提炼到一个类中。 6. Shotgun Surgery（散弹式修改）一个变化引起多个类修改； 使用 Move Method 和 Move Field 把所有需要修改地代码放到同一个类中。 7. Feature Envy（依恋情结）一个函数对某个类的兴趣高于对自己所处类的兴趣，通常是过多访问其它类的数据。 使用 Move Method 将它移到该去的地方，如果对多个类都有 Feature Envy，先用 Extract Method 提取出多个函数。 8. Data Clumps（数据泥团）有些数据经常一起出现，比如两个类具有相同的字段、许多函数有相同的参数。使用 Extract Class 将它们放在一起。 9. Primitive Obsession（基本类型偏执）使用类往往比使用基本类型更好，使用 Replace Data Value with Object 将数据值替换为对象。 10. Switch Statements（switch 惊悚现身）11. Parallel Inheritance Hierarchies（平行继承体系）每当为某个类增加一个子类，必须也为另一个类相应增加一个子类。 这种结果会带来一些重复性，消除重复性的一般策略：让一个继承体系的实例引用另一个继承体系的实例。 12. Lazy Class（冗余类）如果一个类没有做足够多的工作，就应该消失。 13. Speculative Generality（夸夸其谈未来性）有些内容是用来处理未来可能发生的变化，但是往往会造成系统难以理解和维护，并且预测未来可能发生的改变很可能和最开始的设想相反。因此，如果不是必要，就不要这么做。 14. Temporary Field（令人迷惑的暂时字段）某个字段仅为某种特定情况而设，这样的代码不易理解，因为通常认为对象在所有时候都需要它的所有字段。 把这种字段和特定情况的处理操作使用 Extract Class 提炼到一个独立类中。 15. Message Chains（过度耦合的消息链）一个对象请求另一个对象，然后再向后者请求另一个对象，然后…，这就是消息链。采用这种方式，意味着客户代码将与对象间的关系紧密耦合。 改用函数链，用函数委托另一个对象来处理。 16. Middle Man（中间人）中间人负责处理委托给它的操作，如果一个类中有过多的函数都委托给其它类，那就是过度运用委托，应当 Remove Middle Man，直接与负责的对象打交道。 17. Inappropriate Intimacy（狎昵关系）两个类多于亲密，花费太多时间去探讨彼此的 private 成分。 18. Alernative Classes with Different Interfaces（异曲同工的类）19. Incomplete Library Class（不完美的类库）类库的设计者不可能设计出完美的类库，当我们需要对类库进行一些修改时，可以使用以下两种方法：如果只是修改一两个函数，使用 Introduce Foreign Method；如果要添加一大堆额外行为，使用 Introduce Local Extension。 20. Data Class（幼稚的数据类）它只拥有一些数据字段。 找出字段使用的地方，然后把相应的操作移到 Data Class 中。 21. Refused Bequest（被拒绝的馈赠）子类继承超类的所有函数和数据，但是它只想要一部分。 为子类新建一个兄弟类，不需要的函数或数据使用 Push Down Method 和 Push Down Field 下推给那个兄弟。 22. Comments（过多的注释）使用 Extract Method 提炼出需要注释的部分，然后用函数名来解释函数的行为。 第四章 构筑测试体系Java 可以使用 Junit 进行单元测试。 单元测试的对象是类的方法，而功能测以客户的角度保证软件正常运行。 应当集中测试可能出错的边界条件。 第五章 重构列表小步前进，频繁测试。 第六章 重新组织函数1. Extract Method（提炼函数）将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。 2. Inline Method（内联函数）一个函数的本体与名称同样清楚易懂。 在函数调用点插入函数本体，然后移除该函数。 3. Inline Temp（内联临时变量）一个临时变量，只被简单表达式赋值一次，而它妨碍了其它重构手法。 将所有对该变量的引用替换为对它赋值的那个表达式自身。 12double basePrice = anOrder.basePrice();return basePrice &gt; 1000; 1return anOrder.basePrice() &gt; 1000; 4. Replace Temp with Query（以查询取代临时变量）以临时变量保存某一表达式的运算结果，将这个表达式提炼到一个独立函数中，将所有对临时变量的引用点替换为对新函数的调用。Replace Temp with Query 往往是 Extract Method 之前必不可少的一个步骤，因为局部变量会使代码难以提炼。 12345double basePrice = quantity * itemPrice;if(basePrice &gt; 1000) return basePrice * 0.95;else return basePrice * 0.98; 123456789if(basePrice() &gt; 1000) return basePrice() * 0.95;else return basePrice() * 0.98;// ...double basePrice()&#123; return quantity * itemPrice;&#125; 5. Introduce Explaining Variable（引起解释变量）将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。 12345if((platform.toUpperCase().indexOf("MAC") &gt; -1) &amp;&amp; (browser.toUpperCase().indexOf("IE") &gt; -1) &amp;&amp; wasInitialized() &amp;&amp; resize &gt; 0) &#123; // do something&#125; 1234567final boolean isMacOS = platform.toUpperCase().indexOf("MAC") &gt; -1;final boolean isIEBrower = browser.toUpperCase().indexOf("IE") &gt; -1;final boolean wasResized = resize &gt; 0;if(isMacOS &amp;&amp; isIEBrower &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123; // do something&#125; 6. Split Temporary Variable（分解临时变量）某个临时变量被赋值超过一次，它既不是循环变量，也不是用于收集计算结果。 针对每次赋值，创造一个独立、对应的临时变量，每个临时变量只承担一个责任。 7. Remove Assigments to Parameters（移除对参数的赋值）以一个临时变量取代对该参数的赋值。 12int discount (int inputVal, int quentity, int yearToDate)&#123; if (inputVal &gt; 50) inputVal -= 2; 123int discount (int inputVal, int quentity, int yearToDate)&#123; int result = inputVal; if (inputVal &gt; 50) result -= 2; 8. Replace Method with Method Object（以函数对象取代函数）当对一个大型函数采用 Extract Method 时，由于包含了局部变量使得很难进行该操作。 将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后可以在同一个对象中将这个大型函数分解为多个小型函数。 9. Subsititute Algorithn（替换算法）第七章 在对象之间搬移特性1. Move Method（搬移函数）类中的某个函数与另一个类进行更多交流：调用后者或者被后者调用。 将这个函数搬移到另一个类中。 2. Move Field（搬移字段）类中的某个字段被另一个类更多地用到，这里的用到是指调用取值设值函数，应当把该字段移到另一个类中。 3. Extract Class（提炼类）某个类做了应当由两个类做的事。 应当建立一个新类，将相关的字段和函数从旧类搬移到新类。 4. Inline Class（将类内联化）与 Extract Class 相反。 5. Hide Delegate（隐藏“委托关系”）建立所需的函数，隐藏委托关系。 123456789101112131415class Person&#123; Department department; public Department getDepartment()&#123; return department; &#125;&#125;class Department&#123; private Person manager; public Person getManager()&#123; return manager; &#125;&#125; 如果客户希望知道某人的经理是谁，必须获得 Department 对象，这样就对客户揭露了 Department 的工作原理。 1Person manager = john.getDepartment().getManager(); 通过为 Peron 建立一个函数来隐藏这种委托关系。 123public Person getManager()&#123; return department.getManager();&#125; 6. Remove Middle Man（移除中间人）与 Hide Delegate 相反，本方法需要移除委托函数，让客户直接调用委托类。 Hide Delegate 有很大好处，但是它的代价是：每当客户要使用受托类的新特性时，就必须在服务器端添加一个简单的委托函数。随着受委托的特性越来越多，服务器类完全变成了一个“中间人”。 7. Introduce Foreign Method（引入外加函数）需要为提供服务的类添加一个函数，但是无法修改这个类。 可以在客户类中建立一个函数，并以第一参数形式传入一个服务类的实例，让客户类组合服务器实例。 8. Introduce Local Extension（引入本地扩展）和 Introduce Foreign Method 目的一样，但是 Introduce Local Extension 通过建立新的类来实现。有两种方式：子类或者包装类，子类就是通过继承实现，包装类就是通过组合实现。 第八章 重新组织数据1. Self Encapsulate Field（自封装字段）为字段建立取值/设值函数，并用这些函数来访问字段。只有当子类想访问超类的一个字段，又想在子类中将对这个字段访问改为一个计算后的值，才使用这种方式，否则直接访问字段的方式简洁明了。 2. Replace Data Value with Object（以对象取代数据值）在开发初期，往往会用简单的数据项表示简单的情况，但是随着开发的进行，一些简单数据项会具有一些特殊行为。比如一开始会把电话号码存成字符串，但是随后发现电话号码需要“格式化”、“抽取区号”之类的特殊行为。 3. Change Value to Reference（将值对象改成引用对象）将彼此相等的实例替换为同一个对象。这就要用一个工厂来创建这种唯一对象，工厂类中需要保留一份已经创建对象的列表，当要创建一个对象时，先查找这份列表中是否已经存在该对象，如果存在，则返回列表中的这个对象；否则，新建一个对象，添加到列表中，并返回该对象。 4. Change Reference to value（将引用对象改为值对象）以 Change Value to Reference 相反。值对象有个非常重要的特性：它是不可变的，不可变表示如果要改变这个对象，必须用一个新的对象来替换旧对象，而不是修改旧对象。 需要为值对象实现 equals() 和 hashCode() 方法 5. Replace Array with Object（以对象取代数组）有一个数组，其中的元素各自代表不同的东西。 以对象替换数组，对于数组中的每个元素，以一个字段来表示，这样方便操作，也更容易理解。 6. Duplicate Observed Data（赋值“被监视数据”）一些领域数据置身于 GUI 控件中，而领域函数需要访问这些数据。 将该数据赋值到一个领域对象中，建立一个 Oberver 模式，用以同步领域对象和 GUI 对象内的重复数据。 7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）当两个类都需要对方的特性时，可以使用双向关联。 有两个类，分别为订单 Order 和客户 Customer，Order 引用了 Customer，Customer 也需要引用 Order 来查看其所有订单详情。 123456789class Order&#123; private Customer customer; public void setCustomer(Customer customer)&#123; if(this.customer != null) this.customer.removeOrder(this); this.customer = customer; this.customer.add(this); &#125;&#125; 123456789class Curstomer&#123; private Set&lt;Order&gt; orders = new HashSet&lt;&gt;(); public void removeOrder(Order order)&#123; orders.remove(order); &#125; public void addOrder(Order order)&#123; orders.add(order); &#125;&#125; 注意到，这里让 Curstomer 类来控制关联关系。有以下原则来决定哪个类来控制关联关系：如果某个对象是组成另一个对象的部件，那么由后者负责控制关联关系；如果是一对多关系，则由单一引用那一方来控制关联关系。 8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）和 Change Unidirectional Association to Bidirectiona 为反操作。 双向关联维护成本高，并且也不易于理解。大量的双向连接很容易造成“僵尸对象”：某个对象本身已经死亡了，却保留在系统中，因为它的引用还没有全部完全清除。 9. Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）创建一个常量，根据其意义为它命名，并将字面常量换位这个常量。 10. Encapsulate Field（封装字段）public 字段应当改为 private，并提供相应的访问函数。 11. Encapsulate Collection（封装集合）函数返回集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。如果函数返回集合自身，会让用户得以修改集合内容而集合拥有者却一无所知。 12. Replace Record with Data Class（以数据类取代记录）13. Replace Type Code with Class（以类取代类型码）类中有一个数值类型码，但它并不影响类的行为，就用一个新类替换该数值类型码。如果类型码出现在 switch 语句中，需要使用 Replace Conditional with Polymorphism 去掉 switch，首先必须运用 Replace Type Code with Subcalss 或 Replace Type Code with State/Strategy 去掉类型码。 14. Replace Type Code with Subcalsses（以子类取代类型码）有一个不可变的类型码，它会影响类的行为，以子类取代这个类型码。 15. Replace Type Code with State/Strategy （以 State/Strategy 取代类型码）有一个可变的类型码，它会影响类的行为，以状态对象取代类型码。 和 Replace Type Code with Subcalsses 的区别是 Replace Type Code with State/Strategy 的类型码是动态可变的，前者通过继承的方式来实现，后者通过组合的方式来实现。因为类型码可变，如果通过继承的方式，一旦一个对象的类型码改变，那么就要改变用新的对象来取代旧对象，而客户端难以改变新的对象。但是通过组合的方式，改变引用的状态类是很容易的。 16. Replace Subclass with Fields（以字段取代子类）各个子类的唯一差别只在“返回常量数据”的函数上。 第九章 简化条件表达式1. Decompose Conditional（分解条件表达式）对于一个复杂的条件语句，可以从 if、then、else 三个段落中分别提炼出独立函数。 123if(data.befor(SUMMER_START) || data.after(SUMMER_END)) charge = quantity * winterRate + winterServiceCharge;else charge = quantity * summerRate; 123if(notSummer(date)) charge = winterCharge(quantity);else charge = summerCharge(quantity); 2. Consolidate Conditional Expression（合并条件表达式）有一系列条件测试，都得到相同结果。 将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。 123456double disabilityAmount()&#123; if (seniority &lt; 2) return 0; if (monthsDisabled &gt; 12 ) return 0; if (isPartTime) return 0; // ...&#125; 1234double disabilityAmount()&#123; if (isNotEligibleForDisability()) return 0; // ...&#125; 3. Consolidate Duplicate Conditional Fragments （合并重复的条件片段）在条件表达式的每个分支上有着相同的一段代码。 将这段重复代码搬移到条件表达式之外。 1234567if (isSpecialDeal())&#123; total = price * 0.95; send();&#125; else &#123; total = price * 0.98; send();&#125; 123456if (isSpecialDeal()) &#123; total = price * 0.95;&#125; else &#123; total = price * 0.98;&#125;send(); 4. Remove Control Flag（移除控制标记）在一系列布尔表达式中，某个变量带有“控制标记”的作用。 用 break语 句或 return 语句来取代控制标记。 5. Replace Nested Conditional with Guard Clauses （以卫语句取代嵌套条件表达式）如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回，这样的单独检查常常被称为“卫语句”（guard clauses）。 条件表达式通常有两种表现形式。第一种形式是：所有分支都属于正常行为。第二种形式则是：条件表达式提供的答案中只有一种是正常行为，其他都是不常见的情况，可以使用卫语句表现所有特殊情况。 123456789101112double getPayAmount() &#123; double result; if (isDead) result = deadAmount(); else &#123; if (isSeparated) result = separatedAmount(); else &#123; if (isRetired) result = retiredAmount(); else result = normalPayAmount(); &#125;; &#125; return result;&#125;; 123456double getPayAmount() &#123; if (isDead) return deadAmount(); if (isSeparated) return separatedAmount(); if (isRetired) return retiredAmount(); return normalPayAmount();&#125;; 6. Replace Conditional with Polymorphism （以多态取代条件表达式）将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。需要先使用 Replace Type Code with Subclass 或 Replace Type Code with State/Strategy 来建立继承结果。 1234567891011double getSpeed() &#123; switch (type) &#123; case EUROPEAN: return getBaseSpeed(); case AFRICAN: return getBaseSpeed()- getLoadFactor()* numberOfCoconuts; case NORWEGIAN_BLUE: return isNailed ? 0 : getBaseSpeed(voltage); &#125; throw new RuntimeException("Should be unreachable");&#125; 7. Introduce Null Object（引入Null对象）将 null 值替换为 null 对象。这样做的好处在于，不需要询问对象是否为空，直接调用就行。 12if (customer == null) plan = BillingPlan.basic();else plan = customer.getPlan(); 8. Introduce Assertion（引入断言）以断言明确表现某种假设。断言只能用于开发过程中，产品代码中不会有断言。 1234double getExpenseLimit() &#123; // should have either expense limit or a primary project return (expenseLimit != NULL_EXPENSE) ? expenseLimit : primaryProject.getMemberExpenseLimit();&#125; 1234double getExpenseLimit() &#123; Assert.isTrue (expenseLimit != NULL_EXPENSE || primaryProject != null); return (expenseLimit != NULL_EXPENSE) ? expenseLimit : primaryProject.getMemberExpenseLimit();&#125; 第十章 简化函数调用1. Rename Method（函数改名）使函数名能解释函数的用途。 2. Add Parameter（添加参数）使函数不需要通过调用获得某个信息。 3. Remove Parameter（移除参数）与 Add Parameter 相反，改用调用的方式来获得某个信息。 4. Separate Query from Modifier（将查询函数和修改函数分离）某个函数即返回对象状态值，又修改对象状态。 应当建立两个不同的函数，其中一个负责查询，另一个负责修改。任何有返回值的函数，都不应该有看得到的副作用。 1getTotalOutstandingAndSetReadyForSummaries(); 12getTotalOutstanding();setReadyForSummaries(); 5. Parameterize Method（令函数携带参数）若干函数做了类似的工作，但在函数本体中却包含了不同的值。 建立单一函数，以参数表达那些不同的值。 12fivePercentRaise();tenPercentRaise(); 1raise(percentage); 6. Replace Parameter with Explicit Methods（以明确函数取代参数）有一个函数，完全取决于参数值而采取不同行为。 针对该参数的每一个可能值，建立一个独立函数。 1234567891011void setValue(String name, int value)&#123; if (name.equals("height"))&#123; height = value; return; &#125; if (name.equals("width"))&#123; width = value; return; &#125; Assert.shouldNeverReachHere();&#125; 123456void setHeight(int arg)&#123; height = arg;&#125;void setWidth(int arg)&#123; width = arg;&#125; 7. Preserve Whole Object（保持对象完整）从某个对象中取出若干值，将它们作为某一次函数调用时的参数。 改为传递整个对象。 123int low = daysTempRange().getLow();int high = daysTempRange().getHigh();withinPlan = plan.withinRange(low,high); 1withinPlan = plan.withinRange(daysTempRange()); 8. Replace Parameter with Methods（以函数取代参数）对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。 让参数接收者去除该项参数，而是直接调用前一个函数。 123int basePrice = _quantity * _itemPrice;discountLevel = getDiscountLevel();double finalPrice = discountedPrice (basePrice, discountLevel); 12int basePrice = _quantity * _itemPrice;double finalPrice = discountedPrice (basePrice); 9. Introduce Parameter Object（引入参数对象）某些参数总是很自然地同时出现，这些参数就是 Data Clumps。 以一个对象取代这些参数。 10. Remove Setting Method（移除设值函数）类中的某个字段应该在对象创建时被设值，然后就不再改变。 去掉该字段的所有设值函数，并将该字段设为 final。 11. Hide Method（隐藏函数）有一个函数，从来没有被其他任何类用到。 将这个函数修改为 private。 12. Replace Constructor with Factory Method （以工厂函数取代构造函数）希望在创建对象时不仅仅是做简单的建构动作。 将构造函数替换为工厂函数。 13. Encapsulate Downcast（封装向下转型）某个函数返回的对象，需要由函数调用者执行向下转型（downcast）。 将向下转型动作移到函数中。 123Object lastReading()&#123; return readings.lastElement();&#125; 123Reading lastReading()&#123; return (Reading)readings.lastElement();&#125; 14. Replace Error Code with Exception （以异常取代错误码）某个函数返回一个特定的代码，用以表示某种错误情况。 改用异常，异常将普通程序和错误处理分开，使代码更容易理解。 15. Replace Exception with Test（以测试取代异常）面对一个调用者可以预先检查的条件，你抛出了一个异常。 修改调用者，使它在调用函数之前先做检查。 1234567double getValueForPeriod(int periodNumber) &#123; try &#123; return values[periodNumber]; &#125; catch (ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125; 123double getValueForPeriod(int periodNumber) &#123; if (periodNumber &gt;= values.length) return 0; return values[periodNumber]; 第十一章 处理概括关系1. Pull Up Field（字段上移）两个子类拥有相同的字段。 将该字段移至超类。 2. Pull Up Method（函数上移）有些函数，在各个子类中产生完全相同的结果。 将该函数移至超类。 3. Pull Up Constructor Body（构造函数本体上移）你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。 在超类中新建一个构造函数，并在子类构造函数中调用它。 1234567class Manager extends Employee...public Manager(String name, String id, int grade) &#123; this.name = name; this.id = id; this.grade = grade;&#125; 1234public Manager(String name, String id, int grade) &#123; super(name, id); this.grade = grade;&#125; 4. Push Down Method（函数下移）超类中的某个函数只与部分子类有关。 将这个函数移到相关的那些子类去。 5. Push Down Field（字段下移）超类中的某个字段只被部分子类用到。 将这个字段移到需要它的那些子类去。 6. Extract Subclass（提炼子类）类中的某些特性只被某些实例用到。 新建一个子类，将上面所说的那一部分特性移到子类中。 7. Extract Superclass（提炼超类）两个类有相似特性。 为这两个类建立一个超类，将相同特性移至超类。 8. Extract Interface（提炼接口）若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。 将相同的子集提炼到一个独立接口中。 9. Collapse Hierarchy（折叠继承体系）超类和子类之间无太大区别。 将它们合为一体。 10. Form Template Method（塑造模板函数）你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。 将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。(模板方法模式) 11. Replace Inheritance with Delegation （以委托取代继承）某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。 在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去掉两者之间的继承关系。 12. Replace Delegation with Inheritance （以继承取代委托）你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。 让委托类继承受托类。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 校招真题题解]]></title>
    <url>%2Fblog%2F18806.html</url>
    <content type="text"><![CDATA[Java面试笔记 前言省略的代码： 1import java.util.*; 12public class Solution &#123;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; &#125; &#125;&#125; 1. 小米-小米Git 重建多叉树 使用 LCA 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private class TreeNode &#123; int id; List&lt;TreeNode&gt; childs = new ArrayList&lt;&gt;(); TreeNode(int id) &#123; this.id = id; &#125;&#125;public int getSplitNode(String[] matrix, int indexA, int indexB) &#123; int n = matrix.length; boolean[][] linked = new boolean[n][n]; // 重建邻接矩阵 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; linked[i][j] = matrix[i].charAt(j) == '1'; &#125; &#125; TreeNode tree = constructTree(linked, 0); TreeNode ancestor = LCA(tree, new TreeNode(indexA), new TreeNode(indexB)); return ancestor.id;&#125;private TreeNode constructTree(boolean[][] linked, int root) &#123; TreeNode tree = new TreeNode(root); for (int i = 0; i &lt; linked[root].length; i++) &#123; if (linked[root][i]) &#123; linked[i][root] = false; // 因为题目给的邻接矩阵是双向的，在这里需要把它转为单向的 tree.childs.add(constructTree(links, i)); &#125; &#125; return tree;&#125;private TreeNode LCA(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root.id == p.id || root.id == q.id) return root; TreeNode ancestor = null; int cnt = 0; for (int i = 0; i &lt; root.childs.size(); i++) &#123; TreeNode tmp = LCA(root.childs.get(i), p, q); if (tmp != null) &#123; ancestor = tmp; cnt++; &#125; &#125; return cnt == 2 ? root : ancestor;&#125; 2. 小米-懂二进制对两个数进行异或，结果的二进制表示为 1 的那一位就是两个数不同的位。 123public int countBitDiff(int m, int n) &#123; return Integer.bitCount(m ^ n);&#125; 3. 小米-中国牛市背包问题，可以设一个大小为 2 的背包。 状态转移方程如下： 1dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) &#123; jj in range of [0, j-1] &#125; = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj])) 123456789101112public int calculateMax(int[] prices) &#123; int n = prices.length; int[][] dp = new int[3][n]; for (int i = 1; i &lt;= 2; i++) &#123; int localMax = dp[i - 1][0] - prices[0]; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = Math.max(dp[i][j - 1], prices[j] + localMax); localMax = Math.max(localMax, dp[i - 1][j] - prices[j]); &#125; &#125; return dp[2][n - 1];&#125; 4. 微软-LUCKY STRING 斐波那契数列可以预计算； 从头到尾遍历字符串的过程，每一轮循环都使用一个 Set 来保存从 i 到 j 出现的字符，并且 Set 保证了字符都不同，因此 Set 的大小就是不同字符的个数。 1234567891011121314151617181920Set&lt;Integer&gt; fibSet = new HashSet&lt;&gt;(Arrays.asList(1, 2, 3, 5, 8, 13, 21, 34, 55, 89));Scanner in = new Scanner(System.in);String str = in.nextLine();int n = str.length();Set&lt;String&gt; ret = new HashSet&lt;&gt;();for (int i = 0; i &lt; n; i++) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int j = i; j &lt; n; j++) &#123; set.add(str.charAt(j)); int cnt = set.size(); if (fibSet.contains(cnt)) &#123; ret.add(str.substring(i, j + 1)); &#125; &#125;&#125;String[] arr = ret.toArray(new String[ret.size()]);Arrays.sort(arr);for (String s : arr) &#123; System.out.println(s);&#125; 5. 微软-Numeric Keypad123456789101112131415161718192021222324252627282930313233343536373839private static int[][] canReach = &#123; &#123;1, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;, // 0 &#123;1, 1, 1, 1, 1, 1, 1, 1, 1, 1&#125;, // 1 &#123;1, 0, 1, 1, 0, 1, 1, 0, 1, 1&#125;, // 2 &#123;0, 0, 0, 1, 0, 0, 1, 0, 0, 1&#125;, // 3 &#123;1, 0, 0, 0, 1, 1, 1, 1, 1, 1&#125;, // 4 &#123;1, 0, 0, 0, 0, 1, 1, 0, 1, 1&#125;, // 5 &#123;0, 0, 0, 0, 0, 0, 1, 0, 0, 1&#125;, // 6 &#123;1, 0, 0, 0, 0, 0, 0, 1, 1, 1&#125;, // 7 &#123;1, 0, 0, 0, 0, 0, 0, 0, 1, 1&#125;, // 8 &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 1&#125; // 9&#125;;private static boolean isLegal(char[] chars, int idx) &#123; if (idx &gt;= chars.length || idx &lt; 0) return true; int cur = chars[idx] - '0'; int next = chars[idx + 1] - '0'; return canReach[cur][next] == 1;&#125;public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int T = Integer.valueOf(in.nextLine()); for (int i = 0; i &lt; T; i++) &#123; String line = in.nextLine(); char[] chars = line.toCharArray(); for (int j = 0; j &lt; chars.length - 1; j++) &#123; while (!isLegal(chars, j)) &#123; if (--chars[j + 1] &lt; '0') &#123; chars[j--]--; &#125; for (int k = j + 2; k &lt; chars.length; k++) &#123; chars[k] = '9'; &#125; &#125; &#125; System.out.println(new String(chars)); &#125;&#125; 6. 微软-Spring Outing下面以 N = 3，K = 4 来进行讨论。 初始时，令第 0 个地方成为待定地点，也就是呆在家里。 从第 4 个地点开始投票，每个人只需要比较第 4 个地方和第 0 个地方的优先级，里，如果超过半数的人选择了第 4 个地方，那么更新第 4 个地方成为待定地点。 从后往前不断重复以上步骤，不断更新待定地点，直到所有地方都已经投票。 上面的讨论中，先令第 0 个地点成为待定地点，是因为这样的话第 4 个地点就只需要和这个地点进行比较，而不用考虑其它情况。如果最开始先令第 1 个地点成为待定地点，那么在对第 2 个地点进行投票时，每个人不仅要考虑第 2 个地点与第 1 个地点的优先级，也要考虑与其后投票地点的优先级。 12345678910111213141516171819202122int N = in.nextInt();int K = in.nextInt();int[][] votes = new int[N][K + 1];for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; K + 1; j++) &#123; int place = in.nextInt(); votes[i][place] = j; &#125;&#125;int ret = 0;for (int place = K; place &gt; 0; place--) &#123; int cnt = 0; for (int i = 0; i &lt; N; i++) &#123; if (votes[i][place] &lt; votes[i][ret]) &#123; cnt++; &#125; &#125; if (cnt &gt; N / 2) &#123; ret = place; &#125;&#125;System.out.println(ret == 0 ? "otaku" : ret); 7. 微软-S-expression8. 华为-最高分是多少123456789101112131415161718192021222324252627int N = in.nextInt();int M = in.nextInt();int[] scores = new int[N];for (int i = 0; i &lt; N; i++) &#123; scores[i] = in.nextInt();&#125;for (int i = 0; i &lt; M; i++) &#123; String str = in.next(); if (str.equals("U")) &#123; int id = in.nextInt() - 1; int newScore = in.nextInt(); scores[id] = newScore; &#125; else &#123; int idBegin = in.nextInt() - 1; int idEnd = in.nextInt() - 1; int ret = 0; if (idBegin &gt; idEnd) &#123; int t = idBegin; idBegin = idEnd; idEnd = t; &#125; for (int j = idBegin; j &lt;= idEnd; j++) &#123; ret = Math.max(ret, scores[j]); &#125; System.out.println(ret); &#125;&#125; 9. 华为-简单错误记录123456789101112131415HashMap&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();while (in.hasNextLine()) &#123; String s = in.nextLine(); String key = s.substring(s.lastIndexOf('\\') + 1); map.put(key, map.containsKey(key) ? map.get(key) + 1 : 1);&#125;List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new LinkedList&lt;&gt;(map.entrySet());Collections.sort(list, (o1, o2) -&gt; o2.getValue() - o1.getValue());for (int i = 0; i &lt; 8 &amp;&amp; i &lt; list.size(); i++) &#123; String[] token = list.get(i).getKey().split(" "); String filename = token[0]; String line = token[1]; if (filename.length() &gt; 16) filename = filename.substring(filename.length() - 16); System.out.println(filename + " " + line + " " + list.get(i).getValue());&#125; 10. 华为-扑克牌大小1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Main &#123; private Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); public Main() &#123; map.put("3", 0); map.put("4", 1); map.put("5", 2); map.put("6", 3); map.put("7", 4); map.put("8", 5); map.put("9", 6); map.put("10", 7); map.put("J", 8); map.put("Q", 9); map.put("K", 10); map.put("A", 11); map.put("2", 12); map.put("joker", 13); map.put("JOKER ", 14); &#125; private String play(String s1, String s2) &#123; String[] token1 = s1.split(" "); String[] token2 = s2.split(" "); CardType type1 = computeCardType(token1); CardType type2 = computeCardType(token2); if (type1 == CardType.DoubleJoker) return s1; if (type2 == CardType.DoubleJoker) return s2; if (type1 == CardType.Bomb &amp;&amp; type2 != CardType.Bomb) return s1; if (type2 == CardType.Bomb &amp;&amp; type1 != CardType.Bomb) return s2; if (type1 != type2 || token1.length != token2.length) return "ERROR"; for (int i = 0; i &lt; token1.length; i++) &#123; int val1 = map.get(token1[i]); int val2 = map.get(token2[i]); if (val1 != val2) return val1 &gt; val2 ? s1 : s2; &#125; return "ERROR"; &#125; private CardType computeCardType(String[] token) &#123; boolean hasjoker = false, hasJOKER = false; for (int i = 0; i &lt; token.length; i++) &#123; if (token[i].equals("joker")) hasjoker = true; else if (token[i].equals("JOKER")) hasJOKER = true; &#125; if (hasjoker &amp;&amp; hasJOKER) return CardType.DoubleJoker; int maxContinueLen = 1; int curContinueLen = 1; String curValue = token[0]; for (int i = 1; i &lt; token.length; i++) &#123; if (token[i].equals(curValue)) curContinueLen++; else &#123; curContinueLen = 1; curValue = token[i]; &#125; maxContinueLen = Math.max(maxContinueLen, curContinueLen); &#125; if (maxContinueLen == 4) return CardType.Bomb; if (maxContinueLen == 3) return CardType.Triple; if (maxContinueLen == 2) return CardType.Double; boolean isStraight = true; for (int i = 1; i &lt; token.length; i++) &#123; if (map.get(token[i]) - map.get(token[i - 1]) != 1) &#123; isStraight = false; break; &#125; &#125; if (isStraight &amp;&amp; token.length == 5) return CardType.Straight; return CardType.Sigal; &#125; private enum CardType &#123; DoubleJoker, Bomb, Sigal, Double, Triple, Straight; &#125; public static void main(String[] args) &#123; Main main = new Main(); Scanner in = new Scanner(System.in); while (in.hasNextLine()) &#123; String s = in.nextLine(); String[] token = s.split("-"); System.out.println(main.play(token[0], token[1])); &#125; &#125;&#125; 11. 去哪儿-二分查找对于有重复元素的有序数组，二分查找需要注意以下要点： if (val &lt;= A[m]) h = m; 因为 h 的赋值为 m 而不是 m - 1，因此 while 循环的条件也就为 l &lt; h。（如果是 m - 1 循环条件为 l &lt;= h） 123456789public int getPos(int[] A, int n, int val) &#123; int l = 0, h = n - 1; while (l &lt; h) &#123; int m = l + (h - l) / 2; if (val &lt;= A[m]) h = m; else l = m + 1; &#125; return A[h] == val ? h : -1;&#125; 12. 去哪儿-首个重复字符123456789public char findFirstRepeat(String A, int n) &#123; boolean[] hasAppear = new boolean[256]; for (int i = 0; i &lt; n; i++) &#123; char c = A.charAt(i); if(hasAppear[c]) return c; hasAppear[c] = true; &#125; return ' ';&#125; 13. 去哪儿-寻找Coder1234567891011121314151617181920212223242526272829303132333435363738394041public String[] findCoder(String[] A, int n) &#123; List&lt;Pair&lt;String, Integer&gt;&gt; list = new ArrayList&lt;&gt;(); for (String s : A) &#123; int cnt = 0; String t = s.toLowerCase(); int idx = -1; while (true) &#123; idx = t.indexOf("coder", idx + 1); if (idx == -1) break; cnt++; &#125; if (cnt != 0) &#123; list.add(new Pair&lt;&gt;(s, cnt)); &#125; &#125; Collections.sort(list, (o1, o2) -&gt; (o2.getValue() - o1.getValue())); String[] ret = new String[list.size()]; for (int i = 0; i &lt; list.size(); i++) &#123; ret[i] = list.get(i).getKey(); &#125; return ret;&#125;// 牛客网无法导入 javafx.util.Pair，这里就自己实现一下 Pair 类private class Pair&lt;T, K&gt; &#123; T t; K k; Pair(T t, K k) &#123; this.t = t; this.k = k; &#125; T getKey() &#123; return t; &#125; K getValue() &#123; return k; &#125;&#125; 14. 美团-最大差值贪心策略。 123456789public int getDis(int[] A, int n) &#123; int max = 0; int soFarMin = A[0]; for (int i = 1; i &lt; n; i++) &#123; if(soFarMin &gt; A[i]) soFarMin = A[i]; else max = Math.max(max, A[i]- soFarMin); &#125; return max;&#125; 15. 美团-棋子翻转1234567891011public int[][] flipChess(int[][] A, int[][] f) &#123; int[][] direction = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; for (int[] ff : f) &#123; for (int[] dd : direction) &#123; int r = ff[0] + dd[0] - 1, c = ff[1] + dd[1] - 1; if(r &lt; 0 || r &gt; 3 || c &lt; 0 || c &gt; 3) continue; A[r][c] ^= 1; &#125; &#125; return A;&#125; 16. 美团-拜访1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Set&lt;String&gt; paths;private List&lt;Integer&gt; curPath;public int countPath(int[][] map, int n, int m) &#123; paths = new HashSet&lt;&gt;(); curPath = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (map[i][j] == 1) &#123; map[i][j] = -1; int[][] leftRightDirection = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; int[][] topDownDirection = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;&#125;; for (int[] lr : leftRightDirection) &#123; for (int[] td : topDownDirection) &#123; int[][] directions = &#123;lr, td&#125;; backtracking(map, n, m, i, j, directions); &#125; &#125; return paths.size(); &#125; &#125; &#125; return 0;&#125;private void backtracking(int[][] map, int n, int m, int r, int c, int[][] directions) &#123; if (map[r][c] == 2) &#123; String path = ""; for (int num : curPath) &#123; path += num; &#125; paths.add(path); return; &#125; for (int i = 0; i &lt; directions.length; i++) &#123; int nextR = r + directions[i][0]; int nextC = c + directions[i][1]; if (nextR &lt; 0 || nextR &gt;= n || nextC &lt; 0 || nextC &gt;= m || map[nextR][nextC] == -1) continue; map[nextR][nextC] = map[nextR][nextC] == 2 ? 2 : -1; curPath.add(nextR); curPath.add(nextC); backtracking(map, n, m, nextR, nextC, directions); curPath.remove(curPath.size() - 1); curPath.remove(curPath.size() - 1); map[nextR][nextC] = map[nextR][nextC] == 2 ? 2 : 0; &#125;&#125; 17. 美团-直方图内最大矩形1234567891011public int countArea(int[] A, int n) &#123; int max = 0; for (int i = 0; i &lt; n; i++) &#123; int min = A[i]; for (int j = i; j &lt; n; j++) &#123; min = Math.min(min, A[j]); max = Math.max(max, min * (j - i + 1)); &#125; &#125; return max;&#125; 18. 美团-字符串计数字符串都是小写字符，可以把字符串当成是 26 进制。但是字典序的比较和普通的整数比较不同，是从左往右进行比较，例如 “ac” 和 “abc”，字典序的比较结果为 “ac” &gt; “abc”，如果按照整数方法比较，因为 “abc” 是三位数，显然更大。 由于两个字符串的长度可能不想等，在 s1 空白部分和 s2 对应部分进行比较时，应该把 s1 的空白部分看成是 ‘a’ 字符进行填充的。 还有一点要注意的是，s1 到 s2 长度为 leni 的字符串个数只比较前面 i 个字符。例如 ‘aaa’ 和 ‘bbb’ ，长度为 2 的个数为 ‘aa’ 到 ‘bb’ 的字符串个数，不需要考虑后面部分的字符。 在统计个数时，从 len1 开始一直遍历到最大合法长度，每次循环都统计长度为 i 的子字符串个数。 123456789101112131415161718String s1 = in.next();String s2 = in.next();int len1 = in.nextInt();int len2 = in.nextInt();int len = Math.min(s2.length(), len2);int[] subtractArr = new int[len];for (int i = 0; i &lt; len; i++) &#123; char c1 = i &lt; s1.length() ? s1.charAt(i) : 'a'; char c2 = s2.charAt(i); subtractArr[i] = c2 - c1;&#125;int ret = 0;for (int i = len1; i &lt;= len; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; ret += subtractArr[j] * Math.pow(26, i - j - 1); &#125;&#125;System.out.println(ret - 1); 19. 美团-平均年龄123456789int W = in.nextInt();double Y = in.nextDouble();double x = in.nextDouble();int N = in.nextInt();while (N-- &gt; 0) &#123; Y++; // 老员工每年年龄都要加 1 Y += (21 - Y) * x;&#125;System.out.println((int) Math.ceil(Y)); 20. 百度-罪犯转移部分和问题，将每次求的部分和缓存起来。 123456789101112131415161718int n = in.nextInt();int t = in.nextInt();int c = in.nextInt();int[] values = new int[n];for (int i = 0; i &lt; n; i++) &#123; values[i] = in.nextInt();&#125;int cnt = 0;int totalValue = 0;for (int s = 0, e = c - 1; e &lt; n; s++, e++) &#123; if (s == 0) &#123; for (int j = 0; j &lt; c; j++) totalValue += values[j]; &#125; else &#123; totalValue = totalValue - values[s - 1] + values[e]; &#125; if (totalValue &lt;= t) cnt++;&#125;System.out.println(cnt); 22. 百度-裁减网格纸12345678910111213int n = in.nextInt();int minX, minY, maxX, maxY;minX = minY = Integer.MAX_VALUE;maxX = maxY = Integer.MIN_VALUE;for (int i = 0; i &lt; n; i++) &#123; int x = in.nextInt(); int y = in.nextInt(); minX = Math.min(minX, x); minY = Math.min(minY, y); maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);&#125;System.out.println((int) Math.pow(Math.max(maxX - minX, maxY - minY), 2)); 23. 百度-钓鱼比赛P ( 至少钓一条鱼 ) = 1 - P ( 一条也钓不到 ) 坑：读取概率矩阵的时候，需要一行一行进行读取，而不能直接用 in.nextDouble()。 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; int n = in.nextInt(); int m = in.nextInt(); int x = in.nextInt(); int y = in.nextInt(); int t = in.nextInt(); in.nextLine(); // 坑 double pcc = 0.0; double sum = 0.0; for (int i = 1; i &lt;= n; i++) &#123; String[] token = in.nextLine().split(" "); // 坑 for (int j = 1; j &lt;= m; j++) &#123; double p = Double.parseDouble(token[j - 1]); // double p = in.nextDouble(); sum += p; if (i == x &amp;&amp; j == y) &#123; pcc = p; &#125; &#125; &#125; double pss = sum / (n * m); pcc = computePOfIRT(pcc, t); pss = computePOfIRT(pss, t); System.out.println(pcc &gt; pss ? "cc" : pss &gt; pcc ? "ss" : "equal"); System.out.printf("%.2f\n", Math.max(pcc, pss)); &#125;&#125;// compute probability of independent repeated trialsprivate static double computePOfIRT(double p, int t) &#123; return 1 - Math.pow((1 - p), t);&#125; 24. 百度-蘑菇阵这题用回溯会超时，需要用 DP。 dp[i][j] 表示到达 (i,j) 位置不会触碰蘑菇的概率。对于 N*M 矩阵，如果 i == N || j == M，那么 (i,j) 只能有一个移动方向；其它情况下能有两个移动方向。 考虑以下矩阵，其中第 3 行和第 3 列只能往一个方向移动，而其它位置可以有两个方向移动。 123456789101112131415161718192021222324252627int N = in.nextInt();int M = in.nextInt();int K = in.nextInt();boolean[][] mushroom = new boolean[N][M];while (K-- &gt; 0) &#123; int x = in.nextInt(); int y = in.nextInt(); mushroom[x - 1][y - 1] = true;&#125;double[][] dp = new double[N][M];dp[0][0] = 1;for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (mushroom[i][j]) dp[i][j] = 0; else &#123; double cur = dp[i][j]; if (i == N - 1 &amp;&amp; j == M - 1) break; if (i == N - 1) dp[i][j + 1] += cur; else if (j == M - 1) dp[i + 1][j] += cur; else &#123; dp[i][j + 1] += cur / 2; dp[i + 1][j] += cur / 2; &#125; &#125; &#125;&#125;System.out.printf("%.2f\n", dp[N - 1][M - 1]);]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统]]></title>
    <url>%2Fblog%2F8398.html</url>
    <content type="text"><![CDATA[Java面试笔记 第一章 概述操作系统基本特征1. 并发并发性是指宏观上在一段时间内能同时运行多个程序，而并行性则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线或者多处理器。 操作系统通过引入进程和线程，使得程序能够并发运行。 2. 共享共享是指系统中的资源可以供多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，否则会出现错误，需要用同步机制来实现对临界资源的访问。 3. 虚拟虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时分复用技术和空分复用技术，例如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。 4. 异步异步是指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。 系统调用如果一个进程在用户态需要用到操作系统的一些功能，就需要使用系统调用从而陷入内核，由操作系统代为完成。 可以由系统调用请求的功能有设备管理、文件管理、进程管理、进程通信、存储器管理等。 中断分类1. 外中断由 CPU 执行指令以外的事件引起，如 I/O 结束中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 2. 异常由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 3. 陷入在用户程序中使用系统调用。 大内核和微内核1. 大内核大内核是将操作系统功能作为一个紧密结合的整体放到内核，由于各模块共享信息，因此有很高的性能。 2. 微内核由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。但是需要频繁地在用户态和核心态之间进行切换，会有一定的性能损失。 第二章 进程管理进程与线程1. 进程进程是操作系统进行资源分配的基本单位。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 2. 线程一个进程中可以有多个线程，线程是独立调度的基本单位。同一个进程中的多个线程之间可以并发执行，它们共享进程资源。 3. 区别 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问率属进程的资源。 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置。而线程切换时只需保存和设置少量寄存器内容，开销很小。 通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。 举例：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 进程状态的切换 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU，缺少 CPU 会让进程从运行态转换为就绪态。 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 调度算法需要针对不同环境来讨论调度算法。 1. 批处理系统中的调度1.1 先来先服务first-come first-serverd（FCFS）。 调度最先进入就绪队列的作业。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先shortest job first（SJF）。 调度估计运行时间最短的作业。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先shortest remaining time next（SRTN）。 2. 交互式系统中的调度2.1 优先权优先除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。 响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间 这种调度算法主要是为了解决 SJF 中长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。 2.2 时间片轮转将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系。因为每次进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，进程切换太频繁，在进程切换上就会花过多时间。 2.3 多级反馈队列 设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权越高的队列中，为每个进程所规定的执行时间片就越小。 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入下一个队列的队尾。 仅当前 i -1 个队列均空时，才会调度第 i 个队列中的进程。 优点：实时性好，同时适合运行短作业和长作业。 2.4 短进程优先3. 实时系统中的调度实时系统要一个服务请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步1. 临界区对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 123// entry section// critical section;// exit section 2. 同步与互斥同步指多个进程按一定顺序执行；互斥指多个进程在同一时刻只有一个进程能进入临界区。 同步是在对临界区互斥访问的基础上，通过其它机制来实现有序访问的。 3. 信号量信号量（Samaphore） 是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，将进程睡眠，等待信号量大于 0； up：对信号量执行 +1 操作，并且唤醒睡眠的进程，让进程完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了互斥量（Mutex），0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int samaphore;samaphore mutex = 1;void P1() &#123; down(mutex); // 临界区 up(mutex);&#125;void P2() &#123; down(mutex); // 临界区 up(mutex);&#125; 使用信号量实现生产者-消费者问题 使用一个互斥量 mutex 来对临界资源进行访问；empty 记录空缓冲区的数量，full 记录满缓冲区的数量。 注意，必须先执行 down 操作再用互斥量对临界区加锁，否则会出现死锁。因为如果都先对临界区加锁，然后再执行 down 操作，那么可能会出现这种情况：生产者对临界区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生成者睡眠。消费者此时不能进入临界区，因为生产者对临界区加锁了，也就无法执行 up(empty) 操作，那么生产者和消费者就会一直等待下去。 123456789101112131415161718192021222324252627#define N 100typedef int samaphore;samaphore mutex = 1;samaphore empty = N;samaphore full = 0;void producer() &#123; while(TRUE)&#123; int item = produce_item; down(empty); down(mutex); insert_item(item); up(mutex); up(full); &#125;&#125;void consumer() &#123; while(TRUE)&#123; down(full); down(mutex); int item = remove_item(item); up(mutex); up(empty); consume_item(item); &#125;&#125; 4. 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码中的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。 1234567891011121314monitor ProducerConsumer integer i; condition c; procedure insert(); begin end; procedure remove(); begin end;end monitor; 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来让另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 使用管程实现生成者-消费者问题 123456789101112131415161718192021222324252627282930313233343536373839monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 ten signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 进程通信进程通信可以看成是不同进程间的线程通信，对于同一个进程内线程的通信方式，主要使用信号量、条件变量等同步机制。 1. 管道管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的首端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。 管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。 Linux 中管道是通过空文件来实现。 管道有三种： 普通管道：有两个限制：一是只支持半双工通信方式，即只能单向传输；二是只能在父子进程之间使用； 流管道：去除第一个限制，支持双向传输； 命名管道：去除第二个限制，可以在不相关进程之间进行通信。 2. 信号量信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 3. 消息队列消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 4. 信号信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 5. 共享内存共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其它 IPC 运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。 6. 套接字套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。 经典同步问题生产者和消费者问题前面已经讨论过。 1. 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。 1234567891011121314151617181920212223242526typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void reader() &#123; while(TRUE) &#123; down(count_mutex); count++; if(count == 1) down(data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问 up(count_mutex); read(); down(count_mutex); count--; if(count == 0) up(data_mutex); up(count_mutex); &#125;&#125;void writer() &#123; while(TRUE) &#123; down(data_mutex); write(); up(data_mutex); &#125;&#125; 2. 哲学家进餐问题 五个哲学家围着一张圆周，每个哲学家面前放着饭。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先一根一根拿起左右两边的筷子。 下面是一种错误的解法，考虑到如果每个哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 12345678910111213141516#define N 5#define LEFT (i + N - 1) % N#define RIGHT (i + N) % Ntypedef int semaphore;semaphore chopstick[N];void philosopher(int i) &#123; while(TURE)&#123; think(); down(chopstick[LEFT[i]]); down(chopstick[RIGHT[i]]); eat(); up(chopstick[RIGHT[i]]); up(chopstick[LEFT[i]]); &#125;&#125; 为了防止死锁的发生，可以加一点限制，只允许同时拿起左右两边的筷子，方法是引入一个互斥量，对拿起两个筷子的那段代码加锁。 12345678910111213141516semaphore mutex = 1;void philosopher(int i) &#123; while(TURE)&#123; think(); down(mutex); down(chopstick[LEFT[i]]); down(chopstick[RIGHT[i]]); up(mutex); eat(); down(mutex); up(chopstick[RIGHT[i]]); up(chopstick[LEFT[i]]); up(mutex); &#125;&#125; 第三章 死锁死锁的条件 互斥 请求与保持 不可抢占 环路等待 其中，请求与保持是指一个进程因请求资源而阻塞时，对已获得的资源保持不放。 死锁的处理方法1. 鸵鸟策略把头埋在沙子里，假装根本没发生问题。 这种策略不可取。 2. 死锁预防在程序运行之前预防发生死锁。 2.1 破坏互斥条件例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 2.2 破坏请求与保持条件一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 2.3 破坏不可抢占条件2.4 破坏环路等待给资源统一编号，进程只能按编号顺序来请求资源。 3. 死锁避免在程序运行时避免发生死锁。 3.1 安全状态 图 a 的第二列 has 表示已拥有的资源数，第三列 max 表示总共需要的资源数，free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源，运行结束后释放 B，此时 free 变为 4；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 3.2 单个资源的银行家算法一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。 3.3 多个资源的银行家算法 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 4. 死锁检测与死锁恢复不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 4.1 死锁检测算法死锁检测的基本思想是，如果一个进程所请求的资源能够被满足，那么就让它执行，释放它拥有的所有资源，然后让其它能满足条件的进程执行。 上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P1 可以执行，执行后释放 P1 拥有的资源，A = (4 2 2 2) ，P2 也可以执行。所有进程都可以顺利执行，没有死锁。 算法总结如下： 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果有没有这样一个进程，算法终止。 4.2 死锁恢复 利用抢占恢复 杀死进程 第四章 存储器管理虚拟内存每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。 当程序引用到一部分在物理内存中的地址空间时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。 分页与分段1. 分页用户程序的地址空间被划分为若干固定大小的区域，称为“页”。相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配，由一个页表来维护它们之间的映射关系。 2. 分段 上图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态递增的特点会导致覆盖问题的出现。 分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。 每个段都需要程序员来划分。 3. 段页式用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。 用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。 程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护。 4. 分页与分段区别 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 页面置换算法在程序运行过程中，若其所要访问的页面不在内存而需要把它们调入内存，但是内存已无空闲空间时，系统必须从内存中调出一个页面到磁盘对换区中，并且将程序所需要的页面调入内存中。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 1. 最佳（Optimal）所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间会被再访问到。 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列： 7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 进程运行时，先将 7,0,1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。 2. 先进先出（FIFO）所选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 3. 最近最久未使用（LRU, Least Recently Used）虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。 可以用栈来实现该算法，栈中存储页面的页面号。当进程访问一个页面时，将该页面的页面号从栈移除，并将它压入栈顶。这样，最近被访问的页面的页面号总是在栈顶，而最近最久未使用的页面的页面号总是在栈底。 4，7，0，7，1，0，1，2，1，2，6 4. 时钟（Clock）Clock 页面置换算法需要用到一个访问位，当一个页面被访问时，将访问为置为 1。 首先，将内存中的所有页面链接成一个循环队列，当缺页中断发生时，检查当前指针所指向页面的访问位，如果访问位为 0，就将该页面换出；否则将该页的访问位设置为 0，给该页面第二次的机会，移动指针继续检查。 第五章 设备管理磁盘调度算法当多个进程同时请求访问磁盘时，需要进行磁盘调度来控制对磁盘的访问。磁盘调度的主要目标是使磁盘的平均寻道时间最少。 1. 先来先服务（FCFS, First Come First Serverd）根据进程请求访问磁盘的先后次序来进行调度。优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 2. 最短寻道时间优先（SSTF, Shortest Seek Time First）要求访问的磁道与当前磁头所在磁道距离最近的优先进行调度。这种算法并不能保证平均寻道时间最短，但是比 FCFS 好很多。 3. 扫描算法（SCAN）SSTF 会出现进行饥饿现象。考虑以下情况，新进程请求访问的磁道与磁头所在磁道的距离总是比一个在等待的进程来的近，那么等待的进程会一直等待下去。 SCAN 算法在 SSTF 算法之上考虑了磁头的移动方向，要求所请求访问的磁道在磁头当前移动方向上才能够得到调度。因为考虑了移动方向，那么一个进程请求访问的磁道一定会得到调度。 当一个磁头自里向外移动时，移到最外侧会改变移动方向为自外向里，这种移动的规律类似于电梯的运行，因此又常称 SCAN 算法为电梯调度算法。 4. 循环扫描算法（CSCAN）CSCAN 对 SCAN 进行了改动，要求磁头始终沿着一个方向移动。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001. Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统. 进程间的几种通信方式]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 Java HTTP]]></title>
    <url>%2Fblog%2F6481.html</url>
    <content type="text"><![CDATA[Java面试笔记 基础概念Web 基础 HTTP（HyperText Transfer Protocol，超文本传输协议）。 WWW（World Wide Web）的三种技术：HTML、HTTP、URL。 RFC（Request for Comments，征求修正意见书），互联网的设计文档。 URL URI（Uniform Resource Indentifier，统一资源标识符） URL（Uniform Resource Locator，统一资源定位符） URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4 。 URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。 请求和响应报文请求报文 响应报文 HTTP 方法客户端发送的请求报文第一行为请求行，包含了方法字段。 GET：获取资源POST：传输实体主体POST 主要目的不是获取资源，而是传输实体主体数据。 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体部分。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 GET 的传参方式相比于 POST 安全性较差，因为 GET 传的参数在 URL 是可见的，可能会泄露私密信息。并且 GET 只支持 ASCII 字符，如果参数为中文则可能会出现乱码，而 POST 支持标准字符集。 HEAD：获取报文首部和 GET 方法一样，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 PUT：上传文件由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般 WEB 网站不使用该方法。 DELETE：删除文件与 PUT 功能相反，并且同样不带验证机制。 OPTIONS：查询支持的方法查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 TRACE：追踪路径服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 TRACE 一般不会使用，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪），因此更不会去使用它。 CONNECT：要求用隧道协议连接代理主要使用 SSL（Secure Sokets Layer，安全套接字）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 HTTP 状态码服务器返回的响应报文中第一行为状态行，包含了状态码以及原因短语，来告知客户端请求的结果。 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 2XX 成功 200 OK 204 No Content：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content 3XX 重定向 301 Moved Permanently：永久性重定向 302 Found：临时性重定向 303 See Other 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会 在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，但是不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request：请求报文中存在语法错误 401 Unauthorized：该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden：请求被拒绝，服务器端没有必要给出拒绝的详细理由。 404 Not Found 5XX 服务器错误 500 Internal Server Error：服务器正在执行请求时发生错误 503 Service Unavilable：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 HTTP 首部有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 各种首部字段及其含义如下（不需要全记，仅供查阅）： 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、 连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位： 字节） Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 具体应用CookieHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 服务器发送的响应报文包含 Set-Cookie 字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。下次再发送请求时，从浏览器中读出 Cookie 值，在请求报文中包含 Cookie 字段，这样服务器就知道客户端的状态信息了。Cookie 状态信息保存在客户端浏览器中，而不是服务器上。 Set-Cookie 字段有以下属性： 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值（必需项） expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录） domain= 域名 作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名） Secure 仅在 HTTPS 安全通信时才会发送 Cookie HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问 Session 和 Cookie 区别 Session 是服务器用来跟踪用户的一种手段，每个 Session 都有一个唯一标识：Session ID。当服务器创建了一个 Session 时，给客户端发送的响应报文就包含了 Set-Cookie 字段，其中有一个名为 sid 的键值对，这个键值对就是 Session ID。客户端收到后就把 Cookie 保存在浏览器中，并且之后发送的请求报文都包含 Session ID。HTTP 就是通过 Session 和 Cookie 这两种方式一起合作来实现跟踪用户状态的，Session 用于服务器端，Cookie 用于客户端。 浏览器禁用 Cookie 的情况 会使用 URL 重写技术，在 URL 后面加上 sid=xxx 。 使用 Cookie 实现用户名和密码的自动填写 网站脚本会自动从 Cookie 中读取用户名和密码，从而实现自动填写。 缓存有两种缓存方法：让代理服务器进行缓存和让客户端浏览器进行缓存。 Cache-Control 用于控制缓存的行为。Cache-Control: no-cache 有两种含义，如果是客户端向缓存服务器发送的请求报文中含有该指令，表示客户端不想要缓存的资源；如果是源服务器向缓存服务器发送的响应报文中含有该指令，表示缓存服务器不能对资源进行缓存。 Expires 字段可以用于告知缓存服务器该资源什么时候会过期。当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。 持久连接当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。持久连接 只需要进行一次 TCP 连接就能进行多次 HTTP 通信。HTTP/1.1 开始，所有的连接默认都是持久连接。 持久连接需要使用 Connection 首部字段进行管理。HTTP/1.1 开始 HTTP 默认是持久化连接的，如果要断开 TCP 连接，需要由客户端或者服务器端提出断开，使用 Connection: close；而在 HTTP/1.1 之前默认是非持久化连接的，如果要维持持续连接，需要使用 Keep-Alive。 管线化方式可以同时发送多个请求和响应，而不需要发送一个请求然后等待响应之后再发下一个请求。 编码编码（Encoding）主要是为了对实体进行压缩。常用的编码有：gzip、compress、deflate、identity，其中 identity 表示不执行压缩的编码格式。 分块传输分块传输（Chunked Transfer Coding）可以把数据分割成多块，让浏览器逐步显示页面。 多部分对象集合一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔；每个部分都可以有首部字段。 例如，上传多个表单时可以使用如下方式： 范围请求如果网络出现中断，服务器只发送了一部分数据，范围请求使得客户端能够只请求未发送的那部分数据，从而避免服务器端重新发送所有数据。 在请求报文首部中添加 Range 字段，然后指定请求的范围，例如 Range:bytes=5001-10000。请求成功的话服务器发送 206 Partial Content 状态。 内容协商通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。 涉及以下首部字段：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language。 虚拟主机使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。 通信数据转发代理 代理服务器接受客户端的请求，并且转发给其它服务器。 代理服务器一般是透明的，不会改变 URL。 使用代理的主要目的是：缓存、网络访问控制以及访问日志记录。 网关 与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。 隧道 使用 SSL 等加密手段，为客户端和服务器之间建立一条安全的通信线路。 HTTPsHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPs 并不是新协议，而是 HTTP 先和 SSL（Secure Socket Layer）通信，再由 SSL 和 TCP 通信。通过使用 SSL，HTTPs 提供了加密、认证和完整性保护。 加密有两种加密方式：对称密钥加密和公开密钥加密。对称密钥加密的加密和解密使用同一密钥，而公开密钥加密使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 对称密钥加密的缺点：无法安全传输密钥；公开密钥加密的缺点：相对来说更耗时。 HTTPs 采用 混合的加密机制，使用公开密钥加密用于传输对称密钥，之后使用对称密钥加密进行通信。（下图中，共享密钥即对称密钥） 认证通过使用 证书 来对通信方进行认证。证书中有公开密钥数据，如果可以验证公开密钥的确属于通信方的，那么就可以确定通信方是可靠的。 数字证书认证机构（CA，Certificate Authority）可以对其颁发的公开密钥证书对其进行验证。 进行 HTTPs 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，就可以开始通信。 使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。 客户端证书需要用户自行安装，只有在业务需要非常高的安全性时才使用客户端证书，例如网上银行。 完整性SSL 提供摘要功能来验证完整性。 HTTP/1.0 与 HTTP/1.1 的区别HTTP/1.1 新增了以下内容： 默认为长连接； 提供了范围请求功能； 提供了虚拟主机的功能； 多了一些缓存处理字段； 多了一些状态码；]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2Fblog%2F64202.html</url>
    <content type="text"><![CDATA[Java面试笔记 常用操作以及概念求助1. –help 指令的基本用法与选项介绍。 2. man man 是 manual 的缩写，将指令的具体信息显示出来。 当执行 man date 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下： 代号 类型 1 用户在 shell 环境中可以操作的指令或者可执行文件 5 配置文件 8 系统管理员可以使用的管理指令 3. info info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。 关机1. sync 为了加快对磁盘上文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。 2. shutdown 12345# /sbin/shutdown [-krhc] [时间] [警告讯息]-k ： 不会关机，只是发送警告讯息，通知所有在线的用户-r ： 将系统的服务停掉后就重新启动-h ： 将系统的服务停掉后就立即关机-c ： 取消已经在进行的 shutdown 指令内容 3. 其它关机指令 reboot、halt、poweroff。 查看进程1ps aux | grep threadx 查看端口1netstat -anp | grep 80 PATH可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。 1/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin 运行等级 0：关机模式 1：单用户模式（可用于破解root密码） 2：无网络支持的多用户模式 3：有网络支持的多用户模式（文本模式，工作中最常用的模式） 4：保留，未使用 5：有网络支持的 X-windows 多用户模式（桌面） 6：重新引导系统，即重启 sudo使用 sudo 允许一般用户使用 root 可执行的命令，只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。 GNUGNU 计划，又译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议，包含了以下内容： 以任何目的运行此程序的自由； 再复制的自由； 改进此程序，并公开发布改进的自由。 包管理工具RPM 和 DPKG 为最常见的两类软件包管理工具。RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为很多 Linux 系统 (RHEL) 的既定软件标准。与 RPM 进行竞争的是基于 Debian 操作系统 (UBUNTU) 的 DEB 软件包管理工具－ DPKG，全称为 Debian Package，功能方面与 RPM 相似。 YUM 基于 RPM 包管理工具，具有依赖管理功能，并具有软件升级的功能。 常见发行版本Linux 发行版是 Linux 内核及各种应用软件的集成版本。 基于的包管理工具 商业发行版 社区发行版 DPKG Ubuntu Debian RPM Red Hat Fedora / CentOS 分区磁盘的文件名Linux 中每个硬件都被当做一个文件。 常见磁盘的文件名： SCSI/SATA/USB 磁盘：/dev/sd[a-p] IDE 磁盘：/dev/hd[a-d] 其中文件名后面的序号的确定与磁盘插入的顺序有关，而与磁盘所插入的插槽位置无关。 分区表磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。 1. MBRMBR 中，第一个扇区最重要，里面有：主要开机记录（Master boot record, MBR）及分区表（partition table），其中 MBR 占 446 bytes，partition table 占 64 bytes。 分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它将其它空间用来记录分区表，可以记录更多的分区，因此通过扩展分区可以分出更多区分，这些分区称为逻辑分区。 Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名+编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。 2. GPT不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA）。 GPT 第 1 个区块记录了 MBR，紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。 GPT 没有扩展分区概念，都是主分区，最多可以分 128 个分区。 开机检测程序1. BIOSBIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的 MBR，由 MBR 执行其中的开机管理程序，这个开机管理程序的会加载操作系统的核心文件。 MBR 中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动 MBR 中的开机管理程序时，就可以选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。 安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉 MBR，而 Linux 可以选择将开机管理程序安装在 MBR 或者其它分区的启动扇区，并且可以设置开机管理程序的选单。 2. UEFIUEFI 相比于 BIOS 来说功能更为全面，也更为安全。 挂载挂载利用目录作为分区的进入点，也就是说，进入目录之后就可以读取分区的数据。 文件权限与目录配置文件权限概念把用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。 使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x. 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段。 3：链接数； root：文件拥有者； root：所属群组； 17：文件大小； May 6 00:14：文件最后被修改的时间； .config：文件名。 常见的文件类型及其含义有： d：目录； -：文件； l：链接文件； 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件属性以及权限的修改1. 修改文件所属群组12# chgrp [-R] groupname dirname/filename-R：递归修改 2. 修改文件拥有者不仅可以修改文件拥有者，也可以修改文件所属群组。 1# chown [-R] 用户名:群组名 dirname/filename 3. 修改权限可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r：4、w：2、x：1。 1# chmod [-R] xyz dirname/filename 范例：将 .bashrc 文件的权限修改为 -rwxr-xr–。 1# chmod 754 .bashrc 也可以使用符号来设定权限。 12345678# chmod [ugoa] [+-=] [rwx] dirname/filename- u：拥有者- g：所属群组- o：其他人- a：所有人- +：添加权限- -：移除权限- =：设定权限 范例：为 .bashrc 文件的所有用户添加写权限。 1# chmod a+w .bashrc 目录的权限文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。 目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。 文件默认权限文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 可以通过 umask 设置或者查看文件的默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r– 。 目录配置为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下： / (root, 根目录) /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程序运行过程中的数据文件。 完整的目录树如下： 文件与目录文件时间 modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 文件与目录的基本操作1. ls列出文件或者目录的信息，目录的信息就是其中包含的文件。 1234# ls [-aAdfFhilnrRSt] file|dir-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据 2. cp复制操作。 如果源文件有两个以上，则目的文件一定要是目录才行。 12345678cp [-adfilprsu] source destination-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 3. rm移除操作。 12# rm [-fir] 文件或目录-r ：递归删除 4. mv移动操作。 123# mv [-fiu] source destination# mv [options] source1 source2 source3 .... directory-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 获取文件内容1. cat取得文件内容。 12# cat [-AbEnTv] filename-n ：打印出行号，连同空白行也会有行号，-b 不会 2. tac是 cat 的反向操作，从最后一行开始打印。 3. more可以一页一页查看文件内容，和文本编辑器类似。 4. less和 more 类似。 5. head可以取得文件前几行。 12# head [-n number] filename-n ：后面接数字，代表显示几行的意思 6. tail是 head 的反向操作，只是取得是后几行。 7. od可以以字符或者十六进制的形式显示二进制文件。 8. touch修改文件时间或者建立新文件。 123456# touch [-acdmt] filename-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接欲更新的日期而不用当前的日期，也可以使用 --date="日期或时间"-t ：后面可以接欲更新的时间而不用当前的时间，格式为[YYYYMMDDhhmm] 指令与文件搜索1. which指令搜索。 12# which [-a] command-a ：将所有指令列出，而不是只列第一个 2. whereiswhereis 搜索文件的速度比较快，因为它只搜索几个特定的目录。 1# whereis [-bmsu] dirname/filename 3. locatelocate 可以用关键字或者正则表达式进行搜索。 locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 12# locate [-ir] keyword-r：接正则表达式 4. findfind 可以使用文件的属性和权限进行搜索。 1# find filename [option] 4.1 与时间有关的选项1234-mtime n ：列出在 n 天前的那一天修改过内容的文件-mtime +n ：列出在 n 天之前(不含 n 天本身)修改过内容的文件-mtime -n ：列出在 n 天之内(含 n 天本身)修改过内容的文件-newer file ： 列出比 file 更新的文件 +4、4 和 -4 的指示的时间范围如下： 4.2 与文件拥有者和所属群组有关的选项123456-uid n-gid n-user name-group name-nouser ：搜索拥有者不存在 /etc/passwd 的文件-nogroup：搜索所属群组不存在于 /etc/group 的文件 4.3 与文件权限和名称有关的选项123456-name filename-size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k-type TYPE-perm mode ：搜索权限等于 mode 的文件-perm -mode ：搜索权限包含 mode 的文件-perm /mode ：搜索权限包含任一 mode 的文件 磁盘与文件系统文件系统的组成对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统，因此只有文件系统能被挂载，而分区不能被挂载。 文件系统有以下三个结构： superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等； inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 号码； block：记录文件的内容，文件太大时，会占用多个 block。 当要读取一个文件的内容时，先在 inode 中去查找文件内容所在的所有 block，然后把所有 block 的内容读出来。 磁盘碎片是指一个文件内容所在的 block 过于分散。 Ext2 文件系统使用了上述的文件结构，并在此之上加入了 block 群组的概念，也就是将一个文件系统划分为多个 block 群组，方便管理。 inodeExt2 文件系统支持的 block 大小有 1k、2k 和 4k 三种，不同的 block 大小限制了单一文件的大小。而每个 inode 大小是固定为 128 bytes。 inode 中记录了文件内容所在的 block，但是每个 block 非常小，一个大文件随便都需要几十万的 block，而一个 inode 大小有限，无法直接引用这么多 block。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块当成 inode 用来记录引用信息。 inode 具体包含以下信息： 该文件的存取模式(read/write/excute)； 该文件的拥有者与群组(owner/group)； 该文件的容量； 该文件建立或状态改变的时间(ctime)； 最近一次的读取时间(atime)； 最近修改的时间(mtime)； 定义文件特性的旗标(flag)，如 SetUID…； 该文件真正内容的指向 (pointer)。 目录的 inode 与 block建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。 实体链接与符号链接123# ln [-sf] source_filename dist_filename-s ：默认是 hard link，加 -s 为 symbolic link-f ：如果目标文件存在时，先删除目标文件 1. 实体链接hard link 只是在某个目录下新增一个条目，使得新增的条目链接到文件的 inode 上。删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制：不能跨越 File System；不能对目录进行链接。 1234# ln /etc/crontab .# ll -i /etc/crontab crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 2. 符号链接symbolic link 可以理解为 Windows 的快捷方式，通过建立一个独立的文件，这个文件的数据的读取指向链接的那个文件。当源文件被删除了，链接文件就打不开了。 symbolic link 可以为目录建立链接。 123# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 压缩与打包压缩Linux 底下有很多压缩文件的扩展名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 1. gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 123456$ gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为6 2. bzip2提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。 12$ bzip2 [-cdkzv#] filename-k ：保留源文件 3. xz提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意，压缩比越高，压缩的时间也越长。 查看命令：xzcat、xzmore、xzless、xzgrep。 1$ xz [-dtlkc#] filename 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。 123456789101112$ tar [-z|-j|-J] [cv] [-f 新建的tar文件] filename... ==打包压缩$ tar [-z|-j|-J] [tv] [-f 已有的tar文件] ==查看$ tar [-z|-j|-J] [xv] [-f 已有的tar文件] [-C 目录] ==解压缩-z ：使用zip；-j ：使用bzip2；-J ：使用xz；-c ：新建打包文件；-t ：查看打包文件里面有哪些文件；-x ：解打包或解压缩的功能；-v ：在压缩/解压缩的过程中，显示正在处理的文件名；-f : filename：要处理的文件；-C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 Bash可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。 Bash 特性1. 命令历史 记录使用过的命令。本次登录所执行的命令都会暂时存放到内存中， ~/.bash_history 文件中记录的是前一次登录所执行过的命令。 2. 命令与文件补全 快捷键：tab 3. 命名别名 例如 lm 是 ls -al 的别名。 4. shell scripts 5. 通配符 例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件。 变量操作 对一个变量赋值直接使用 = ； 对变量取用需要在变量前加上 \{} 的形式； 输出变量使用 echo 命令。 123$ var=abc$ echo $var$ echo $&#123;var&#125; 变量内容如果有空格，需要使用双引号或者单引号。双引号内的特殊字符可以保留原本特性，例如var=”lang is \&lt;img src=”https://latex.codecogs.com/gif.latex?LANG&quot;，则var的值为langiszh_TW.UTF-8；而单引号内的特殊字符就是特殊字符本身，例如var=&#39;langis\&quot;/&gt;LANG&#39;，则 var 的值为 lang is \$LANG。 可以使用 `指令` 或者 \(uname -r)，则 version 的值为 3.10.0-229.el7.x86_64。 可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。 Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令： 12345$ declare [-aixr] variable-a ： 定义为数组类型-i ： 定义为整数类型-x ： 定义为环境变量-r ： 定义为readonly类型 使用 [ ] 来对数组进行操作： 123$ array[1]=a$ array[2]=b$ echo $&#123;array[1]&#125; 指令搜索顺序 以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ； 由别名找到该指令来执行； 由 Bash 内建的指令来执行； 按 \$PATH 变量指定的搜索路径的顺序找到第一个指令来执行。 数据流重定向重定向就是使用文件代替标准输入、标准输出和标准错误输出。 标准输入(stdin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：代码为 0 ，使用 &lt; 或 &lt;&lt; ； 标准输出(stdout)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：代码为 1 ，使用 &gt; 或 &gt;&gt; ； 标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ； 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 1$ find /home -name .bashrc &gt; list 2&gt;&amp;1 管线指令管线是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的格式时就可以使用管线。在命令之间使用 | 分隔各个管线命令。 1$ ls -al /etc | less 1. 提取指令：cut提取过程一行一行地进行。 cut 对数据进行切分，取出想要的部分。 1234$ cut-d ：分隔符-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间-c ：以字符为单位取出区间 范例 1：last 将显示的登入者的信息，要求仅显示用户名。 123456$ lastroot pts/1 192.168.201.101 Sat Feb 7 12:35 still logged inroot pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)$ last | cut -d ' ' -f 1 范例 2：将 export 输出的讯息，取得第 12 字符以后的所有字符串。 12345678$ exportdeclare -x HISTCONTROL="ignoredups"declare -x HISTSIZE="1000"declare -x HOME="/home/dmtsai"declare -x HOSTNAME="study.centos.vbird".....(其他省略).....$ export | cut -c 12 2. 排序命令：sort、uniqsort 进行排序。 123456789$ sort [-fbMnrtuk] [file or stdin]-f ：忽略大小写-b ：忽略最前面的空格-M ：以月份的名字来排序，例如 JAN，DEC-n ：使用数字-r ：反向排序-u ：相当于 unique，重复的内容只出现一次-t ：分隔符，默认为 tab-k ：指定排序的区间 范例：/etc/passwd 内容是以 : 来分隔的，以第三栏来排序。 12345$ cat /etc/passwd | sort -t ':' -k 3root:x:0:0:root:/root:/bin/bashdmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bashalex:x:1001:1002::/home/alex:/bin/basharod:x:1002:1003::/home/arod:/bin/bash uniq 可以将重复的数据只取一个。 123$ uniq [-ic]-i ：忽略大小写-c ：进行计数 范例：取得每个人的登录总次数 1234567$ last | cut -d ' ' -f 1 | sort | uniq -c16 (unknown47 dmtsai4 reboot7 root1 wtmp 3. 双向输出重定向：tee输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。 1$ tee [-a] file 4. 字符转换指令：tr、col、expand、join、paste tr 用来删除一行中的字符，或者对字符进行替换。 12$ tr [-ds] SET1 ...-d ： 删除行中 SET1 这个字符串 范例，将 last 输出的信息所有小写转换为大写。 1$ last | tr '[a-z]' '[A-Z]' col 将 tab 字符转为空格字符。 12$ col [-xb]-x ： 将 tab 键转换成对等的空格键 expand 将 tab 转换一定数量的空格，默认是 8 个。 12$ expand [-t] file-t ：tab 转为空格的数量 join 将有相同数据的那一行合并在一起。 12345$ join [-ti12] file1 file2-t ：分隔符，默认为空格-i ：忽略大小写的差异-1 ：第一个文件所用的比较字段-2 ：第二个文件所用的比较字段 paste 直接将两行粘贴在一起。 12$ paste [-d] file1 file2-d ：分隔符，默认为 tab 5. 分区指令：splitsplit 将一个文件划分成多个文件。 1234$ split [-bl] file PREFIX-b ：以大小来进行分区，可加单位，例如 b, k, m 等-l ：以行数来进行分区。- PREFIX ：分区文件的前导名称 正规表示法与文件格式化处理grep使用正则表示式把匹配的行提取出来。 1234567$ grep [-acinv] [--color=auto] 搜寻字符串 filename-a ： 将 binary 文件以 text 文件的方式进行搜寻-c ： 计算找到个数-i ： 忽略大小写-n ： 输出行号-v ： 反向选择，亦即显示出没有 搜寻字符串 内容的那一行--color=auto ：找到的关键字加颜色显示 范例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串） 123456$ grep -n 'the' regular_express.txt8:I can't finish the test.12:the symbol '*' is represented as start.15:You are the best is mean you are the no. 1.16:The world Happy is the same with "glad".18:google is the best tools for search keyword 因为 { 与 } 的符号在 shell 是有特殊意义的，因此必须要使用使用转义字符进行转义。 1$ grep -n 'go\&#123;2,5\&#125;g' regular_express.txt printf用于格式化输出。 它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。 1234$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt) DmTsai 80 60 92 77.33 VBird 75 55 80 70.00 Ken 60 90 70 73.33 awk1$ awk '条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...' filename awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：\0 表示一整行。 范例 1：取出登录用户的用户名和 ip 12345678$ last -n 5dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged indmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)$ last -n 5 | awk '&#123;print $1 "\t" $3&#125; awk 变量： 变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 范例 2：输出正在处理的行号，并显示每一行有多少字段 123456$ last -n 5 | awk '&#123;print $1 "\t lines: " NR "\t columns: " NF&#125;'dmtsai lines: 1 columns: 10dmtsai lines: 2 columns: 10dmtsai lines: 3 columns: 10dmtsai lines: 4 columns: 10dmtsai lines: 5 columns: 9 可以使用大于等于逻辑，其中等于使用 ==。 范例 3：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。 1234cat /etc/passwd | awk &apos;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&apos;root 0bin 1daemon 2 vim 三个模式 在指令列模式下，有以下命令用于离开或者存储文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 参考资料 鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009. Linux 平台上的软件包管理]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL命令]]></title>
    <url>%2Fblog%2F16221.html</url>
    <content type="text"><![CDATA[Java面试笔记 基础模式：定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。 主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL，各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 查询SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。 DISTINCT 相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 12SELECT DISTINCT col1, col2FROM mytable; LIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 返回前 5 行的 SQL： 123SELECT *FROM mytableLIMIT 5; 123SELECT *FROM mytableLIMIT 0, 5; 返回第 3 ~ 5 行： 123SELECT *FROM mytableLIMIT 2, 3; 注释 12345# 注释SELECT *FROM mytable -- 注释/* 注释1 注释2 */ 排序ASC：升序（默认）DESC：降序 可以按多个列进行排序： 123SELECT *FROM mytableORDER BY col1 DESC, col2 ASC; 过滤在应用层也可以过滤数据，但是不在服务器端进行过滤的数据非常大，导致通过网络传输了很多多余的数据，从而浪费了网络带宽。 123SELECT *FROM mytableWHERE col IS NULL; 下表显示了 WHERE 子句可用的操作符 操作符 说明 = &lt; &gt; 等于 小于 大于 &lt;&gt; != 不等于 &lt;= !&gt; 小于等于 &gt;= !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为NULL值 应该注意到，NULL 与 0 、空字符串都不同。 AND OR 用于连接多个过滤条件。优先处理 AND，因此当一个过滤表达式涉及到多个 AND 和 OR 时，应当使用 () 来决定优先级。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 通配符通配符也是用在过滤语句中，只能用于文本字段。 % 匹配 &gt;=0 个任意字符，类似于 *； _ 匹配 ==1 个任意字符，类似于 .； [ ] 可以匹配集合内的字符，用脱字符 ^ 可以对其进行否定 使用 Like 来进行通配符匹配。 123SELECT *FROM mytableWHERE col LIKE '[^AB]%' -- 不以AB开头的任意文本 不要滥用通配符，通配符位于开头处匹配会非常慢。 计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12SELECT col1*col2 AS aliasFROM mytable Concat() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 12SELECT Concat(TRIM(col1), ' (', TRIM(col2), ')')FROM mytable 函数各个 DBMS 的函数都是不相同的，因此不可移植。 文本处理 函数 说明 LEFT() RIGHT() 左边或者右边的字符 LOWER() UPPER() 转换为小写或者大写 LTRIM() RTIM() 去除左边或者右边的空格 LENGTH() 长度 SUNDEX() 转换为语音值 其中，SOUNDEX() 是将一个字符串转换为描述其语音表示的字母数字模式的算法，它是根据发音而不是字母比较。 123SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple') 日期和时间处理日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 12mysql&gt; SELECT NOW(); -&gt; '2017-06-28 14:01:52' 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 DISTINCT 关键字会只汇总不同的值。 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable 分组分组就是把相同的数据放在同一组中。 可以对每组数据使用汇总函数进行处理，例如求每组数的平均值等。 按 col 排序并分组数据： 123SELECT col, COUNT(*) AS numFROM mytableGROUP BY col; WHERE 过滤行，HAVING 过滤分组，行过滤应当先与分组过滤； 12345SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING COUNT(*) &gt;= 2; GROUP BY 的排序结果为分组字段，而 ORDER BY 也可以以聚集字段来进行排序。 1234SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总计算语句之外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 子查询子查询中只能返回一个列。 可以将子查询的结果作为 WHRER 语句的过滤条件： 1234SELECT *FROM mytable1WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量。子查询语句会对检索出的每个客户执行一次： 123456SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM CustomersORDER BY cust_name; 连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123select a, b, cfrom A inner join Bon A.key = B.key 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123select a, b, cfrom A, Bwhere A.key = B.key 在没有条件语句的情况下返回笛卡尔积。 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 123456select namefrom employeewhere department = ( select department from employee where name = &quot;Jim&quot;); 自连接版本 1234select namefrom employee as e1, employee as e2where e1.department = e2.department and e1.name = &quot;Jim&quot;; 连接一般比子查询的效率高。 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列；内连接属于自然连接。 12select *from employee natural join department; 外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表的所有行。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123select Customers.cust_id, Orders.order_num from Customers left outer join Orders on Customers.cust_id = Orders.curt_id 如果需要统计顾客的订单数，使用聚集函数。 12345select Customers.cust_id, COUNT(Orders.order_num) as num_ordfrom Customers left outer join Orderson Customers.cust_id = Orders.curt_idgroup by Customers.cust_id 组合查询使用 UNION 来连接两个查询，每个查询必须包含相同的列、表达式或者聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL 。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 插入普通插入 12INSERT INTO mytable(col1, col2)VALUES(val1, val2); 插入检索出来的数据 123INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2; 将一个表的内容复制到一个新表 12CREATE TABLE newtable ASSELECT * FROM mytable; 更新123UPDATE mytableSET col = valWHERE id = 1; 删除12DELETE FROM mytableWHERE id = 1; TRUNCATE TABLE 可以清空表，也就是删除所有行。 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。 创建表123456CREATE TABLE mytable ( id INT NOT NULL AUTO_INCREMENT, col1 INT NOT NULL DEFAULT 1, col2 VARCHAR(45) NULL, col3 DATE NULL, PRIMARY KEY (`id`)); 修改表添加列 12ALTER TABLE mytableADD col CHAR(20); 删除列 12ALTER TABLE mytableDROP COLUMN col; 删除表 1DROP TABLE mytable; 视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 1234CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS count_colFROM mytableWHERE col5 = val; 存储过程存储过程可以看成是对一系列 SQL 操作的批处理； 使用存储过程的好处 把实现封装在了存储过程中，不仅简单，也保证了安全性； 可以复用代码； 由于是预先编译，因此具有很高的性能。 创建存储过程 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 1234567891011delimiter //create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end //delimiter ; 12call myprocedure(@ret);select @ret; 游标在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； 1234567891011121314151617181920delimiter //create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate '02000' set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化。 INSERT 触发器包含一个名为 NEW 的虚拟表。 12CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col; DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。 MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。 事务处理基本术语 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CRETE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，也就是每执行一条语句就会提交一次。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过设置 autocommit 为 0 可以取消自动提交，直到 autocommit 被设置为 1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。 1234567START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT 字符集基本术语 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定： 123CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对： 123SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci; 权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 12USE mysql;SELECT user FROM user; 创建账户 1CREATE USER myuser IDENTIFIED BY 'mypassword'; 新创建的账户没有任何权限。 修改账户名 1RENAME myuser TO newuser; 删除账户 1DROP USER myuser; 查看权限 1SHOW GRANTS FOR myuser; 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 授予权限 1GRANT SELECT, INSERT ON mydatabase.* TO myuser; 删除权限 1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 更改密码 必须使用 Password() 函数 1SET PASSWROD FOR myuser = Password('newpassword');]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2Fblog%2F17374.html</url>
    <content type="text"><![CDATA[Java面试笔记 内存模型 注：白色区域为线程私有的，蓝色区域为线程共享的。 1. 程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是 Native 方法则为空）。 2. Java 虚拟机栈每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请导足够内存，会抛出 OutOfMemoryError 异常。 3. 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 4. Java 堆所有对象实例都在这里分配内存。 这块区域是垃圾收集器管理的主要区域（”GC 堆 “）。现在收集器基本都是采用分代收集算法，Java 堆还可以分成：新生代和老年代（新生代还可以分成 Eden 空间、From Survivor 空间、To Survivor 空间等）。 不需要连续内存，可以通过 -Xmx 和 -Xms 来控制动态扩展内存大小，如果动态扩展失败会抛出 OutOfMemoryError 异常。 5. 方法区用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现，HotSpot 虚拟机把它当成永久代来进行垃圾回收。 6. 运行时常量池运行时常量池是方法区的一部分。 类加载后，Class 文件中的常量池（用于存放编译期生成的各种字面量和符号引用）就会被放到这个区域。 在运行期间也可以用过 String 类的 intern() 方法将新的常量放入该区域。 7. 直接内存在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 垃圾收集程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。 垃圾回收主要是针对 Java 堆和方法区进行。 1. 判断一个对象是否可回收1.1 引用计数给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。 引用计数为 0 的对象可被回收。 两个对象会出现循环引用问题，此时引用计数器永远不为 0，导致 GC 收集器无法回收。 12objA.instance = objB;objB.instance = objA; 1.2 可达性通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是都是可用的，不可达的对象可被回收。 GC Roots 一般包含以下内容： 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中引用的对象 1.3 引用类型无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定独享是否存活都与“引用”有关。 1.3.1 强引用只要强引用存在，垃圾回收器永远不会回收调掉被引用的对象。 1Object obj = new Object(); 1.3.2 软引用非必须引用，内存溢出之前进行回收。 1234Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;sf.get(); sf 是对 obj 的一个软引用，通过 sf.get() 方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回 null； 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 1.3.3 弱引用只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会被回收。 12345Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;wf.get();wf.isEnQueued(); 1.3.4 虚引用又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 12345Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj=null;pf.get();pf.isEnQueued(); 1.3 方法区的回收在方法区主要是对常量池的回收和对类的卸载。 常量池的回收和堆中对象回收类似。 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGo 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 1.4 finalize()当一个对象可被回收时，如果该对象有必要执行 finalize() 方法，那么就有可能可能通过在该方法中让对象重新被引用，从而实现自救。 finalize() 类似 C++ 的虚构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 2. 垃圾收集算法2.1 标记 - 清除算法 将需要回收的对象进行标记，然后清除。 不足： 标记和清除过程效率都不高 会产生大量碎片 之后的算法都是基于该算法进行改进。 2.2 复制算法 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，需要依赖于老年代进行分配担保，也就是借用老年代的空间。 2.3 标记 - 整理算法 让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存。 2.4 分代收集算法现在的商业虚拟机采用分代收集算法，它使用了前面介绍的几种收集算法，根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将 Java 堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清理 或者 标记 - 整理 算法。 3. 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 3.1 Serial 收集器 它是单线程的收集器，不仅意味着只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停所有其他工作线程，往往造成过长的等待时间。 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 在 Client 应用场景中，分配给虚拟机管理的内存一般来说不会很大，该收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 3.2 ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。 3.3 Parallel Scavenge 收集器是并行的多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。自适应调节策略也是它与 ParNew 收集器的一个重要区别。 3.4 Serial Old 收集器 Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 3.5 Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 3.6 CMS 收集器 CMS（Concurrent Mark Sweep），从 Mark Sweep 可以知道它是基于 标记 - 清除 算法实现的。 特点：并发收集、低停顿。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 对 CPU 资源敏感。CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4，当 CPU 不足 4 个时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。并且低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率变低。 无法处理浮动垃圾。由于并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留到下一次 GC 时再清理掉，这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此它不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。可以使用 -XX:CMSInitiatingOccupancyFraction 的值来改变触发收集器工作的内存占用百分比，JDK 1.5 默认设置下该值为 68，也就是当老年代使用了 68% 的空间之后会触发收集器工作。如果该值设置的太高，导致浮动垃圾无法保存，那么就会出现 Concurrent Mode Failure，此时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集。 标记 - 清除算法导致的空间碎片，给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前出发一次 Full GC。 3.7 G1 收集器 G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。 具备如下特点： 并行与并发：能充分利用多 CPU 环境下的硬件优势，使用多个 CPU 来缩短停顿时间； 分代收集：分代概念依然得以保留，虽然它不需要其它收集器配合就能独立管理整个 GC 堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次 GC 的旧对象来获取更好的收集效果。 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：这是它相对 CMS 的一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。 在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老生代，而 G1 不再是这样，Java 堆的内存布局与其他收集器有很大区别，将整个 Java 堆划分为多个大小相等的独立区域（Region）。虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分 Region（不需要连续）的集合。 之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。它跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了它在有限的时间内可以获取尽可能高的收集效率。 Region 不可能是孤立的，一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个 Java 堆才能保证准确性，这显然是对 GC 效率的极大伤害。为了避免全堆扫描的发生，每个 Region 都维护了一个与之对应的 Remembered Set。虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中，如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 3.8 七种垃圾收集器的比较 收集器 串行、并行 or 并发 新生代 / 老年代 算法 目标 适用场景 Serial 串行 新生代 复制算法 响应速度优先 单 CPU 环境下的 Client 模式 Serial Old 串行 老年代 标记 - 整理 响应速度优先 单 CPU 环境下的 Client 模式、CMS 的后备预案 ParNew 并行 新生代 复制算法 响应速度优先 多 CPU 环境时在 Server 模式下与 CMS 配合 Parallel Scavenge 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 并行 老年代 标记 - 整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并发 老年代 标记 - 清除 响应速度优先 集中在互联网站或 B/S 系统服务端上的 Java 应用 G1 并发 both 标记 - 整理 + 复制算法 响应速度优先 面向服务端应用，将来替换 CMS 4. 内存分配与回收策略4.1 优先在 Eden 分配大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC； 4.2 大对象直接进入老年代提供 -XX:PretenureSizeThreshold 参数，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制； 4.3 长期存活的对象进入老年代JVM 为对象定义年龄计数器，经过 Minor GC 依然存活且被 Survivor 区容纳的，移动到 Survivor 区，年龄加 1，每经历一次 Minor GC 不被清理则年龄加 1，增加到一定年龄则移动到老年区（默认 15 岁，通过 -XX:MaxTenuringThreshold 设置）； 4.4 动态对象年龄判定若 Survivor 区中同年龄所有对象大小总和大于 Survivor 空间一半，则年龄大于等于该年龄的对象可以直接进入老年代； 4.5 空间分配担保在发生 Minor GC 之前，JVM 先检查老年代最大可用连续空间是否大于新生代所有对象总空间，成立的话 Minor GC 确认是安全的；否则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，大于的话进行 Minor GC，小于的话进行 Full GC。 4.6 Full GC 的触发条件对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 4.6.1 调用 System.gc()此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc()。 4.6.2 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出如下错误： Java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。 4.6.3 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。 4.6.4 JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space 为避免 PermGen 占满造成 Full GC 现象，可采用的方法为增大 PermGen 空间或转为使用 CMS GC。 在 JDK 1.8 中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种 Full GC 触发的可能性。 4.6.5 Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 类加载机制类是在运行期间动态加载的。 1 类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 2. 类初始化时机虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化：( 加载、验证、准备都会随着发生 ) 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 jdk1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 1. 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 2. 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 3. 类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。 3.1 加载加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。 从网络中获取，这种场景最典型的应用是 Applet。 运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。 从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。… 3.2 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 主要有以下 4 个阶段： 文件格式验证 元数据验证（对字节码描述的信息进行语义分析） 字节码验证（通过数据流和控制流分析，确保程序语义是合法、符合逻辑的，将对类的方法体进行校验分析） 符号引用验证 3.3 准备类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。 1public static final int value = 123; 3.4 解析将常量池的符号引用替换为直接引用的过程。 3.5 初始化初始化阶段即虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 &lt;clinit&gt;() 方法具有以下特点： 是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 与类的构造函数（或者说实例构造器 &lt;init&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 &lt;clinit&gt;() 方法运行之前，父类的 &lt;clinit&gt;() 方法已经执行结束。因此虚拟机中第一个执行 &lt;clinit&gt;() 方法的类肯定为 java.lang.Object。 由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码： 1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); // 输出结果是父类中的静态变量值 A，也就是 2&#125; &lt;clinit&gt;() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 &lt;clinit&gt;() 方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。 虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。 4. 类加载器虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流 ( 即字节码 )”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 4.1 类与类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗而言：比较两个类是否“相等”（这里所指的“相等”，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof() 关键字对做对象所属关系判定等情况），只有在这两个类时由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 4.2 类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；另一种就是所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader） 此类加载器负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader） 这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;Java_Home&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader） 这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 4.3 双亲委派模型应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 工作过程 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是把这个请求委派给父类加载器，每一个层次的加载器都是如此，依次递归，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成此加载请求（它搜索范围中没有找到所需类）时，子加载器才会尝试自己加载。 好处 使用双亲委派模型来组织类加载器之间的关系，使得 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放再 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型，由各个类加载器自行加载的话，如果用户编写了一个称为｀java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将变得一片混乱。如果开发者尝试编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但是永远无法被加载运行。 实现 12345678910111213141516171819202122protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; //check the class has been loaded or not Class c = findLoadedClass(name); if(c == null) &#123; try&#123; if(parent != null) &#123; c = parent.loadClass(name, false); &#125; else&#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch(ClassNotFoundException e) &#123; //if throws the exception , the father can not complete the load &#125; if(c == null) &#123; c = findClass(name); &#125; &#125; if(resolve) &#123; resolveClass(c); &#125; return c;&#125; JVM 参数GC 优化配置 配置 描述 -Xms 初始化堆内存大小 -Xmx 堆内存最大值 -Xmn 新生代大小 -XX:PermSize 初始化永久代大小 -XX:MaxPermSize 永久代最大容量 GC 类型设置 配置 描述 -XX:+UseSerialGC 串行垃圾回收器 -XX:+UseParallelGC 并行垃圾回收器 -XX:+UseConcMarkSweepGC 并发标记扫描垃圾回收器 -XX:ParallelCMSThreads= 并发标记扫描垃圾回收器 = 为使用的线程数量 -XX:+UseG1GC G1 垃圾回收器 1java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法思想]]></title>
    <url>%2Fblog%2F29283.html</url>
    <content type="text"><![CDATA[Java面试笔记 算法思想二分查找二分查找思想简单，但是在实现时有一些需要注意的细节： 在计算 mid 时不能使用 mid = (l + h) / 2 这种方式，因为 l + h 可能会导致加法溢出，应该使用 mid = l + (h - l) / 2。 对 h 的赋值和循环条件有关，当循环条件为 l &lt;= h 时，h = mid - 1；当循环条件为 l &lt; h 时，h = mid。解释如下：在循环条件为 l &lt;= h 时，如果 h = mid，会出现循环无法退出的情况，例如 l = 1，h = 1，此时 mid 也等于 1，如果此时继续执行 h = mid，那么就会无限循环；在循环条件为 l &lt; h，如果 h = mid - 1，会错误跳过查找的数，例如对于数组 [1,2,3]，要查找 1，最开始 l = 0，h = 2，mid = 1，判断 key &lt; arr[mid] 执行 h = mid - 1 = 0，此时循环退出，直接把查找的数跳过了。 l 的赋值一般都为 l = mid + 1。 12345678910public int search(int key, int[] arr) &#123; int l = 0, h = arr.length - 1; while (l &lt;= h) &#123; int mid = l + (h - l) / 2; if (key == arr[mid]) return mid; if (key &lt; arr[mid]) h = mid - 1; else l = mid + 1; &#125; return -1;&#125; 求开方 Leetcode : 69. Sqrt(x) (Easy) 一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt 。可以利用二分查找在 0 ~ x 之间查找 sqrt。 123456789101112public int mySqrt(int x) &#123; if(x &lt;= 1) return x; int l = 1, h = x; while(l &lt;= h)&#123; int mid = l + (h - l) / 2; int sqrt = x / mid; if(sqrt == mid) return mid; else if(sqrt &lt; mid) h = mid - 1; else l = mid + 1; &#125; return h;&#125; 摆硬币 Leetcode : 441. Arranging Coins (Easy) 123456789n = 8The coins can form the following rows:¤¤ ¤¤ ¤ ¤¤ ¤Because the 4th row is incomplete, we return 3. 题目描述：第 i 行摆 i 个，统计能够摆的行数。 返回 h 而不是 l，因为摆的硬币最后一行不能算进去。 1234567891011public int arrangeCoins(int n) &#123; int l = 0, h = n; while(l &lt;= h)&#123; int m = l + (h - l) / 2; long x = m * (m + 1L) / 2; if(x == n) return m; else if(x &lt; n) l = m + 1; else h = m - 1; &#125; return h;&#125; 可以不用二分查找，更直观的解法如下： 12345678public int arrangeCoins(int n) &#123; int level = 1; while (n &gt; 0) &#123; n -= level; level++; &#125; return n == 0 ? level - 1 : level - 2;&#125; 有序数组的 Single Element Leetcode : 540. Single Element in a Sorted Array (Medium) 题目描述：一个有序数组只有一个数不出现两次，找出这个数。 12345678910public int singleNonDuplicate(int[] nums) &#123; int l = 0, h = nums.length - 1; while(l &lt; h) &#123; int m = l + (h - l) / 2; if(m % 2 == 1) m--; // 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数 if(nums[m] == nums[m + 1]) l = m + 2; else h = m; &#125; return nums[l];&#125; 贪心思想贪心思想保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。 分配饼干 Leetcode : 455. Assign Cookies (Easy) 题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。 因为最小的孩子最容易得到满足，因此先满足最小孩子。给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。 证明：假设在某次选择中，贪心策略选择给第 i 个孩子分配第 m 个饼干，并且第 i 个孩子满足度最小，第 m 个饼干为可以满足第 i 个孩子的最小饼干，利用贪心策略最终可以满足 k 个孩子。假设最优策略在这次选择中给 i 个孩子分配第 n 个饼干，并且这个饼干大于第 m 个饼干。我们发现使用第 m 个饼干去替代第 n 个饼干完全不影响后续的结果，因此不存在比贪心策略更优的策略，即贪心策略就是最优策略。 12345678910public int findContentChildren(int[] g, int[] s) &#123; Arrays.sort(g); Arrays.sort(s); int i = 0, j = 0; while(i &lt; g.length &amp;&amp; j &lt; s.length)&#123; if(g[i] &lt;= s[j]) i++; j++; &#125; return i;&#125; 投飞镖刺破气球 Leetcode : 452. Minimum Number of Arrows to Burst Balloons (Medium) 12345Input:[[10,16], [2,8], [1,6], [7,12]]Output:2 题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直射向坐标轴，使得路径上的气球都会刺破。求解最小的投飞镖次数使所有气球都被刺破。 从左往右投飞镖，并且在每次投飞镖时满足以下条件： 左边已经没有气球了； 本次投飞镖能够刺破最多的气球。 1234567891011121314public int findMinArrowShots(int[][] points) &#123; if(points.length == 0) return 0; Arrays.sort(points,(a,b) -&gt; (a[1] - b[1])); int curPos = points[0][1]; int ret = 1; for (int i = 1; i &lt; points.length; i++) &#123; if(points[i][0] &lt;= curPos) &#123; continue; &#125; curPos = points[i][1]; ret++; &#125; return ret; &#125; 股票的最大收益 Leetcode : 122. Best Time to Buy and Sell Stock II (Easy) 题目描述：一次交易包含买入和卖出，多个交易之间不能交叉进行。 对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加加到收益中，从而在局部最优的情况下也保证全局最优。 1234567public int maxProfit(int[] prices) &#123; int profit = 0; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i] &gt; prices[i-1]) profit += (prices[i] - prices[i-1]); &#125; return profit;&#125; 种植花朵 Leetcode : 605. Can Place Flowers (Easy) 12Input: flowerbed = [1,0,0,0,1], n = 1Output: True 题目描述：花朵之间至少需要一个单位的间隔。 12345678910111213public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; int cnt = 0; for(int i = 0; i &lt; flowerbed.length; i++)&#123; if(flowerbed[i] == 1) continue; int pre = i == 0 ? 0 : flowerbed[i - 1]; int next = i == flowerbed.length - 1 ? 0 : flowerbed[i + 1]; if(pre == 0 &amp;&amp; next == 0) &#123; cnt++; flowerbed[i] = 1; &#125; &#125; return cnt &gt;= n;&#125; 修改一个数成为非递减数组 Leetcode : 665. Non-decreasing Array (Easy) 题目描述：判断一个数组能不能只修改一个数就成为非递减数组。 在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，那么就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，只修改 nums[i - 1] = nums[i] 不能令数组成为非递减，只能通过修改 nums[i] = nums[i - 1] 才行。 1234567891011public boolean checkPossibility(int[] nums) &#123; int cnt = 0; for(int i = 1; i &lt; nums.length; i++)&#123; if(nums[i] &lt; nums[i - 1])&#123; cnt++; if(i - 2 &gt;= 0 &amp;&amp; nums[i - 2] &gt; nums[i]) nums[i] = nums[i-1]; else nums[i - 1] = nums[i]; &#125; &#125; return cnt &lt;= 1;&#125; 判断是否为子串 Leetcode : 392. Is Subsequence (Medium) 12s = "abc", t = "ahbgdc"Return true. 1234567public boolean isSubsequence(String s, String t) &#123; for (int i = 0, pos = 0; i &lt; s.length(); i++, pos++) &#123; pos = t.indexOf(s.charAt(i), pos); if(pos == -1) return false; &#125; return true;&#125; 分隔字符串使同种字符出现在一起 Leetcode : 763. Partition Labels (Medium) 123456Input: S = "ababcbacadefegdehijhklij"Output: [9,7,8]Explanation:The partition is "ababcbaca", "defegde", "hijhklij".This is a partition so that each letter appears in at most one part.A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts. 1234567891011121314151617public List&lt;Integer&gt; partitionLabels(String S) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); int[] lastIdxs = new int[26]; for(int i = 0; i &lt; S.length(); i++) lastIdxs[S.charAt(i) - 'a'] = i; int startIdx = 0; while(startIdx &lt; S.length()) &#123; int endIdx = startIdx; for(int i = startIdx; i &lt; S.length() &amp;&amp; i &lt;= endIdx; i++) &#123; int lastIdx = lastIdxs[S.charAt(i) - 'a']; if(lastIdx == i) continue; if(lastIdx &gt; endIdx) endIdx = lastIdx; &#125; ret.add(endIdx - startIdx + 1); startIdx = endIdx + 1; &#125; return ret;&#125; 根据身高和序号重组队列 Leetcode : 406. Queue Reconstruction by Height(Medium) 12345Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。 为了在每次插入操作时不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入第 k 个位置可能会变成第 k+1 个位置。 身高降序、k 值升序，然后按排好序的顺序插入队列的第 k 个位置中。 1234567891011121314151617181920212223public int[][] reconstructQueue(int[][] people) &#123; if(people == null || people.length == 0 || people[0].length == 0) return new int[0][0]; Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; if(a[0] == b[0]) return a[1] - b[1]; return b[0] - a[0]; &#125; &#125;); int n = people.length; List&lt;int[]&gt; tmp = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; n; i++) &#123; tmp.add(people[i][1], new int[]&#123;people[i][0], people[i][1]&#125;); &#125; int[][] ret = new int[n][2]; for(int i = 0; i &lt; n; i++) &#123; ret[i][0] = tmp.get(i)[0]; ret[i][1] = tmp.get(i)[1]; &#125; return ret;&#125; 双指针双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 从一个已经排序的数组中查找出两个数，使它们的和为 0 Leetcode ：167. Two Sum II - Input array is sorted (Easy) 使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 如果两个指针指向元素的和 sum == target，那么得到要求的结果；如果 sum &gt; target，移动较大的元素，使 sum 变小一些；如果 sum &lt; target，移动较小的元素，使 sum 变大一些。 12345678910public int[] twoSum(int[] numbers, int target) &#123; int i = 0, j = numbers.length - 1; while (i &lt; j) &#123; int sum = numbers[i] + numbers[j]; if (sum == target) return new int[]&#123;i + 1, j + 1&#125;; else if (sum &lt; target) i++; else j--; &#125; return null;&#125; 反转字符串中的元音字符 Leetcode : 345. Reverse Vowels of a String (Easy) 使用双指针，指向待反转的两个元音字符，一个指针从头向尾遍历，一个指针从尾到头遍历。 123456789101112131415161718192021222324private HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;(Arrays.asList('a','e','i','o','u','A','E','I','O','U'));public String reverseVowels(String s) &#123; if(s.length() == 0) return s; int i = 0, j = s.length() - 1; char[] result = new char[s.length()]; while(i &lt;= j)&#123; char ci = s.charAt(i); char cj = s.charAt(j); if(!vowels.contains(ci))&#123; result[i] = ci; i++; &#125; else if(!vowels.contains(cj))&#123; result[j] = cj; j--; &#125; else&#123; result[i] = cj; result[j] = ci; i++; j--; &#125; &#125; return new String(result);&#125; 两数平方和 Leetcode : 633. Sum of Square Numbers (Easy) 题目描述：判断一个数是否为两个数的平方和，例如 5 = 12 + 22。 12345678910public boolean judgeSquareSum(int c) &#123; int left = 0, right = (int) Math.sqrt(c); while(left &lt;= right)&#123; int powSum = left * left + right * right; if(powSum == c) return true; else if(powSum &gt; c) right--; else left++; &#125; return false;&#125; 回文字符串 Leetcode : 680. Valid Palindrome II (Easy) 题目描述：字符串可以删除一个字符，判断是否能构成回文字符串。 123456789101112131415161718192021public boolean validPalindrome(String s) &#123; int i = 0, j = s.length() -1; while(i &lt; j)&#123; if(s.charAt(i) != s.charAt(j))&#123; return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j); &#125; i++; j--; &#125; return true;&#125;private boolean isPalindrome(String s, int l, int r)&#123; while(l &lt; r)&#123; if(s.charAt(l) != s.charAt(r)) return false; l++; r--; &#125; return true;&#125; 归并两个有序数组 Leetcode : 88. Merge Sorted Array (Easy) 题目描述：把归并结果存到第一个数组上 1234567891011public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1, j = n - 1; // 需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值 int idx = m + n - 1; while(i &gt;= 0 || j &gt;= 0)&#123; if(i &lt; 0) nums1[idx] = nums2[j--]; else if(j &lt; 0) nums1[idx] = nums1[i--]; else if(nums1[i] &gt; nums2[j]) nums1[idx] = nums1[i--]; else nums1[idx] = nums2[j--]; idx--; &#125;&#125; 判断链表是否存在环 Leetcode : 141. Linked List Cycle (Easy) 使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。 1234567891011public boolean hasCycle(ListNode head) &#123; if(head == null) return false; ListNode l1 = head, l2 = head.next; while(l1 != null &amp;&amp; l2 != null)&#123; if(l1 == l2) return true; l1 = l1.next; if(l2.next == null) break; l2 = l2.next.next; &#125; return false;&#125; 最长子序列 Leetcode : 524. Longest Word in Dictionary through Deleting (Medium) 12345Input:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]Output:&quot;apple&quot; 题目描述：可以删除 s 中的一些字符，使得它成为字符串列表 d 中的一个字符串。要求在 d 中找到满足条件的最长字符串。 123456789101112131415public String findLongestWord(String s, List&lt;String&gt; d) &#123; String ret = ""; for (String str : d) &#123; for (int i = 0, j = 0; i &lt; s.length() &amp;&amp; j &lt; str.length(); i++) &#123; if (s.charAt(i) == str.charAt(j)) j++; if (j == str.length()) &#123; if (ret.length() &lt; str.length() || (ret.length() == str.length() &amp;&amp; ret.compareTo(str) &gt; 0)) &#123; ret = str; &#125; &#125; &#125; &#125; return ret;&#125; 排序快速选择一般用于求解 Kth Element 问题，可以在 O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。 与快速排序一样，快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为 O(n2)。 堆排序堆排序用于求解 TopK Elements 问题，通过维护一个大小为 K 的堆，堆中的元素就是 TopK Elements。当然它也可以用于求解 Kth Element 问题，因为最后出堆的那个元素就是 Kth Element。快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。 Kth Element Leetocde : 215. Kth Largest Element in an Array (Medium) 排序：时间复杂度 O(nlgn)，空间复杂度 O(1) 解法 12345public int findKthLargest(int[] nums, int k) &#123; int N = nums.length; Arrays.sort(nums); return nums[N - k];&#125; 堆排序：时间复杂度 O(nlgk)，空间复杂度 O(k) 12345678910public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); for(int val : nums) &#123; pq.offer(val); if(pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; return pq.peek();&#125; 快速选择：时间复杂度 O(n)，空间复杂度 O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142public int findKthLargest(int[] nums, int k) &#123; k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) &#123; final int j = partition(nums, lo, hi); if(j &lt; k) &#123; lo = j + 1; &#125; else if (j &gt; k) &#123; hi = j - 1; &#125; else &#123; break; &#125; &#125; return nums[k]; &#125; private int partition(int[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; while(true) &#123; while(i &lt; hi &amp;&amp; less(a[++i], a[lo])); while(j &gt; lo &amp;&amp; less(a[lo], a[--j])); if(i &gt;= j) &#123; break; &#125; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125; private void exch(int[] a, int i, int j) &#123; final int tmp = a[i]; a[i] = a[j]; a[j] = tmp; &#125; private boolean less(int v, int w) &#123; return v &lt; w; &#125;&#125; 桶排序找出出现频率最多的 k 个数 Leetcode : 347. Top K Frequent Elements (Medium) 12345678910111213141516171819202122public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; List&lt;Integer&gt;[] bucket = new List[nums.length + 1]; for(int key : map.keySet()) &#123; int frequency = map.get(key); if(bucket[frequency] == null) &#123; bucket[frequency] = new ArrayList&lt;&gt;(); &#125; bucket[frequency].add(key); &#125; for(int i = bucket.length - 1; i &gt;= 0 &amp;&amp; ret.size() &lt; k; i--) &#123; if(bucket[i] != null) &#123; ret.addAll(bucket[i]); &#125; &#125; return ret;&#125; 搜索深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此。 BFS 广度优先搜索的搜索过程有点像一层一层地进行遍历：从节点 0 出发，遍历到 6、2、1 和 5 这四个新节点。 继续从 6 开始遍历，得到节点 4 ；从 2 开始遍历，没有下一个节点；从 1 开始遍历，没有下一个节点；从 5 开始遍历，得到 3 和 4 节点。这一轮总共得到两个新节点：4 和 3 。 反复从新节点出发进行上述的遍历操作。 可以看到，每一轮遍历的节点都与根节点路径长度相同。设 di 表示第 i 个节点与根节点的路径长度，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di&lt;=dj。利用这个结论，可以求解最短路径 最优解 问题：第一次遍历到目的节点，其所经过的路径为最短路径，如果继续遍历，之后再遍历到目的节点，所经过的路径就不是最短路径。 在程序实现 BFS 时需要考虑以下问题： 队列：用来存储每一轮遍历的节点 标记：对于遍历过得节点，应该将它标记，防止重复遍历； 计算在网格中从原点到特定点的最短路径长度 1234[[1,1,0,1],[1,0,1,0],[1,1,1,1],[1,0,1,1]] 123456789101112131415161718192021222324252627public int minPathLength(int[][] grids, int tr, int tc) &#123; int[][] next = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; int m = grids.length, n = grids[0].length; Queue&lt;Position&gt; queue = new LinkedList&lt;&gt;(); queue.add(new Position(0, 0, 1)); while (!queue.isEmpty()) &#123; Position pos = queue.poll(); for (int i = 0; i &lt; 4; i++) &#123; Position nextPos = new Position(pos.r + next[i][0], pos.c + next[i][1], pos.length + 1); if (nextPos.r &lt; 0 || nextPos.r &gt;= m || nextPos.c &lt; 0 || nextPos.c &gt;= n) continue; if (grids[nextPos.r][nextPos.c] != 1) continue; grids[nextPos.r][nextPos.c] = 0; if (nextPos.r == tr &amp;&amp; nextPos.c == tc) return nextPos.length; queue.add(nextPos); &#125; &#125; return -1;&#125;private class Position &#123; int r, c, length; public Position(int r, int c, int length) &#123; this.r = r; this.c = c; this.length = length; &#125;&#125; DFS 广度优先搜索一层一层遍历，每一层遍历到的所有新节点，要用队列先存储起来以备下一层遍历的时候再遍历；而深度优先搜索在遍历到一个新节点时立马对新节点进行遍历：从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 可达性 问题。 在程序实现 DFS 时需要考虑以下问题： 栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。也可以使用递归栈。 标记：和 BFS 一样同样需要对已经遍历过得节点进行标记。 查找最大的连通面积 Leetcode : 695. Max Area of Island (Easy) 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] 123456789101112131415161718public int maxAreaOfIsland(int[][] grid) &#123; int m = grid.length, n = grid[0].length; int max = 0; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(grid[i][j] == 1) max = Math.max(max, dfs(grid, i, j)); &#125; &#125; return max;&#125;private int dfs(int[][] grid, int i, int j)&#123; int m = grid.length, n = grid[0].length; if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n) return 0; if(grid[i][j] == 0) return 0; grid[i][j] = 0; return dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) + 1;&#125; 图的连通分量 Leetcode : 547. Friend Circles (Medium) 1234567Input:[[1,1,0], [1,1,0], [0,0,1]]Output: 2Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.The 2nd student himself is in a friend circle. So return 2. 12345678910111213141516171819202122public int findCircleNum(int[][] M) &#123; int n = M.length; int ret = 0; boolean[] hasFind = new boolean[n]; for(int i = 0; i &lt; n; i++) &#123; if(!hasFind[i]) &#123; dfs(M, i, hasFind); ret++; &#125; &#125; return ret;&#125;private void dfs(int[][] M, int i, boolean[] hasFind) &#123; hasFind[i] = true; int n = M.length; for(int k = 0; k &lt; n; k++) &#123; if(M[i][k] == 1 &amp;&amp; !hasFind[k]) &#123; dfs(M, k, hasFind); &#125; &#125;&#125; 矩阵中的连通区域数量 Leetcode : 200. Number of Islands (Medium) 1234511110110101100000000Answer: 1 1234567891011121314151617181920212223242526private int m, n;private int[][] direction = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;public int numIslands(char[][] grid) &#123; if (grid == null || grid.length == 0) return 0; m = grid.length; n = grid[0].length; int ret = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == '1') &#123; dfs(grid, i, j); ret++; &#125; &#125; &#125; return ret;&#125;private void dfs(char[][] grid, int i, int j) &#123; if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] == '0') return; grid[i][j] = '0'; for (int k = 0; k &lt; direction.length; k++) &#123; dfs(grid, i + direction[k][0], j + direction[k][1]); &#125;&#125; 输出二叉树中所有从根到叶子的路径 Leetcode : 257. Binary Tree Paths (Easy) 12345 1/ \2 3\ 5 1["1-&gt;2-&gt;5", "1-&gt;3"] 1234567891011121314151617public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; ret = new ArrayList(); if(root == null) return ret; dfs(root, "", ret); return ret;&#125;private void dfs(TreeNode root, String prefix, List&lt;String&gt; ret)&#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null)&#123; ret.add(prefix + root.val); return; &#125; prefix += (root.val + "-&gt;"); dfs(root.left, prefix, ret); dfs(root.right, prefix, ret);&#125; 填充封闭区域 Leetcode : 130. Surrounded Regions (Medium) 1234567891011For example,X X X XX O O XX X O XX O X XAfter running your function, the board should be:X X X XX X X XX X X XX O X X 题目描述：使得被 ‘X’ 的 ‘O’ 转换为 ‘X’。 先填充最外侧，剩下的就是里侧了。 123456789101112131415161718192021222324252627282930private int[][] direction = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;private int m, n;public void solve(char[][] board) &#123; if (board == null || board.length == 0) return; m = board.length; n = board[0].length; for (int i = 0; i &lt; m; i++) &#123; dfs(board, i, 0); dfs(board, i, n - 1); &#125; for (int i = 0; i &lt; n; i++) &#123; dfs(board, 0, i); dfs(board, m - 1, i); &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 'T') board[i][j] = 'O'; else if (board[i][j] == 'O') board[i][j] = 'X'; &#125; &#125;&#125;private void dfs(char[][] board, int r, int c) &#123; if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || board[r][c] != 'O') return; board[r][c] = 'T'; for (int i = 0; i &lt; direction.length; i++) &#123; dfs(board, r + direction[i][0], c + direction[i][1]); &#125;&#125; 从两个方向都能到达的区域 Leetcode : 417. Pacific Atlantic Water Flow (Medium) 123456789101112Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * AtlanticReturn:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). 题目描述：左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。 1234567891011121314151617181920212223242526272829303132333435363738394041private int m, n;private int[][] matrix;private int[][] direction = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;public List&lt;int[]&gt; pacificAtlantic(int[][] matrix) &#123; List&lt;int[]&gt; ret = new ArrayList&lt;&gt;(); if (matrix == null || matrix.length == 0) return ret; this.m = matrix.length; this.n = matrix[0].length; this.matrix = matrix; boolean[][] canReachP = new boolean[m][n]; boolean[][] canReachA = new boolean[m][n]; for (int i = 0; i &lt; m; i++) &#123; dfs(i, 0, canReachP); dfs(i, n - 1, canReachA); &#125; for (int i = 0; i &lt; n; i++) &#123; dfs(0, i, canReachP); dfs(m - 1, i, canReachA); &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123; ret.add(new int[]&#123;i, j&#125;); &#125; &#125; &#125; return ret;&#125;private void dfs(int r, int c, boolean[][] canReach) &#123; if(canReach[r][c]) return; canReach[r][c] = true; for (int i = 0; i &lt; direction.length; i++) &#123; int nextR = direction[i][0] + r; int nextC = direction[i][1] + c; if (nextR &lt; 0 || nextR &gt;= m || nextC &lt; 0 || nextC &gt;= n || matrix[r][c] &gt; matrix[nextR][nextC]) continue; dfs(nextR, nextC, canReach); &#125;&#125; N 皇后 Leetcode : 51. N-Queens (Hard) 题目描述：在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，要求解所有的 n 皇后解。 一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。 45 度对角线标记数组的维度为 2*n - 1，通过下图可以明确 (r,c) 的位置所在的数组下标为 r + c。 135 度对角线标记数组的维度也是 2*n - 1，(r,c) 的位置所在的数组下标为 n - 1 - (r - c)。 123456789101112131415161718192021222324252627282930313233343536373839404142private List&lt;List&lt;String&gt;&gt; ret;private char[][] nQueens;private boolean[] colUsed;private boolean[] diagonals45Used;private boolean[] diagonals135Used;private int n;public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; ret = new ArrayList&lt;&gt;(); nQueens = new char[n][n]; Arrays.fill(nQueens, '.'); colUsed = new boolean[n]; diagonals45Used = new boolean[2 * n - 1]; diagonals135Used = new boolean[2 * n - 1]; this.n = n; backstracking(0); return ret;&#125;private void backstracking(int row) &#123; if (row == n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (char[] chars : nQueens) &#123; list.add(new String(chars)); &#125; ret.add(list); return; &#125; for (int col = 0; col &lt; n; col++) &#123; int diagonals45Idx = row + col; int diagonals135Idx = n - 1 - (row - col); if (colUsed[col] || diagonals45Used[diagonals45Idx] || diagonals135Used[diagonals135Idx]) &#123; continue; &#125; nQueens[row][col] = 'Q'; colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = true; backstracking(row + 1); colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = false; nQueens[row][col] = '.'; &#125;&#125; Backtracking回溯是 DFS 的一种，它不是用在遍历图的节点上，而是用于求解 排列组合 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串。 在程序实现时，回溯需要注意对元素进行标记的问题。使用递归实现的回溯，在访问一个新元素进入新的递归调用，此时需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；但是在递归返回时，需要将该元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，而在不同的递归链是可以访问已经访问过但是不在当前递归链中的元素。 数字键盘组合 Leetcode : 17. Letter Combinations of a Phone Number (Medium) 12Input:Digit string "23"Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 1234567891011121314151617181920private static final String[] KEYS = &#123;"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;;public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); if (digits != null &amp;&amp; digits.length() != 0) &#123; combination("", digits, 0, ret); &#125; return ret;&#125;private void combination(String prefix, String digits, int offset, List&lt;String&gt; ret) &#123; if (offset == digits.length()) &#123; ret.add(prefix); return; &#125; String letters = KEYS[digits.charAt(offset) - '0']; for (char c : letters.toCharArray()) &#123; combination(prefix + c, digits, offset + 1, ret); &#125;&#125; 在矩阵中寻找字符串 Leetcode : 79. Word Search (Medium) 12345678910For example,Given board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]word = "ABCCED", -&gt; returns true,word = "SEE", -&gt; returns true,word = "ABCB", -&gt; returns false. 1234567891011121314151617181920212223242526272829303132333435private static int[][] shift = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;private static boolean[][] visited;private int m;private int n;public boolean exist(char[][] board, String word) &#123; if (word == null || word.length() == 0) return true; if (board == null || board.length == 0 || board[0].length == 0) return false; m = board.length; n = board[0].length; visited = new boolean[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dfs(board, word, 0, i, j)) return true; &#125; &#125; return false;&#125;private boolean dfs(char[][] board, String word, int start, int r, int c) &#123; if (start == word.length()) &#123; return true; &#125; if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || board[r][c] != word.charAt(start) || visited[r][c] ) &#123; return false; &#125; visited[r][c] = true; for (int i = 0; i &lt; shift.length; i++) &#123; int nextR = r + shift[i][0]; int nextC = c + shift[i][1]; if (dfs(board, word, start + 1, nextR, nextC)) return true; &#125; visited[r][c] = false; return false;&#125; IP 地址划分 Leetcode : 93. Restore IP Addresses(Medium) 12Given "25525511135",return ["255.255.11.135", "255.255.111.35"]. 1234567891011121314151617181920212223private List&lt;String&gt; ret;public List&lt;String&gt; restoreIpAddresses(String s) &#123; ret = new ArrayList&lt;&gt;(); doRestore(0, "", s); return ret;&#125;private void doRestore(int k, String path, String s) &#123; if (k == 4 || s.length() == 0) &#123; if (k == 4 &amp;&amp; s.length() == 0) &#123; ret.add(path); &#125; return; &#125; for (int i = 0; i &lt; s.length() &amp;&amp; i &lt;= 2; i++) &#123; if (i != 0 &amp;&amp; s.charAt(0) == '0') break; String part = s.substring(0, i + 1); if (Integer.valueOf(part) &lt;= 255) &#123; doRestore(k + 1, path.length() != 0 ? path + "." + part : part, s.substring(i + 1)); &#125; &#125;&#125; 排列 Leetcode : 46. Permutations (Medium) 123456789[1,2,3] have the following permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; permuteList = new ArrayList&lt;&gt;(); boolean[] visited = new boolean[nums.length]; backtracking(permuteList, visited, nums, ret); return ret;&#125;private void backtracking(List&lt;Integer&gt; permuteList, boolean[] visited, int[] nums, List&lt;List&lt;Integer&gt;&gt; ret)&#123; if(permuteList.size() == nums.length)&#123; ret.add(new ArrayList(permuteList)); return; &#125; for(int i = 0; i &lt; visited.length; i++)&#123; if(visited[i]) continue; visited[i] = true; permuteList.add(nums[i]); backtracking(permuteList, visited, nums, ret); permuteList.remove(permuteList.size() - 1); visited[i] = false; &#125;&#125; 含有相同元素求排列 Leetcode : 47. Permutations II (Medium) 12[1,1,2] have the following unique permutations:[[1,1,2], [1,2,1], [2,1,1]] 题目描述：数组元素可能含有相同的元素，进行排列时就有可能出先重复的排列，要求重复的排列只返回一个。 在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; permuteList = new ArrayList&lt;&gt;(); Arrays.sort(nums); boolean[] visited = new boolean[nums.length]; backtracking(permuteList, visited, nums, ret); return ret;&#125;private void backtracking(List&lt;Integer&gt; permuteList, boolean[] visited, int[] nums, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (permuteList.size() == nums.length) &#123; ret.add(new ArrayList(permuteList)); return; &#125; for (int i = 0; i &lt; visited.length; i++) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) continue; if (visited[i]) continue; visited[i] = true; permuteList.add(nums[i]); backtracking(permuteList, visited, nums, ret); permuteList.remove(permuteList.size() - 1); visited[i] = false; &#125;&#125; 组合 Leetcode : 77. Combinations (Medium) 123456789If n = 4 and k = 2, a solution is:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; combineList = new ArrayList&lt;&gt;(); backtracking(1, n, k, combineList, ret); return ret;&#125;private void backtracking(int start, int n, int k, List&lt;Integer&gt; combineList, List&lt;List&lt;Integer&gt;&gt; ret)&#123; if(k == 0)&#123; ret.add(new ArrayList(combineList)); // 这里要重新构造一个 List return; &#125; for(int i = start; i &lt;= n - k + 1; i++)&#123; // 剪枝 combineList.add(i); // 把 i 标记为已访问 backtracking(i + 1, n, k - 1, combineList, ret); combineList.remove(combineList.size() - 1); // 把 i 标记为未访问 &#125;&#125; 组合求和 Leetcode : 39. Combination Sum (Medium) 123given candidate set [2, 3, 6, 7] and target 7,A solution set is:[[7],[2, 2, 3]] 123456789101112131415161718192021private List&lt;List&lt;Integer&gt;&gt; ret;public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; ret = new ArrayList&lt;&gt;(); doCombination(candidates, target, 0, new ArrayList&lt;&gt;()); return ret;&#125;private void doCombination(int[] candidates, int target, int start, List&lt;Integer&gt; list) &#123; if (target == 0) &#123; ret.add(new ArrayList&lt;&gt;(list)); return; &#125; for (int i = start; i &lt; candidates.length; i++) &#123; if (candidates[i] &lt;= target) &#123; list.add(candidates[i]); doCombination(candidates, target - candidates[i], i, list); list.remove(list.size() - 1); &#125; &#125;&#125; 含有相同元素的求组合求和 Leetcode : 40. Combination Sum II (Medium) 12345678For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 12345678910111213141516171819202122232425private List&lt;List&lt;Integer&gt;&gt; ret;public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; ret = new ArrayList&lt;&gt;(); Arrays.sort(candidates); doCombination(candidates, target, 0, new ArrayList&lt;&gt;(), new boolean[candidates.length]); return ret;&#125;private void doCombination(int[] candidates, int target, int start, List&lt;Integer&gt; list, boolean[] visited) &#123; if (target == 0) &#123; ret.add(new ArrayList&lt;&gt;(list)); return; &#125; for (int i = start; i &lt; candidates.length; i++) &#123; if (i != 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !visited[i - 1]) continue; if (candidates[i] &lt;= target) &#123; list.add(candidates[i]); visited[i] = true; doCombination(candidates, target - candidates[i], i + 1, list, visited); visited[i] = false; list.remove(list.size() - 1); &#125; &#125;&#125; 子集 Leetcode : 78. Subsets (Medium) 题目描述：找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复 123456789101112131415161718192021222324private List&lt;List&lt;Integer&gt;&gt; ret;private List&lt;Integer&gt; subsetList;public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; ret = new ArrayList&lt;&gt;(); subsetList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= nums.length; i++) &#123; backtracking(0, i, nums); &#125; return ret;&#125;private void backtracking(int startIdx, int size, int[] nums) &#123; if (subsetList.size() == size) &#123; ret.add(new ArrayList(subsetList)); return; &#125; for (int i = startIdx; i &lt; nums.length; i++) &#123; subsetList.add(nums[i]); backtracking(i + 1, size, nums); // startIdx 设为下一个元素，使 subset 中的元素都递增排序 subsetList.remove(subsetList.size() - 1); &#125;&#125; 含有相同元素求子集 Leetcode : 90. Subsets II (Medium) 1234567891011For example,If nums = [1,2,2], a solution is:[ [2], [1], [1,2,2], [2,2], [1,2], []] 123456789101112131415161718192021222324252627282930private List&lt;List&lt;Integer&gt;&gt; ret;private List&lt;Integer&gt; subsetList;private boolean[] visited;public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; ret = new ArrayList&lt;&gt;(); subsetList = new ArrayList&lt;&gt;(); visited = new boolean[nums.length]; Arrays.sort(nums); for (int i = 0; i &lt;= nums.length; i++) &#123; backtracking(0, i, nums); &#125; return ret;&#125;private void backtracking(int startIdx, int size, int[] nums) &#123; if (subsetList.size() == size) &#123; ret.add(new ArrayList(subsetList)); return; &#125; for (int i = startIdx; i &lt; nums.length; i++) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) continue; subsetList.add(nums[i]); visited[i] = true; backtracking(i + 1, size, nums); visited[i] = false; subsetList.remove(subsetList.size() - 1); &#125;&#125; 分割字符串使得每部分都是回文数 Leetcode : 131. Palindrome Partitioning (Medium) 12345678910111213141516171819202122232425262728private List&lt;List&lt;String&gt;&gt; ret;public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; ret = new ArrayList&lt;&gt;(); doPartion(new ArrayList&lt;&gt;(), s); return ret;&#125;private void doPartion(List&lt;String&gt; list, String s) &#123; if (s.length() == 0) &#123; ret.add(new ArrayList&lt;&gt;(list)); return; &#125; for (int i = 0; i &lt; s.length(); i++) &#123; if (isPalindrome(s, 0, i)) &#123; list.add(s.substring(0, i + 1)); doPartion(list, s.substring(i + 1)); list.remove(list.size() - 1); &#125; &#125;&#125;private boolean isPalindrome(String s, int begin, int end) &#123; while (begin &lt; end) &#123; if (s.charAt(begin++) != s.charAt(end--)) return false; &#125; return true;&#125; 数独 Leetcode : 37. Sudoku Solver (Hard) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private boolean[][] rowsUsed = new boolean[9][10];private boolean[][] colsUsed = new boolean[9][10];private boolean[][] cubesUsed = new boolean[9][10];private char[][] board;public void solveSudoku(char[][] board) &#123; this.board = board; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] == '.') continue; int num = board[i][j] - '0'; rowsUsed[i][num] = true; colsUsed[j][num] = true; cubesUsed[cubeNum(i, j)][num] = true; &#125; &#125; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; backtracking(i, j); &#125; &#125;&#125;private boolean backtracking(int row, int col) &#123; while (row &lt; 9 &amp;&amp; board[row][col] != '.') &#123; row = col == 8 ? row + 1 : row; col = col == 8 ? 0 : col + 1; &#125; if (row == 9) &#123; return true; &#125; for (int num = 1; num &lt;= 9; num++) &#123; if (rowsUsed[row][num] || colsUsed[col][num] || cubesUsed[cubeNum(row, col)][num]) continue; rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = true; board[row][col] = (char) (num + '0'); if (backtracking(row, col)) return true; board[row][col] = '.'; rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = false; &#125; return false;&#125;private int cubeNum(int i, int j) &#123; int r = i / 3; int c = j / 3; return r * 3 + c;&#125; 分治给表达式加括号 Leetcode : 241. Different Ways to Add Parentheses (Medium) 123456Input: "2-1-1".((2-1)-1) = 0(2-(1-1)) = 2Output : [0, 2] 12345678910111213141516171819202122public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; int n = input.length(); List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; char c = input.charAt(i); if (c == '+' || c == '-' || c == '*') &#123; List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0, i)); List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + 1)); for (int l : left) &#123; for (int r : right) &#123; switch (c) &#123; case '+': ret.add(l + r); break; case '-': ret.add(l - r); break; case '*': ret.add(l * r); break; &#125; &#125; &#125; &#125; &#125; if (ret.size() == 0) ret.add(Integer.valueOf(input)); return ret;&#125; 动态规划递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解。 分割整数分割整数的最大乘积 Leetcode : 343. Integer Break (Medim) 题目描述：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4). 12345678910public int integerBreak(int n) &#123; int[] dp = new int[n + 1]; dp[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= i - 1; j++) &#123; dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j))); &#125; &#125; return dp[n];&#125; 按平方数来分割整数 Leetcode : 279. Perfect Squares(Medium) 题目描述：For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 12345678910111213141516171819public int numSquares(int n) &#123; List&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); // 存储小于 n 的平方数 int diff = 3; while(square &lt;= n) &#123; squares.add(square); square += diff; diff += 2; &#125; int[] dp = new int[n + 1]; for(int i = 1; i &lt;= n; i++) &#123; int max = Integer.MAX_VALUE; for(int s : squares) &#123; if(s &gt; i) break; max = Math.min(max, dp[i - s] + 1); &#125; dp[i] = max; &#125; return dp[n];&#125; 分割整数构成字母字符串 Leetcode : 91. Decode Ways (Medium) 题目描述：Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12). 123456789101112131415public int numDecodings(String s) &#123; if(s == null || s.length() == 0) return 0; int n = s.length(); int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = s.charAt(0) == '0' ? 0 : 1; for(int i = 2; i &lt;= n; i++) &#123; int one = Integer.valueOf(s.substring(i - 1, i)); if(one != 0) dp[i] += dp[i - 1]; if(s.charAt(i - 2) == '0') continue; int two = Integer.valueOf(s.substring(i - 2, i)); if(two &lt;= 26) dp[i] += dp[i - 2]; &#125; return dp[n];&#125; 矩阵路径矩阵的总路径数 Leetcode : 62. Unique Paths (Medium) 题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向左和向下移动。 12345678910public int uniquePaths(int m, int n) &#123; int[] dp = new int[n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if(i == 0) dp[j] = 1; else if(j != 0) dp[j] = dp[j] + dp[j - 1]; &#125; &#125; return dp[n - 1];&#125; 矩阵的最小路径和 Leetcode : 64. Minimum Path Sum (Medium) 题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向左和向下移动。 12345678910111213public int minPathSum(int[][] grid) &#123; if(grid.length == 0 || grid[0].length == 0) return 0; int m = grid.length, n = grid[0].length; int[] dp = new int[n]; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(j == 0) dp[0] = dp[0] + grid[i][0]; else if(i == 0) dp[j] = dp[j - 1] + grid[0][j]; else dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j]; &#125; &#125; return dp[n - 1];&#125; 斐波那契数列爬楼梯 Leetcode : 70. Climbing Stairs (Easy) 题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。 定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。 dp[N] 即为所求。 考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2] 即可，使得原来的 O(n) 空间复杂度优化为 O(1) 复杂度。 123456789101112public int climbStairs(int n) &#123; if(n == 1) return 1; if(n == 2) return 2; // 前一个楼梯、后一个楼梯 int pre1 = 2, pre2 = 1; for(int i = 2; i &lt; n; i++)&#123; int cur = pre1 + pre2; pre2 = pre1; pre1 = cur; &#125; return pre1;&#125; 母牛生产 程序员代码面试指南-P181 题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。 第 i 年成熟的牛的数量为： 强盗抢劫 Leetcode : 198. House Robber (Easy) 题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。 定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。由于不能抢劫邻近住户，因此如果抢劫了第 i 个住户那么只能抢劫 i - 2 和 i - 3 的住户，所以 O(n) 空间复杂度实现方法： 1234567891011121314public int rob(int[] nums) &#123; int n = nums.length; if(n == 0) return 0; if(n == 1) return nums[0]; if(n == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[n]; dp[0] = nums[0]; dp[1] = nums[1]; dp[2] = nums[0] + nums[2]; for(int i = 3; i &lt; n; i++)&#123; dp[i] = Math.max(dp[i -2], dp[i - 3]) + nums[i]; &#125; return Math.max(dp[n - 1], dp[n - 2]);&#125; O(1) 空间复杂度实现方法： 1234567891011121314public int rob(int[] nums) &#123; int n = nums.length; if(n == 0) return 0; if(n == 1) return nums[0]; if(n == 2) return Math.max(nums[0], nums[1]); int pre3 = nums[0], pre2 = nums[1], pre1 = nums[2] + nums[0]; for(int i = 3; i &lt; n; i++)&#123; int cur = Math.max(pre2, pre3) + nums[i]; pre3 = pre2; pre2 = pre1; pre1 = cur; &#125; return Math.max(pre1, pre2);&#125; 强盗在环形街区抢劫 Leetcode : 213. House Robber II (Medium) 1234567891011121314151617181920public int rob(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int n = nums.length; if(n == 1) return nums[0]; return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));&#125;private int rob(int[] nums, int s, int e) &#123; int n = nums.length; if(e - s == 0) return nums[s]; if(e - s == 1) return Math.max(nums[s], nums[s + 1]); int[] dp = new int[n]; dp[s] = nums[s]; dp[s + 1] = nums[s + 1]; dp[s + 2] = nums[s] + nums[s + 2]; for (int i = s + 3; i &lt;= e; i++) &#123; dp[i] = Math.max(dp[i - 2], dp[i - 3]) + nums[i]; &#125; return Math.max(dp[e], dp[e - 1]);&#125; 信件错排 题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信的方式数量。 定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况： ① i==k，交换 i 和 k 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。 ② i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (n-1)*dp[i-1] 种错误装信方式。 综上所述，错误装信数量方式数量为： dp[N] 即为所求。 和上楼梯问题一样，dp[i] 只与 dp[i-1] 和 dp[i-2] 有关，因此也可以只用两个变量来存储 dp[i-1] 和 dp[i-2]。 最长递增子序列已知一个序列 {S1, S2,…,Sn} ，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个子序列。 如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个递增子序列。 定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,…,Sim}，如果 im &lt; n 并且 Sim &lt; Sn ，此时 {Si1, Si2,…, Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n} 。 因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，因此需要对前面的求解方程做修改，令 dp[n] 最小为 1，即： 对于一个长度为 N 的序列，最长子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，即 max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。 最长递增子序列 Leetcode : 300. Longest Increasing Subsequence (Medium) 12345678910111213141516public int lengthOfLIS(int[] nums) &#123; int n = nums.length; int[] dp = new int[n]; for(int i = 0; i &lt; n; i++)&#123; int max = 1; for(int j = 0; j &lt; i; j++)&#123; if(nums[i] &gt; nums[j]) max = Math.max(max, dp[j] + 1); &#125; dp[i] = max; &#125; int ret = 0; for(int i = 0; i &lt; n; i++)&#123; ret = Math.max(ret, dp[i]); &#125; return ret;&#125; 以上解法的时间复杂度为 O(n2) ，可以使用二分查找使得时间复杂度降低为 O(nlogn)。定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素，例如对于数组 [4,5,6,3]，有 123len = 1 : [4], [5], [6], [3] =&gt; tails[0] = 3len = 2 : [4, 5], [5, 6] =&gt; tails[1] = 5len = 3 : [4, 5, 6] =&gt; tails[2] = 6 对于一个元素 x，如果它大于 tails 数组所有的值，那么把它添加到 tails 后面；如果 tails[i-1] &lt; x &lt;= tails[i]，那么更新 tails[i] = x 。 可以看出 tails 数组保持有序，因此在查找 Si 位于 tails 数组的位置时就可以使用二分查找。 123456789101112131415161718192021public int lengthOfLIS(int[] nums) &#123; int n = nums.length; int[] tails = new int[n]; int size = 0; for(int i = 0; i &lt; n; i++)&#123; int idx = binarySearch(tails, 0, size, nums[i]); tails[idx] = nums[i]; if(idx == size) size++; &#125; return size;&#125;private int binarySearch(int[] nums, int sIdx, int eIdx, int key)&#123; while(sIdx &lt; eIdx)&#123; int mIdx = sIdx + (eIdx - sIdx) / 2; if(nums[mIdx] == key) return mIdx; else if(nums[mIdx] &gt; key) eIdx = mIdx; else sIdx = mIdx + 1; &#125; return sIdx;&#125; 最长摆动子序列 Leetcode : 376. Wiggle Subsequence (Medium) 要求：使用 O(n) 时间复杂度求解。 使用两个状态 up 和 down。 12345678910public int wiggleMaxLength(int[] nums) &#123; int len = nums.length; if (len == 0) return 0; int up = 1, down = 1; for (int i = 1; i &lt; len; i++) &#123; if (nums[i] &gt; nums[i - 1]) up = down + 1; else if (nums[i] &lt; nums[i - 1]) down = up + 1; &#125; return Math.max(up, down);&#125; 最长公共子系列对于两个子序列 S1 和 S2，找出它们最长的公共子序列。 定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况： ① 当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1 ，即 dp[i][j] = dp[i-1][j-1] + 1。 ② 当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，与 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。 综上，最长公共子系列的状态转移方程为： 对于长度为 N 的序列 S1 和 长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。 与最长递增子序列相比，最长公共子序列有以下不同点： ① 针对的是两个序列，求它们的最长公共子序列。② 在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j 。③ 由于 2 ，在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。 1234567891011public int lengthOfLCS(int[] nums1, int[] nums2) &#123; int n1 = nums1.length, n2 = nums2.length; int[][] dp = new int[n1 + 1][n2 + 1]; for (int i = 1; i &lt;= n1; i++) &#123; for (int j = 1; j &lt;= n2; j++) &#123; if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[n1][n2];&#125; 0-1 背包有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。 定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示体积不超过 j 的情况下，前 i 件物品能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论： ① 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。② 第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。 第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。 综上，0-1 背包的状态转移方程为： 123456789101112131415public int knapsack(int W, int N, int[] weights, int[] values) &#123; int[][] dp = new int[N][W]; for (int i = W - 1; i &gt;= 0; i--) &#123; dp[0][i] = i &gt; weights[0] ? values[0] : 0; &#125; for (int i = 1; i &lt; N; i++) &#123; for (int j = W - 1; j &gt;= weights[i]; j--) &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]); &#125; for (int j = weights[i - 1] - 1; j &gt;= 0; j--) &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[N - 1][W - 1];&#125; 空间优化 在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅由前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时， 因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w] 防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。 无法使用贪心算法的解释 0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22. id w v v/w 0 1 6 6 1 2 10 5 2 3 12 4 变种 完全背包：物品可以无限个，可以转换为 0-1 背包，令每种物品的体积和价值变为 1/2/4… 倍数，把它们都当成一个新物品，然后一种物品只能添加一次。 多重背包：物品数量有限制，同样可以转换为 0-1 背包。 多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制。 其它：物品之间相互约束或者依赖。 划分数组为和相等的两部分 Leetcode : 416. Partition Equal Subset Sum (Medium) 可以看成一个背包大小为 sum/2 的 0-1 背包问题，但是也有不同的地方，这里没有价值属性，并且背包必须被填满。 以下实现使用了空间优化。 12345678910111213141516171819202122public boolean canPartition(int[] nums) &#123; int sum = 0; for (int num : nums) &#123; sum += num; &#125; if (sum % 2 != 0) &#123; return false; &#125; int W = sum / 2; boolean[] dp = new boolean[W + 1]; int n = nums.length; for(int i = 0; i &lt;= W; i++) &#123; if(nums[0] == i) dp[i] = true; &#125; for(int i = 1; i &lt; n; i++) &#123; for(int j = W; j &gt;= nums[i]; j--) &#123; dp[j] = dp[j] || dp[j - nums[i]]; &#125; &#125; return dp[W];&#125; 字符串按单词列表分割 Leetcode : 139. Word Break (Medium) 123s = "leetcode",dict = ["leet", "code"].Return true because "leetcode" can be segmented as "leet code". 1234567891011121314public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int n = s.length(); boolean[] dp = new boolean[n + 1]; dp[0] = true; for (int i = 1; i &lt;= n; i++) &#123; for (String word : wordDict) &#123; if (word.length() &lt;= i &amp;&amp; word.equals(s.substring(i - word.length(), i))) &#123; dp[i] = dp[i] || dp[i - word.length()]; &#125; &#125; &#125; return dp[n];&#125; 改变一组数的正负号使得它们的和为一给定数 Leetcode : 494. Target Sum (Medium) 1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. 该问题可以转换为 subset sum 问题，从而使用 0-1 背包的方法来求解。可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导： 123 sum(P) - sum(N) = targetsum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N) 2 * sum(P) = target + sum(nums) 因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。 1234567891011121314151617181920212223public int findTargetSumWays(int[] nums, int S) &#123; int sum = 0; for (int num : nums) &#123; sum += num; &#125; if (sum &lt; S || (sum + S) % 2 == 1) &#123; return 0; &#125; return subsetSum(nums, (sum + S) &gt;&gt;&gt; 1);&#125;private int subsetSum(int[] nums, int targetSum) &#123; Arrays.sort(nums); int[] dp = new int[targetSum + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; for (int j = targetSum; j &gt;= num; j--) &#123; dp[j] = dp[j] + dp[j - num]; &#125; &#125; return dp[targetSum];&#125; 01字符构成最多的字符串 Leetcode : 474. Ones and Zeroes (Medium) 1234Input: Array = &#123;"10", "0001", "111001", "1", "0"&#125;, m = 5, n = 3Output: 4Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0” 这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。 123456789101112131415161718192021public int findMaxForm(String[] strs, int m, int n) &#123; if (strs == null || strs.length == 0) return 0; int l = strs.length; int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt; l; i++) &#123; String s = strs[i]; int ones = 0, zeros = 0; for (char c : s.toCharArray()) &#123; if (c == '0') zeros++; else if (c == '1') ones++; &#125; for (int j = m; j &gt;= zeros; j--) &#123; for (int k = n; k &gt;= ones; k--) &#123; if (zeros &lt;= j &amp;&amp; ones &lt;= k) &#123; dp[j][k] = Math.max(dp[j][k], dp[j - zeros][k - ones] + 1); &#125; &#125; &#125; &#125; return dp[m][n];&#125; 找零钱 Leetcode : 322. Coin Change (Medium) 题目描述：给一些面额的硬币，要求用这些硬币来组成给定面额的钱数，并且使得硬币数量最少。硬币可以重复使用。 这是一个完全背包问题，完全背包问题和 0-1背包问题在实现上唯一的不同是，第二层循环是从 0 开始的，而不是从尾部开始。 12345678910111213public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for (int i = 1; i &lt;= amount; i++) &#123; for (int j = 0; j &lt; coins.length; j++) &#123; if (coins[j] &lt;= i) &#123; dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount];&#125; 组合总和 Leetcode : 377. Combination Sum IV (Medium) 123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. 123456789101112public int combinationSum4(int[] nums, int target) &#123; int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1; i &lt;= target; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; if(nums[j] &lt;= i) &#123; dp[i] += dp[i - nums[j]]; &#125; &#125; &#125; return dp[target];&#125; 只能进行两次的股票交易 Leetcode : 123. Best Time to Buy and Sell Stock III (Hard) 1234567891011public int maxProfit(int[] prices) &#123; int firstBuy = Integer.MIN_VALUE, firstSell = 0; int secondBuy = Integer.MIN_VALUE, secondSell = 0; for (int curPrice : prices) &#123; if (firstBuy &lt; -curPrice) firstBuy = -curPrice; if (firstSell &lt; firstBuy + curPrice) firstSell = firstBuy + curPrice; if (secondBuy &lt; firstSell - curPrice) secondBuy = firstSell - curPrice; if (secondSell &lt; secondBuy + curPrice) secondSell = secondBuy + curPrice; &#125; return secondSell;&#125; 只能进行 k 次的股票交易 Leetcode : 188. Best Time to Buy and Sell Stock IV (Hard) 1dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) &#123; jj in range of [0, j-1] &#125; = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj])) 1234567891011121314151617181920public int maxProfit(int k, int[] prices) &#123; int n = prices.length; if (k &gt;= n/2) &#123; int maxPro = 0; for (int i = 1; i &lt; n; i++) &#123; if (prices[i] &gt; prices[i-1]) maxPro += prices[i] - prices[i-1]; &#125; return maxPro; &#125; int[][] dp = new int[k + 1][n]; for (int i = 1; i &lt;= k; i++) &#123; int localMax = dp[i - 1][0] - prices[0]; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = Math.max(dp[i][j - 1], prices[j] + localMax); localMax = Math.max(localMax, dp[i - 1][j] - prices[j]); &#125; &#125; return dp[k][n - 1];&#125; 数组区间数组区间和 Leetcode : 303. Range Sum Query - Immutable (Easy) 求区间 i ~ j 的和，可以转换为 sum[j] - sum[i-1]，其中 sum[i] 为 0 ~ j 的和。 1234567891011121314class NumArray &#123; int[] nums; public NumArray(int[] nums) &#123; for(int i = 1; i &lt; nums.length; i++) nums[i] += nums[i - 1]; this.nums = nums; &#125; public int sumRange(int i, int j) &#123; return i == 0 ? nums[j] : nums[j] - nums[i - 1]; &#125;&#125; 子数组最大的和 Leetcode : 53. Maximum Subarray (Easy) 令 sum[i] 为以 num[i] 为结尾的子数组最大的和，可以由 sum[i-1] 得到 sum[i] 的值，如果 sum[i-1] 小于 0，那么以 num[i] 为结尾的子数组不能包含前面的内容，因为加上前面的部分，那么和一定会比 num[i] 还小。 1234567891011public int maxSubArray(int[] nums) &#123; int n = nums.length; int[] sum = new int[n]; sum[0] = nums[0]; int max = sum[0]; for(int i = 1; i &lt; n; i++)&#123; sum[i] = (sum[i-1] &gt; 0 ? sum[i-1] : 0) + nums[i]; max = Math.max(max, sum[i]); &#125; return max;&#125; 空间复杂度可以优化成 O(1) 空间复杂度 123456789public int maxSubArray(int[] nums) &#123; int max = nums[0]; int oldsum = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; oldsum = (oldsum &gt; 0 ? oldsum: 0) + nums[i]; max = Math.max(max, oldsum); &#125; return max;&#125; 数组中等差递增子区间的个数 Leetcode : 413. Arithmetic Slices (Medium) 123A = [1, 2, 3, 4]return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself. 对于 (1,2,3,4)，它有三种组成递增子区间的方式，而对于 (1,2,3,4,5)，它组成递增子区间的方式除了 (1,2,3,4) 的三种外还多了一种，即 (1,2,3,4,5)，因此 dp[i] = dp[i - 1] + 1。 1234567891011121314public int numberOfArithmeticSlices(int[] A) &#123; int n = A.length; int[] dp = new int[n]; for(int i = 2; i &lt; n; i++) &#123; if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]) &#123; dp[i] = dp[i - 1] + 1; &#125; &#125; int ret = 0; for(int cnt : dp) &#123; ret += cnt; &#125; return ret;&#125; 字符串编辑删除两个字符串的字符使它们相等 Leetcode : 583. Delete Operation for Two Strings (Medium) 可以转换为求两个字符串的最长公共子序列问题。 123456789101112public int minDistance(String word1, String word2) &#123; int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) continue; dp[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? dp[i - 1][j - 1] + 1 : Math.max(dp[i][j - 1], dp[i - 1][j]); &#125; &#125; return m + n - 2 * dp[m][n];&#125; 修改一个字符串称为另一个字符串 // TODO Leetcode : 72. Edit Distance (Hard) 其它问题需要冷却期的股票交易 Leetcode : 309. Best Time to Buy and Sell Stock with Cooldown(Medium) 题目描述：交易之后需要有一天的冷却时间。 123s0[i] = max(s0[i - 1], s2[i - 1]); // Stay at s0, or rest from s2s1[i] = max(s1[i - 1], s0[i - 1] - prices[i]); // Stay at s1, or buy from s0s2[i] = s1[i - 1] + prices[i]; // Only one way from s1 12345678910111213141516public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int n = prices.length; int[] s0 = new int[n]; int[] s1 = new int[n]; int[] s2 = new int[n]; s0[0] = 0; s1[0] = -prices[0]; s2[0] = Integer.MIN_VALUE; for (int i = 1; i &lt; n; i++) &#123; s0[i] = Math.max(s0[i - 1], s2[i - 1]); s1[i] = Math.max(s1[i - 1], s0[i - 1] - prices[i]); s2[i] = Math.max(s2[i - 1], s1[i - 1] + prices[i]); &#125; return Math.max(s0[n - 1], s2[n - 1]);&#125; 统计从 0 ~ n 每个数的二进制表示中 1 的个数 Leetcode : 338. Counting Bits (Medium) 对于数字 6(110)，它可以看成是数字 2(10) 前面加上一个 1 ，因此 dp[i] = dp[i&amp;(i-1)] + 1; 1234567public int[] countBits(int num) &#123; int[] ret = new int[num + 1]; for(int i = 1; i &lt;= num; i++)&#123; ret[i] = ret[i&amp;(i-1)] + 1; &#125; return ret;&#125; 一组整数对能够构成的最长链 Leetcode : 646. Maximum Length of Pair Chain (Medium) 对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。 12345678910111213141516171819202122public int findLongestChain(int[][] pairs) &#123; if(pairs == null || pairs.length == 0) &#123; return 0; &#125; Arrays.sort(pairs, (a, b) -&gt; (a[0] - b[0])); int n = pairs.length; int[] dp = new int[n]; Arrays.fill(dp, 1); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; if(pairs[i][0] &gt; pairs[j][1])&#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; int ret = 0; for(int num : dp) &#123; ret = Math.max(ret, num); &#125; return ret;&#125; 买入和售出股票最大的收益 Leetcode : 121. Best Time to Buy and Sell Stock (Easy) 只进行一次交易。 只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看这个价格是否是当前的最大价格。 1234567891011public int maxProfit(int[] prices) &#123; int n = prices.length; if(n == 0) return 0; int soFarMin = prices[0]; int max = 0; for(int i = 1; i &lt; n; i++)&#123; if(soFarMin &gt; prices[i]) soFarMin = prices[i]; else max = Math.max(max, prices[i] - soFarMin); &#125; return max;&#125; 复制粘贴字符 Leetcode : 650. 2 Keys Keyboard (Medium) 12345678910111213public int minSteps(int n) &#123; int[] dp = new int[n + 1]; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = i; for (int j = i - 1; j &gt;= 0; j--) &#123; if (i % j == 0) &#123; dp[i] = dp[j] + dp[i / j]; break; &#125; &#125; &#125; return dp[n];&#125; 1234567public int minSteps(int n) &#123; if (n == 1) return 0; for (int i = 2; i &lt;= Math.sqrt(n); i++) &#123; if (n % i == 0) return i + minSteps(n / i); &#125; return n;&#125; 数学素数素数分解 每一个数都可以分解成素数的乘积，例如 84 = 22 * 31 * 50 * 71 * 110 * 130 * 170 * … 整除 令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * … 如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。 x 和 y 的 最大公约数 为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * … x 和 y 的 最小公倍数 为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * … 生成素数序列 Leetcode : 204. Count Primes (Easy) 埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。 12345678910111213public int countPrimes(int n) &#123; boolean[] notPrimes = new boolean[n + 1]; int cnt = 0; for(int i = 2; i &lt; n; i++)&#123; if(notPrimes[i]) continue; cnt++; // 从 i * i 开始，因为如果 k &lt; i，那么 k * i 在之前就已经被去除过了 for(long j = (long) i * i; j &lt; n; j += i)&#123; notPrimes[(int) j] = true; &#125; &#125; return cnt;&#125; 最大公约数1234int gcd(int a, int b) &#123; if (b == 0) return a; return gcd(b, a % b);&#125; 最大公倍数为两数的乘积除以最大公约数。 123int lcm(int a, int b)&#123; return a * b / gcd(a, b);&#125; 对于最大公约数问题，因为需要计算 a % b ，而这个操作是比较耗时的，可以使用 编程之美：2.7 的方法，利用减法和移位操作来替换它。 对于 a 和 b 的最大公约数 f(a, b)，有： 1. 如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);2. 如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);3. 如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);4. 如果 a 和 b 均为奇数，f(a, b) = f(a, a-b); 乘 2 和除 2 都可以转换为移位操作。 进制转换Java 中 static String toString(int num, int radix) 可以将一个整数装换为 redix 进制表示的字符串。 7 进制 Leetcode : 504. Base 7 (Easy) 123456789public String convertToBase7(int num) &#123; if (num &lt; 0) &#123; return '-' + convertToBase7(-num); &#125; if (num &lt; 7) &#123; return num + ""; &#125; return convertToBase7(num / 7) + num % 7;&#125; 16 进制 Leetcode : 405. Convert a Number to Hexadecimal (Easy) 12345678910public String toHex(int num) &#123; char[] map = &#123;'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;; if(num == 0) return "0"; String ret = ""; while(num != 0)&#123; ret = map[(num &amp; 0b1111)] + ret; num &gt;&gt;&gt;= 4; &#125; return ret;&#125; 阶乘统计阶乘尾部有多少个 0 Leetcode : 172. Factorial Trailing Zeroes (Easy) 尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。 对于一个数 N，它所包含 5 的个数为：N/5 + N/52 + N/53 + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/52 表示不大于 N 的数中 52 的倍数再贡献一个 5 …。 123public int trailingZeroes(int n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);&#125; 如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 编程之美：2.2 。和求解有多少个 5 一样，2 的个数为 N/2 + N/22 + N/23 + … 字符串加法减法二进制加法 Leetcode : 67. Add Binary (Easy) 123456789101112public String addBinary(String a, String b) &#123; int i = a.length() - 1, j = b.length() - 1, carry = 0; String str = ""; while(i &gt;= 0 || j &gt;= 0)&#123; if(i &gt;= 0 &amp;&amp; a.charAt(i--) == '1') carry++; if(j &gt;= 0 &amp;&amp; b.charAt(j--) == '1') carry++; str = (carry % 2) + str; carry /= 2; &#125; if(carry == 1) str = "1" + str; return str;&#125; 字符串加法 Leetcode : 415. Add Strings (Easy) 题目描述：字符串的值为非负整数 1234567891011public String addStrings(String num1, String num2) &#123; StringBuilder sb = new StringBuilder(); int carry = 0; for(int i = num1.length() - 1, j = num2.length() - 1; i &gt;= 0 || j &gt;= 0 || carry == 1; i--, j--)&#123; int x = i &lt; 0 ? 0 : num1.charAt(i) - '0'; int y = j &lt; 0 ? 0 : num2.charAt(j) - '0'; sb.append((x + y + carry) % 10); carry = (x + y + carry) / 10; &#125; return sb.reverse().toString();&#125; 相遇问题改变数组元素使所有的数组元素都相等 Leetcode : 462. Minimum Moves to Equal Array Elements II (Medium) 题目描述：每次可以对一个数组元素加一或者减一，求最小的改变次数。 这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下： 设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。 设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。 解法 1 先排序，时间复杂度：O(NlgN) 1234567891011public int minMoves2(int[] nums) &#123; Arrays.sort(nums); int ret = 0; int l = 0, h = nums.length - 1; while(l &lt;= h) &#123; ret += nums[h] - nums[l]; l++; h--; &#125; return ret;&#125; 解法 2 使用快速排序找到中位数，时间复杂度 O(N) 123456789101112131415161718192021222324252627public int minMoves2(int[] nums) &#123; int ret = 0; int n = nums.length; int median = quickSelect(nums, 0, n - 1, n / 2 + 1); for(int num : nums) ret += Math.abs(num - median); return ret;&#125;private int quickSelect(int[] nums, int start, int end, int k) &#123; int l = start, r = end, privot = nums[(l + r) / 2]; while(l &lt;= r) &#123; while(nums[l] &lt; privot) l++; while(nums[r] &gt; privot) r--; if(l &gt;= r) break; swap(nums, l, r); l++; r--; &#125; int left = l - start + 1; if(left &gt; k) return quickSelect(nums, start, l - 1, k); if(left == k &amp;&amp; l == r) return nums[l]; int right = r - start + 1; return quickSelect(nums, r + 1, end, k - right);&#125;private void swap(int[] nums, int i, int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;&#125; 多数投票问题数组中出现次数多于 n / 2 的元素 Leetcode : 169. Majority Element (Easy) 先对数组排序，最中间那个数出现次数一定多于 n / 2 1234public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length / 2];&#125; 可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(n)。可以这么理解该算法：使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不想等时，令 cnt–。如果前面查找了 i 个元素，且 cnt == 0 ，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目多于 (n - i) / 2，因此继续查找就能找出 majority。 123456789101112public int majorityElement(int[] nums) &#123; int cnt = 0, majority = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(cnt == 0) &#123; majority = nums[i]; cnt++; &#125; else if(majority == nums[i]) cnt++; else cnt--; &#125; return majority;&#125; 其它平方数 Leetcode : 367. Valid Perfect Square (Easy) 平方序列：1,4,9,16,..间隔：3,5,7,… 间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。 12345678public boolean isPerfectSquare(int num) &#123; int subNum = 1; while (num &gt; 0) &#123; num -= subNum; subNum += 2; &#125; return num == 0;&#125; 3 的 n 次方 Leetcode : 326. Power of Three (Easy) 123public boolean isPowerOfThree(int n) &#123; return n &gt; 0 &amp;&amp; (1162261467 % n == 0);&#125; 找出数组中的乘积最大的三个数 Leetcode : 628. Maximum Product of Three Numbers (Easy) 1234567891011121314151617181920212223public int maximumProduct(int[] nums) &#123; int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; for (int n : nums) &#123; if (n &gt; max1) &#123; max3 = max2; max2 = max1; max1 = n; &#125; else if (n &gt; max2) &#123; max3 = max2; max2 = n; &#125; else if (n &gt; max3) &#123; max3 = n; &#125; if (n &lt; min1) &#123; min2 = min1; min1 = n; &#125; else if (n &lt; min2) &#123; min2 = n; &#125; &#125; return Math.max(max1*max2*max3, max1*min1*min2);&#125; 乘积数组 Leetcode : 238. Product of Array Except Self (Medium) 题目描述：给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。 题目要求：时间复杂度为 O(n)，并且不能使用除法。 1234567891011121314public int[] productExceptSelf(int[] nums) &#123; int n = nums.length; int[] ret = new int[n]; ret[0] = 1; for(int i = 1; i &lt; n; i++) &#123; ret[i] = ret[i - 1] * nums[i - 1]; &#125; int right = 1; for(int i = n - 1; i &gt;= 0; i--) &#123; ret[i] *= right; right *= nums[i]; &#125; return ret;&#125; 数据结构相关栈和队列用栈实现队列 一个栈实现： 1234567891011121314151617181920212223242526class MyQueue &#123; private Stack&lt;Integer&gt; st = new Stack(); public void push(int x) &#123; Stack&lt;Integer&gt; temp = new Stack(); while(!st.isEmpty())&#123; temp.push(st.pop()); &#125; st.push(x); while(!temp.isEmpty())&#123; st.push(temp.pop()); &#125; &#125; public int pop() &#123; return st.pop(); &#125; public int peek() &#123; return st.peek(); &#125; public boolean empty() &#123; return st.isEmpty(); &#125;&#125; 两个栈实现： 123456789101112131415161718192021222324252627282930class MyQueue &#123; private Stack&lt;Integer&gt; in = new Stack(); private Stack&lt;Integer&gt; out = new Stack(); public void push(int x) &#123; in.push(x); &#125; public int pop() &#123; in2out(); return out.pop(); &#125; public int peek() &#123; in2out(); return out.peek(); &#125; private void in2out()&#123; if(out.isEmpty())&#123; while(!in.isEmpty())&#123; out.push(in.pop()); &#125; &#125; &#125; public boolean empty() &#123; return in.isEmpty() &amp;&amp; out.isEmpty(); &#125;&#125; 用队列实现栈 Leetcode : 225. Implement Stack using Queues (Easy) 123456789101112131415161718192021222324252627class MyStack &#123; private Queue&lt;Integer&gt; queue; public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; public void push(int x) &#123; queue.add(x); for(int i = 1; i &lt; queue.size(); i++)&#123; // 翻转 queue.add(queue.remove()); &#125; &#125; public int pop() &#123; return queue.remove(); &#125; public int top() &#123; return queue.peek(); &#125; public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; 最小值栈 Leetcode : 155. Min Stack (Easy) 用两个栈实现，一个存储数据，一个存储最小值。 1234567891011121314151617181920212223242526272829303132333435363738class MinStack &#123; private Stack&lt;Integer&gt; dataStack; private Stack&lt;Integer&gt; minStack; private int min; public MinStack() &#123; dataStack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); min = Integer.MAX_VALUE; &#125; public void push(int x) &#123; dataStack.add(x); if(x &lt; min) &#123; min = x; &#125; minStack.add(min); &#125; public void pop() &#123; dataStack.pop(); minStack.pop(); if(!minStack.isEmpty()) &#123; min = minStack.peek(); &#125; else&#123; min = Integer.MAX_VALUE; &#125; &#125; public int top() &#123; return dataStack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125; 对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。 用栈实现括号匹配 Leetcode : 20. Valid Parentheses (Easy) 123"()[]&#123;&#125;"Output : true 1234567891011121314151617public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++)&#123; char c = s.charAt(i); if(c == '(' || c == '&#123;' || c == '[') stack.push(c); else&#123; if(stack.isEmpty()) return false; char cStack = stack.pop(); if(c == ')' &amp;&amp; cStack != '(' || c == ']' &amp;&amp; cStack != '[' || c == '&#125;' &amp;&amp; cStack != '&#123;' ) &#123; return false; &#125; &#125; &#125; return stack.isEmpty();&#125; 数组中比当前元素大的下一个数组元素的距离 12Input: [73, 74, 75, 71, 69, 72, 76, 73]Output: [1, 1, 4, 2, 1, 1, 0, 0] Leetcode : 739. Daily Temperatures (Medium) 使用栈来存储还未计算的元素。可以保证从栈顶向下元素递增，否则上面有一个比下面某个元素大的元素进入栈中，下面那个元素已经找到比它大的元素，因此会出栈。 12345678910111213public int[] dailyTemperatures(int[] temperatures) &#123; int n = temperatures.length; int[] ret = new int[n]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i = 0; i &lt; n; i++) &#123; while(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123; int idx = stack.pop(); ret[idx] = i - idx; &#125; stack.add(i); &#125; return ret;&#125; 数组中下一个比当前数大的数 Leetcode : 496. Next Greater Element I (Easy) 12Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1] 在遍历数组时用 Stack 把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。 12345678910111213141516public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int num : nums2)&#123; while(!stack.isEmpty() &amp;&amp; num &gt; stack.peek())&#123; map.put(stack.pop(), num); &#125; stack.add(num); &#125; int[] ret = new int[nums1.length]; for(int i = 0; i &lt; nums1.length; i++)&#123; if(map.containsKey(nums1[i])) ret[i] = map.get(nums1[i]); else ret[i] = -1; &#125; return ret;&#125; 循环数组中下一个比当前元素大的数 Leetcode : 503. Next Greater Element II (Medium) 123456789101112public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length, next[] = new int[n]; Arrays.fill(next, -1); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; n * 2; i++) &#123; int num = nums[i % n]; while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num) next[stack.pop()] = num; if (i &lt; n) stack.push(i); &#125; return next;&#125; 哈希表利用 Hash Table 可以快速查找一个元素是否存在等问题，但是需要一定的空间来存储。在优先考虑时间复杂度的情况下，可以利用 Hash Table 这种空间换取时间的做法。 Java 中的 HashSet 用于存储一个集合，并以 O(1) 的时间复杂度查找元素是否在集合中。 如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在，例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。 Java 中的 HashMap 主要用于映射关系，从而把两个元素联系起来。 在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。例如在一个简化 url 的系统中（Leetcdoe : 535. Encode and Decode TinyURL (Medium)），利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源。 HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。 数组中的两个数和为给定值 Leetcode : 1. Two Sum (Easy) 可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(nlgn)，空间复杂度为 O(1)。 用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i] ，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(n)，空间复杂度为 O(n)，使用空间来换取时间。 12345678public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(map.containsKey(target - nums[i])) return new int[]&#123;map.get(target - nums[i]), i&#125;; else map.put(nums[i], i); &#125; return null;&#125; 最长和谐序列 和谐序列中最大数和最小数只差正好为 1 Leetcode : 594. Longest Harmonious Subsequence (Easy) 12345678910111213public int findLHS(int[] nums) &#123; Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (long num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; int result = 0; for (long key : map.keySet()) &#123; if (map.containsKey(key + 1)) &#123; result = Math.max(result, map.get(key + 1) + map.get(key)); &#125; &#125; return result;&#125; 字符串两个字符串的包含的字符是否完全相同 Leetcode : 242. Valid Anagram (Easy) 字符串只包含小写字符，总共有 26 个小写字符。可以用 Hash Table 来映射字符与出现次数，因为键值范围很小，因此可以用数组来进行映射。 使用长度为 26 的整型数组对字符串出现的字符进行统计，比较两个字符串出现的字符数量是否相同。 1234567public boolean isAnagram(String s, String t) &#123; int[] cnts = new int[26]; for(int i = 0; i &lt; s.length(); i++) cnts[s.charAt(i) - 'a'] ++; for(int i = 0; i &lt; t.length(); i++) cnts[t.charAt(i) - 'a'] --; for(int i = 0; i &lt; 26; i++) if(cnts[i] != 0) return false; return true;&#125; 字符串同构 Leetcode : 205. Isomorphic Strings (Easy) 例如 “egg” 和 “add” 就属于同构字符串。 记录一个字符上次出现的位置，如果两个字符串中某个字符上次出现的位置一样，那么就属于同构。 123456789101112public boolean isIsomorphic(String s, String t) &#123; int[] m1 = new int[256]; int[] m2 = new int[256]; for(int i = 0; i &lt; s.length(); i++)&#123; if(m1[s.charAt(i)] != m2[t.charAt(i)]) &#123; return false; &#125; m1[s.charAt(i)] = i + 1; m2[t.charAt(i)] = i + 1; &#125; return true;&#125; 计算一组字符集合可以组成的回文字符串的最大长度 Leetcode : 409. Longest Palindrome 使用长度为 128 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。 12345678public int longestPalindrome(String s) &#123; int[] cnts = new int[128]; // ascii 码总共 128 个 for(char c : s.toCharArray()) cnts[c]++; int ret = 0; for(int cnt : cnts) ret += (cnt / 2) * 2; if(ret &lt; s.length()) ret ++; // 这个条件下 s 中一定有单个未使用的字符存在，可以把这个字符放到回文的最中间 return ret;&#125; 判断一个整数是否是回文数 Leetcode : 9. Palindrome Number (Easy) 要求不能使用额外空间，也就不能将整数转换为字符串进行判断。 将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。 1234567891011public boolean isPalindrome(int x) &#123; if(x == 0) return true; if(x &lt; 0) return false; if(x % 10 == 0) return false; int right = 0; while(x &gt; right)&#123; right = right * 10 + x % 10; x /= 10; &#125; return x == right || x == right / 10;&#125; 回文子字符串 Leetcode : 647. Palindromic Substrings (Medium) 解决方案是从字符串的某一位开始，尝试着去扩展子字符串。 12345678910111213141516private int cnt = 0;public int countSubstrings(String s) &#123; for(int i = 0; i &lt; s.length(); i++) &#123; extendSubstrings(s, i, i); // 奇数长度 extendSubstrings(s, i, i + 1); // 偶数长度 &#125; return cnt;&#125;private void extendSubstrings(String s, int start, int end) &#123; while(start &gt;= 0 &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end)) &#123; start--; end++; cnt++; &#125;&#125; 统计二进制字符串中连续 1 和 连续 0 数量相同的子字符串个数 123Input: "00110011"Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Leetcode : 696. Count Binary Substrings (Easy) 12345678910111213public int countBinarySubstrings(String s) &#123; int preLen = 0, curLen = 1, ret = 0; for(int i = 1; i &lt; s.length(); i++)&#123; if(s.charAt(i) == s.charAt(i-1)) curLen++; else&#123; preLen = curLen; curLen = 1; &#125; if(preLen &gt;= curLen) ret++; &#125; return ret;&#125; 字符串循环移位包含 编程之美：3.1 给定两个字符串 s1 和 s2 ，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。 12s1 = AABCD, s2 = CDAAReturn : true s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可。 字符串循环移位 编程之美：2.17 将字符串向右循环移动 k 位。 例如 abcd123 向右移动 3 位 得到 123abcd 将 abcd123 中的 abcd 和 123 单独逆序，得到 dcba321，然后对整个字符串进行逆序，得到123abcd。 字符串中单词的翻转 程序员代码面试指南 例如将 “I am a student” 翻转成 “student a am I” 将每个单词逆序，然后将整个字符串逆序。 数组与矩阵把数组中的 0 移到末尾 Leetcode : 283. Move Zeroes (Easy) 12345678910public void moveZeroes(int[] nums) &#123; int n = nums.length; int idx = 0; for(int i = 0; i &lt; n; i++)&#123; if(nums[i] != 0) nums[idx++] = nums[i]; &#125; while(idx &lt; n)&#123; nums[idx++] = 0; &#125;&#125; 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出丢失的数和重复的数 Leetcode : 645. Set Mismatch (Easy) 最直接的方法是先对数组进行排序，这种方法时间复杂度为 O(nlogn)，本题可以以 O(n) 的时间复杂度、O(1) 空间复杂度来求解。 主要思想是让通过交换数组元素，使得数组上的元素在正确的位置上。 遍历数组，如果第 i 位上的元素不是 i + 1 ，那么就交换第 i 位 和 nums[i] - 1 位上的元素，使得 num[i] - 1 的元素为 nums[i] ，也就是该位的元素是正确的。交换操作需要循环进行，因为一次交换没办法使得第 i 位上的元素是正确的。但是要交换的两个元素可能就是重复元素，那么循环就可能永远进行下去，终止循环的方法是加上 nums[i] != nums[nums[i] - 1 条件。 类似题目： Leetcode :448. Find All Numbers Disappeared in an Array (Easy)，寻找所有丢失的元素 Leetcode : 442. Find All Duplicates in an Array (Medium)，寻找所有重复的元素。 1234567891011121314151617public int[] findErrorNums(int[] nums) &#123; for(int i = 0; i &lt; nums.length; i++)&#123; while(nums[i] != i + 1 &amp;&amp; nums[i] != nums[nums[i] - 1]) swap(nums, i, nums[i] - 1); &#125; for(int i = 0; i &lt; nums.length; i++)&#123; if(i + 1 != nums[i]) return new int[]&#123;nums[i], i + 1&#125;; &#125; return null;&#125;private void swap(int[] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;&#125; 找出数组中重复的数，数组值在 [0, n-1] 之间 Leetcode : 287. Find the Duplicate Number (Medium) 二分查找解法： 12345678910111213public int findDuplicate(int[] nums) &#123; int l = 1, h = nums.length - 1; while (l &lt;= h) &#123; int mid = l + (h - l) / 2; int cnt = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &lt;= mid) cnt++; &#125; if (cnt &gt; mid) h = mid - 1; else l = mid + 1; &#125; return l;&#125; 双指针解法，类似于有环链表中找出环的入口： 1234567891011121314public int findDuplicate(int[] nums) &#123; int slow = nums[0], fast = nums[nums[0]]; while (slow != fast) &#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; fast = 0; while (slow != fast) &#123; slow = nums[slow]; fast = nums[fast]; &#125; return slow;&#125; 有序矩阵有序矩阵指的是行和列分别有序的矩阵。 一般可以利用有序性使用二分查找方法。 12345[ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]] 有序矩阵查找 Leetocde : 240. Search a 2D Matrix II (Medium) 1234567891011public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; int m = matrix.length, n = matrix[0].length; int row = 0, col = n - 1; while (row &lt; m &amp;&amp; col &gt;= 0) &#123; if (target == matrix[row][col]) return true; else if (target &lt; matrix[row][col]) col--; else row++; &#125; return false;&#125; 有序矩阵的 Kth Element Leetcode : 378. Kth Smallest Element in a Sorted Matrix ((Medium)) 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. 解题参考：Share my thoughts and Clean Java Code 二分查找解法： 12345678910111213141516public int kthSmallest(int[][] matrix, int k) &#123; int m = matrix.length, n = matrix[0].length; int lo = matrix[0][0], hi = matrix[m - 1][n - 1]; while(lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; int cnt = 0; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) &#123; cnt++; &#125; &#125; if(cnt &lt; k) lo = mid + 1; else hi = mid - 1; &#125; return lo;&#125; 堆解法： 1234567891011121314151617181920212223public int kthSmallest(int[][] matrix, int k) &#123; int m = matrix.length, n = matrix[0].length; PriorityQueue&lt;Tuple&gt; pq = new PriorityQueue&lt;Tuple&gt;(); for(int j = 0; j &lt; n; j++) pq.offer(new Tuple(0, j, matrix[0][j])); for(int i = 0; i &lt; k - 1; i++) &#123; // 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数 Tuple t = pq.poll(); if(t.x == m - 1) continue; pq.offer(new Tuple(t.x + 1, t.y, matrix[t.x + 1][t.y])); &#125; return pq.poll().val;&#125;class Tuple implements Comparable&lt;Tuple&gt; &#123; int x, y, val; public Tuple(int x, int y, int val) &#123; this.x = x; this.y = y; this.val = val; &#125; @Override public int compareTo(Tuple that) &#123; return this.val - that.val; &#125;&#125; 链表判断两个链表的交点 Leetcode : 160. Intersection of Two Linked Lists 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3 要求：时间复杂度为 O(n) 空间复杂度为 O(1) 设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。 当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 123456789public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null) return null; ListNode l1 = headA, l2 = headB; while(l1 != l2)&#123; l1 = (l1 == null) ? headB : l1.next; l2 = (l2 == null) ? headA : l2.next; &#125; return l1;&#125; 如果只是判断是否存在交点，那么就是另一个问题，即 编程之美：3.6 的问题。有两种解法：把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；或者直接比较第一个链表最后一个节点和第二个链表最后一个节点是否相同。 链表反转 Leetcode : 206. Reverse Linked List 头插法能够按逆序构建链表。 12345678910public ListNode reverseList(ListNode head) &#123; ListNode newHead = null; // 设为 null ，作为新链表的结尾 while(head != null)&#123; ListNode nextNode = head.next; head.next = newHead; newHead = head; head = nextNode; &#125; return newHead;&#125; 归并两个有序的链表 Leetcode : 21. Merge Two Sorted Lists 链表和树一样，可以用递归方式来定义：链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。 12345678910111213public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; ListNode newHead = null; if(l1.val &lt; l2.val)&#123; newHead = l1; newHead.next = mergeTwoLists(l1.next, l2); &#125; else&#123; newHead = l2; newHead.next = mergeTwoLists(l1, l2.next); &#125; return newHead;&#125; 从有序链表中删除重复节点 Leetcode : 83. Remove Duplicates from Sorted List (Easy) 12345public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); return head.next != null &amp;&amp; head.val == head.next.val ? head.next : head;&#125; 回文链表 Leetcode : 234. Palindrome Linked List (Easy) 切成两半，把后半段反转，然后比较两半是否相等。 123456789101112131415161718192021222324252627282930313233343536373839404142public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null) return true; ListNode slow = head, fast = head.next; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; if(fast != null)&#123; // 偶数节点，让 slow 指向下一个节点 slow = slow.next; &#125; cut(head, slow); // 切成两个链表 ListNode l1 = head, l2 = slow; l2 = reverse(l2); return isEqual(l1, l2);&#125;private void cut(ListNode head, ListNode cutNode)&#123; while( head.next != cutNode ) head = head.next; head.next = null;&#125;private ListNode reverse(ListNode head)&#123; ListNode newHead = null; while(head != null)&#123; ListNode nextNode = head.next; head.next = newHead; newHead = head; head = nextNode; &#125; return newHead;&#125;private boolean isEqual(ListNode l1, ListNode l2)&#123; while(l1 != null &amp;&amp; l2 != null)&#123; if(l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; &#125; return true;&#125; 从链表中删除节点 编程之美：3.4 12B.val = C.val;B.next = C.next; 链表元素按奇偶聚集 Leetcode : 328. Odd Even Linked List (Medium) 1234567891011121314public ListNode oddEvenList(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode odd = head, even = head.next, evenHead = even; while (even != null &amp;&amp; even.next != null) &#123; odd.next = odd.next.next; odd = odd.next; even.next = even.next.next; even = even.next; &#125; odd.next = evenHead; return head;&#125; 树递归一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。 树的高度 Leetcode : 104. Maximum Depth of Binary Tree (Easy) 1234public int maxDepth(TreeNode root) &#123; if(root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;&#125; 翻转树 Leetcode : 226. Invert Binary Tree (Easy) 1234567public TreeNode invertTree(TreeNode root) &#123; if(root == null) return null; TreeNode left = root.left; // 后面的操作会改变 left 指针，因此先保存下来 root.left = invertTree(root.right); root.right = invertTree(left); return root;&#125; 归并两棵树 Leetcode : 617. Merge Two Binary Trees (Easy) 123456789public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1 == null &amp;&amp; t2 == null) return null; if(t1 == null) return t2; if(t2 == null) return t1; TreeNode root = new TreeNode(t1.val + t2.val); root.left = mergeTrees(t1.left, t2.left); root.right = mergeTrees(t1.right, t2.right); return root;&#125; 判断路径和是否等于一个数 Leetcdoe : 112. Path Sum (Easy) 题目描述：路径和定义为从 root 到 leaf 的所有节点的和 12345public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) return true; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);&#125; 统计路径和等于一个数的路径数量 Leetcode : 437. Path Sum III (Easy) 题目描述：路径不一定以 root 开头并以 leaf 结尾，但是必须连续 pathSumStartWithRoot() 方法统计以某个节点开头的路径个数。 12345678910111213public int pathSum(TreeNode root, int sum) &#123; if(root == null) return 0; int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum); return ret;&#125;private int pathSumStartWithRoot(TreeNode root, int sum)&#123; if(root == null) return 0; int ret = 0; if(root.val == sum) ret++; ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val); return ret;&#125; 树的对称 Leetcode : 101. Symmetric Tree (Easy) 1234567891011public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; return isSymmetric(root.left, root.right);&#125;private boolean isSymmetric(TreeNode t1, TreeNode t2)&#123; if(t1 == null &amp;&amp; t2 == null) return true; if(t1 == null || t2 == null) return false; if(t1.val != t2.val) return false; return isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);&#125; 平衡树 Leetcode : 110. Balanced Binary Tree (Easy) 题目描述：左右子树高度差是否都小于等于 1 1234567891011121314private boolean result = true;public boolean isBalanced(TreeNode root) &#123; maxDepth(root); return result;&#125;public int maxDepth(TreeNode root) &#123; if (root == null) return 0; int l = maxDepth(root.left); int r = maxDepth(root.right); if (Math.abs(l - r) &gt; 1) result = false; return 1 + Math.max(l, r);&#125; 最小路径 Leetcode : 111. Minimum Depth of Binary Tree (Easy) 题目描述：树的根节点到叶子节点的最小长度 1234567public int minDepth(TreeNode root) &#123; if(root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); if(left == 0 || right == 0) return left + right + 1; return Math.min(left, right) + 1;&#125; 统计左叶子节点的和 Leetcode : 404. Sum of Left Leaves (Easy) 12345678910public int sumOfLeftLeaves(TreeNode root) &#123; if(root == null) return 0; if(isLeaf(root.left)) return root.left.val + sumOfLeftLeaves(root.right); return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);&#125;private boolean isLeaf(TreeNode node)&#123; if(node == null) return false; return node.left == null &amp;&amp; node.right == null;&#125; 修剪一棵树 Leetcode : 669. Trim a Binary Search Tree (Easy) 题目描述：只保留值在 L ~ R 之间的节点 12345678public TreeNode trimBST(TreeNode root, int L, int R) &#123; if(root == null) return null; if(root.val &gt; R) return trimBST(root.left, L, R); if(root.val &lt; L) return trimBST(root.right, L, R); root.left = trimBST(root.left, L, R); root.right = trimBST(root.right, L, R); return root;&#125; 子树 Leetcode : 572. Subtree of Another Tree (Easy) 12345678910111213public boolean isSubtree(TreeNode s, TreeNode t) &#123; if(s == null &amp;&amp; t == null) return true; if(s == null || t == null) return false; if(s.val == t.val &amp;&amp; isSame(s, t)) return true; return isSubtree(s.left, t) || isSubtree(s.right, t);&#125;private boolean isSame(TreeNode s, TreeNode t)&#123; if(s == null &amp;&amp; t == null) return true; if(s == null || t == null) return false; if(s.val != t.val) return false; return isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right);&#125; 从有序数组中构造二叉查找树 Leetcode : 108. Convert Sorted Array to Binary Search Tree (Easy) 二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。 123456789101112public TreeNode sortedArrayToBST(int[] nums) &#123; return toBST(nums, 0, nums.length - 1);&#125;private TreeNode toBST(int[] nums, int sIdx, int eIdx)&#123; if(sIdx &gt; eIdx) return null; int mIdx = (sIdx + eIdx) / 2; TreeNode root = new TreeNode(nums[mIdx]); root.left = toBST(nums, sIdx, mIdx - 1); root.right = toBST(nums, mIdx + 1, eIdx); return root;&#125; 两节点的最长路径 1234567 1 / \ 2 3 / \ 4 5Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. 12345678910111213141516private int max = 0;public int diameterOfBinaryTree(TreeNode root) &#123; depth(root); return max;&#125;private int depth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftDepth = depth(root.left); int rightDepth = depth(root.right); max = Math.max(max, leftDepth + rightDepth); return Math.max(leftDepth, rightDepth) + 1;&#125; 找出二叉树中第二小的节点 Leetcode : 671. Second Minimum Node In a Binary Tree (Easy) 12345678Input: 2 / \ 2 5 / \ 5 7Output: 5 一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点。 1234567891011public int findSecondMinimumValue(TreeNode root) &#123; if(root == null) return -1; if(root.left == null &amp;&amp; root.right == null) return -1; int leftVal = root.left.val; int rightVal = root.right.val; if(leftVal == root.val) leftVal = findSecondMinimumValue(root.left); if(rightVal == root.val) rightVal = findSecondMinimumValue(root.right); if(leftVal != -1 &amp;&amp; rightVal != -1) return Math.min(leftVal, rightVal); if(leftVal != -1) return leftVal; return rightVal;&#125; 寻找两个节点的最近公共祖先 Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree (Easy) 12345public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root;&#125; 最近公共祖先 Leetcode : 236. Lowest Common Ancestor of a Binary Tree (Medium) 123456public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); return left == null ? right : right == null ? left : root;&#125; 最大相同节点值的路径长度 Leetcode : 687. Longest Univalue Path (Easy) 1234567 1 / \ 4 5 / \ \ 4 4 5Output : 2 123456789101112131415private int path = 0;public int longestUnivaluePath(TreeNode root) &#123; dfs(root); return path;&#125;private int dfs(TreeNode root)&#123; if(root == null) return 0; int left = dfs(root.left); int right = dfs(root.right); int leftPath = root.left != null &amp;&amp; root.left.val == root.val ? left + 1 : 0; int rightPath = root.right != null &amp;&amp; root.right.val == root.val ? right + 1 : 0; path = Math.max(path, leftPath + rightPath); return Math.max(leftPath, rightPath);&#125; 间隔遍历 Leetcode : 337. House Robber III (Medium) 123456789101112public int rob(TreeNode root) &#123; if (root == null) return 0; int val1 = root.val; if (root.left != null) &#123; val1 += rob(root.left.left) + rob(root.left.right); &#125; if (root.right != null) &#123; val1 += rob(root.right.left) + rob(root.right.right); &#125; int val2 = rob(root.left) + rob(root.right); return Math.max(val1, val2);&#125; 层次遍历使用 BFS，不需要使用两个队列来分别存储当前层的节点和下一层的节点， 因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。 计算一棵树每层节点的平均数 637. Average of Levels in Binary Tree (Easy) 123456789101112131415161718public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; ret = new ArrayList&lt;&gt;(); if(root == null) return ret; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int cnt = queue.size(); double sum = 0; for(int i = 0; i &lt; cnt; i++)&#123; TreeNode node = queue.poll(); sum += node.val; if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); &#125; ret.add(sum / cnt); &#125; return ret;&#125; 得到左下角的节点 Leetcode : 513. Find Bottom Left Tree Value (Easy) 12345678910public int findBottomLeftValue(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; root = queue.poll(); if(root.right != null) queue.add(root.right); if(root.left != null) queue.add(root.left); &#125; return root.val;&#125; 前中后序遍历12345 1 / \ 2 3 / \ \4 5 6 层次遍历顺序：[1 2 3 4 5 6]前序遍历顺序：[1 2 4 5 3 6]中序遍历顺序：[4 2 5 1 3 6]后序遍历顺序：[4 5 2 6 3 1] 层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现。 前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。 ① 前序 12345void dfs(TreeNode root)&#123; visit(root); dfs(root.left); dfs(root.right);&#125; ② 中序 12345void dfs(TreeNode root)&#123; dfs(root.left); visit(root); dfs(root.right);&#125; ③ 后序 12345void dfs(TreeNode root)&#123; dfs(root.left); dfs(root.right); visit(root);&#125; 非递归实现二叉树的前序遍历 Leetcode : 144. Binary Tree Preorder Traversal (Medium) 12345678910111213public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) return ret; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); ret.add(node.val); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); // 先添加右子树再添加左子树，这样是为了让左子树在栈顶 &#125; return ret;&#125; 非递归实现二叉树的后续遍历 Leetcode : ### 145. Binary Tree Postorder Traversal (Medium) 前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root，可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。 1234567891011121314public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) return ret; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); ret.add(node.val); if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); &#125; Collections.reverse(ret); return ret;&#125; 非递归实现二叉树的中序遍历 Leetcode : 94. Binary Tree Inorder Traversal (Medium) 123456789101112131415public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty()) &#123; while(cur != null) &#123; // 模拟递归栈的不断深入 stack.add(cur); cur = cur.left; &#125; TreeNode node = stack.pop(); ret.add(node.val); cur = node.right; &#125; return ret;&#125; 使用中序遍历和前序遍历序列重建二叉树 //TODO BST主要利用 BST 中序遍历有序的特点。 在 BST 中寻找两个节点，使它们的和为一个给定值。 653. Two Sum IV - Input is a BST 使用中序遍历得到有序数组之后，再利用双指针对数组进行查找。 应该注意到，这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中。 12345678910111213141516171819public boolean findTarget(TreeNode root, int k) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); inOrder(root, nums); int i = 0, j = nums.size() - 1; while(i &lt; j)&#123; int sum = nums.get(i) + nums.get(j); if(sum == k) return true; if(sum &lt; k) i++; else j--; &#125; return false;&#125;private void inOrder(TreeNode root, List&lt;Integer&gt; nums)&#123; if(root == null) return; inOrder(root.left, nums); nums.add(root.val); inOrder(root.right, nums);&#125; 在 BST 中查找最小的两个节点之差的绝对值 Leetcode : 530. Minimum Absolute Difference in BST (Easy) 利用 BST 的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。 123456789101112131415private int minDiff = Integer.MAX_VALUE;private int preVal = -1;public int getMinimumDifference(TreeNode root) &#123; inorder(root); return minDiff;&#125;private void inorder(TreeNode node)&#123; if(node == null) return; inorder(node.left); if(preVal != -1) minDiff = Math.min(minDiff, Math.abs(node.val - preVal)); preVal = node.val; inorder(node.right);&#125; 把 BST 每个节点的值都加上比它大的节点的值 Leetcode : Convert BST to Greater Tree (Easy) 先遍历右子树。 1234567891011121314151617181920private int sum = 0;public TreeNode convertBST(TreeNode root) &#123; traver(root); return root;&#125;private void traver(TreeNode root) &#123; if (root == null) &#123; return; &#125; if (root.right != null) &#123; traver(root.right); &#125; sum += root.val; root.val = sum; if (root.left != null) &#123; traver(root.left); &#125;&#125; 寻找 BST 中出现次数最多的节点 123456789101112131415161718192021222324252627282930313233private int cnt = 1;private int maxCnt = 1;private TreeNode preNode = null;private List&lt;Integer&gt; list;public int[] findMode(TreeNode root) &#123; list = new ArrayList&lt;&gt;(); inorder(root); int[] ret = new int[list.size()]; int idx = 0; for(int num : list)&#123; ret[idx++] = num; &#125; return ret;&#125;private void inorder(TreeNode node)&#123; if(node == null) return; inorder(node.left); if(preNode != null)&#123; if(preNode.val == node.val) cnt++; else cnt = 1; &#125; if(cnt &gt; maxCnt)&#123; maxCnt = cnt; list.clear(); list.add(node.val); &#125; else if(cnt == maxCnt)&#123; list.add(node.val); &#125; preNode = node; inorder(node.right);&#125; 寻找 BST 的第 k 个元素 Leetcode : 230. Kth Smallest Element in a BST (Medium) 递归解法： 1234567891011public int kthSmallest(TreeNode root, int k) &#123; int leftCnt = count(root.left); if(leftCnt == k - 1) return root.val; if(leftCnt &gt; k - 1) return kthSmallest(root.left, k); return kthSmallest(root.right, k - leftCnt - 1);&#125;private int count(TreeNode node) &#123; if(node == null) return 0; return 1 + count(node.left) + count(node.right);&#125; 中序遍历解法： 123456789101112131415161718private int cnt = 0;private int val;public int kthSmallest(TreeNode root, int k) &#123; inorder(root, k); return val;&#125;private void inorder(TreeNode node, int k) &#123; if(node == null) return; inorder(node.left, k); cnt++; if(cnt == k) &#123; val = node.val; return; &#125; inorder(node.right, k);&#125; Trie Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。 实现一个 Trie Leetcode : 208. Implement Trie (Prefix Tree) (Medium) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Trie &#123; private class Node&#123; Node[] childs = new Node[26]; boolean isLeaf; &#125; private Node root = new Node(); /** Initialize your data structure here. */ public Trie() &#123; &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; int idx = word.charAt(0) - 'a'; insert(word, root); &#125; private void insert(String word, Node node)&#123; int idx = word.charAt(0) - 'a'; if(node.childs[idx] == null)&#123; node.childs[idx] = new Node(); &#125; if(word.length() == 1) node.childs[idx].isLeaf = true; else insert(word.substring(1), node.childs[idx]); &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; return search(word, root); &#125; private boolean search(String word, Node node)&#123; if(node == null) return false; int idx = word.charAt(0) - 'a'; if(node.childs[idx] == null) return false; if(word.length() == 1) return node.childs[idx].isLeaf; return search(word.substring(1), node.childs[idx]); &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; return startWith(prefix, root); &#125; private boolean startWith(String prefix, Node node)&#123; if(node == null) return false; if(prefix.length() == 0) return true; int idx = prefix.charAt(0) - 'a'; return startWith(prefix.substring(1), node.childs[idx]); &#125;&#125; 实现一个 Trie，用来求前缀和 Leetcode : 677. Map Sum Pairs (Medium) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MapSum &#123; private class Trie &#123; int val; Map&lt;Character, Trie&gt; childs; boolean isWord; Trie() &#123; childs = new HashMap&lt;&gt;(); &#125; &#125; private Trie root; public MapSum() &#123; root = new Trie(); &#125; public void insert(String key, int val) &#123; Trie cur = root; for(char c : key.toCharArray()) &#123; if(!cur.childs.containsKey(c)) &#123; Trie next = new Trie(); cur.childs.put(c, next); &#125; cur = cur.childs.get(c); &#125; cur.val = val; cur.isWord = true; &#125; public int sum(String prefix) &#123; Trie cur = root; for(char c : prefix.toCharArray()) &#123; if(!cur.childs.containsKey(c)) return 0; cur = cur.childs.get(c); &#125; return dfs(cur); &#125; private int dfs(Trie cur) &#123; int sum = 0; if(cur.isWord) &#123; sum += cur.val; &#125; for(Trie next : cur.childs.values()) &#123; sum += dfs(next); &#125; return sum; &#125;&#125; 图位运算1. 基本原理 0s 表示 一串 0 ，1s 表示一串 1。 123x ^ 0s = x x &amp; 0s = 0 x | 0s = xx ^ 1s = ~x x &amp; 1s = x x | 1s = 1sx ^ x = 0 x &amp; x = x x | x = x ① 利用 x ^ 1s = ~x 的特点，可以将位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数；② 利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask ：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位；③ 利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设置操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1 。 >> n 为算术右移，相当于除以 2n；>>> n 为无符号右移，左边会补上 0。&lt;&lt; n 为算术左移，相当于乘以 2n。 n&amp;(n-1) 该位运算是去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000。 n-n&amp;(~n+1) 概运算是去除 n 的位级表示中最高的那一位。 n&amp;(-n) 该运算得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100 2. mask 计算 要获取 111111111，将 0 取反即可，~0。 要得到只有第 i 位为 1 的 mask，将 1 向左移动 i 位即可，1&lt;&lt;i 。例如 1&lt;&lt;5 得到只有第 5 位为 1 的 mask ：00010000。 要得到 1 到 i 位为 1 的 mask，1&lt;&lt;(i+1)-1 即可，例如将 1&lt;&lt;(4+1)-1 = 00010000-1 = 00001111。 要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~(1&lt;&lt;(i+1)-1)。 3. 位操作举例 ① 获取第 i 位 num &amp; 00010000 != 0 1(num &amp; (1 &lt;&lt; i)) != 0; ② 将第 i 位设置为 1 num | 00010000 1num | (1 &lt;&lt; i); ③ 将第 i 位清除为 0 num &amp; 11101111 1num &amp; (~(1 &lt;&lt; i)) ④ 将最高位到第 i 位清除为 0 num &amp; 00001111 1num &amp; ((1 &lt;&lt; i) - 1); ⑤ 将第 0 位到第 i 位清除为 0 num &amp; 11110000 1num &amp; (~((1 &lt;&lt; (i+1)) - 1)); ⑥ 将第 i 位设置为 0 或者 1 先将第 i 位清零，然后将 v 左移 i 位，执行“位或”运算。 1(num &amp; (1 &lt;&lt; i)) | (v &lt;&lt; i); 4. Java 中的位操作 123static int Integer.bitCount() // 统计 1 的数量static int Integer.highestOneBit() // 获得最高位static String toBinaryString(int i) // 转换位二进制表示的字符串 统计两个数的二进制表示有多少位不同 Leetcode : 461. Hamming Distance (Easy) 对两个数进行异或操作，不同的那一位结果为 1 ，统计有多少个 1 即可。 123456789public int hammingDistance(int x, int y) &#123; int z = x ^ y; int cnt = 0; while(z != 0)&#123; if((z &amp; 1) == 1) cnt++; z = z &gt;&gt; 1; &#125; return cnt;&#125; 可以使用 Integer.bitcount() 来统计 1 个的个数。 123public int hammingDistance(int x, int y) &#123; return Integer.bitCount(x ^ y);&#125; 翻转一个数的比特位 Leetcode : 190. Reverse Bits (Easy) 123456789public int reverseBits(int n) &#123; int ret = 0; for(int i = 0; i &lt; 32; i++)&#123; ret &lt;&lt;= 1; ret |= (n &amp; 1); n &gt;&gt;&gt;= 1; &#125; return ret;&#125; 不用额外变量交换两个整数 程序员代码面试指南 ：P317 123a = a ^ b;b = a ^ b;a = a ^ b; 将 c = a ^ b，那么 b ^ c = b ^ b ^ a = a，a ^ c = a ^ a ^ b = b。 判断一个数是不是 4 的 n 次方 Leetcode : 342. Power of Four (Easy) 该数二进制表示有且只有一个奇数位为 1 ，其余的都为 0 ，例如 16 ： 10000。可以每次把 1 向左移动 2 位，就能构造出这种数字，然后比较构造出来的数与要判断的数是否相同。 12345678public boolean isPowerOfFour(int num) &#123; int i = 1; while(i &gt; 0)&#123; if(i == num) return true; i = i &lt;&lt; 2; &#125; return false;&#125; 也可以用 Java 的 Integer.toString() 方法将该数转换为 4 进制形式的字符串，然后判断字符串是否以 1 开头。 123public boolean isPowerOfFour(int num) &#123; return Integer.toString(num, 4).matches("10*");&#125; 判断一个数是不是 2 的 n 次方 Leetcode : 231. Power of Two (Easy) 同样可以用 Power of Four 的方法，但是 2 的 n 次方更特殊，它的二进制表示只有一个 1 存在。 123public boolean isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; Integer.bitCount(n) == 1;&#125; 利用 1000 &amp; 0111 == 0 这种性质，得到以下解法： 123public boolean isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;&#125; 数组中唯一一个不重复的元素 Leetcode : 136. Single Number (Easy) 两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。 类似的有：Leetcode : 389. Find the Difference (Easy)，两个字符串仅有一个字符不相同，使用异或操作可以以 O(1) 的空间复杂度来求解，而不需要使用 HashSet。 12345public int singleNumber(int[] nums) &#123; int ret = 0; for(int n : nums) ret = ret ^ n; return ret;&#125; 数组中不重复的两个元素 Leetcode : 260. Single Number III (Medium) 两个不相等的元素在位级表示上必定会有一位存在不同。 将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。 diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。 123456789101112public int[] singleNumber(int[] nums) &#123; int diff = 0; for(int num : nums) diff ^= num; // 得到最右一位 diff &amp;= -diff; int[] ret = new int[2]; for(int num : nums) &#123; if((num &amp; diff) == 0) ret[0] ^= num; else ret[1] ^= num; &#125; return ret;&#125; 判断一个数的位级表示是否不会出现连续的 0 和 1 Leetcode : 693. Binary Number with Alternating Bits (Easy) 对于 10101 这种位级表示的数，把它向右移动 1 位得到 1010 ，这两个数每个位都不同，因此异或得到的结果为 11111。 1234public boolean hasAlternatingBits(int n) &#123; int a = (n ^ (n &gt;&gt; 1)); return (a &amp; (a + 1)) == 0;&#125; 求一个数的补码 Leetcode : 476. Number Complement (Easy) 不考虑二进制表示中的首 0 部分 对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。 1234567public int findComplement(int num) &#123; if(num == 0) return 1; int mask = 1 &lt;&lt; 30; while((num &amp; mask) == 0) mask &gt;&gt;= 1; mask = (mask &lt;&lt; 1) - 1; return num ^ mask;&#125; 可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。 123456public int findComplement(int num) &#123; if(num == 0) return 1; int mask = Integer.highestOneBit(num); mask = (mask &lt;&lt; 1) - 1; return num ^ mask;&#125; 对于 10000000 这样的数要扩展成 11111111，可以利用以下方法： 123mask |= mask &gt;&gt; 1 11000000mask |= mask &gt;&gt; 2 11110000mask |= mask &gt;&gt; 4 11111111 123456789public int findComplement(int num) &#123; int mask = num; mask |= mask &gt;&gt; 1; mask |= mask &gt;&gt; 2; mask |= mask &gt;&gt; 4; mask |= mask &gt;&gt; 8; mask |= mask &gt;&gt; 16; return (mask ^ num);&#125; 实现整数的加法 Leetcode : 371. Sum of Two Integers (Easy) a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。 123public int getSum(int a, int b) &#123; return b == 0 ? a : getSum((a ^ b), (a &amp; b) &lt;&lt; 1);&#125; 字符串数组最大乘积 Leetcode : 318. Maximum Product of Word Lengths (Medium) 题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。 解题思路：本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。 12345678910111213141516171819public int maxProduct(String[] words) &#123; int n = words.length; if (n == 0) return 0; int[] val = new int[n]; for (int i = 0; i &lt; n; i++) &#123; for (char c : words[i].toCharArray()) &#123; val[i] |= 1 &lt;&lt; (c - 'a'); &#125; &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if ((val[i] &amp; val[j]) == 0) &#123; ret = Math.max(ret, words[i].length() * words[j].length()); &#125; &#125; &#125; return ret;&#125; 参考资料 Leetcode Weiss M A, 冯舜玺. 数据结构与算法分析——C 语言描述[J]. 2004. Sedgewick R. Algorithms[M]. Pearson Education India, 1988. 何海涛, 软件工程师. 剑指 Offer: 名企面试官精讲典型编程题[M]. 电子工业出版社, 2014. 《编程之美》小组. 编程之美[M]. 电子工业出版社, 2008. 左程云. 程序员代码面试指南[M]. 电子工业出版社, 2015.]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计和编程]]></title>
    <url>%2Fblog%2F35697.html</url>
    <content type="text"><![CDATA[Java面试笔记 S.O.L.I.DS.O.L.I.D 是面向对象设计和编程 (OOD&amp;OOP) 中几个重要编码原则 (Programming Priciple) 的首字母缩写。 简写 全拼 中文翻译 SRP The Single Responsibility Principle 单一责任原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 ISP The Interface Segregation Principle 接口分离原则 DIP The Dependency Inversion Principle 依赖倒置原则 1. 单一责任原则当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 2. 开放封闭原则软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 3. 里氏替换原则当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有 is-a 关系。 4. 接口分离原则不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。 5. 依赖倒置原则 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 抽象不应该依赖于细节，细节应该依赖于抽象 封装、继承、多态封装、继承、多态是面向对象的三大特性。 1. 封装利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。 封装有三大好处： 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员进行更精确的控制。 隐藏信息，实现细节。 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。 注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改使用的数据类型时，也可以在不影响客户端代码的情况下进行。 123456789101112131415161718192021public class Person &#123; private String name; private int gender; private int age; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender == 0 ? "man" : "woman"; &#125; public void work() &#123; if(18 &lt;= age &amp;&amp; age &lt;= 50) &#123; System.out.println(name + " is working very hard!"); &#125; else &#123; System.out.println(name + " can't work!"); &#125; &#125;&#125; 2. 继承继承实现了 is-a 关系，例如 Cat 和 Animal 就是一种 is-a 关系，因此可以将 Cat 继承自 Animal，从而获得 Animal 非 private 的属性和方法。 Cat 可以当做 Animal 来使用，也就是可以使用 Animal 引用 Cat 对象，这种子类转换为父类称为 向上转型。 继承应该遵循里氏替换原则：当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有 is-a 关系。 1Animal animal = new Cat(); 3. 多态多态分为编译时多态和运行时多态。编译时多态主要指方法的重装，运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定。 多态有三个条件：1. 继承；2. 覆盖父类方法；3. 向上转型。 下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。 12345678910111213141516171819202122232425262728public class Instrument &#123; public void play() &#123; System.out.println("Instument is playing..."); &#125;&#125;public class Wind extends Instrument &#123; public void play() &#123; System.out.println("Wind is playing..."); &#125;&#125;public class Percussion extends Instrument &#123; public void play() &#123; System.out.println("Percussion is playing..."); &#125;&#125;public class Music &#123; public static void main(String[] args) &#123; List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;(); instruments.add(new Wind()); instruments.add(new Percussion()); for(Instrument instrument : instruments) &#123; instrument.play(); &#125; &#125;&#125; UML1. 类图1.1 继承相关 继承有两种形式 : 泛化（generalize）和实现（realize），表现为 is-a 关系。 ① 泛化关系 (generalization) 从具体类中继承 ② 实现关系 (realize) 从抽象类或者接口中继承 1.2 整体和部分 ① 聚合关系 (aggregation) 表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。以下表示 B 由 A 组成： ② 组合关系 (composition) 和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。 1.3 相互联系 ① 关联关系 (association) 表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 ② 依赖关系 (dependency) 和关联关系不同的是 , 依赖关系是在运行过程中起作用的。一般依赖作为类的构造器或者方法的参数传入。双向依赖时一种不好的设计。 2. 时序图2.1 定义 时序图描述了对象之间传递消息的时间顺序，它用来表示用例的行为顺序。它的主要作用是通过对象间的交互来描述用例（注意是对象），从而寻找类的操作。 2.2 赤壁之战时序图 从虚线从上往下表示时间的推进。 可见，通过时序图可以知道每个类具有以下操作： 123456789101112131415161718192021publc class 刘备 &#123; public void 应战 ();&#125;publc class 孔明 &#123; public void 拟定策略 (); public void 联合孙权 (); private void 借东风火攻 ();&#125;public class 关羽 &#123; public void 防守荊州 ();&#125;public class 张飞 &#123; public void 防守荆州前线 ();&#125;public class 孙权 &#123; public void 领兵相助 ();&#125; 2.3 活动图、时序图之间的关系 活动图示从用户的角度来描述用例； 时序图是从计算机的角度（对象间的交互）描述用例。 2.4 类图与时序图的关系 类图描述系统的静态结构，时序图描述系统的动态行为。 2.5 时序图的组成 ① 对象 有三种表现形式 在画图时，应该遵循以下原则： 把交互频繁的对象尽可能地靠拢。 把初始化整个交互活动的对象（有时是一个参与者）放置在最左边。 ② 生命线 生命线从对象的创建开始到对象销毁时终止 ③ 消息 对象之间的交互式通过发送消息来实现的。 消息有 4 种类型： 1. 简单消息，不区分同步异步。 2. 同步消息，发送消息之后需要暂停活动来等待回应。 3. 异步消息，发送消息之后不需要等待。 4. 返回消息，可选。 ④ 激活 生命线上的方框表示激活状态，其它时间处于休眠状态。 参考资料 Java 编程思想 面向对象设计的 SOLID 原则 看懂 UML 类图和时序图 UML 系列——时序图（顺序图）sequence diagram 面向对象编程三大特性 —— 封装、继承、多态]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析]]></title>
    <url>%2Fblog%2F60876.html</url>
    <content type="text"><![CDATA[Java面试笔记 算法分析1. 函数转换指数函数可以转换为线性函数，从而在函数图像上显示的更直观。 T(N)=aN3 转换为 lg(T(N))=3lgN+lga 2. 数学模型近似 使用 ~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数 , 例如 N3/6-N2/2+N/3 ~ N3/6。 增长数量级 增长数量级将算法与它的实现隔离开来，一个算法的增长数量级为 N3 与它是否用 Java 实现，是否运行于特定计算机上无关。 内循环 执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环。 成本模型 使用成本模型来评估算法，例如数组的访问次数就是一种成本模型。 3. ThreeSumThreeSum 程序用于统计一个数组中三元组的和为 0 的数量。 12345678910111213141516public class ThreeSum &#123; public static int count(int[] a) &#123; int N = a.length; int cnt = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = i + 1; j &lt; N; j++) &#123; for (int k = j + 1; k &lt; N; k++) &#123; if (a[i] + a[j] + a[k] == 0) &#123; cnt++; &#125; &#125; &#125; &#125; return cnt; &#125;&#125; 该程序的内循环为 if (a[i] + a[j] + a[k] == 0) 语句，总共执行的次数为 N3/6-N2/2+N/3，因此它的近似执行次数为 ~N3/6，增长数量级为 N3。 改进 通过将数组先排序，对两个元素求和，并用二分查找方法查找是否存在该和的相反数，如果存在，就说明存在三元组的和为 0。 该方法可以将 ThreeSum 算法增长数量级降低为 N2logN。 123456789101112131415161718public class ThreeSumFast &#123; public static int count(int[] a) &#123; Arrays.sort(a); int N = a.length; int cnt = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = i + 1; j &lt; N; j++) &#123; for (int k = j + 1; k &lt; N; k++) &#123; // rank() 方法返回元素在数组中的下标，如果元素不存在，这里会返回 -1。应该注意这里的下标必须大于 j，这样就不会重复统计了。 if (BinarySearch.rank(-a[i] - a[j], a) &gt; j) &#123; cnt++; &#125; &#125; &#125; &#125; return cnt; &#125;&#125; 4. 倍率实验如果 T(N) ~ aNblgN，那么 T(2N)/T(N) ~ 2b，例如对于暴力方法的 ThreeSum 算法，近似时间为 ~N3/6，对它进行倍率实验得到如下结果： 可见 T(2N)/T(N)~23，也就是 b 为 3。 5. 注意事项大常数 在求近似时，如果低级项的常数系数很大，那么近似的结果就是错误的。 缓存 计算机系统会使用缓存技术来组织内存，访问数组相邻的元素会比访问不相邻的元素快很多。 对最坏情况下的性能的保证 在核反应堆、心脏起搏器或者刹车控制器中的软件，最坏情况下的性能是十分重要的。 随机化算法 通过打乱输入，去除算法对输入的依赖。 均摊分析 将所有操作的总成本所以操作总数来将成本均摊。例如对一个空栈进行 N 次连续的 push() 调用需要访问数组的元素为 N+4+8+16+…+2N=5N-4（N 是向数组写入元素，其余的都是调整数组大小时进行复制需要的访问数组操作），均摊后每次操作访问数组的平均次数为常数。 排序1. 初级排序算法1.1 约定待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法。 研究排序算法的成本模型时，计算的是比较和交换的次数。 使用辅助函数 less() 和 exch() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。 123456789private boolean less(Comparable v, Comparable w)&#123; return v.compareTo(w) &lt; 0;&#125;private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t;&#125; 1.2 选择排序找到数组中的最小元素，然后将它与数组的第一个元素交换位置。然后再从剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。 123456789101112public class Selection &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 0; i &lt; N; i++) &#123; int min = i; for (int j = i + 1; j &lt; N; j++) &#123; if (less(a[j], a[min])) min = j; &#125; exch(a, i, min); &#125; &#125;&#125; 选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。 1.3 插入排序将一个元素插入到已排序的数组中，使得插入之后的数组也是有序的。插入排序从左到右插入每个元素，每次插入之后左部的子数组是有序的。 12345678910public class Insertion &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 1; i &lt; N; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) &#123; exch(a, j, j - 1); &#125; &#125; &#125;&#125; 插入排序的复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么插入排序会很快。平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换，最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是逆序的；而最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。 插入排序对于部分有序数组和小规模数组特别高效。 1.4 选择排序和插入排序的比较对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比是一个较小的常数。 1.5 希尔排序对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，如果要把元素从一端移到另一端，就需要很多次操作。 希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，使得元素更快的移到正确的位置上。 希尔排序使用插入排序对间隔 h 的序列进行排序，如果 h 很大，那么元素就能很快的移到很远的地方。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 1234567891011121314151617public class Shell &#123; public static void sort(Comparable[] a) &#123; int N = a.length; int h = 1; while (h &lt; N / 3) &#123; h = 3 * h + 1;// 1, 4, 13, 40, ... &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123; exch(a, j, j - h); &#125; &#125; h = h / 3; &#125; &#125;&#125; 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。 2 归并排序归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。 2.1 归并方法123456789101112131415161718public class MergeSort &#123; private static Comparable[] aux; private static void merge(Comparable[] a, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; // 将数据复制到辅助数组 &#125; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (aux[i].compareTo(a[j]) &lt; 0) a[k] = aux[i++]; // 先进行这一步，保证稳定性 else a[k] = aux[j++]; &#125; &#125;&#125; 2.2 自顶向下归并排序123456789101112public static void sort(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a, 0, a.length - 1);&#125;private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); sort(a, mid + 1, hi); merge(a, lo, mid, hi);&#125; 很容易看出该排序算法的时间复杂度为 O(NlgN)。 因为小数组的递归操作会过于频繁，因此使用插入排序来处理小数组将会获得更高的性能。 2.3 自底向上归并排序先归并那些微型数组，然后成对归并得到的子数组。 123456789public static void busort(Comparable[] a) &#123; int N = a.length; aux = new Comparable[N]; for (int sz = 1; sz &lt; N; sz += sz) &#123; for (int lo = 0; lo &lt; N - sz; lo += sz + sz) &#123; merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1)); &#125; &#125;&#125; 3.快速排序3.1 基本算法归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。 12345678910111213public class QuickSort &#123; public static void sort(Comparable[] a) &#123; shuffle(a); sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); &#125;&#125; 3.2 切分取 a[lo] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于等于它的元素，交换这两个元素，并不断继续这个过程，就可以保证左指针的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[lo] 和左子数组最右侧的元素 a[j] 交换然后返回 j 即可。 123456789101112private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo, j = hi + 1; Comparable v = a[lo]; while (true) &#123; while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; if (i &gt;= j) break; exch(a, i, j); &#125; exch(a, lo, j); return j;&#125; 3.3 性能分析快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。 快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，也就是复杂度为 O(NlgN)。 最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。 3.4 算法改进3.4.1 切换到插入排序因为快速排序在小数组中也会调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。 3.4.2 三取样最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。人们发现取 3 个元素并将大小居中的元素作为切分元素的效果最好。 3.4.3 三向切分对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。 三向切分快速排序对于只有若干不同主键的随机数组可以在线性时间内完成排序。 123456789101112131415public class Quick3Way &#123; public static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int lt = lo, i = lo + 1, gt = hi; Comparable v = a[lo]; while (i &lt;= gt) &#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; &#125; sort(a, lo, lt - 1); sort(a, gt + 1, hi); &#125;&#125; 4. 优先队列优先队列主要用于处理最大元素。 4.1 堆定义：一颗二叉树的每个节点都大于等于它的两个子节点。 堆可以用数组来表示，因为堆是一种完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里我们不使用数组索引为 0 的位置，是为了更清晰地理解节点的关系。 1234567891011121314151617181920212223242526public class MaxPQ&lt;Key extends Comparable&lt;Key&gt; &#123; private Key[] pq; private int N = 0; public MaxPQ(int maxN) &#123; pq = (Key[]) new Comparable[maxN + 1]; &#125; public boolean isEmpty() &#123; return N == 0; &#125; public int size() &#123; return N; &#125; private boolean less(int i, int j) &#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; private void exch(int i, int j) &#123; Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; &#125;&#125; 4.2 上浮和下沉在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作。把这种操作称为上浮。 123456private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; less(k / 2, k)) &#123; exch(k / 2, k); k = k / 2; &#125;&#125; 类似地，当一个节点比子节点来得小，也需要不断的向下比较和交换操作，把这种操作称为下沉。一个节点有两个子节点，应当与两个子节点中最大那么节点进行交换。 123456789private void sink(int k) &#123; while (2 * k &lt;= N) &#123; int j = 2 * k; if (j &lt; N &amp;&amp; less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125;&#125; 4.3 插入元素将新元素放到数组末尾，然后上浮到合适的位置。 1234public void insert(Key v) &#123; pq[++N] = v; swim(N);&#125; 4.4 删除最大元素从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。 1234567public Key delMax() &#123; Key max = pq[1]; exch(1, N--); pq[N + 1] = null; sink(1); return max;&#125; 4.5 堆排序由于堆可以很容易得到最大的元素并删除它，不断地进行这种操作可以得到一个递减序列。如果把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列。因此很容易使用堆来进行排序，并且堆排序是原地排序，不占用额外空间。 堆排序要分两个阶段，第一个阶段是把无序数组建立一个堆；第二个阶段是交换最大元素和当前堆的数组最后一个元素，并且进行下沉操作维持堆的有序状态。 无序数组建立堆最直接的方法是从左到右遍历数组，然后进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，因此可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。 12345678910public static void sort(Comparable[] a)&#123; int N = a.length; for(int k = N/2; k &gt;= 1; k--)&#123; sink(a, k, N); &#125; while(N &gt; 1)&#123; exch(a, 1, N--); sink(a, 1, N); &#125;&#125; 4.6 分析一个堆的高度为 lgN，因此在堆中插入元素和删除最大元素的复杂度都为 lgN。 对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlgN。 堆排序时一种原地排序，没有利用额外的空间。 现代操作系统很少使用堆排序，因为它无法利用缓存，也就是数组元素很少和相邻的元素进行比较。 5. 应用5.1 排序算法的比较 快速排序时最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间增长数量级为 ~cNlgN，这里的 c 比其他线性对数级别的排序算法都要小。使用三向切分之后，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。 5.2 Java 的排序算法实现Java 系统库中的主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。 5.3 基于切分的快速选择算法快速排序的 partition() 方法，会将数组的 a[lo] 至 a[hi] 重新排序并返回一个整数 j 使得 a[lo..j-1] 小于等于 a[j]，且 a[j+1..hi] 大于等于 a[j]。那么如果 j=k，a[j] 就是第 k 个数。 该算法是线性级别的，因为每次正好将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。 12345678910public static Comparable select(Comparable[] a, int k) &#123; int lo = 0, hi = a.length - 1; while (hi &gt; lo) &#123; int j = partion(a, lo, hi); if (j == k) return a[k]; else if (j &gt; k) hi = j - 1; else lo = j + 1; &#125; return a[k];&#125; 查找本章使用三种经典的数据类型来实现高效的符号表：二叉查找树、红黑树和散列表。 1. 符号表1.1 无序符号表 1.2 有序符号表 有序符号表的键需要实现 Comparable 接口。 查找的成本模型：键的比较次数，在不进行比较时使用数组的访问次数。 1.3 二分查找实现有序符号表使用一对平行数组，一个存储键一个存储值。 需要创建一个 Key 类型的 Comparable 对象数组和一个 Value 类型的 Object 对象数组。 rank() 方法至关重要，当键在表中时，它能够知道该键的位置；当键不在表中时，它也能知道在何处插入新键。 复杂度：二分查找最多需要 lgN+1 次比较，使用二分查找实现的符号表的查找操作所需要的时间最多是对数级别的。但是插入操作需要移动数组元素，是线性级别的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Key[] keys; private Value[] values; private int N; public BinarySearchST(int capacity) &#123; keys = (Key[]) new Comparable[capacity]; values = (Value[]) new Object[capacity]; &#125; public int size() &#123; return N; &#125; public Value get(Key key) &#123; int i = rank(key); if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) &#123; return values[i]; &#125; return null; &#125; public int rank(Key key) &#123; int lo = 0, hi = N - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; int cmp = key.compareTo(keys[mid]); if (cmp == 0) return mid; else if (cmp &lt; 0) hi = mid - 1; else lo = mid + 1; &#125; return lo; &#125; public void put(Key key, Value value) &#123; int i = rank(key); if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) &#123; values[i] = value; return; &#125; for (int j = N; j &gt; i; j--) &#123; keys[j] = keys[j - 1]; values[j] = values[j - 1]; &#125; keys[i] = key; values[i] = value; N++; &#125; public Key ceiling(Key key)&#123; int i = rank(key); return keys[i]; &#125;&#125; 2. 二叉查找树二叉树 定义为一个空链接，或者是一个有左右两个链接的节点，每个链接都指向一颗子二叉树。 二叉查找树（BST）是一颗二叉树，并且每个节点的键都大于其左子树中的任意节点的键而小于右子树的任意节点的键。 二叉查找树的查找操作每次迭代都会让区间减少一半，和二分查找类似。 1234567891011121314151617181920212223242526public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; private class Node &#123; private Key key; private Value val; private Node left, right; // 以该节点为根的子树中节点总数 private int N; public Node(Key key, Value val, int N) &#123; this.key = key; this.val = val; this.N = N; &#125; &#125; public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) return 0; return x.N; &#125;&#125; 2.1 get()如果树是空的，则查找未命中；如果被查找的键和根节点的键相等，查找命中，否则递归地在子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找。 12345678910public Value get(Key key) &#123; return get(root, key);&#125;private Value get(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x.val; else if (cmp &lt; 0) return get(x.left, key); else return get(x.right, key);&#125; 2.2 put()当插入的键不存在于树中，需要创建一个新节点，并且更新上层节点的链接使得该节点正确链接到树中。 123456789101112public void put(Key key, Value val) &#123; root = put(root, key, val);&#125;private Node put(Node x, Key key, Value val) &#123; if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); if (cmp == 0) x.val = val; else if (cmp &lt; 0) x.left = put(x.left, key, val); else x.right = put(x.right, key, val); x.N = size(x.left) + size(x.right) + 1; return x;&#125; 2.3 分析二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。最好的情况下树是完全平衡的，每条空链接和根节点的距离都为 lgN。在最坏的情况下，树的高度为 N。 复杂度：查找和插入操作都为对数级别。 2.4 floor()如果 key 小于根节点的 key，那么小于等于 key 的最大键节点一定在左子树中；如果 key 大于根节点的 key，只有当根节点右子树中存在小于等于 key 的节点，小于等于 key 的最大键节点才在右子树中，否则根节点就是小于等于 key 的最大键节点。 1234567891011121314151617public Key floor(Key key) &#123; Node x = floor(root, key); if (x == null) return null; return x.key;&#125;private Node floor(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp &lt; 0) return floor(x.left, key); Node t = floor(x.right, key); if (t != null) &#123; return t; &#125; else &#123; return x; &#125;&#125; 2.5 rank()12345678910public int rank(Key key) &#123; return rank(key, root);&#125;private int rank(Key key, Node x) &#123; if (x == null) return 0; int cmp = key.compareTo(x.key); if (cmp == 0) return size(x.left); else if (cmp &lt; 0) return rank(key, x.left); else return 1 + size(x.left) + rank(key, x.right);&#125; 2.6 min()1234private Node min(Node x) &#123; if (x.left == null) return x; return min(x.left);&#125; 2.7 deleteMin()令指向最小节点的链接指向最小节点的右子树。 123456789public void deleteMin() &#123; root = deleteMin(root);&#125;public Node deleteMin(Node x) &#123; if (x.left == null) return x.right; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1; return x;&#125; 2.8 delete()如果待删除的节点只有一个子树，那么只需要让指向待删除节点的链接指向唯一的子树即可；否则，让右子树的最小节点替换该节点。 12345678910111213141516171819public void delete(Key key) &#123; root = delete(root, key);&#125;private Node delete(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = delete(x.left, key); else if (cmp &gt; 0) x.right = delete(x.right, key); else &#123; if (x.right == null) return x.left; if (x.left == null) return x.right; Node t = x; x = min(t.right); x.right = deleteMin(t.right); x.left = t.left; &#125; x.N = size(x.left) + size(x.right) + 1; return x;&#125; 2.9 keys()利用二叉查找树中序遍历的结果为有序序列的特点。 12345678910111213public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123; Queue&lt;Key&gt; queue = new LinkedList&lt;&gt;(); keys(root, queue, lo, hi); return queue;&#125;private void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) &#123; if (x == null) return; int cmpLo = lo.compareTo(x.key); int cmpHi = hi.compareTo(x.key); if (cmpLo &lt; 0) keys(x.left, queue, lo, hi); if (cmpLo &lt;= 0 &amp;&amp; cmpHi &gt;= 0) queue.add(x.key); if (cmpHi &gt; 0) keys(x.right, queue, lo, hi);&#125; 2.10 性能分析复杂度：二叉查找树所有操作在最坏的情况下所需要的时间都和树的高度成正比。 3. 平衡查找树3.1 2-3 查找树 一颗完美平衡的 2-3 查找树的所有空链接到根节点的距离应该是相同的。 3.1.1 插入操作当插入之后产生一个临时 4- 节点时，需要将 4- 节点分裂成 3 个 2- 节点，并将中间的 2- 节点移到上层节点中。如果上移操作继续产生临时 4- 节点则一直进行分裂上移，直到不存在临时 4- 节点。 3.1.2 性质2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。 2-3 查找树的查找和插入操作复杂度和插入顺序 无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。 3.2 红黑二叉查找树2-3 查找树需要用到 2- 节点和 3- 节点，红黑树使用红链接来实现 3- 节点。指向一个节点的链接颜色如果为红色，那么这个节点和上层节点表示的是一个 3- 节点，而黑色则是普通链接。 红黑树具有以下性质： 红链接都为左链接； 完美黑色平衡，即任意空链接到根节点的路径上的黑链接数量相同。 画红黑树时可以将红链接画平。 12345678910111213141516171819202122232425public class RedBlackBST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; private static final boolean RED = true; private static final boolean BLACK = false; private class Node &#123; Key key; Value val; Node left, right; int N; boolean color; Node(Key key, Value val, int n, boolean color) &#123; this.key = key; this.val = val; N = n; this.color = color; &#125; &#125; private boolean isRed(Node x) &#123; if (x == null) return false; return x.color == RED; &#125;&#125; 3.2.1 左旋转因为合法的红链接都为左链接，如果出现右链接为红链接，那么就需要进行左旋转操作。 12345678910public Node rotateLeft(Node h) &#123; Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = 1 + size(h.left) + size(h.right); return x;&#125; 3.2.2 右旋转进行右旋转是为了转换两个连续的左红链接，这会在之后的插入过程中探讨。 123456789public Node rotateRight(Node h) &#123; Node x = h.left; h.left = x.right; x.color = h.color; h.color = RED; x.N = h.N; h.N = 1 + size(h.left) + size(h.right); return x;&#125; 3.2.3 颜色转换一个 4- 节点在红黑树中表现为一个节点的左右子节点都是红色的。分裂 4- 节点除了需要将子节点的颜色由红变黑之外，同时需要将父节点的颜色由黑变红，从 2-3 树的角度看就是将中间节点移到上层节点。 12345void flipColors(Node h)&#123; h.color = RED; h.left.color = BLACK; h.right.color = BLACK;&#125; 3.2.4 插入先将一个节点按二叉查找树的方法插入到正确位置，然后再进行如下颜色操作： 如果右子节点是红色的而左子节点是黑色的，进行左旋转； 如果左子节点是红色的且它的左子节点也是红色的，进行右旋转； 如果左右子节点均为红色的，进行颜色转换。 12345678910111213141516171819public void put(Key key, Value val) &#123; root = put(root, key, val); root.color = BLACK;&#125;private Node put(Node x, Key key, Value val) &#123; if (x == null) return new Node(key, val, 1, RED); int cmp = key.compareTo(x.key); if (cmp == 0) x.val = val; else if (cmp &lt; 0) x.left = put(x.left, key, val); else x.right = put(x.right, key, val); if (isRed(x.right) &amp;&amp; !isRed(x.left)) x = rotateLeft(x); if (isRed(x.left) &amp;&amp; isRed(x.left.left)) x = rotateRight(x); if (isRed(x.left) &amp;&amp; isRed(x.right)) flipColors(x); x.N = size(x.left) + size(x.right) + 1; return x;&#125; 可以看到该插入操作和 BST 的插入操作类似，只是在最后加入了旋转和颜色变换操作即可。 根节点一定为黑色，因为根节点没有上层节点，也就没有上层节点的左链接指向根节点。flipColors() 有可能会使得根节点的颜色变为红色，每当根节点由红色变成黑色时树的黑链接高度加 1. 3.2.5 删除最小键如果最小键在一个 2- 节点中，那么删除该键会留下一个空链接，就破坏了平衡性，因此要确保最小键不在 2- 节点中。将 2- 节点转换成 3- 节点或者 4- 节点有两种方法，一种是向上层节点拿一个 key，一种是向兄弟节点拿一个 key。如果上层节点是 2- 节点，那么就没办法从上层节点拿 key 了，因此要保证删除路径上的所有节点都不是 2- 节点。在向下删除的过程中，保证以下情况之一发生： 如果当前节点的左子节点不是 2- 节点，完成； 如果当前节点的左子节点是 2- 节点而它的兄弟节点不是 2- 节点，向兄弟节点拿一个 key 过来； 如果当前节点的左子节点和它的兄弟节点都是 2- 节点，将左子节点、父节点中的最小键和最近的兄弟节点合并为一个 4- 节点。 最后得到一个含有最小键的 3- 节点或者 4- 节点，直接从中删除。然后再从头分解所有临时的 4- 节点。 3.2.6 分析一颗大小为 N 的红黑树的高度不会超过 2lgN。最坏的情况下是它所对应的 2-3 树中构成最左边的路径节点全部都是 3- 节点而其余都是 2- 节点。 红黑树大多数的操作所需要的时间都是对数级别的。 4. 散列表散列表类似于数组，可以把散列表的散列值看成数组的索引值。访问散列表和访问数组元素一样快速，它可以在常数时间内实现查找和插入的符号表。 由于无法通过散列值知道键的大小关系，因此散列表无法实现有序性操作。 4.1 散列函数对于一个大小为 M 的散列表，散列函数能够把任意键转换为 [0, M-1] 内的正整数，该正整数即为 hash 值。 散列表有冲突的存在，也就是两个不同的键可能有相同的 hash 值。 散列函数应该满足以下三个条件： 一致性：相等的键应当有相等的 hash 值。 高效性：计算应当简便，有必要的话可以把 hash 值缓存起来，在调用 hash 函数时直接返回。 均匀性：所有键的 hash 值应当均匀地分布到 [0, M-1] 之间，这个条件至关重要，直接影响到散列表的性能。 除留余数法可以将整数散列到 [0, M-1] 之间，例如一个正整数 k，计算 k%M 既可得到一个 [0, M-1] 之间的 hash 值。注意 M 必须是一个素数，否则无法利用键包含的所有信息。例如 M 为 10k，那么只能利用键的后 k 位。 对于其它数，可以将其转换成整数的形式，然后利用除留余数法。例如对于浮点数，可以将其表示成二进制形式，然后使用二进制形式的整数值进行除留余数法。 对于有多部分组合的键，每部分都需要计算 hash 值，并且最后合并时需要让每部分 hash 值都具有同等重要的地位。可以将该键看成 R 进制的整数，键中每部分都具有不同的权值。 例如，字符串的散列函数实现如下 123int hash = 0;for(int i = 0; i &lt; s.length(); i++) hash = (R * hash + s.charAt(i)) % M; 再比如，拥有多个成员的自定义类的哈希函数如下 1int hash = (((day * R + month) % M) * R + year) % M; R 的值不是很重要，通常取 31。 Java 中的 hashCode() 实现了 hash 函数，但是默认使用对象的内存地址值。在使用 hashCode() 函数时，应当结合除留余数法来使用。因为内存地址是 32 位整数，我们只需要 31 位的非负整数，因此应当屏蔽符号位之后再使用除留余数法。 1int hash = (x.hashCode() &amp; 0x7fffffff) % M; 使用 Java 自带的 HashMap 等自带的哈希表实现时，只需要去实现 Key 类型的 hashCode() 函数即可。Java 规定 hashCode() 能够将键均匀分布于所有的 32 位整数，Java 中的 String、Integer 等对象的 hashCode() 都能实现这一点。以下展示了自定义类型如何实现 hashCode()。 12345678910111213public class Transaction&#123; private final String who; private final Date when; private final double amount; public int hashCode()&#123; int hash = 17; hash = 31 * hash + who.hashCode(); hash = 31 * hash + when.hashCode(); hash = 31 * hash + ((Double) amount).hashCode(); return hash; &#125;&#125; 4.2 基于拉链法的散列表拉链法使用链表来存储 hash 值相同的键，从而解决冲突。此时查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。 对于 N 个键，M 条链表 (N&gt;M)，如果哈希函数能够满足均匀性的条件，每条链表的大小趋向于 N/M，因此未命中的查找和插入操作所需要的比较次数为 ~N/M。 4.3 基于线性探测法的散列表线性探测法使用空位来解决冲突，当冲突发生时，向前探测一个空位来存储冲突的键。使用线程探测法，数组的大小 M 应当大于键的个数 N（M&gt;N)。 123456789101112131415161718192021222324public class LinearProbingHashST&lt;Key, Value&gt; &#123; private int N; private int M = 16; private Key[] keys; private Value[] vals; public LinearProbingHashST() &#123; init(); &#125; public LinearProbingHashST(int M) &#123; this.M = M; init(); &#125; private void init() &#123; keys = (Key[]) new Object[M]; vals = (Value[]) new Object[M]; &#125; private int hash(Key key) &#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125;&#125; 4.3.1 查找12345678public Value get(Key key) &#123; for (int i = hash(key); keys[i] != null; i = (i + 1) % M) &#123; if (keys[i].equals(key)) &#123; return vals[i]; &#125; &#125; return null;&#125; 4.3.2 插入12345678910111213public void put(Key key, Value val) &#123; int i; for (i = hash(key); keys[i] != null; i = (i + 1) % M) &#123; if (keys[i].equals(key)) &#123; vals[i] = val; return; &#125; &#125; keys[i] = key; vals[i] = val; N++; resize();&#125; 4.3.3 删除删除操作应当将右侧所有相邻的键值重新插入散列表中。 123456789101112131415161718192021public void delete(Key key) &#123; if (!contains(key)) return; int i = hash(key); while (!key.equals(keys[i])) &#123; i = (i + 1) % M; &#125; keys[i] = null; vals[i] = null; i = (i + 1) % M; while (keys[i] != null) &#123; Key keyToRedo = keys[i]; Value valToRedo = vals[i]; keys[i] = null; vals[i] = null; N--; put(keyToRedo, valToRedo); i = (i + 1) % M; &#125; N--; resize();&#125; 4.3.4 调整数组大小线性探测法的成本取决于连续条目的长度，连续条目也叫聚簇。当聚簇很长时，在查找和插入时也需要进行很多次探测。 α = N/M，把 α 称为利用率。理论证明，当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。 为了保证散列表的性能，应当调整数组的大小，使得 α 在 [1/4, 1/2] 之间。 12345678910111213141516private void resize() &#123; if (N &gt;= M / 2) resize(2 * M); else if (N &lt;= M / 8) resize(M / 2);&#125;private void resize(int cap) &#123; LinearProbingHashST&lt;Key, Value&gt; t = new LinearProbingHashST&lt;&gt;(cap); for (int i = 0; i &lt; M; i++) &#123; if (keys[i] != null) &#123; t.put(keys[i], vals[i]); &#125; &#125; keys = t.keys; vals = t.vals; M = t.M;&#125; 虽然每次重新调整数组都需要重新把每个键值对插入到散列表，但是从摊还分析的角度来看，所需要的代价却是很小的。从下图可以看出，每次数组长度加倍后，累计平均值都会增加 1，因为表中每个键都需要重新计算散列值，但是随后平均值会下降。 5. 应用5.1 各种符号表实现的比较 应当优先考虑散列表，当需要有序性操作时使用红黑树。 5.2 Java 的符号表实现Java 的 java.util.TreeMap 和 java.util.HashMap 分别是基于红黑树和拉链法的散列表的符号表实现。 5.3 集合类型除了符号表，集合类型也经常使用，它只有键没有值，可以用集合类型来存储一系列的键然后判断一个键是否在集合中。 5.4 稀疏向量乘法当向量为稀疏向量时，可以使用符号表来存储向量中的非 0 索引和值，使得乘法运算只需要对那些非 0 元素进行即可。 1234567891011121314151617181920212223242526import java.util.HashMap;public class SparseVector &#123; private HashMap&lt;Integer, Double&gt; hashMap; public SparseVector(double[] vector) &#123; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; vector.length; i++) &#123; if (vector[i] != 0) &#123; hashMap.put(i, vector[i]); &#125; &#125; &#125; public double get(int i) &#123; return hashMap.getOrDefault(i, 0.0); &#125; public double dot(SparseVector other) &#123; double sum = 0; for (int i : hashMap.keySet()) &#123; sum += this.get(i) * other.get(i); &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java成神之路-Tomcat、Jsp/servlet、Ajax（八）]]></title>
    <url>%2Fblog%2F56228.html</url>
    <content type="text"><![CDATA[Java成神之路-Tomcat、Jsp/servlet、Ajax tomcat服务tomcat的内存设置Tomcat的启动分为startupo.bat启动和注册为windows服务的启动，下面一一说明。 startup.bat启动在tomcat_home/bin目录下找到catalina.bat，用文本编辑器打开，加上下面一行： 1set JAVA_OPTS= -Xms1024M -Xmx1024M -XX:PermSize=256M -XX:MaxNewSize=256M -XX:MaxPermSize=256M 解释一下各个参数： -Xms1024M：初始化堆内存大小（注意，不加M的话单位是KB） -Xmx1029M：最大堆内存大小 -XX:PermSize=256M：初始化类加载内存池大小 -XX:MaxPermSize=256M：最大类加载内存池大小 -XX:MaxNewSize=256M：这个还不清楚哈，有知道的说声 还有一个-server参数，是指启动jvm时以服务器方式启动，比客户端启动慢，但性能较好，大家可以自己选择。 windows服务启动​ 如果你的tomcat是注册为windows服务并且是以服务方式启动的，那么上面的方法就无效了，因为这时tomcat启动是读取注册表的参数，而不是读取批处理文件的参数，这时我们有两种方法来设置jvm参数。 第一种比较简单，tomcat为我们提供了一个设置启动参数的窗体，双击tomcat_home/bin目录下的tomcat6w.exe，如图 下方的Initial memory pool就是初始化堆内存大小，Maximun memory pool是最大堆内存大小。 而要设置Perm Gen池的大小就要在Java Option里面加参数了，在里面加上： -Dcatalina.base=%tomcat_home% -Dcatalina.home=%tomcat_home% -Djava.endorsed.dirs=%tomcat_home%\endorsed -Djava.io.tmpdir=%tomcat_home%\temp -XX:PermSize=256M -XX:MaxPermSize=256M -XX:ReservedCodeCacheSize=48M -Duser.timezone=GMT+08 （PS：网上说每一行后面不要有空格，没试过） 第二种方法是打开注册表-&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\Procrun 2.0\Tomcat6\Parameters\Java(路径可能有一点点差别) 修改Options的值，把刚才上面那些参数加进去就OK了。（别忘了先备份一下注册表） 修改tomcat端口默认情况下tomcat的端口是8080，如果出现8080端口号冲突，用如下方法可以修改Tomcat的端口号： 在C:/Tomcat/conf/Server.xml文件中找到如下文本： 123&lt;Connector port="8080" protocol="HTTP/1.1" maxThreads="150" connectionTimeout="20000" redirectPort="8443" /&gt; 也有可能是这样的： 1&lt;Connector port="8080" maxThreads="150" minSpareThreads="25" maxSpareThreads="75" enableLookups="false" redirectPort="8443" acceptCount="100" debug="0" connectionTimeout="20000" disableUploadTimeout="true" /&gt; 等等； 最后：将port=”8080”改为如port=”8081”等，保存server.xml，重启Tomcat，Tomcat就可以使用8081端口。 使用两个tomcat修改了上面的以后，还要修改两处： 将 12&lt;Connector port="8009" enableLookups="false" redirectPort="8443" debug="0"protocol="AJP/1.3" /&gt; 的8009改为其它的端口。 将 1&lt;Server port="8005" shutdown="SHUTDOWN" debug="0"&gt; 的8005改为其它的端口。修改以上三处。 tomcat改名 找到tomcat下面的这个文件：tomcat_home\bin\catalina.bat 搜索到： 12345:doStart shift if not "%OS%" == "Windows_NT" goto noTitle set EXECJAVA=start "Tomcat" %RUNJAVA% goto gotTitle 将”Tomcat”修改成想替换的名称即可 在tomcat6.0.29以后的版本则如下： 123456:doStart shift if not "%OS%" == "Windows_NT" goto noTitle if "%TITLE%" == "" set TITLE=Tomcat set _EXECJAVA=start "%TITLE%" %_RUNJAVA% goto gotTitle 同理将 1if &quot;%TITLE%&quot; == &quot;&quot; set TITLE=Tomcat 改为： 1if &quot;%TITLE%&quot; == &quot;&quot; set TITLE=你的应用服务名 ServletServlet 生命周期Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 现在让我们详细讨论生命周期的方法。 init() 方法init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。 Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。 当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。 init 方法的定义如下： 123public void init() throws ServletException &#123; // 初始化代码...&#125; service() 方法service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。 下面是该方法的特征： 1234public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException&#123;&#125; service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。 doGet() 方法GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。 12345public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码&#125; doPost() 方法POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。 12345public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码&#125; destroy() 方法destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示： 123public void destroy() &#123; // 终止化代码...&#125; 架构图Servlet 生命周期方案。 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。 Servlet 容器在调用 service() 方法之前加载 Servlet。 然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。 destory 方法被调用后，servlet 被销毁，但是并没有立即被回收，再次请求时，并没有重新初始化。 代码示例 12345678910111213141516171819202122232425262728private String message;@Overridepublic void init() throws ServletException &#123; message = "Hello World , Nect To Meet You: " + System.currentTimeMillis(); System.out.println("servlet初始化……"); super.init();&#125;@Overridepublic void doGet(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter writer = response.getWriter(); writer.write("&lt;h1&gt;" + message + "&lt;/h1&gt;"); destroy();&#125;@Overridepublic void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub super.doPost(req, resp);&#125;@Overridepublic void destroy() &#123; System.out.println("servlet销毁！"); super.destroy();&#125; 控制台打印： 123456789101112131415servlet初始化……servlet销毁！2017-7-6 19:48:52 org.apache.catalina.core.StandardContext reload信息: Reloading Context with name [/myServlet] has startedservlet销毁！2017-7-6 19:48:52 org.apache.catalina.core.StandardContext reload信息: Reloading Context with name [/myServlet] is completedservlet初始化……servlet销毁！servlet销毁！servlet销毁！servlet销毁！servlet销毁！servlet销毁！servlet销毁！ Servlet常用类和接口接口：Servlet、ServletConfig、ServletRequest、ServletResponse、HttpServletRequest、HttpServletResponse、ServletContext 类：HttpServlet(抽象类)、GenericServlet(抽象类) 基本类和接口 javax.servlet.Servlet接口servlet抽象集是javax.servlet.Servlet接口，它规定了必须由Servlet类实现由servlet引擎识别和管理的方法集。Servlet接口的基本目标是提供生命期方法init()、service()和destroy()方法。 servlet接口中的方法 void init(ServletConfit config)throws ServletException 在servlet被载入后和实施服务前由servlet引擎进行?次性调用。如果init()产生溢出UnavailableException，则 servle退出服务。 ServletConfig getServletConfig() 返回传递到servlet的init()方法的ServletConfig对象 void service(ServletRequest request, ServletResponse response)throws ServletException,IOException 处理request对象中描述的请求，使用response对象返回请求结果 String getServletInfo() 返回描述servlet的一个字符串 void destory() 当servlet将要卸载时由servlet引擎调用 javax.servlet.GenericServlet类（协议无关版本）GenericServlet是一种与协议无关的servlet，是一种跟本不对请求提供服务的servlet，而是简单地从init()方法启动后台线程并在destory()中杀死。它可以用于模拟操作系统的端口监控进程。servlet API提供了Servlet接口的直接实现，称为GenericServlet。此类提供除了service()方法外所有接口中方法的缺省实现。这意味着通过简单地扩展GenericServlte可以编写一个基本的servlet。除了Servlet接口外，GenericServlet也实现了ServletConfig接口，处理初始化参数和servlet上下文，提供对授权传递到init()方法中的ServletConfig对象的方法。 GenericServlet类中的方法 void destory() 编飞组成单词“destory”的一个注册入口 String getInitParameter(String name) 返回具有指定名称的初始化参数值。通过凋用config.getInitParameter(name)实现。 Enumeration getInitParameterNames() 返回此serv]et已编码的所有初始化参数的?个枚举类型值。调用config.getInitParameterNames()获得列表。如果未提供初始化参数，则返回?个空的枚举类型值（但不是null） ServletConfig getServletConfig() 返回传递到init()方法的ServletConfig对象 ServletContext getServletContext() 返回在config对象中引用的ServletContext String getServletInfo() 返回空字符串 void init(ServletConfig config)throws ServletException 在一实例变量中保存config对象。编写组成单词“init”的注册入口,然后调用方法init() void init()throws ServletException 可以被跳过以处理servlet初始化.在config对象被保存后init(ServletConfig config)的结尾处自动被调用.servlet作者经常会忘记调用super.init(config) void log(String msg) 编写注册servlet的入口.为此调用servlet上下文的log()方法.servlet的名字被加到消息文本的开头。 void log(String msg,Throwable t) 编写一个入口和servlet注册的栈轨迹。此方法也是ServletContext中相应方法的一个副本。 abstract void service(Request request,Response response)throws ServletException,IOException 由servlet引擎调用为请求对象描述的请求提供服务。这是GenericServlet中唯一的抽象方法。因此它也是唯一必须被子类所覆盖的方法。 String getServletName() 返回在Web应用发布描述器（web.xml）中指定的servlet的名字。 javax.servlet.http.HttpServlet类（HTTP版本）虽然servlet API允许扩展到其它协议，但最终所有的servlet均在Web环境下实施操作，只有几种servlet直接扩展了GenericServlet。对servlet更一般的是扩展其HTTP子类HttpServlet。HttpServlet 类通过调用指定到HTTP请求方法的方法实现service()，亦即对DELETE、HEAD、GET、OPTIONS、POST、PUT和 TRACE，分别调用doDelete()、doHead()、doGet()、doOptions()、doPost()、doPut()和 doTrace()方法，将请求和响应对象置入其HTTP指定子类。 HttpServlet类中的方法 Void doGet(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException 由servlet引擎调用用处理一个HTTP GET请求。输入参数、HTTP头标和输入流可从request对象、response头标和response对象的输出流中获得。 Void doPost(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException 由servlet引擎调用用处理一个HTTP POST请求。输入参数、HTTP头标和输入流可从request对象、response头标和response对象的输出流中获得。 Void doPut(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException 由servlet引擎调用用处理一个HTTP PUT请求。本方法中请求URI指出被载入的文件位置。 Void doDelete(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException 由servlet引擎调用用处理一个HTTP DELETE请求。请求URI指出资源被删除。 Void doOptions(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException 由servlet引擎调用用处理一个HTTP OPTIONS请求。返回一个Allow响应头标表明此servlet支持的HTTP方法。一个servlet不需要覆盖此方法，因为 HttpServlet方法已经实现规范所需的功能。 Void doTrace(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException 由servlet引擎调用用处理一个HTTP TRACE请求。使得请求头标被反馈成响应关标。一个servlet不需要覆盖此方法，因为HttpServlet方法已经实现HTTP规范所需的功能。 Void service(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException Service(Request request,Response response)调用的一个立即方法，带有指定HTTP请求和响应。此方法实际上将请求导向doGet()、doPost()等等。不应该覆盖此方法。 Void service(Request request,Response response)throws ServletException,IOException 将请求和响应对象置入其指定的HTTP子类，并调用指定HTTP的service()方法。 javax.servlet.ServletRequest类（协议无关版本）ServletRequest接口封装了客户端请求的细节。它与协议无关，并有一个指定HTTP的子接口。 ServletRequest主要处理： 找到客户端的主机名和IP地址 检索请求参数 取得和设置属性 取得输入和输出流 ServletRequest类中的方法 Object getAttribute(String name) 返回具有指定名字的请求属性，如果不存在则返回null。属性可由servlet引擎设置或使用setAttribute()显式加入。 Enumeration getAttributeName() 返回请求中所有属性名的枚举。如果不存在属性，则返回一个空的枚举。 String getCharacteEncoding() 返回请求所用的字符编码。 Int getContentLength() 指定输入流的长度，如果未知则返回-1。 ServletInputStream getInputStream()throws IOException 返回与请求相关的（二进制）输入流。可以调用getInputStream()或getReader()方法之一。 String getParameter(String name) 返回指定输入参数，如果不存在，返回null。 Enumeration getParameterName() 返回请求中所有参数名的一个可能为空的枚举。 String[] getParameterValues(String name) 返回指定输入参数名的取值数组，如果取值不存在则返回null。它在参数具有多个取值的情况下十分有用。 String get Protocol() 返回请求使用协议的名称和版本。 String getScheme() 返回请求URI的子串，但不包含第一个冒号前的内容。 String getServerName() 返回处理请求的服务器的主机名。 String getServerPort() 返回接收主机正在侦听的端口号。 BufferedReader getReader()throws IOException 返回与请求相关输入数据的一个字符解读器。此方法与getInputStream()只可分别调用，不能同时使用。 String getRemoteAddr() 返回客户端主机的数字型IP地址。 String getRemoteHost() 如果知道，返回客户端主机名。 void setAttribute(String name,Object obj) 以指定名称保存请求中指定对象的引用。 void removeAttribute(String name) 从请求中删除指定属性 Locale getLocale() 如果已知，返回客户端的第一现场或者为null。 Enumeration getLocales() 如果已知，返回客户端的第一现场的一个枚举，否则返回服务器第一现场。 boolean isSecure() 如果请求使用了如HTTPS安全隧道，返回true RequestDispatcher getRequestDispatcher(String name) 返回指定源名称的RequsetDispatcher对象。 javax.servlet.http.HttpServletRequest接口（HTTP版本）HttpServletRequest类主要处理：1.读取和写入HTTP头标 取得和设置cookies 取得路径信息 标识HTTP会话 HttpServletRequest接口中的方法 String getAuthType() 如果servlet由一个鉴定方案所保护，如HTTP基本鉴定，则返回方案名称。 String getContextPath() 返回指定servlet上下文（web应用）的URL的前缀。 Cookie[] getCookies() 返回与请求相关cookie的一个数组。 Long getDateHeader(String name) 将输出转换成适合构建Date对象的long类型取值的getHeader()的简化版。 String getHeader(String name) 返回指定的HTTP头标指。如果其由请求给出，则名字应为大小写不敏感。 Enumeration getHeaderNames() 返回请求给出的所有HTTP头标名称的权举值。 Enumeration getHeaders(String name) 返回请求给出的指定类型的所有HTTP头标的名称的枚举值，它对具有多取值的头标非常有用。 int getIntHeader(String name) 将输出转换为int取值的getHeader()的简化版。 String getMethod() 返回HTTP请求方法（例如GET、POST等等） String getPathInfo() 返回在URL中指定的任意附加路径信息。 String getPathTranslated() 返回在URL中指定的任意附加路径信息，被子转换成一个实际路径。 String getQueryString() 返回查询字符串，即URL中?后面的部份。 String getRemoteUser() 如果用户通过鉴定，返回远程用户名，否则为null。 String getRequestedSessionId() 返回客户端的会话ID String getRequestURI() 返回URL中一部分，从“/”开始，包括上下文，但不包括任意查询字符串。 String getServletPath() 返回请求URI上下文后的子串 HttpSession getSession() 调用getSession(true)的简化版。 HttpSession getSession(boolean create) 返回当前HTTP会话，如果不存在，则创建一个新的会话，create参数为true。 Principal getPrincipal() 如果用户通过鉴定，返回代表当前用户的java.security.Principal对象，否则为null。 boolean isRequestedSessionIdFromCookie() 如果请求的会话ID由一个Cookie对象提供，则返回true，否则为false。 boolean isRequestedSessionIdFromURL() 如果请求的会话ID在请求URL中解码，返回true，否则为false boolean isRequestedSessionIdValid() 如果客户端返回的会话ID仍然有效，则返回true。 Boolean isUserInRole(String role) 如果当前已通过鉴定用户与指定角色相关，则返回true，如果不是或用户未通过鉴定，则返回false。 javax.servlet.ServletResponse接口（协议无关版本）ServletResponse对象将一个servlet生成的结果传到发出请求的客户端。ServletResponse操作主要是作为输出流及其内容类型和长度的包容器，它由servlet引擎创建. ServletResponse接口中的方法 void flushBuffer()throws IOException 发送缓存到客户端的输出内容。因为HTTP需要头标在内容前被发送，调用此方法发送状态行和响应头标，以确认请求。 int getBufferSize() 返回响应使用的缓存大小。如果缓存无效则返加0。 String getCharacterEncoding() 返回响应使用字符解码的名字。除非显式设置，否则为ISO-8859-1 Locale getLocale() 返回响应使用的现场。除非用setLocale()修改，否则缺省为服务器现场。 OutputStream getOutputStream()throws IOException 返回用于将返回的二进制输出写入客户端的流，此方法和getWrite()方法二者只能调用其一。 Writer getWriter()throws IOException 返回用于将返回的文本输出写入客户端的一个字符写入器，此方法和getOutputStream()二者只能调用其一。 boolean isCommitted() 如果状态和响应头标已经被发回客户端，则返回true，在响应被确认后发送响应头标毫无作用。 void reset() 清除输出缓存及任何响应头标。如果响应已得到确认，则引发事件IllegalStateException。 void setBufferSize(int nBytes) 设置响应的最小缓存大小。实际缓存大小可以更大，可以通过调用getBufferSize()得到。如果输出已被写入，则产生IllegalStateException。 void setContentLength(int length) 设置内容体的长度。 void setContentType(String type) 设置内容类型。在HTTP servlet中即设置Content-Type头标。 void setLocale(Locale locale) 设置响应使用的现场。在HTTP servlet中，将对Content-Type头标取值产生影响。 javax.servlet.http.HttpServletResponse接口（HTTP版本）HttpServletResponse加入表示状态码、状态信息和响应头标的方法，它还负责对URL中写入一Web页面的HTTP会话ID进行解码。 HttpServletResponse接口中的方法 void addCookie(Cookie cookie) 将一个Set-Cookie头标加入到响应。 void addDateHeader(String name,long date) 使用指定日期值加入带有指定名字（或代换所有此名字头标）的响应头标的方法。 void setHeader(String name,String value) 设置具有指定名字和取值的一个响应头标。 void addIntHeader(String name,int value) 使用指定整型值加入带有指定名字的响应头标（或代换此名字的所有头标）。 boolean containsHeader(String name) 如果响应已包含此名字的头标，则返回true。 String encodeRedirectURL(String url) 如果客户端不知道接受cookid，则向URL加入会话ID。第一种形式只对在sendRedirect()中使用的URL进行调用。其他被编码的 URLs应被传递到encodeURL() String encodeURL(String url) void sendError(int status) 设置响应状态码为指定值（可选的状态信息）。HttpServleetResponse定义了一个完整的整数常量集合表示有效状态值。 void sendError(int status,String msg) void setStatus(int status) 设置响应状态码为指定指。只应用于不产生错误的响应，而错误响应使用sendError()。 javax.servlet.ServletContext接口一个servlet上下文是servlet引擎提供用来服务于Web应用的接口。Servlet上下文具有名字（它属于Web应用的名字）唯一映射到文件系统的一个目录。一个servlet可以通过ServletConfig对象的getServletContext()方法得到servlet上下文的引用，如果servlet直接或间接调用子类GenericServlet，则可以使用getServletContext()方法。 Web应用中servlet可以使用servlet上下文得到： 在调用期间保存和检索属性的功能，并与其他servlet共享这些属性。 读取Web应用中文件内容和其他静态资源的功能。 互相发送请求的方式。 记录错误和信息化消息的功能。 ServletContext接口中的方法 Object getAttribute(String name) 返回servlet上下文中具有指定名字的对象，或使用已指定名捆绑一个对象。从Web应用的标准观点看，这样的对象是全局对象，因为它们可以被同一 servlet在另一时刻访问。或上下文中任意其他servlet访问。 void setAttribute(String name,Object obj) 设置servlet上下文中具有指定名字的对象。 Enumeration getAttributeNames() 返回保存在servlet上下文中所有属性名字的枚举。 ServletContext getContext(String uripath) 返回映射到另一URL的servlet上下文。在同一服务器中URL必须是以“/”开头的绝对路径。 String getInitParameter(String name) 返回指定上下文范围的初始化参数值。此方法与ServletConfig方法名称不一样，后者只应用于已编码的指定servlet。此方法应用于上下文中所有的参数。 Enumeration getInitParameterNames() 返回（可能为空）指定上下文范围的初始化参数值名字的枚举值。 int getMajorVersion() 返回此上下文中支持servlet API级别的最大和最小版本号。 int getMinorVersion() String getMimeType(String fileName) 返回指定文件名的MIME类型。典型情况是基于文件扩展名，而不是文件本身的内容（它可以不必存在）。如果MIME类型未知，可以返回null。 RequestDispatcher getNameDispatcher(String name) 返回具有指定名字或路径的servlet或JSP的RequestDispatcher。如果不能创建RequestDispatch，返回null。如果指定路径，必须心“/”开头，并且是相对于servlet上下文的顶部。 RequestDispatcher getNameDispatcher(String path) String getRealPath(String path) 给定一个URI，返回文件系统中URI对应的绝对路径。如果不能进行映射，返回null。 URL getResource(String path) 返回相对于servlet上下文或读取URL的输入流的指定绝对路径相对应的URL，如果资源不存在则返回null。 InputStream getResourceAsStream(String path) String getServerInfo() 返顺servlet引擎的名称和版本号。 void log(String message) void log(String message,Throwable t) 将一个消息写入servlet注册，如果给出Throwable参数，则包含栈轨迹。 void removeAttribute(String name) 从servlet上下文中删除指定属性。 javax.servlet.http.HttpSession接口HttpSession类似于哈希表的接口，它提供了setAttribute ()和getAttribute()方法存储和检索对象。HttpSession提供了一个会话ID关键字，一个参与会话行为的客户端在同一会话的请求中存储和返回它。servlet引擎查找适当的会话对象，并使之对当前请求可用。 HttpSession接口中的方法 Object getAttribute(String name) 将会话中一个对象保存为指定名字，返回或删除前面保存的此名称对象。 void setAttribute(String name,Object value) void removeAttribute(String name) Enumeration getAttributeName() 返回捆绑到当前会话的所有属性名的枚举值。 long getCreationTime() 返回表示会话创建和最后访问日期和时间的一个长整型，该整型形式为java.util.Date()构造器中使用的形式。 long getLastAccessedTime() String getId() 返回会话ID，servlet引擎设置的一个唯一关键字。 ing getMaxInactiveInterval() 如果没有与客户端发生交互，设置和返回会话存活的最大秒数。 void setMasInactiveInterval(int seconds) void invalidate() 使得会话被终止，释放其中任意对象。 boolean isNew() 如果客户端仍未加入到会话，返回true。当会话首次被创建，会话ID被传入客户端，但客户端仍未进行包含此会话ID的第二次请示时，返回true。 Servlet的两种配置方式在Servlet2.5规范之前，通过web.xml文件来配置管理 Servlet3.0规范可通过Annotation来配置管理Web组件 通过web.xml配置 123456789&lt;span style="white-space:pre"&gt; &lt;/span&gt;&lt;servlet&gt; &lt;servlet-name&gt;GetApplication&lt;/servlet-name&gt; &lt;servlet-class&gt;com.fpp.GetApplication&lt;/servlet-class&gt; &lt;!-- 通过servletConfig getInitParameter()取出参数 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;GetApplication&lt;/servlet-name&gt; &lt;url-pattern&gt;/GetApplication&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 使用@WebServlet Annotation进行配置 12@WebServlet(name="GetApplication",urlPatterns="/GetApplication") public class GetApplication extends HttpServlet @WebServlet支持的常用属性：displayName,initParams,loadOnStartup,name,urlPatterns/value,asyncSupported 如果打算使用Annotation来配置Servlet，需要注意以下几点： 不要在web.xml文件的根元素（）中指定metadata-complete=“true”； 不要在web.xml文件中配置该Servlet; 配置中各节点的含义123456789101112131415&lt;!-- 配置一个servlet --&gt;&lt;!-- servlet的配置 --&gt;&lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;lm.practice.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 可以看到，在配置Servlet时，有两个地方需要配置，一个是,另一个是，这两个一个是配置Servlet，一个是配置其映射信息，其中中的可以随意指定，但要有一定的意义，一般取为类的名称，例如我的类名为ServletDemo，这里取名为ServletDemo,下面的是类的全路径，package+calssname，一定要是全路径！ 是映射信息，它也有一个，里面的名字是对应的Servlet名，也就是我们上面配置的Servlet名字，这里是ServletDemo，下面的是映射路径，也就是访问Servlet的名称，这里也是以方便和有意义为前提的，是我们在访问Servlet在浏览器地址栏后面输入的那个信息，例如我的映射路径命名为/servlet，在地址栏中输入http://localhost/20170323/servlet 注意：这里的映射路径一定不是丢掉/，否则就会出错了，一定要写成/servlet，不能是servlet 这里说一下在配置映射路径的时候，有以下两种： url-pattern 浏览器输入 精确匹配 /servlet http://localhost:8080/day10/servlet 模糊匹配 /* http://localhost:8080/20170323/任意路径 模糊匹配 /lm/* http://localhost:8080/20170323/lm/任意路径 模糊匹配 *.后缀名 http://localhost:8080/20170323/任意路径.do 模糊匹配 *.do 模糊匹配 *.action 模糊匹配 *.html(伪静态) 注意： url-pattern要么以 / 开头，要么以开头。 绝对不能漏掉斜杠！！！！！！！！！ 不能同时使用两种模糊匹配，例如 /lm/.do是非法路径 当有输入的URL有多个servlet同时被匹配的情况下： 精确匹配优先。（长的最像优先被匹配） 以后缀名结尾的模糊匹配先级最低！！！ JSP一. 三大指令： page: 该指令是针对当前页面的指令。 include: 用于指定如何包含另一个页面。 tablib: 用于定义和访问自定义标签。 二. 七大动作： forward: 执行页面转向，将请求的处理转发到下一个页面。 param: 用于传递参数，必须与其他支持参数曲标签一起使用。 include: 用于动态引入一个 JSP 页面。 plugin: 用于下载 JavaBean 或 Applet 到客户端执行。 useBean: 使用 JavaBean。 setProperty: 修改 JavaBean 实例的属性值。 getProperty: 获取 JavaBean 实例的属性值。 三. 九大对象： application: javax.servlet.ServletContext 的实例，该实例代表JSP所属的 Web应用本身，可用于 JSP 页面，或者 Servlet 之间交换信息。 常用的方法有getAttribute(String attNarne) , setAttribute(String attNarne , String attValue)和getInitPararneter(String paramNarne)等。 config: javax.servlet.ServletConfig 的实例，该实例代表该JSP 的配置信息。常用的方法有 getInitPararneter(StringparamNarne)及 getInitPararneternarnes() 等方法。事实上， JSP 页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet 中有效。 exception: java.lang.Throwable的实例，该实例代表其他页面中的异常和错误。只有当页面是错误处理页面，即编译指令page 的 isErrorPage属性为 true 时，该对象才可以使用。 常用的方法有getMessageO和 printStackTraceO等。 out: javax.servlet.jsp.JspWriter的实例，该实例代表JSP 页面的输出流，用于输出内容，形成HTML 页面。 page: 代表该页面本身，通常没有太大用处。也就是 Servlet 中的 this，其类型就是生成的 Serlet 。 pageContext: javax.servlet.jsp.PageContext的实例，该对象代表该JSP 页面上下文，使用该对象可以访问页面中的共享数据。 常用的方法有getServletContextO和getServletConfigO等。 request: javax.servlet.http:HttpServletRequest的实例，该对象封装了一次请求，客户端的请求参数都被封装在该对象里。这是一个常用的对象，获取客户端请求参数必须使用该对象。封装请求属性，封装地址栏参数，封装表单域值。 常用的方法有getPararneter(StringparamNarne), getPararneterValues(String paramName), setAttribute(String atttibuteName,Object attributeValue),getAttribute(String attributeName)和 setCharacterEncoding(Stringenv)等。 response: javax.servlet.http.HttpServletResponse的实例，代表服务器对客户端的响应。通常，也很少使用该对象直接响应，输出响应使用out 对象，而 response 对象常用于重定向。 常用的方法有sendRedirect(java.lang.Stringlocation)等。 session: javax.servlet.http.HttpSession的实例，该对象代表一次会话。从客户端浏览器与站点建立连接起，开始会话，直到关闭浏览器时结束会话。 常用的方法有:getAttribute(StringattName),setAttribute(StringattName,String attValue)等。 jsp九大内置对象 out 向客户端输出数据,字节流.如out.print(“ dgaweyr”); request 接收客户端的http请求. String getParameter(String name): 得到表单参数名name的值. String[] getParameterValues(String name): (得到String[]复选框时常用). setAttribute(String name,Object obj): 设置属性名为name,属性值为obj. getAttribute(String name); 得到属性值. response: 封装jsp产生的回应,然后发送到客户端以响应客户的请求.重定向跳转任意界面.(服务器跳转) addCookie(Cookie cookie): sendRedirect(“/wel.jsp”):跳转到指定页面 session:用于保存用户信息,跟踪用户行为,当前打开的浏览器内,多个页面共享数据. session对象指的是客户端与服务器的一次会话,从客户连到服务器的一个WebApplication开始,直到客户端与服务器断开连接为止.它是HttpSession类的实例. setAttribute(String name,Object obj):设置属性名为name,属性值为obj. getAttribute(String name):得到属性值. application对象:实现了用户间数据的共享,可存放全局变量.它开始于服务器的启动,直到服务器的关闭,在此期间,此对象将一直存在;这样在用户的前后连接或不同用户之间的连接中,可以对此对象的同一属性进行操作;在任何地方对此对象属性的操作,都将影响到其他用户对此的访问.服务器的启动和关闭决定了application对象的生命.它是ServletContext类的实例. session, application, request的区别:一个项目中session尽量少用几个,因为过多的session会影响程序的执行效率.它主要用于保存登录信息(用户信息,权限,资源)即频繁使用的信息. application: 用于多个浏览器之间共享数据,多个用户共享该对象,可以做计数器.它的用法与session完全一样. 数据范围: application(服务器关闭时失效)&gt;session(浏览器关闭时失效)&gt;request(只能用于两个跳转页面之间) page对象代表jsp这个实体本身,即当前页面有效.相当于java中的this. 数据范围:page&lt;session&lt;application exception:代表运行时的异常. 在会发生异常的页面加入指令:&lt;%@ page errorPage=”处理错误的页面.jsp”%&gt; 在处理异常的页面写入:&lt;%@ page isErrorPage=”true”%&gt; pageContext对象 pageContext对象提供了对JSP页面内所有的对象及名字空间的访问,也就是说他可以访问到本页所在的SESSION,也可以取本页面所在的application的某一属性值,他相当于页面中所有功能的集大成者,它的本类名也叫pageContext. config jsp对应的servlet的配置,可以得到web.xml中的初使化参数. jsp七大动作 include 动态包含(分别编译) 用于动态引入一个 JSP 页面。 用jsp:include动作实现 1&lt;jsp: include page="included.jsp" flush="true" /&gt; 它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。flush属性: 用true ，表示页面可刷新。默认为false; useBean动作(jsp页面使用javaBean的第二种方式): 使用 JavaBean。 1&lt;jsp:useBean id="对象名" class="包名.类名" scope="作用范围(request/page/application/session)"/&gt; 作用域默认为page(本页面有效). getProperty动作(name为useBean动作中的id). 获取 JavaBean 实例的属性值。 从对象中取出属性值： 1&lt;jsp:getProperty name="javaBean对象" property="javaBean对象属性名" /&gt; setProperty动作(name为useBean动作中的id): 修改 JavaBean 实例的属性值。 为对象设置属性值： 1&lt;jsp:setProperty name="javaBean对象" property="javaBean对象属性名" value=http://www.hake.cc/kf/201109/"值"/&gt; 为对象设置属性值: 1&lt;jsp:setProperty property="javaBean对象属性名" name="javaBean对象" param="username"/&gt; 1(param="username" 相当于 value=http://www.hake.cc/kf/201109/&lt;%=request.getParameter("username")%&gt;) param动作(传递参数)): 用于传递参数，必须与其他支持参数曲标签一起使用。 到达跳转页面可以通过 request.getParameter(“参数名”)方式取出参数值 12345&lt;jsp:include page="转向页面的url" &gt; &lt;jsp:param name="参数名1" value=http://www.hake.cc/kf/201109/"参数值1"&gt; &lt;jsp:param name="参数名2" value=http://www.hake.cc/kf/201109/"参数值2"&gt; ...........&lt;/jsp:include&gt; 或: 12345&lt;jsp:forward page="转向页面的url" &gt; &lt;jsp:param name="参数名1" value=http://www.hake.cc/kf/201109/"参数值1"&gt; &lt;jsp:param name="参数名2" value=http://www.hake.cc/kf/201109/"参数值2"&gt; ...........&lt;/jsp:forward&gt; forward动作: 执行页面转向，将请求的处理转发到下一个页面。 跳转页面 1&lt;jsp:forward page="login.jsp" /&gt; plugin动作:jsp:plugin:用于指定在客户端运行的插件 用于下载 JavaBean 或 Applet 到客户端执行。 JSP三大指令 page指令: 该指令是针对当前页面的指令。 指定页面编码.例: 1&lt;%@ page language="java" contentType="text/html;charset=gbk" pageEncoding="gbk" %&gt; 导入包,例: 1&lt;%@ page import="java.util.,java.text." %&gt; include 指令 用于指定如何包含另一个页面。 静态包含(统一编译): 1&lt;%@ include file="included.jsp"%&gt; taglib 用于定义和访问自定义标签。 Jsp中的静态包含与动态包含 12&lt;jsp: include page="included.jsp"/&gt;//动态include&lt;%@ include file="included.jsp"%&gt;//静态include 静态include的结果是把其他jsp引入当前jsp,两者合为一体,可以达到数据的共享即可以说是统一编译的,而 动态include的结构是两者独立的,直到输出时才合并即为分别编译的. 动态include的jsp文件独立性很强,是一个单独的jsp文件,需要使用的对象,页面设置,都由自己创建,而静态include纯粹是把代码写在外面的一种共享方法,所有的变量都是可以和include它的主文件共享,两者高度紧密结合,不能 有变量同名的冲突.而页面设置也可以借用主文件的. 动态包含总是检查被包含页面的变化,静态包含不一定检查被包含页面的变化. 动态包含可带参数,静态包含不能带参数.如(&lt;jsp: include page=&quot;included.jsp&quot;&gt;放入参数/jsp:include); El表达式：​ ${} ：可以自动获取域中对象，request，session，application，pageContext，EL找不到返回空白字符串。 ​ EL表达式中11大内置对象 ​ 1，pageContext 获取页面context的Map对象 ​ 2，pageScope 获取页面域的Map对象 ​ 3，requestScope 获取request域的Map对象 ​ 4，sessionScope 获取session域Map对象 ​ 5，applicationScope 获取context的Map对象 ​ 6，param 获取一个请求参数 ​ 7，paramValues 获取一个请求参数数组 ​ 8， header 获取一个请求域对象 ​ 9，headerValues ​ 10，cookies ​ 11，initParam 获取web.xml中的参数 El表达式中可以直接获取域中的数据： 1234567891011121314151617181920212223242526272829303132333435363738&lt;% pageContext.setAttribute("NAME","哈哈"); %&gt; 姓名：$&#123;NAME&#125;&lt;br/&gt; &lt;hr/&gt; &lt;% User user = new User(2015,"呵呵",10000D); request.setAttribute("USER",user); %&gt; 编号：$&#123;USER.id&#125;&lt;br/&gt; 姓名：$&#123;USER.name&#125;&lt;br/&gt;&lt;!--自动调用getter方法--&gt; 薪水：$&#123;USER.sal&#125;&lt;br/&gt; &lt;hr/&gt; &lt;% List&lt;String&gt; nameList = new ArrayList&lt;String&gt;(); nameList.add("A"); nameList.add("B"); nameList.add("C"); session.setAttribute("NAMELIST",nameList); %&gt; 第二个元素是：$&#123;NAMELIST[1]&#125;&lt;br/&gt; &lt;hr/&gt; &lt;% Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;String,Integer&gt;(); map.put("jack",10000); map.put("marry",12000); map.put("sisi",14000); application.setAttribute("MAP",map); %&gt; SISI的工资是：$&#123;MAP['sisi']&#125;&lt;br/&gt; &lt;hr/&gt; &lt;% String[] strArray = &#123;"北京","上海","广州","深圳"&#125;; pageContext.setAttribute("STRARRAY",strArray); %&gt; 你目前所在的城市是：$&#123;STRARRAY[2]&#125;&lt;br/&gt; &lt;hr/&gt; 姓名：$&#123;NAMEE&#125;&lt;br/&gt; EL表达式中的运算符： 123456789101112131415161718192021&lt;%@ page language="java" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;body&gt; 10+3=$&#123;10+3&#125;&lt;br/&gt; 10-3=$&#123;10-3&#125;&lt;br/&gt; 10*3=$&#123;10*3&#125;&lt;br/&gt; 10/3=$&#123;10/3&#125;&lt;br/&gt; 10%3=$&#123;10%3&#125;&lt;br/&gt; &lt;hr/&gt; true &amp;&amp; false = $&#123;true &amp;&amp; false&#125;&lt;br/&gt; true || false = $&#123;true || false&#125;&lt;br/&gt; ! false = $&#123;! false&#125;&lt;br/&gt; &lt;hr/&gt; 10&gt;3=$&#123;10&gt;3&#125;&lt;br/&gt; 10!=3=$&#123;10 ne 3&#125;&lt;br/&gt; 10==3=$&#123;10 eq 3&#125;&lt;br/&gt; &lt;/body&gt; &lt;/html&gt; EL表达式中的三木运算符： 123456789101112131415161718&lt;%@ page language="java" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;body&gt; &lt;% pageContext.setAttribute("city","深圳"); %&gt; 城市： &lt;select name="city"&gt; &lt;option&gt;选择城市&lt;/option&gt; &lt;option $&#123;city=='北京'?'selected':''&#125;&gt;北京&lt;/option&gt; &lt;option $&#123;city=='上海'?'selected':''&#125;&gt;上海&lt;/option&gt; &lt;option $&#123;city=='深圳'?'selected':''&#125;&gt;深圳&lt;/option&gt; &lt;option $&#123;city=='广州'?'selected':''&#125;&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;/body&gt; &lt;/html&gt; 12345678910111213141516171819202122&lt;%@ page language="java" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;body&gt; 当前web应用的根目录名：$&#123;pageContext.request.contextPath&#125;&lt;br/&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/el/03_el.jsp"&gt;点点&lt;/a&gt;&lt;br/&gt; &lt;% session.setAttribute("NAME","哈哈"); %&gt; 姓名：$&#123;sessionScope.NAME&#125;&lt;br/&gt; 参数值：$&#123;param.name&#125;&lt;br/&gt; 第三个爱好是：$&#123;paramValues.like[2]&#125;&lt;br/&gt; 请求头1：$&#123;header.host&#125;&lt;br/&gt; 请求头2：$&#123;headerValues["Accept-Encoding"][0]&#125;&lt;br/&gt; cookie的名：$&#123;cookie.PASS.name&#125;&lt;br/&gt; cookie的值：$&#123;cookie.PASS.value&#125;&lt;br/&gt; &lt;hr/&gt; web初始化参数之driver为：$&#123;initParam.driver&#125;&lt;br/&gt; web初始化参数之url为：$&#123;initParam.url&#125;&lt;br/&gt; &lt;/body&gt; &lt;/html&gt; JSP-JSTL标签库—-函数fn​ 1，导入相关的jstl包 ​ 2，要在使用jstl的页面中用taglib指令引入相关包 1234567891011121314&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %&gt; fn:toLowerCase("str") 字符串变成小写 fn:toUpperCase("str") 字符串变成大写 fn:trim("str") 去掉字符串两端空白 fn:split("String","regex") 切割字符串 fn:join("array","#") 用#把array中每个元素连接 fn:indexOf("str","s") 返回第二个参数在第一个参数首次出现的位置 fn:contains("s1","s2") 返回第二个参数是否包含在第一个参数 fn:startsWith("s1","s2") 第一个参数是否以第二个参数开头 fn:endsWith("s1","s2") 第一个参数是否以第二个参数结尾 fn:replace("s1","s2","s3") 把s1中的所有s2用s3替换 fn:substring("s1",a,b) 把s1中的第a个字符到b-1个字符截取出来 fn:substringAfter() $&#123;fn:substringAfter("www@163@com","@")&#125; fn:substringBefore() $&#123;fn:substringBefore("www@163@com","@")&#125; JSP-JSTL标签库—核心core&lt;c:out&gt;标签 —–把内容输出到浏览器1234567891011121314151617&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;% pageContext.setAttribute("script", "&lt;script&gt;alert('哈哈');&lt;/script&gt;"); %&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- escapeXml="false" 表示不转义js代码 --&gt; &lt;c:out value="$&#123;script&#125; &#125;" escapeXml="false"/&gt; &lt;/body&gt; &lt;/html&gt; &lt;c:set&gt;标签 —- 把数据绑定到域中12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;%@ page import="itcast.util.User" %&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP '02_c_set.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- class User&#123; private String id; private String name; public void setId(String id)&#123; this.id = id; &#125; public void setName(String name)&#123; this.name = name; &#125; public String getId()&#123; return this.id; &#125; public String getName()&#123; return this.name; &#125; &#125; --&gt; &lt;% User user = new User(); pageContext.setAttribute("USER", user); %&gt; &lt;c:set target="$&#123;pageScope.USER&#125;" property="id" value="2015"/&gt; &lt;c:set target="$&#123;pageScope.USER&#125;" property="name" value="笨笨"/&gt; 编号:$&#123;pageScope.USER.id&#125;&lt;br/&gt; 姓名:$&#123;pageScope.USER.name&#125; &lt;/body&gt; &lt;/html&gt; &lt;c:remove&gt;标签1&lt;c:remove var="NAME" scope="page"/&gt; 移除pageContext域中的名为NAME的数据 &lt;c:catch&gt;标签1234&lt;c:catch var="myError"&gt; &lt;% int i = 10/0; %&gt; &lt;/c:catch&gt; 原因为：$&#123;myError.message&#125;&lt;br/&gt; &lt;c:if&gt;标签12&lt;c:if test="判断条件"&gt; &lt;/c:if&gt; &lt;c:choose&gt;和&lt;c:when&gt;&lt;c:otherwise&gt;标签12345678910&lt;c:choose&gt; &lt;c:when test=""&gt; &lt;/c:when&gt; &lt;c:when test=""&gt; &lt;/c:when&gt; &lt;c:when test=""&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;c:forEach var items/&gt;标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page language="java" pageEncoding="UTF-8"%&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; &lt;%@ page import="java.util.*" %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;body&gt; &lt;% List&lt;String&gt; nameList = new ArrayList&lt;String&gt;(); nameList.add("小德子"); nameList.add("小格子"); nameList.add("小桌子"); nameList.add("小羊子"); nameList.add("小凳子"); pageContext.setAttribute("NAMELIST",nameList); %&gt; &lt;table border="2" align="center"&gt; &lt;tr&gt; &lt;th&gt;索引&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;是第一个元素吗&lt;/th&gt; &lt;th&gt;是最后个元素吗&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach var="xxx" items="$&#123;NAMELIST&#125;" varStatus="stat" begin="0" end="2"&gt; &lt;tr&gt; &lt;td&gt; $&#123;stat.index&#125; &lt;/td&gt; &lt;td&gt; $&#123;stat.count&#125; &lt;/td&gt; &lt;td&gt; $&#123;xxx&#125; &lt;/td&gt; &lt;td&gt; $&#123;stat.first&#125; &lt;/td&gt; &lt;td&gt; $&#123;stat.last&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; &lt;c:url&gt;和&lt;c:param&gt;标签12345678&lt;!-- /表示当前web应用的根目录 --&gt; &lt;c:url var="downURL" value="/DownloadServlet"&gt; &lt;!-- c:param负责编码 --&gt; &lt;c:param name="filename" value="三国123abc"/&gt; &lt;/c:url&gt; &lt;a href="$&#123;downURL&#125;" style="text-decoration:none"&gt; 下载三图[GET] &lt;/a&gt; &lt;c:redirect&gt;标签1&lt;c:redirect url="/core/07_c_forEach.jsp"/&gt; jsp:forward标签1&lt;jsp:forward page="/core/07_c_forEach.jsp"/&gt; Jsp监听器参考 http://blog.csdn.net/u011024652/article/details/52293932 Jsp过滤器参考 http://blog.csdn.net/u011024652/article/details/52186200 Jsp分页参考 http://blog.csdn.net/u011054333/article/details/54632265 Jsp上传文件参考 http://blog.csdn.net/sinat_34803353/article/details/53249354 AJaxJSON 语法 JSON 语法是 JavaScript 语法的子集。 JSON 语法规则JSON 语法是 JavaScript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 JSON 名称/值对JSON 数据的书写格式是：名称/值对。 名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值： &quot;name&quot; : &quot;菜鸟教程&quot; 这很容易理解，等价于这条 JavaScript 语句： name = “菜鸟教程” JSON 值JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在中括号中） 对象（在大括号中） null JSON 数字JSON 数字可以是整型或者浮点型： { &quot;age&quot;:30 } JSON 对象JSON 对象在大括号（{}）中书写： 对象可以包含多个名称/值对： { &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; } 这一点也容易理解，与这条 JavaScript 语句等价： name = &quot;菜鸟教程&quot;url = &quot;www.runoob.com&quot; JSON 数组JSON 数组在中括号中书写： 数组可包含多个对象： 1&#123;"sites": [&#123; "name":"菜鸟教程" , "url":"www.runoob.com" &#125;, &#123; "name":"google" , "url":"www.google.com" &#125;, &#123; "name":"微博" , "url":"www.weibo.com" &#125;]&#125; 在上面的例子中，对象 “sites” 是包含三个对象的数组。每个对象代表一条关于某个网站（name、url）的记录。 JSON 布尔值JSON 布尔值可以是 true 或者 false： { &quot;flag&quot;:true } JSON nullJSON 可以设置 null 值： { &quot;runoob&quot;:null } JSON 使用 JavaScript 语法因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。 通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值： JSON 文件 JSON 文件的文件类型是 “.json” JSON 文本的 MIME 类型是 “application/json” JS中使用Json参考： http://blog.csdn.net/xujie3/article/details/52954940 Java对象和Json互转参考： https://www.cnblogs.com/wangf-keep/p/6480019.html XMLHttpRequest对象参考： http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_create.asp 使用jQuery实现ajax参考: https://www.cnblogs.com/jackcheblog/p/7065421.html https://www.cnblogs.com/starof/p/6434791.html Ajax获取Json数据参考： https://www.cnblogs.com/zhangyongl/p/6399955.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java成神之路-数据库、PowerDesigner、JDBC（七）]]></title>
    <url>%2Fblog%2F786.html</url>
    <content type="text"><![CDATA[Java成神之路-数据库、PowerDesigner、JDBC Mysql数据库常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657net start mysql // 启动MYSQL服务net stop mysql // 停止MYSQL服务 netstat –na | findstr 3306 //查看被监听的端口 , findstr用于查找后面的端口是否存在 mysql –user=root –password=123456 db_name //在命令行中登陆MYSQL控制台 , 即使用 MYSQL COMMEND LINE TOOL mysql –u root –p123456 db_name //在命令行中登陆MYSQL控制台// 进入MYSQL命令行工具后 , 使用status; 或\s 查看运行环境信息 use new_dbname; // 切换连接数据库的语法show databases; // 显示所有数据库show tables; // 显示数据库中的所有表show create table table_name; //显示某个表创建时的全部信息 Describe table_name; desc table_name; //查看表的具体属性信息及表中各字段的描述 create database name; //创建数据库 use databasename; //选择数据库 drop database name //直接删除数据库，不提醒 mysqladmin drop databasename //删除数据库前，有提示。 show tables; //显示表 describe tablename; //表的详细描述select version(),current_date; //显示当前mysql版本和当前日期 SELECT DISTINCT `name` from users; //select 中加上distinct去除重复字段 SELECT DISTINCT name,age FROM users; //select 中加上distinct去除重复字段 SELECT count(DISTINCT name,age) FROM users; //select 中加上distinct去除重复字段select * from table_name; //查询:查询所有数据select 字段1 , 字段2 from table_name; //查询指定字段的数据select count(*) from tablename; //Mysql命令查询一个表的记录总数select count(*) as num from tablename; //Mysql命令查询一个表的记录总数select count(*) as total from tablename; //Mysql命令查询一个表的记录总数alter table t1 rename t2; //重新命名表Create database db_name; //数据库创建Drop database db_name; //数据库删除 drop database if exits db_name //删除时先判断是否存在create table table_name (字段1 数据类型 , 字段2 数据类型); //建表 : 创建数据表的语法create table mytable (id int , username char(20)); //建表示例CREATE USER username1 identified BY ‘password’ , username2 IDENTIFIED BY ‘password’…. //创建数据库用户drop table table_name; //删表Insert into 表名 [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..); //添加数据 insert into mytable (id,username) values (1,’zhangsan’); // 如果向表中的每个字段都插入一个值,那么前面 [ ] 括号内字段名可写也可不写Update table_name set 字段名=’新值’ [, 字段2 =’新值’ , …..][where id=id_num] [order by 字段 顺序]delete from table_name; //删除整个表中的信息delete from table_name where 条件语句 ; 条件语句如 : id=3; //删除表中指定条件的语句 Grant all ON db_name.table_name TO user_name [ indentified by ‘password’ ]; //库，表级的权限控制,将某库中的某表的控制权赋予某用户alter table table_name add column (字段名 字段类型); //增加一个字段格式----此方法带括号 alter table table_name add column 字段名 字段类型 after 某字段；//指定字段插入的位置 alter table table_name drop字段名; //删除一个字段alter table table_name change 旧字段名 新字段名 新字段的类型; //修改字段名称/类型alter table table_name rename to new_table_name; //改表的名字ALTER TABLE table_name ENGINE=MyISAM | InnoDB; //修改数据库引擎 truncate table table_name; //清空表中的所有数据 此方法也会使表中的取号器(ID)从1开始 SHOW CREATE TABLE table_name; //查看数据库当前引擎 修改密码1234567shell&gt;mysql -u root -p mysql&gt; update user set password=password(”xueok654123″) where user=’root’; mysql&gt; flush privileges //刷新数据库 mysql&gt;use dbname； //打开数据库： mysql&gt;show databases; //显示所有数据库 mysql&gt;show tables; //显示数据库mysql中所有的表：先use mysql；然后 mysql&gt;describe user; //显示表mysql数据库中user表的列信息）； 授权创建一个从任何地方连接服务器的超级用户，使用一个口令something 1mysql&gt; grant all privileges on *.* to user@localhost identified by ’something’ with 增加新用户格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 12GRANT ALL PRIVILEGES ON *.* TO monty@localhost IDENTIFIED BY ’something’ WITH GRANT OPTION; GRANT ALL PRIVILEGES ON *.* TO monty@”%” IDENTIFIED BY ’something’ WITH GRANT OPTION; 删除授权： 123mysql&gt; revoke all privileges on *.* from root@”%”; mysql&gt; delete from user where user=”root” and host=”%”; mysql&gt; flush privileges; 创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandb 1mysql &gt;grant select, insert, update, delete, create,drop on fangchandb.* to custom@ it363.com identified by ‘ passwd’ 备份备份数据库 1shell&gt; mysqldump -h host -u root -p dbname &gt;dbname_backup.sql 恢复数据库 12shell&gt; mysqladmin -h myhost -u root -p create dbname shell&gt; mysqldump -h host -u root -p dbname &lt; dbname_backup.sql 如果只想卸出建表指令，则命令如下： 1shell&gt; mysqladmin -u root -p -d databasename &gt; a.sql 如果只想卸出插入数据的sql命令，而不需要建表命令，则命令如下： 1shell&gt; mysqladmin -u root -p -t databasename &gt; a.sql 基础12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651、说明：创建数据库CREATE DATABASE database-name2、说明：删除数据库drop database dbname3、说明：备份sql server--- 创建 备份数据的 deviceUSE masterEXEC sp_addumpdevice 'disk', 'testBack', 'c:\mssql7backup\MyNwind_1.dat'--- 开始 备份BACKUP DATABASE pubs TO testBack4、说明：创建新表create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)根据已有的表创建新表：A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… from tab_old definition only5、说明：删除新表drop table tabname6、说明：增加一个列Alter table tabname add column col type注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。7、说明：添加主键： Alter table tabname add primary key(col)说明：删除主键： Alter table tabname drop primary key(col)8、说明：创建索引：create [unique] index idxname on tabname(col….)删除索引：drop index idxname注：索引是不可更改的，想更改必须删除重新建。9、说明：创建视图：create view viewname as select statement删除视图：drop view viewname10、说明：几个简单的基本的sql语句选择：select * from table1 where 范围插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!排序：select * from table1 order by field1,field2 [desc]总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table111、说明：几个高级查询运算词A： UNION 运算符UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。B： EXCEPT 运算符EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。C： INTERSECT 运算符INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。注：使用运算词的几个查询结果行必须是一致的。12、说明：使用外连接A、left （outer） join：左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.cB：right （outer） join:右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。C：full/cross （outer） join：全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。12、分组:Group by: 一张表，一旦分组完成后，查询后只能得到组相关的信息。 组相关的信息：（统计信息） count,sum,max,min,avg 分组的标准) 在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据 在selecte统计函数中的字段，不能和普通的字段放在一起；13、对数据库进行操作： 分离数据库： sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名14.如何修改数据库的名称:sp_renamedb 'old_name', 'new_name' 提升1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)法一：select * into b from a where 1&lt;&gt;1（仅用于SQlServer）法二：select top 0 * into b from a2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)insert into b(a, b, c) select d,e,f from b;3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件例子：..from b in '"&amp;Server.MapPath(".")&amp;"\data.mdb" &amp;"' where..4、说明：子查询(表名1：a 表名2：b)select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)5、说明：显示文章、提交人和最后回复时间select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b6、说明：外连接查询(表名1：a 表名2：b)select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c7、说明：在线视图查询(表名1：a )select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括select * from table1 where time between time1 and time2select a,b,c, from table1 where a not between 数值1 and 数值29、说明：in 的使用方法select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)10、说明：两张关联表，删除主表中已经在副表中没有的信息delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )11、说明：四表联查问题：select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where .....12、说明：日程安排提前五分钟提醒SQL: select * from 日程安排 where datediff('minute',f开始时间,getdate())&gt;513、说明：一条sql 语句搞定数据库分页select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段具体实现：关于数据库分页： declare @start int,@end int @sql nvarchar(600) set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’ exec sp_executesql @sql 注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）14、说明：前10条记录select top 10 * form table1 where 范围15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表(select a from tableA ) except (select a from tableB) except (select a from tableC)17、说明：随机取出10条数据select top 10 * from tablename order by newid()18、说明：随机选择记录select newid()19、说明：删除重复记录1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)2),select distinct * into temp from tablename delete from tablename insert into tablename select * from temp评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段alter table tablename--添加一个自增列add column_b int identity(1,1) delete from tablename where column_b not in(select max(column_b) from tablename group by column1,column2,...)alter table tablename drop column column_b20、说明：列出数据库里所有的表名select name from sysobjects where type='U' // U代表用户21、说明：列出表里的所有的列名select name from syscolumns where id=object_id('TableName')22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。select type,sum(case vender when 'A' then pcs else 0 end),sum(case vender when 'C' then pcs else 0 end),sum(case vender when 'B' then pcs else 0 end) FROM tablename group by type显示结果：type vender pcs电脑 A 1电脑 A 1光盘 B 2光盘 A 2手机 B 3手机 C 323、说明：初始化表table1TRUNCATE TABLE table124、说明：选择从10到15的记录select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc 技巧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411、1=1，1=2的使用，在SQL语句组合时用的较多“where 1=1” 是表示选择全部 “where 1=2”全部不选，如：if @strWhere !=''beginset @strSQL = 'select count(*) as Total from [' + @tblName + '] where ' + @strWhereendelsebeginset @strSQL = 'select count(*) as Total from [' + @tblName + ']'end我们可以直接写成错误！未找到目录项。set @strSQL = 'select count(*) as Total from [' + @tblName + '] where 1=1 安定 '+ @strWhere 2、收缩数据库--重建索引DBCC REINDEXDBCC INDEXDEFRAG--收缩数据和日志DBCC SHRINKDBDBCC SHRINKFILE3、压缩数据库dbcc shrinkdatabase(dbname)4、转移数据库给新用户以已存在用户权限exec sp_change_users_login 'update_one','newname','oldname'go5、检查备份集RESTORE VERIFYONLY from disk='E:\dvbbs.bak'6、修复数据库ALTER DATABASE [dvbbs] SET SINGLE_USERGODBCC CHECKDB('dvbbs',repair_allow_data_loss) WITH TABLOCKGOALTER DATABASE [dvbbs] SET MULTI_USERGO7、日志清除SET NOCOUNT ONDECLARE @LogicalFileName sysname, @MaxMinutes INT, @NewSize INT USE tablename -- 要操作的数据库名SELECT @LogicalFileName = 'tablename_log', -- 日志文件名@MaxMinutes = 10, -- Limit on time allowed to wrap log. @NewSize = 1 -- 你想设定的日志文件的大小(M)Setup / initializeDECLARE @OriginalSize intSELECT @OriginalSize = size FROM sysfiles WHERE name = @LogicalFileNameSELECT 'Original Size of ' + db_name() + ' LOG is ' + CONVERT(VARCHAR(30),@OriginalSize) + ' 8K pages or ' + CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + 'MB' FROM sysfiles WHERE name = @LogicalFileNameCREATE TABLE DummyTrans (DummyColumn char (8000) not null) DECLARE @Counter INT, @StartTime DATETIME, @TruncLog VARCHAR(255)SELECT @StartTime = GETDATE(), @TruncLog = 'BACKUP LOG ' + db_name() + ' WITH TRUNCATE_ONLY'DBCC SHRINKFILE (@LogicalFileName, @NewSize)EXEC (@TruncLog)-- Wrap the log if necessary.WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName) AND (@OriginalSize * 8 /1024) &gt; @NewSize BEGIN -- Outer loop.SELECT @Counter = 0 WHILE ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000)) BEGIN -- update INSERT DummyTrans VALUES ('Fill Log') DELETE DummyTrans SELECT @Counter = @Counter + 1 END EXEC (@TruncLog) ENDSELECT 'Final Size of ' + db_name() + ' LOG is ' + CONVERT(VARCHAR(30),size) + ' 8K pages or ' + CONVERT(VARCHAR(30),(size*8/1024)) + 'MB' FROM sysfiles WHERE name = @LogicalFileNameDROP TABLE DummyTransSET NOCOUNT OFF8、说明：更改某个表exec sp_changeobjectowner 'tablename','dbo'9、存储更改全部表CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch@OldOwner as NVARCHAR(128),@NewOwner as NVARCHAR(128)ASDECLARE @Name as NVARCHAR(128)DECLARE @Owner as NVARCHAR(128)DECLARE @OwnerName as NVARCHAR(128)DECLARE curObject CURSOR FORselect 'Name' = name, 'Owner' = user_name(uid)from sysobjectswhere user_name(uid)=@OldOwnerorder by nameOPEN curObjectFETCH NEXT FROM curObject INTO @Name, @OwnerWHILE(@@FETCH_STATUS=0)BEGIN if @Owner=@OldOwnerbegin set @OwnerName = @OldOwner + '.' + rtrim(@Name) exec sp_changeobjectowner @OwnerName, @NewOwnerend-- select @name,@NewOwner,@OldOwnerFETCH NEXT FROM curObject INTO @Name, @OwnerENDclose curObjectdeallocate curObjectGO 10、SQL SERVER中直接循环写入数据declare @i intset @i=1while @i&lt;30begin insert into test (userid) values(@i) set @i=@i+1end案例：有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格: Name score Zhangshan 80 Lishi 59 Wangwu 50 Songquan 69while((select min(score) from tb_table)&lt;60)beginupdate tb_table set score =score*1.01where score&lt;60if (select min(score) from tb_table)&gt;60 break else continueend 数据开发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 1.按姓氏笔画排序:Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多2.数据库加密:select encrypt('原始密码')select pwdencrypt('原始密码')select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同 encrypt('原始密码')select pwdencrypt('原始密码')select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同3.取回表中字段:declare @list varchar(1000),@sql nvarchar(1000)select @list=@list+','+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name='表A'set @sql='select '+right(@list,len(@list)-1)+' from 表A'exec (@sql)4.查看硬盘分区:EXEC master..xp_fixeddrives5.比较A,B表是否相等:if (select checksum_agg(binary_checksum(*)) from A) = (select checksum_agg(binary_checksum(*)) from B)print '相等'elseprint '不相等'6.杀掉所有的事件探察器进程:DECLARE hcforeach CURSOR GLOBAL FOR SELECT 'kill '+RTRIM(spid) FROM master.dbo.sysprocessesWHERE program_name IN('SQL profiler',N'SQL 事件探查器')EXEC sp_msforeach_worker '?'7.记录搜索:开头到N条记录Select Top N * From 表-------------------------------N到M条记录(要有主索引ID)Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc----------------------------------N到结尾记录Select Top N * From 表 Order by ID Desc案例例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句，找出表的第31到第40个记录。 select top 10 recid from A where recid not in(select top 30 recid from A)分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。 select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A 则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。解决方案1， 用order by select top 30 recid from A order by ricid 如果该字段不是自增长，就会出现问题2， 在那个子查询中也加条件：select top 30 recid from A where recid&gt;-1例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。set @s = 'select top 1 * from T where pid not in (select top ' + str(@count-1) + ' pid from T)'print @s exec sp_executesql @s9：获取当前数据库中的所有用户表select Name from sysobjects where xtype='u' and status&gt;=010：获取某一个表的所有字段select name from syscolumns where id=object_id('表名')select name from syscolumns where id in (select id from sysobjects where type = 'u' and name = '表名')两种方式的效果相同11：查看与某一个表相关的视图、存储过程、函数select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like '%表名%'12：查看当前数据库中所有存储过程select name as 存储过程名称 from sysobjects where xtype='P'13：查询用户创建的所有数据库select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name='sa')或者select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x0114：查询某一个表的字段和数据类型select column_name,data_type from information_schema.columnswhere table_name = '表名'15：不同服务器数据库之间的数据操作--创建链接服务器exec sp_addlinkedserver 'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 'exec sp_addlinkedsrvlogin 'ITSV ', 'false ',null, '用户名 ', '密码 '--查询示例select * from ITSV.数据库名.dbo.表名--导入示例select * into 表 from ITSV.数据库名.dbo.表名--以后不再使用时删除链接服务器exec sp_dropserver 'ITSV ', 'droplogins ' --连接远程/局域网数据(openrowset/openquery/opendatasource)--1、openrowset--查询示例select * from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)--生成本地表select * into 表 from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名) --把本地表导入远程表insert openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)select *from 本地表--更新本地表update bset b.列A=a.列A from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)as a inner join 本地表 bon a.column1=b.column1--openquery用法需要创建一个连接--首先创建一个连接创建链接服务器exec sp_addlinkedserver 'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 '--查询select *FROM openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ')--把本地表导入远程表insert openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ')select * from 本地表--更新本地表update bset b.列B=a.列BFROM openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ') as a inner join 本地表 b on a.列A=b.列A --3、opendatasource/openrowsetSELECT *FROM opendatasource( 'SQLOLEDB ', 'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ' ).test.dbo.roy_ta--把本地表导入远程表insert opendatasource( 'SQLOLEDB ', 'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ').数据库.dbo.表名select * from 本地表 PowerDesigner设计建造MySQL数据库制作建库脚本 设计CDM(Conceptual Data Model) 选择 Tools -&gt; Generate Physical Data Model ，选择对应的DBMS为MySQL，生成PDM 选择 Database -&gt; Generate Database ，在弹出的 Database Generation 对话框中选择脚本存取路径及脚本文件名称 点击确定后生成数据库建库脚本(*.sql) 执行sql脚本第一种方法:在命令行下(未连接数据库),输入 mysql -h localhost -u root -p123456 &lt; F:/mytest/testdb.sql (注意路径不用加引号的!!) 回车即可. 第二种方法:在命令行下(已连接数据库,此时的提示符为 mysql&gt; ),输入 source F:/mytest/testdb.sql (注意路径不用加引号的) 回车即可 JDBCJDBC概念JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 一、JDBC常用接口、类介绍JDBC提供对独立于数据库统一的API，用以执行SQL命令。API常用的类、接口如下： DriverManager管理JDBC驱动的服务类，主要通过它获取Connection数据库链接，常用方法如下： 1public static synchronized Connection getConnection(String url, String user, String password) throws Exception; 该方法获得url对应的数据库的连接。 Connection常用数据库操作方法：12345Statement createStatement throws SQLException: //该方法返回一个Statement对象。PreparedStatement prepareStatement(String sql) throws SQLException;//该方法返回预编译的Statement对象， 即将SQL语句提交到数据库进行预编译。CallableStatement prepareCall(String sql) throws SQLException：//该方法返回CallableStatement对象，该对象用于存储过程的调用。 上面的三个方法都是返回执行SQL语句的Statement对象，PreparedStatement、CallableStatement的对象是Statement的子类，只有获得Statement之后才可以执行SQL语句。 Connection控制事务12345678910111213Savepoint setSavepoint(): //创建一个保存点Savepoint setSavepoint(String name)：//创建一个带有名称的保存点void setTransactionIsolation(int level)://设置事务隔离级别void rollback()：//回滚事务void rollback(Savepoint savepoint)：//回滚到指定保存点void setAutoCommit(boolean autoCommit): //关闭自动提交，打开事务void commit()：提交事务 Statement用于执行SQL语句的API接口，该对象可以执行DDL、DCL语句，也可以执行DML语句，还可以执行SQL查询语句，当执行查询语句是返回结果集，常用方法如下： 12345ResultSet executeQuery(String sql) throws SQLException：//该方法用于执行查询语句，并返回查询结果对应的ResultSet对象，该方法只用于查询语句。int executeUpdate(String sql) throws SQLException：//该方法用于执行DML语句，并返回受影响的行数；该方法也可以执行DDL，执行DDL返回0；boolean execute(String sql) throws SQLException：//该方法可以执行任何SQL语句，如果执行后第一个结果是ResultSet对象，则返回true；如果执行后第一个结果为受影响的行数或没有任何结果，则返回false； PreparedStatement预编译的statement对象，PreparedStatement是Statement的子接口，它允许数据库预编译SQL（通常指带参数SQL）语句，以后每次只改变SQL命令参数，避免数据库每次都编译SQL语句，这样性能就比较好。而相对于Statement而言，使用PreparedStatement执行SQL语句时，无需重新传入SQL语句，因为它已经预编译了SQL语句。 但是PreparedStatement需要为编译的SQL语句传入参数值，所以它比了如下方法： 1void setXxx(int index, value)//根据该方法传入的参数值的类型不同，需要使用不同的方法。 传入的值的类型根据传入的SQL语句参数而定。 ResultSet123456789101112131415void close() throws SQLException：//释放、关闭ResultSet对象boolean absolute(int row)://将结果集移动到第几行，如果row是负数，则移动到倒数第几行。如果移动到的记录指针指向一条有效记录，则该方法返回true；void beforeFisrt(): //将ResultSet的记录指针定位到首行之前，这是ResultSet结果集记录指针的初始状态：记录指针的起始位置位于第一行之前。boolean first()：//将ResultSet的记录指针定位到首行。如果移动后的记录指针指向一条有效记录，则该方法返回true。boolean previous()：//将ResultSet的记录指针定位到上一行，如果移动后的记录指针指向一条有效记录，则该方法返回true。boolean next()：//将ResultSet的记录指针定位到下一行。如果移动后的记录指针指向一条有效记录，则返回true。boolean last()：//将ResultSet的记录指针定位到最后一行。如果移动后的记录指针指向一条有效记录，则返回true。void afterLast()：//将ResultSet的记录指针定位到最后一行之后。 注意：在JDK1.4以前只支持next移动，且每次移动一个位置。到JDK1.5就可以随意定位。 二、JDBC编程步骤进行jdbc编程步骤大致如下： 加载数据库驱动 Class.forName(driverClass)上面的dirverClass就是数据库驱动类所对应的类路径字符串，根据不同数据库厂商提供的驱动也不同。 通过DriverManager获取数据库的链接 DriverManager.getConnection(String url, Stirng user, String pass)当使用DriverManager来获取链接，需要传入三个参数：分别是数据量的url、用户名、密码。 通过Connection对象创建Statement对象，Connection创建Statement的方法如下三个： createStatement()创建基本的Statement对象。prepareStatement(String sql)：根据传入的sql语句创建预编译的Statement对象。prepareCall(String sql)：根据传入的sql语句创建CallableStatement对象 Statement执行SQL语句，Statement有三大方法来执行SQL语句： execute：可以执行任何SQL语句，单比较麻烦executeUpdate：可以执行DML、DDL语句。执行DML返回受影响的SQL语句行数，执行DDL返回0；executeQuery：只能执行查询语句，执行后返回代表查询结果的ResultSet对象。 操作结果集，针对ResultSet 主要移动指针和获得值 next、previous、first、last、beforeFrist、afterLast、absolute等移动指针的方法。 getXxx获得移动指针指向行，特定列、索引的值。使用列名作为获取值的参数可读性好、使用索引作为获取参数性能好。 三、JDBC执行SQL语句 executeUpdate执行DDL、DML语句 Statement提供了execute、executeUpdate、executeQuery三种方法执行，下面用executeUpdate来执行DDL、DML语句，executeUpdate执行DDL返回值是0，执行了DML是返回影响后的记录条数。 execute执行SQL语句 当我们知道SQL语句是完成修改语句时，我们就知道使用executeUpdate语句来完成操作；如果SQL语句是完成查询操作的时候，我们就使用executeQuery来完成。 如果我们不知道SQL语句完成什么操作的时候，就可以使用execute方法来完成。 当我们使用Statement对象的execute方法执行SQL语句后返回的是boolean值，这就说明该语句能否返回ResultSet对象。 那么，如何判断是否是ResultSet对象？方法如下： getResultSet()：获取该Statement执行查询语句返回的ResultSet对象 getUpdateCount()：获取该Statement执行修改语句影响的行数 PrepareStatement执行SQL语句 对于我们操作数据库的时候，执行某一条SQL语句的时候。只有它的参数不同，而SQL语句相同。 我们可以使用占位符来设置我们的参数信息，PrepareStatement中的占位符是？，用？代替参数的位置。 1insert into table values(?, ‘abc’, ?); 占位符仅仅支持PrepareStatement，而Statement不支持占位符。PrepareStatement是预编译SQL语句的，然后将占位符替换成参数。而Statement就不能做到。 PrepareStatement对象也有execute、executeUpdate、executeQuery这三个方法，但这三个方法都无需传递参数。只需用PrepareStatement来设置占位符的参数，通过用setXxxx(index, value)来完成设置参数信息即可。PrepareStatement的效率要比Statement的效率高。PrepareStatement设置参数可以不拼接字符串，而Statement设置参数信息的时候需要手动拼接字符串。拼接字符串容易操作程序错误、可读性降低、维护性升高、程序性能下降。而PrepareStatement直接设置参数信息就降低了编程的复杂度。并且它可以放在SQL注入。因为它是通过setXxx方法进行设置参数信息，而Statement是通过拼接字符串，很容易就造成SQL注入。 综上所述，PrepareStatement比Statement有以下优点： 预编译SQL语句，性能更好 无需拼接SQL语句，编程更简单 可以防止SQL语句注入，安全性更好 CallableStatement调用存储过程 存储过程的调用可以通过CallableStatement，通过Connection对象的prepareCall方法来创建CallableStatement对象。 然后传入存储过程的SQL语句，即可调用存储过程，格式如下： 1&#123;call proc_name(?, ?, ?)&#125; 上面的?是占位符，表示传递的参数。 存储过程有传入参数、传出参数。传入参数是程程序必须传入的参数，可以 通过setXxx方法进行设置参数值。 而传出参数则需要通过程序进行设置，可以用CallableStatement对象的registerOutParameter方法来注册输出参数，cs.registerOutParameter(3, Types.STRING); 设置完毕后，当调用存储过程后要获取输出参数值，可以通过getXxx方法来完成。 四、操作结果集(ResultSet)JDBC是通过ResultSet来管理结果集，操作ResultSet可以通过移动其指针来指向不同的行记录，然后取出当前记录即可。并且ResultSet可以完成更新记录，还提供了ResultSetMetaData来获得对象相关信息。 可移动、可更新的ResultSet 前面介绍过ResultSet的相关方法，可以通过一系列的方法来移动记录指针，如：absolute、previous、next、first、last、beforeFirst、afterLast等方法。 ResultSet默认是不支持更新的，如果希望ResultSet完成更新操作，必须在创建Statement或PrepareStatement时传入一些参数。 Connection对象在创建Statement或PrepareStatement时可以传入两个参数： resultSetType：控制ResultSet的类型，该参数有以下三个值： ResultSet.TYPE_FORWARD_ONLY该常量控制记录指针只能向前移动。Jdk1.4的默认值 ResultSet.TYPE_SCROLL_INSENSITIVE：该常量控制记录指针自由移动(可滚动结果集)，但底层的数据改变不影响结果集ResultSet的内容 ResultSet.TYPE_SCROLL_SENSITIVE：该常量控制记录指针自由移动，但底层数据的影响会改变结果集ResultSet的内容 resultSetConcurrency：控制ResultSet的并发类型，该参数可以接收如下两个值： ResultSet.CONCUR_READ_ONLY：该常量表示ResultSet是只读并发模式 ResultSet.CONCUR_UPDATABLE：该常量表示ResultSet是更新并发模式 通过PrepareStatement、Statement的创建时进行参数设置来创建可滚动、可更新的ResultSet，然后通过rs的updateXxx方法来完成某列的更新值设置，通过updateRow来提交修改。 ResultSet中的二进制Blob数据处理 Blob类型通常用来存储文件，如：图片、音频、视频文件。将文件转换成二进制保存在数据库中，取出来的时候可以二进制数据恢复成文件。 如果要插入图片到数据库，显然不能直接设置SQL参数拼接字符串进行插入。因为二进制常量无法表示。 但是将Blob类型数据插入到数据可以用PrepareStatement，通过PrepareStatement对象的setBinaryStatement方法将参数传入到二进制输入流；也可以用Blob对象的getBytes方法直接取出数据。 利用ResultSetMetaData操作ResultSet结果集 在我们查询数据返回的结果集中，我们不清楚结果集存放的数据类型、数据列数。 那样我们就可以用ResultSetMetaData来读取ResultSet的信息。 通过ResultSet的getMetaData()的方法可以获取ResultSetMetaData对象。 然后可以用ResultSetMetaData对象的方法来操作ResultSet，常用方法如下： int getColumnCount()：返回ResultSet的列名数量 int getColumnType(int column)：返回指定索引的类型 String getColumnName(int column)：返回指定索引的列名 五、JDBC事务 事务介绍 事务是一步或多步组成操作序列组成的逻辑执行单元，这个序列要么全部执行，要么则全部放弃执行。 事务的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（IsoIation）和持续性（Durability） 原子性（Atomicity）：事务应用最小的执行单元，不可再分。是事务中不可再分的最小逻辑执行体。 一致性（Consistency）：事务的执行结果，必须使数据库的从一个一致性的状态变到另一个一致性的状态。 隔离线（IsoIation）：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能互相影响。 持续性（Durability）：持续性也称为持久性（Persistence），指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常就是保存在物理数据库中。 通常数据库的事务涉及到的语句有： 一组DML（Data Munipulation Language，数据操作语言）语句，这组DML语句修改后数据将保持较好的一致性； 操作表的语句，如插入、修改、删除等； 一个DDL（Data Definition Language，数据定义语言）语句，操作数据对象的语言，有create、alter、drop。 一个DCL（Data Control Language，数据控制语言）语句，主要有grant、revoke语句。 DDL和DCL语句最多只能有一个，因为它们都会导致事务的立即提交。 当事务所包含的全部数据库操作都成功执行后，应该提交事务，使这些修改永久生效。 事务提交有两种方式：显示提交和自动提交。 显示提交：使用commit提交 自动提交：执行DLL或DCL，或者程序正常退出 当事务包含的任意一个数据库操作执行失败后，应该回滚（rollback）事务，使该事务中所作的修改全部失效。 事务的回滚方式有两种：显示回滚和自动回滚。 显示回滚：使用rollback 自动回滚：系统错误或强行退出 JDBC的事物的支持 JDBC的Connection也支持事物，Connection默认打开自动提交，即关闭事物。 也就是说，每条SQL语句执行就会立即提交到数据库，永久生效，无法对其进行操作。 关闭Connection的自动提交，开启事物。Connection的setAutoCommit方法即可：connection.setAutoCommit(false); 通过connection.getAutoCommit()来获取事物的模式。 当我们开启事物后，在当前Connection中完成的数据库操作，都不会立即提交到数据库，需要调用Connection的commit方法才行。 如果有语句执行失败，可以调用rollback来回滚。 注意：如果Connection遇到未处理的SQLException异常时，系统将非正常退出，系统会自动回滚该事务。 如果程序捕捉了该异常，则需要在异常处理中显示回滚事务。 Connection提供了设置事务中间保存点的方法：setSavepoint，有2个方法可以设置中间点： Savepoint setSavepoint()：在当前事务中创建一个未命名的中间点，并返回该中间点的Savepoint对象。 Savepoint setSavepoint(String name)：当前事务中创建一个具有指定名称的中间点，并返回该中间点的Savepoint对象 通常setSavepoint(String name)设置中间点的名称，事务回滚并不是通过中间点的名称进行回滚的，而是根据中间点对象进行回滚的。 设置名称只是更好的区分中间点对象，用Connection的rollback(Savepoint savepoint)方法即可完成回滚到指定中间点。 JDBC的批量更新 批量更新就是可以同时进行多条SQL语句，将会被作为一批操作被同时执行、同时提交。 批量更新需要得到数据底层的支持，可以通过调研DataBaseMetaData的supportsBatchUpdates方法来查看底层数据库是否支持批量更新。 批量更新也需要创建一个Statement对象，然后通过该对象的addBatch方法将多条SQL语句同时收集在一起， 然后通过Statement对象的executeBatch同时执行这些SQL语句，如下代码： 1234567Statement sm = conn.createStatement();sm.addBatch(sql);sm.addBatch(sql2);sm.addBatch(sql3);…//同时执行多条SQL语句sm.executeBatch(); 执行executeBatch将返回一个int[]的数组，因为使用Statement执行DDL、DML都将返回一个int的值，而执行多条DDL、DML也将返回一个int数组。批量更新中不允许出现select查询语句，一旦出现程序将出现异常。 如果要批量更新正确、批量完成，需要用单个事务，如果批量更新过程中有失败，则需要用事务回滚到原始状态。 如果要达到这样的效果，需要关闭事务的自动提交，当批量更新完成再提交事务，如果出现异常将回滚事务。 然后将连接恢复成自动提交模式。 1234567891011121314151617181920212223242526272829public int[] executeBatch(String[] sql) throws SQLException &#123; int[] result = null; conn = DBHelper.getConnection(); try &#123; //获得当前Connection的提交模式 boolean autoCommit = conn.getAutoCommit(); //关闭自动提交模式 conn.setAutoCommit(false); sm = conn.createStatement(); for (String s : sql) &#123; sm.addBatch(s); &#125; //执行批量更新 result = sm.executeBatch(); //提交事务 conn.commit(); //还原提交模式 conn.setAutoCommit(autoCommit); &#125; catch (Exception e) &#123; e.printStackTrace(); conn.rollback(); &#125; finally &#123; if (sm != null) &#123; sm.close(); &#125; DBHelper.close(); &#125; return result;&#125; 六、分析数据库数据 使用DatabaseMetaData分析数据库数据 JDBC提供了DatabaseMetaData来封装数据库连接对应的数据库信息，通过Connection的getMetaData方法来获取该对象。 DatabaseMetaData接口通常数据库驱动提供商完成实现，其作用是让用户了解数据库的底层信息。 使用该接口可以了解数据库底层的实现，便于完成多个数据库的相互切换。 如：可以利用supportsCorrelatedSubquenes方法来查看数据库底层是否可以利用关联子查询，或是调用supportsBatchUpdates方法查看是否支持批量更新。 大部分的DatabaseMetaData都是以ResultSet对象返回的，可以通过ResultSet对象的getString、getInt来获取相关信息。DatabaseMetaData方法都需要传递一个xxxPattern的模式字符串，这个字符串是过滤条件，一般传递是SQL中的%、_等内容。如果传递一个null表示不作任何过滤。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java成神之路-Java异常、集合、IO流、多线程和反射（六）]]></title>
    <url>%2Fblog%2F59531.html</url>
    <content type="text"><![CDATA[Java成神之路-Java异常、集合、IO流、多线程和反射 Java异常处理一、异常概述异常：Exception，是在运行发生的不正常情况。 原始异常处理： 代码阅读性差，臃肿不堪，与正常流程代码结合的很紧密，所以，在JAVA中进行一系列的改良，将一系列常见的问题，用面向对象的思考方式，对其进行了描述、封装。 在JAVA中，用类的形式对不正常情况进行了描述和封装对象。当程序出现问题时，调用相应的处理办法。 描述不正常情况的类，就称为异常类。将流程代码和异常代码进行分离。 异常就是JAVA通过面向对象的思想，将问题封装成了对象。用异常类对其进行描述。不同的问题，用不同的类进行描述。那么意味着，问题有多少，类就有多少。 二、异常体系问题很多，意味着描述的类也很多，将其共性进行向上抽取，就形成了异常体系。最终异常分为两大类： Throwable（父类）：问题发生，就应该抛出，让调用者处理。该体系的特点就在于Throwable及其子类都具有可抛性。 两个关键字实现可抛性：throws、throw |–1.一般不可处理的。Error（错误） 特点：是由JVM（java虚拟机）抛出的严重性的问题。这种问题发生，一般不针对性处理，直接修改程序。 |–2.可以处理的。Exception（异常） 特点：子类的后缀名都是用其父类名作为后缀，阅读性很强。 三、异常-原理&amp;异常对象的抛出throw可以看出，异常时，底层throw直接调用异常方法，抛出异常，只不过这些都在底层完成，我们看不到而已。 JAVA虚拟机它有一套异常处理机制，就是会把异常的各种信息，位置等报出来，以供解决异常。 真正开发的时候，这些异常信息是不会直接报出来的，会存成日志，我们定期查看。而且这个异常信息给用户也没用，只有给我们才有用。 四、异常-自定义异常&amp;异常类的抛出throws自定义异常：JAVA给出的一堆现有的异常没有我们需要的，这时候可以自定义了。但是这个类一定要继承Exception类。 五、异常-编译时检测异常和运行时异常的区别&amp;throw和throws的区别Exception体系分两种：1.一种是编译时被检测异常（throws）。除runtimeException子类的所有子类。这样的问题可以针对性的处理。 2.运行时异常（throw）。Exception的子类中runtimeException和其子类。这种问题一般不处理，直接编译通过，在运行时让调用时的程序强制停止。 六、异常-异常捕捉try-catch异常处理的捕捉形式：具体格式： 建立日志文件：第三方插件-log4j 七、异常-多catch情况一个try对应多个catch的时候，小细节： 当多catch需要存在catch(Exception e)的时候，需要放到最后，不然会挂，因为Exception为父类，能接收所有的异常，放它之后，其他的就多余了，所以，它要放在最后的catch。 八、异常-异常处理原则异常就是问题，JAVA对一些常见的问题已经弄好了，拿来用就好了。 如果，个别问题只在你自己的项目里出现，并且JAVA里没有这类问题，那就需要自己描述该问题。 1.方法内如果抛出需要检测的异常，那么方法上必须要声明，否则必须在方法内用try-catch捕捉，否则编译失败。 2.如果调用了声明异常的函数，要么try-catch要么throws，否则编译失败。 3.什么时候catch，什么时候throws？功能内容可以解决，用catch，解决不了，用throws告诉调用者，有调用者解决。 4.如果一个功能抛出了多个异常，那么调用时必须有对应多个catch进行针对性的处理。 九、异常-finally代码块finally为一定会执行的代码，只有一种情况，finally不会执行。 try-catch-finally代码块组合特点： 1.try-catch-finally常见组合体 2.try-catch(可以多个catch)没有finally，没有资源需要释放（关闭），可以不用finally。 3.try-finally，没有catch时，方法旁边需要throws声明，因为没catch没处理。异常无法直接catch处理，但是资源需要关闭，这时用此组合。 十、异常的注意事项1.子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的子类。 2.如果父类抛出多个异常，那么子类只能抛出父类异常的子集。—-子类覆盖父类只能抛出父类异常或者子类或者子集。如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，只能try。 常用异常方法： Error类的常见子类： Exception类的常见子类： RuntimeException类的常见的子类： JAVA集合类汇总一、集合与数组数组（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用。 集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用。 二、层次关系Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。 Set中不能包含重复的元素。 List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。 Iterator，所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法： hasNext()是否还有下一个元素。 next()返回下一个元素。 remove()删除当前元素。 三、几种重要的接口和类简介 List（有序、可重复） List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 Set（无序、不能重复） Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 Map（键值对、键唯一、值不唯一） Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 对比如下： 是否有序 是否允许元素重复 Collection List 是 是 Set AbstractSet 否 否 HashSet TreeSet 是（用二叉排序树） Map AbstractMap 否 使用key-value来映射和存储数据，key必须唯一，value可以重复 HashMap TreeMap 是（用二叉排序树） 四、遍历 在类集中提供了以下四种的常见输出方式： 1）Iterator：迭代输出，是使用最多的输出方式。 2）ListIterator：是Iterator的子接口，专门用于输出List中的内容。 3）foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。 4）for循环 代码示例如下： for的形式： 123for（int i=0;i&lt;arr.size();i++）&#123; ...&#125; foreach的形式： 123for（int i：arr）&#123; ...&#125; iterator的形式： 1234Iterator it = arr.iterator();while(it.hasNext())&#123; object o =it.next(); ...&#125; 五、ArrayList和LinkedListArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反。 六、Map集合实现类：HashMap、Hashtable、LinkedHashMap和TreeMap HashMap HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的 Hashtable Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 ConcurrentHashMap 线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 LinkedHashMap LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。 TreeMap TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的； map的遍历第一种：KeySet()将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。典型用法如下： 12345Map map = new HashMap();map.put("key1","lisi1");map.put("key2","lisi2");map.put("key3","lisi3");map.put("key4","lisi4"); //先获取map集合的所有键的set集合，keyset（） 123456Iterator it = map.keySet().iterator(); //获取迭代器while(it.hasNext())&#123; Object key = it.next();System.out.println(map.get(key));&#125; 第二种：entrySet（）Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。典型用法如下： 12345Map map = new HashMap();map.put("key1","lisi1");map.put("key2","lisi2");map.put("key3","lisi3");map.put("key4","lisi4"); //将map集合中的映射关系取出，存入到set集合 12345Iterator it = map.entrySet().iterator(); while(it.hasNext())&#123; Entry e =(Entry) it.next(); System.out.println("键"+e.getKey () + "的值为" + e.getValue());&#125; 推荐使用第二种方式，即entrySet()方法，效率较高。对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。 七、 List集合 list中添加，获取，删除元素； list中是否包含某个元素； list中根据索引将元素数值改变(替换)； list中查看（判断）元素的索引； 根据元素索引位置进行的判断； 利用list中索引位置重新生成一个新的list（截取集合）； 对比两个list中的所有元素； 判断list是否为空； 返回Iterator集合对象； 将集合转换为字符串； 将集合转换为数组； 集合类型转换； 去重复； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158package MyTest01; import java.util.ArrayList;import java.util.List; public class ListTest01 &#123; public static void main(String[] args) &#123; //list中添加，获取，删除元素 List&lt;String&gt; person=new ArrayList&lt;&gt;(); person.add("jackie"); //索引为0 //.add(e) person.add("peter"); //索引为1 person.add("annie"); //索引为2 person.add("martin"); //索引为3 person.add("marry"); //索引为4 person.remove(3); //.remove(index) person.remove("marry"); //.remove(Object o) String per=""; per=person.get(1); System.out.println(per); ////.get(index) for (int i = 0; i &lt; person.size(); i++) &#123; System.out.println(person.get(i)); //.get(index) &#125; //list总是否包含某个元素 List&lt;String&gt; fruits=new ArrayList&lt;&gt;(); fruits.add("苹果"); fruits.add("香蕉"); fruits.add("桃子"); //for循环遍历list for (int i = 0; i &lt; fruits.size(); i++) &#123; System.out.println(fruits.get(i)); &#125; String appleString="苹果"; //true or false System.out.println("fruits中是否包含苹果："+fruits.contains(appleString)); if (fruits.contains(appleString)) &#123; System.out.println("我喜欢吃苹果"); &#125;else &#123; System.out.println("我不开心"); &#125; //list中根据索引将元素数值改变(替换) String a="白龙马", b="沙和尚", c="八戒", d="唐僧", e="悟空"; List&lt;String&gt; people=new ArrayList&lt;&gt;(); people.add(a); people.add(b); people.add(c); people.set(0, d); //.set(index, element) //将d唐僧放到list中索引为0的位置，替换a白龙马 people.add(1, e); //.add(index, element); //将e悟空放到list中索引为1的位置,原来位置的b沙和尚后移一位 //增强for循环遍历list for(String str:people)&#123; System.out.println(str); &#125; //list中查看（判断）元素的索引 List&lt;String&gt; names=new ArrayList&lt;&gt;(); names.add("刘备"); //索引为0 names.add("关羽"); //索引为1 names.add("张飞"); //索引为2 names.add("刘备"); //索引为3 names.add("张飞"); //索引为4 System.out.println(names.indexOf("刘备")); System.out.println(names.lastIndexOf("刘备")); System.out.println(names.indexOf("张飞")); System.out.println(names.lastIndexOf("张飞")); //根据元素索引位置进行的判断 if (names.indexOf("刘备")==0) &#123; System.out.println("刘备在这里"); &#125;else if (names.lastIndexOf("刘备")==3) &#123; System.out.println("刘备在那里"); &#125;else &#123; System.out.println("刘备到底在哪里？"); &#125; //利用list中索引位置重新生成一个新的list（截取集合） List&lt;String&gt; phone=new ArrayList&lt;&gt;(); phone.add("三星"); //索引为0 phone.add("苹果"); //索引为1 phone.add("锤子"); //索引为2 phone.add("华为"); //索引为3 phone.add("小米"); //索引为4 //原list进行遍历 for(String pho:phone)&#123; System.out.println(pho); &#125; //生成新list phone=phone.subList(1, 4); //.subList(fromIndex, toIndex) //利用索引1-4的对象重新生成一个list，但是不包含索引为4的元素，4-1=3 for (int i = 0; i &lt; phone.size(); i++) &#123; // phone.size() 该方法得到list中的元素数的和 System.out.println("新的list包含的元素是"+phone.get(i)); &#125; //对比两个list中的所有元素 //两个相等对象的equals方法一定为true, 但两个hashcode相等的对象不一定是相等的对象 if (person.equals(fruits)) &#123; System.out.println("两个list中的所有元素相同"); &#125;else &#123; System.out.println("两个list中的所有元素不一样"); &#125; if (person.hashCode()==fruits.hashCode()) &#123; System.out.println("我们相同"); &#125;else &#123; System.out.println("我们不一样"); &#125; //判断list是否为空 //空则返回true，非空则返回false if (person.isEmpty()) &#123; System.out.println("空的"); &#125;else &#123; System.out.println("不是空的"); &#125; //返回Iterator集合对象 System.out.println("返回Iterator集合对象:"+person.iterator()); //将集合转换为字符串 String liString=""; liString=person.toString(); System.out.println("将集合转换为字符串:"+liString); //将集合转换为数组，默认类型 System.out.println("将集合转换为数组:"+person.toArray()); ////将集合转换为指定类型（友好的处理） //1.默认类型 List&lt;Object&gt; listsStrings=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; person.size(); i++) &#123; listsStrings.add(person.get(i)); &#125; //2.指定类型 List&lt;StringBuffer&gt; lst=new ArrayList&lt;&gt;(); for(String string:person)&#123; lst.add(StringBuffer(string)); &#125; &#125; private static StringBuffer StringBuffer(String string) &#123; return null; &#125; &#125; 八、Set集合12345678910111213141516171819202122232425262728//对 set 的遍历 //1.迭代遍历： Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; String str = it.next(); System.out.println(str); &#125; //2.for循环遍历： for (String str : set) &#123; System.out.println(str); &#125; //优点还体现在泛型 假如 set中存放的是Object Set&lt;Object&gt; set = new HashSet&lt;Object&gt;(); //for循环遍历： for (Object obj: set) &#123; if(obj instanceof Integer)&#123; int aa= (Integer)obj; &#125;else if(obj instanceof String)&#123; String aa = (String)obj &#125; ........ &#125; 九、主要实现类区别小结Vector和ArrayList vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。 如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。 如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。 ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。 arraylist和linkedlist ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 HashMap与TreeMap HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。 在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 两个map中的元素一样，但顺序不一样，导致hashCode()不一样。同样做测试：在HashMap中，同样的值的map,顺序不同，equals时，false;而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。 HashTable与HashMap 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。 HashMap允许存在一个为null的key，多个为null的value 。 hashtable的key和value都不允许为null。 Java IO流一、IO流概述概述： ​ IO流简单来说就是Input和Output流，IO流主要是用来处理设备之间的数据传输，java对于数据的操作都是通过流实现，而java用于操作流的对象都在IO包中。 分类： ​ 按操作数据分为：字节流和字符流。 如：Reader和InpurStream ​ 按流向分：输入流和输出流。如：InputStream和OutputStream IO流常用的基类： ​ * InputStream ， OutputStream 字符流的抽象基类： ​ * Reader ， Writer 由上面四个类派生的子类名称都是以其父类名作为子类的后缀： ​ 如：FileReader和FileInputStream 二、字符流1. 字符流简介：* 字符流中的对象融合了编码表，也就是系统默认的编码表。我们的系统一般都是GBK编码。 * 字符流只用来处理文本数据，字节流用来处理媒体数据。 * 数据最常见的表现方式是文件，字符流用于操作文件的子类一般是FileReader和FileWriter。 2.字符流读写：注意事项： 写入文件后必须要用flush()刷新。 用完流后记得要关闭流 使用流对象要抛出IO异常 ​ 定义文件路径时，可以用“/”或者“\”。 在创建一个文件时，如果目录下有同名文件将被覆盖。 在读取文件时，必须保证该文件已存在，否则出异常 ​ 示例1：在硬盘上创建一个文件,并写入一些文字数据 123456789101112131415161718192021class FireWriterDemo &#123; public static void main(String[] args) throws IOException &#123; //需要对IO异常进行处理 //创建一个FileWriter对象，该对象一被初始化就必须要明确被操作的文件。 //而且该文件会被创建到指定目录下。如果该目录有同名文件，那么该文件将被覆盖。 FileWriter fw = new FileWriter("F:\\1.txt");//目的是明确数据要存放的目的地。 //调用write的方法将字符串写到流中 fw.write("hello world!"); //刷新流对象缓冲中的数据，将数据刷到目的地中 fw.flush(); //关闭流资源，但是关闭之前会刷新一次内部缓冲中的数据。当我们结束输入时候，必须close(); fw.write("first_test"); fw.close(); //flush和close的区别：flush刷新后可以继续输入，close刷新后不能继续输入。 &#125;&#125; 示例2：FileReader的reade()方法. 要求：用单个字符和字符数组进行分别读取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class FileReaderDemo &#123; public static void main(String[] args) &#123; characters(); &#125;/*****************字符数组进行读取*********************/ private static void characters() &#123; try &#123; FileReader fr = new FileReader("Demo.txt"); char [] buf = new char[6]; //将Denmo中的文件读取到buf数组中。 int num = 0; while((num = fr.read(buf))!=-1) &#123; //String(char[] value , int offest,int count) 分配一个新的String,包含从offest开始的count个字符 sop(new String(buf,0,num)); &#125; sop('\n'); fr.close(); &#125; catch (IOException e) &#123; sop(e.toString()); &#125; &#125;/*****************单个字母读取*************************/ private static void singleReader() &#123; try &#123; //创建一个文件读取流对象，和指定名称的文件关联。 //要保证文件已经存在，否则会发生异常：FileNotFoundException FileReader fr = new FileReader("Demo.txt"); //如何调用读取流对象的read方法？ //read()方法，一次读取一个字符，并且自动往下读。如果到达末尾则返回-1 int ch = 0; while ((ch=fr.read())!=-1) &#123; sop((char)ch); &#125; sop('\n'); fr.close(); /*int ch = fr.read(); sop("ch=" + (char)ch); int ch2 = fr.read(); sop("ch2=" + (char)ch2); //使用结束注意关闭流 fr.close(); */ &#125; catch (IOException e) &#123; sop(e.toString()); &#125; &#125;/**********************Println************************/ private static void sop(Object obj) &#123; System.out.print(obj); &#125;&#125; 示例3：对已有文件的数据进行续写 1234567891011121314151617181920212223import java.io.*;class FileWriterDemo3 &#123; public static void main(String[] args) &#123; try &#123; //传递一个参数,代表不覆盖已有的数据。并在已有数据的末尾进行数据续写 FileWriter fw = new FileWriter("F:\\java_Demo\\day9_24\\demo.txt",true); fw.write(" is charactor table?"); fw.close(); &#125; catch (IOException e) &#123; sop(e.toString()); &#125; &#125;/**********************Println************************/ private static void sop(Object obj) &#123; System.out.println(obj); &#125;&#125; 练习： 将F盘的一个文件复制到E盘。 思考： 其实就是将F盘下的文件数据存储到D盘的一个文件中。 步骤： 1.在D盘创建一个文件，存储F盘中文件的数据。 2.定义读取流和F：盘文件关联。 3.通过不断读写完成数据存储。 4.关闭资源。 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.*;import java.util.Scanner;class CopyText &#123; public static void main(String[] args) throws IOException &#123; sop("请输入要拷贝的文件的路径:"); Scanner in = new Scanner(System.in); String source = in.next(); sop("请输入需要拷贝到那个位置的路径以及生成的文件名:"); String destination = in.next(); in.close(); CopyTextDemo(source,destination); &#125;/*****************文件Copy*********************/ private static void CopyTextDemo(String source,String destination) &#123; try &#123; FileWriter fw = new FileWriter(destination); FileReader fr = new FileReader(source); char [] buf = new char[1024]; //将Denmo中的文件读取到buf数组中。 int num = 0; while((num = fr.read(buf))!=-1) &#123; //String(char[] value , int offest,int count) 分配一个新的String,包含从offest开始的count个字符 fw.write(new String(buf,0,num)); &#125; fr.close(); fw.close(); &#125; catch (IOException e) &#123; sop(e.toString()); &#125; &#125;/**********************Println************************/ private static void sop(Object obj) &#123; System.out.println(obj); &#125;&#125; 三、缓冲区1. 字符流的缓冲区BufferedReader和BufferedWreiter 缓冲区的出现时为了提高流的操作效率而出现的. 需要被提高效率的流作为参数传递给缓冲区的构造函数 在缓冲区中封装了一个数组，存入数据后一次取出 BufferedReader示例： 读取流缓冲区提供了一个一次读一行的方法readline，方便对文本数据的获取。readline()只返回回车符前面的字符，不返回回车符。如果是复制的话，必须加入newLine()，写入回车符 newLine()是java提供的多平台换行符写入方法。 1234567891011121314151617181920212223import java.io.*;class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; //创建一个字符读取流流对象，和文件关联 FileReader rw = new FileReader("buf.txt"); //只要将需要被提高效率的流作为参数传递给缓冲区的构造函数即可 BufferedReader brw = new BufferedReader(rw); for(;;) &#123; String s = brw.readLine(); if(s==null) break; System.out.println(s); &#125; brw.close();//关闭输入流对象 &#125;&#125; BufferedWriter示例： 1234567891011121314151617181920212223242526272829303132import java.io.*;class BufferedWriterDemo &#123; public static void main(String[] args) throws IOException &#123; //创建一个字符写入流对象 FileWriter fw = new FileWriter("buf.txt"); //为了提高字符写入效率，加入了缓冲技术。 //只要将需要被提高效率的流作为参数传递给缓冲区的构造函数即可 BufferedWriter bfw = new BufferedWriter(fw); //bfw.write("abc\r\nde"); //bfw.newLine(); 这行代码等价于bfw.write("\r\n"),相当于一个跨平台的换行符 //用到缓冲区就必须要刷新 for(int x = 1; x &lt; 5; x++) &#123; bfw.write("abc"); bfw.newLine(); //java提供了一个跨平台的换行符newLine(); bfw.flush(); &#125; bfw.flush(); //刷新缓冲区 bfw.close(); //关闭缓冲区，但是必须要先刷新 //注意，关闭缓冲区就是在关闭缓冲中的流对象 fw.close(); //关闭输入流对象 &#125;&#125; 2.装饰设计模式 装饰设计模式：：：： 要求：自定义一些Reader类，读取不同的数据(装饰和继承的区别) MyReader //专门用于读取数据的类 MyTextReader MyBufferTextReader MyMediaReader MyBufferMediaReader MyDataReader MyBufferDataReader 如果将他们抽取出来，设计一个MyBufferReader，可以根据传入的类型进行增强 12345class MyBufferReader &#123;MyBufferReader (MyTextReader text) &#123;&#125; MyBufferReader (MyMediaReader media) &#123;&#125; MyBufferReader (MyDataReader data) &#123;&#125;&#125; 但是上面的类拓展性很差。找到其参数的共同类型，通过多态的形式，可以提高拓展性 1234class MyBufferReader extends MyReader&#123; private MyReader r; //从继承变为了组成模式 装饰设计模式 MyBufferReader(MyReader r) &#123;&#125;&#125; 优化后的体系： MyTextReader MyMediaReader MyDataReader MyBufferReader //增强上面三个。装饰模式比继承灵活， ​ 避免继承体系的臃肿。降低类与类之间的耦合性装饰类只能增强已有的对象，具备的功能是相同的。所以装饰类和被装饰类属于同一个体系 MyBuffereReader类： 自己写一个MyBuffereReader类，功能与BuffereReader相同 12345678910111213141516171819202122232425262728293031323334353637383940class MyBufferedReader1 extends Reader&#123; private Reader r; MyBufferedReader1(Reader r)&#123; this.r = r; &#125; //一次读一行数据的方法 public String myReaderline() throws IOException &#123; //定义一个临时容器，原BufferReader封装的是字符数组。 //为了演示方便。定义一个StringBuilder容器。最终要将数据变成字符串 StringBuilder sb = new StringBuilder(); int ch = 0; while((ch = r.read()) != -1) &#123; if(ch == '\r') continue; if(ch == '\n') //遇到换行符\n,返回字符串 return sb.toString(); else sb.append((char)ch); &#125; if(sb.length()!=0) //当最后一行不是以\n结束时候，这里需要判断 return sb.toString(); return null; &#125; /* 需要覆盖Reader中的抽象方法close()，read(); */ public void close()throws IOException &#123; r.close(); &#125; public int read(char[] cbuf,int off, int len)throws IOException &#123; //覆盖read方法 return r.read(cbuf,off,len); &#125; public void myClose() throws IOException&#123; r.close(); &#125;&#125; 四、字节流参考： http://blog.csdn.net/qq_28261343/article/details/52678681 Java 多线程JAVA多线程实现的四种方式 Java多线程实现方式主要有四种：继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程。 其中前两种方式线程执行完后都没有返回值，后两种是带返回值的。 继承Thread类创建线程Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。例如： 12345678910public class MyThread extends Thread &#123; public void run() &#123; System.out.println("MyThread.run()"); &#125; &#125; MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.start(); myThread2.start(); 实现Runnable接口创建线程如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口，如下： 12345public class MyThread extends OtherClass implements Runnable &#123; public void run() &#123; System.out.println("MyThread.run()"); &#125; &#125; 为了启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例： 123MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); thread.start(); 事实上，当传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run()，参考JDK源代码： 12345public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 实现Callable接口通过FutureTask包装器来创建Thread线程Callable接口（也只有一个方法）定义如下： 1234567891011121314151617181920public interface Callable&lt;V&gt; &#123; V call（） throws Exception; &#125; public class SomeCallable&lt;V&gt; extends OtherClass implements Callable&lt;V&gt; &#123; @Override public V call() throws Exception &#123; // TODO Auto-generated method stub return null; &#125;&#125;Callable&lt;V&gt; oneCallable = new SomeCallable&lt;V&gt;(); //由Callable&lt;Integer&gt;创建一个FutureTask&lt;Integer&gt;对象： FutureTask&lt;V&gt; oneTask = new FutureTask&lt;V&gt;(oneCallable); //注释：FutureTask&lt;Integer&gt;是一个包装器，它通过接受Callable&lt;Integer&gt;来创建，它同时实现了Future和Runnable接口。 //由FutureTask&lt;Integer&gt;创建一个Thread对象： Thread oneThread = new Thread(oneTask); oneThread.start(); //至此，一个线程就创建完成了。 使用ExecutorService、Callable、Future实现有返回结果的线程ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，有了这种特征就不需要再为了得到返回值而大费周折了。而且自己实现了也可能漏洞百出。 可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。 执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。 注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。 再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。 下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.*; import java.util.Date; import java.util.List; import java.util.ArrayList; / * 有返回值的线程 */ @SuppressWarnings("unchecked") public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println("----程序开始运行----"); Date date1 = new Date(); int taskSize = 5; // 创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(taskSize); // 创建多个有返回值的任务 List&lt;Future&gt; list = new ArrayList&lt;Future&gt;(); for (int i = 0; i &lt; taskSize; i++) &#123; Callable c = new MyCallable(i + " "); // 执行任务并获取Future对象 Future f = pool.submit(c); // System.out.println("&gt;&gt;&gt;" + f.get().toString()); list.add(f); &#125; // 关闭线程池 pool.shutdown(); // 获取所有并发任务的运行结果 for (Future f : list) &#123; // 从Future对象上获取任务的返回值，并输出到控制台 System.out.println("&gt;&gt;&gt;" + f.get().toString()); &#125; Date date2 = new Date(); System.out.println("----程序结束运行----，程序运行时间【" + (date2.getTime() - date1.getTime()) + "毫秒】"); &#125; &#125; class MyCallable implements Callable&lt;Object&gt; &#123; private String taskNum; MyCallable(String taskNum) &#123; this.taskNum = taskNum; &#125; public Object call() throws Exception &#123; System.out.println("&gt;&gt;&gt;" + taskNum + "任务启动"); Date dateTmp1 = new Date(); Thread.sleep(1000); Date dateTmp2 = new Date(); long time = dateTmp2.getTime() - dateTmp1.getTime(); System.out.println("&gt;&gt;&gt;" + taskNum + "任务终止"); return taskNum + "任务返回运行结果,当前任务时间【" + time + "毫秒】"; &#125; &#125; 代码说明： 上述代码中Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。 public static ExecutorService newFixedThreadPool(int nThreads) 创建固定数目线程的线程池。 public static ExecutorService newCachedThreadPool() 创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。 public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的Executor。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。 ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。 软件-注重思想、逻 Java反射机制详解​ Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。 1、关于Class​ 1、Class是一个类，一个描述类的类（也就是描述类本身），封装了描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性​ 2、对象照镜子后（反射）可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。​ 3、对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。​ 一个 Class 对象包含了特定某个类的有关信息。​ 4、Class 对象只能由系统建立对象​ 5、一个类在 JVM 中只会有一个Class实例 12345678910111213141516171819202122232425262728293031323334353637383940package com.java.reflection;public class Person &#123; String name; private int age; public Person() &#123; System.out.println("无参构造器"); &#125; public Person(String name, int age) &#123; System.out.println("有参构造器"); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 2、反射机制获取类有三种方法123456789101112131415161718192021/** * 反射机制获取类有三种方法 */@Testpublic void testGetClass() throws ClassNotFoundException &#123; Class clazz = null; //1 直接通过类名.Class的方式得到 clazz = Person.class; System.out.println("通过类名: " + clazz); //2 通过对象的getClass()方法获取,这个使用的少（一般是传的是Object，不知道是什么类型的时候才用） Object obj = new Person(); clazz = obj.getClass(); System.out.println("通过getClass(): " + clazz); //3 通过全类名获取，用的比较多，但可能抛出ClassNotFoundException异常 clazz = Class.forName("com.java.reflection.Person"); System.out.println("通过全类名获取: " + clazz);&#125; 通过类名: class com.java.reflection.Person 无参构造器 通过getClass(): class com.java.reflection.Person 通过全类名获取: class com.java.reflection.Person 3、利用newInstance创建对象：调用的类必须有无参的构造器123456789101112131415/** * Class类的newInstance()方法，创建类的一个对象。 */ @Test public void testNewInstance() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class clazz = Class.forName("com.java.reflection.Person"); //使用Class类的newInstance()方法创建类的一个对象 //实际调用的类的那个 无参数的构造器（这就是为什么写的类的时候，要写一个无参数的构造器，就是给反射用的） //一般的，一个类若声明了带参数的构造器，也要声明一个无参数的构造器 Object obj = clazz.newInstance(); System.out.println(obj); &#125; 无参构造器Person{name=’null’, age=0} /** Class类的newInstance()方法，创建类的一个对象。 */ @Test public void testNewInstance() ​ throws ClassNotFoundException, IllegalAccessException, InstantiationException { ​ ​ Class clazz = Class.forName(“com.java.reflection.Person”); ​ ​ //使用Class类的newInstance()方法创建类的一个对象 ​ //实际调用的类的那个 无参数的构造器（这就是为什么写的类的时候，要写一个无参数的构造器，就是给反射用的） ​ //一般的，一个类若声明了带参数的构造器，也要声明一个无参数的构造器 ​ Object obj = clazz.newInstance(); ​ System.out.println(obj); } 4、ClassLoader类加载器类加载器详解：http://blog.csdn.net/ochangwen/article/details/51473120 12345678910111213141516171819202122232425262728/** * ClassLoader类装载器 */@Testpublic void testClassLoader1() throws ClassNotFoundException, IOException &#123; //1、获取一个系统的类加载器 ClassLoader classLoader = ClassLoader.getSystemClassLoader(); System.out.println("系统的类加载器--&gt;" + classLoader); //2、获取系统类加载器的父类加载器(扩展类加载器（extensions classLoader）) classLoader = classLoader.getParent(); System.out.println("扩展类加载器--&gt;" + classLoader); //3、获取扩展类加载器的父类加载器 //输出为Null,无法被Java程序直接引用 classLoader = classLoader.getParent(); System.out.println("启动类加载器--&gt;" + classLoader); // //4、测试当前类由哪个类加载器进行加载 ,结果就是系统的类加载器 classLoader = Class.forName("com.java.reflection.Person").getClassLoader(); System.out.println("当前类由哪个类加载器进行加载--&gt;"+classLoader); //5、测试JDK提供的Object类由哪个类加载器负责加载的 classLoader = Class.forName("java.lang.Object").getClassLoader(); System.out.println("JDK提供的Object类由哪个类加载器加载--&gt;" + classLoader);&#125; 系统的类加载器–&gt;sun.misc.Launcher$AppClassLoader@43be2d65 扩展类加载器–&gt;sun.misc.Launcher$ExtClassLoader@7a9664a1 启动类加载器–&gt;null 当前类由哪个类加载器进行加载–&gt;sun.misc.Launcher$AppClassLoader@43be2d65 JDK提供的Object类由哪个类加载器加载–&gt;null getResourceAsStream方法1234567891011121314151617181920212223 @Test public void testGetResourceAsStream() throws ClassNotFoundException, IOException &#123; // 这么写的话，文件需要放到src目录下 // InputStream in = new FileInputStream("test.properties"); //5、关于类加载器的一个主要方法 //调用getResourceAsStream 获取类路径下的文件对应的输入流 InputStream in = this.getClass().getClassLoader() .getResourceAsStream("com/java/reflection/test.properties"); System.out.println("in: " +in); Properties properties = new Properties(); properties.load(in); String driverClass = properties.getProperty("dirver"); String jdbcUrl = properties.getProperty("jdbcUrl"); //中文可能会出现乱码，需要转换一下 String user = new String(properties.getProperty("user").getBytes("ISO-8859-1"), "UTF-8"); String password = properties.getProperty("password"); System.out.println("diverClass: "+driverClass); System.out.println("user: " + user); &#125; 5、Method: 对应类中的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Person &#123; private String name; private int age; //新增一个私有方法 private void privateMthod()&#123; &#125; public Person() &#123; System.out.println("无参构造器"); &#125; public Person(String name, int age) &#123; System.out.println("有参构造器"); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; /** * * @param age 类型用Integer，不用int */ public void setName(String name , int age)&#123; System.out.println("name: " + name); System.out.println("age:"+ age); &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930@Testpublic void testMethod() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; Class clazz = Class.forName("com.java.reflection.Person"); //1、得到clazz 对应的类中有哪些方法,不能获取private方法 Method[] methods =clazz.getMethods(); System.out.print(" getMethods: "); for (Method method : methods)&#123; System.out.print(method.getName() + ", "); &#125; //2、获取所有的方法(且只获取当着类声明的方法，包括private方法） Method[] methods2 = clazz.getDeclaredMethods(); System.out.print("\ngetDeclaredMethods: "); for (Method method : methods2)&#123; System.out.print(method.getName() + ", "); &#125; //3、获取指定的方法 Method method = clazz.getDeclaredMethod("setName",String.class);//第一个参数是方法名，后面的是方法里的参数 System.out.println("\nmethod : " + method); Method method2 = clazz.getDeclaredMethod("setName",String.class ,int.class);//第一个参数是方法名，后面的是方法里的参数 System.out.println("method2: " + method2); //4、执行方法！ Object obj = clazz.newInstance(); method2.invoke(obj, "changwen", 22);&#125; getMethods: toString, getName, setName, setName, setAge, getAge, wait, wait, wait, equals, hashCode, getClass, notify, notifyAll,getDeclaredMethods: toString, getName, setName, setName, setAge, getAge, privateMthod,method : public void com.java.reflection.Person.setName(java.lang.String)method2: public void com.java.reflection.Person.setName(java.lang.String,int)无参构造器name: changwenage:22]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java成神之路-JavaSE 面向对象和Java常用类（五）]]></title>
    <url>%2Fblog%2F56594.html</url>
    <content type="text"><![CDATA[Java成神之路-面向对象和Java常用类 java简介1.java是什么？java是一种高级的面向对象的程序设计语言 。 2.JVMJava Virtual Machine，是java程序跨平台的关键，不同的平台有不同的JVM，而java字节码不包含任何与平台相关的信息，不直接与平台交互，而是通过JVM间接与平台交互。应用程序在执行时，JVM加载字节码，将字节码解释成特定平台的机器码，让平台执行。 任何一个应用程序都必须转化为机器码，才能与计算机进行交互，如果机器码的来源依赖于具体的平台，那么这个应用程序就不能跨平台。而java应用程序运行时机器码由java体系的一部分JVM提供，不受平台的限制，所以实现了跨平台。 3.java程序运行过程程序员编写的源码经编译器编译转化为字节码，字节码被加载到JVM，由JVM解释成机器码在计算机上运行。 4.java版本针对不同的用途，java分为3个版本： Java SE：java的标准版，是其他版本的基础，主要用于开发桌面应用程序。 Java EE：java的企业版，主要用于开发企业级分布式网络程序。 Java ME：主要用于嵌入式系统开发。 5.JDKJava Develop Kits，使用java语言开发应用程序必备的工具包，主要包含包括了编译器、JVM、Java基础API等。 6.JREJava Run Environment，java运行所依赖的环境，包括JVM以及java基础API。 7.APIApplication Programming Interface，应用程序编程接口，是使用java语言编写应用程序的入口，包含源码、字节码帮助文档三部分。应用程序由一系列方法构成，方法有哪些要求？什么样的方法是编程语言接受的？API提供了一些基础的方法，程序员要实现某项功能必须遵循java语言规范，调用这些方法编写更高级的方法。 8.java特性 简单：java语言是从C++发展起来的，取消了C++中复杂难以掌握的部分，如指针。 面向对象：java语言的基础。java将一切问题都看做对象与对象之间的交互，将对象抽象成方法与属性的集合。 分布性：包含操作分布性与数据分布性两个方面。操作分布性是指由多个主机共同完成一项功能，数据分布性是分布在多台主机上的数据当做一个完成的整体处理。 跨平台：java语言编写的应用程序，不受平台限制，可以由一种平台迁移到另一种平台。 解释型：使用java语言编写的源码被转化为字节码，字节码只有被JVM解释成机器码才能被计算机执行。 安全性：java语言的底层设计可以有效避免非法操作。 健壮性：java提供了许多机制防止运行时出现严重错误，如编译时类型检查、异常处理。 多线程：java支持多线程，允许进程内部多个线程同时工作。 window系统安装java下载JDK首先我们需要下载java开发工具包JDK，下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html， 下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。 安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 C:\Program Files (x86)\Java\jdk1.8.0_91。 配置环境变量1.安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”； 2.选择”高级”选项卡，点击”环境变量”； 然后就会出现如下图所示的画面： 在”系统变量”中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。 变量设置参数如下： 变量名：JAVA_HOME 变量值：C:\Program Files (x86)\Java\jdk1.8.0_91 // 要根据自己的实际路径配置 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; //记得前面有个”.” 变量名：Path 变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 注意：在 Windows10 中，因为系统的限制，path 变量只可以使用 JDK 的绝对路径。%JAVA_HOME% 会无法识别，导致配置失败。如下所示： 12&gt; C:\Program Files (x86)\Java\jdk1.8.0_91\bin;C:\Program Files (x86)\Java\jdk1.8.0_91\jre\bin;&gt; JAVA_HOME 设置 PATH设置 CLASSPATH 设置 这是 Java 的环境配置，配置完成后，你可以启动 Eclipse 来编写代码，它会自动完成java环境的配置。 注意：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。 测试JDK是否安装成功1、”开始”-&gt;”运行”，键入”cmd”； 2、键入命令: java -version、java、javac 几个命令，出现以下信息，说明环境变量配置成功； Linux，UNIX，Solaris，FreeBSD环境变量设置环境变量PATH应该设定为指向Java二进制文件安装的位置。如果设置遇到困难，请参考shell文档。 例如，假设你使用bash作为shell，你可以把下面的内容添加到你的 .bashrc文件结尾: export PATH=/path/to/java:$PATH 流行JAVA开发工具正所谓工欲善其事必先利其器，我们在开发java语言过程中同样需要依款不错的开发工具，目前市场上的IDE很多，本文为大家推荐以下下几款java开发工具： Eclipse（推荐）:另一个免费开源的java IDE，下载地址： http://www.eclipse.org/ 选择 Eclipse IDE for Java Developers： Notepad++ : Notepad++ 是在微软视窗环境之下的一个免费的代码编辑器，下载地址： http://notepad-plus-plus.org/ Netbeans:开源免费的java IDE，下载地址： http://www.netbeans.org/index.html 使用 Eclipse 运行第一个 Java 程序演示如下所示： HelloWorld.java 文件代码： 1234public class HelloWorld &#123; public static void main(String []args) &#123; System.out.println("Hello World"); &#125;&#125; Java基本语言元素规则 命名规则 类名称：首字母大写，尽可能采取驼峰式命名:MaLin HelloWorld 命名标识符规范：数字、字母、下划线、$组成，但是不能以数字开头，不能是关键字或者保留字。 变量名称 ：首字母必须小写 常量：必须全大些 PI MAX 方法名称：首字母必须小写 严格区分大小写 以分号 ‘;’ 结束 数据类型基本数据类型（四类八种） 简单类型 第一类：整型 byte short int long 第二类：浮点型 float double 第三类：逻辑型 boolean(它只有两个值可取true false) 第四类：字符型 char 封装类型（数据类型转换简单类型） Byte Short Integer Long Float Double Character Boolean 基本类型只能按值传递，而每个基本类型对应的封装类是按引用传递的。 从性能上说java中的基本类型是在堆栈上创建的，而所有的对象类型都是在堆上创建的，（对象的引用在堆栈上创建） 引用类型 数组、 类（对象）、接口 说明： ​ 导包快捷键 ctrl+shift+o 变量、常量1. 语法：数据类型 变量名称 [= 值]; 12345char sex; //声明变量 sex = &apos;男&apos;;//初始化、赋值 int age = 10; float score = 93.2F; int x,y,z=20; final 数据类型 变量名称 [= 值]; final int X=1;先声明 、初始化 、使用 2. 类型之间的转换：2.1小——&gt;大：自动类型转换 123short y = 1;System.out.println(y);double x = y; System.out.println(x);—&gt;小： 强制类型转换 1234at score = 13;//13(int)--&gt;小，到 System.out.println(score); int rs = (int)score; // 0.3截取丢失 System.out.println(rs); 字符串类型String在java.lang.String1. 必须掌握： = = 、 equals() 字符串比较差别： 2. 熟练进行 简单类型字符串类型String.valueOf(参数) 任意类型+””字符串简单类型（封装类型：parseXxx()） 12345678public class Test2 &#123; public static void main(String[] args) &#123; float num = 3.1f; String str = String.valueOf(num); System.out.println(str);//3.1(String) num = Float.parseFloat(str) ; &#125;&#125; 3. 掌握：String类中常用功能 SN(序号) 方法描述 1 char charAt(int index)返回指定索引处的 char 值。 2 int compareTo(Object o)把这个字符串和另一个对象比较。 3 int compareTo(String anotherString)按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str)按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str)将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb)当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data)返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count)返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix)测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject)将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString)将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName)使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)将字符从此字符串复制到目标字符数组。 15 int hashCode()返回此字符串的哈希码。 16 int indexOf(int ch)返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex)返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex)返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex)返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str)返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length()返回此字符串的长度。 26 boolean matches(String regex)告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar)返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit)根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix)测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset)测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex)返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray()将此字符串转换为一个新的字符数组。 40 String toLowerCase()使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase()使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale)使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim()返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x)返回给定data type类型x参数的字符串表示形式。 频繁的操作字符串：不建议使用String类，而是使用StringBuilder &amp; StringBuffer 运算符1. 算术运算符双目： * / %(取余、求模) + -单目： ++ –a 前缀（num++;） 1234int num = 4; ++num; int rs = ++num*2; System.out.println(rs);//? b 后缀 123456int num = 4; int x = 3; num++;//5 int rs = num++ +x; //rs = 8 num=6 System.out.println(rs++);//? System.out.println(rs); 2. 关系运算符：true/false &lt; &gt;= &lt;= ==(恒等于) !=逻辑运算符：true/false！（取反） &amp;&amp;（短路且） ||（短路或） 123int x=3,y=4,z=10;boolean rs = x&gt;y&amp;&amp;++z&gt;10;// true / falseSystem.out.println(z); 算符 =3. 赋值运算符赋值运算符： =复合赋值运算符： += -= *= /= %= 1234int x = 5;// x = x + 10; x+=10; System.out.println(x); 4. 三目运算符：exp1 ? exp2 : exp3;exp1:true exp2;exp1:false exp3;5. 位运算符：~ 非 |或 &amp;与 ^异或按位~运算符：10100101=01011010按位&amp;运算符：1101&amp;1010=1000按位|运算符： 1101 | 1010= 1111按位异或运算符：1101 ^ 1010 = 01116. 位移运算符&lt;&lt; 3&lt;&lt;3=24 &gt;&gt;在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方7. 转义字符： 1234567\n 换行 \r 回车 \t 水平制表 \v 垂直 制表 \” “ \’ ‘ \ \ Java流程控制介绍Java流程控制包括顺序控制、条件控制和循环控制。 顺序控制，就是从头到尾依次执行每条语句操作。 条件控制，基于条件选择执行语句，比方说，如果条件成立，则执行操作A，或者如果条件成立，则执行操作A，反之则执行操作B。 循环控制，又称为回路控制，根据循环初始条件和终结要求，执行循环体内的操作。 分支结构: 顺序结构只能顺序执行，不能进行判断和选择，因此需要分支结构。 Java有两种分支结构： if语句 switch语句 Java中有三种主要的循环结构： while循环 do…while循环 for循环 笔记123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.hgd.study2;import java.util.Scanner;/** * java的流程控制：顺序结构 分之机构 循环结构 * * @author HuTiger 顺序结构：通过debug模式可以看出java程序的运行时顺序结构的 * * 分支结构：if语句 * */public class ProcessControl &#123; public static void main(String[] args) &#123; // IfStudy(); // SwitchCaseStudy(); // WhileStudy(); &#125; /* * IF语句 */ private static void IfStudy() &#123; /* * 根据条件表达的世界(true||false)来判断是否进入语句块 if(条件表达式)&#123; 语句块 &#125; 继续执行后面的语句 */ int i = 100; if (i &gt; 60) &#123; System.out.println(i); &#125; System.out.println("后面需要执行的语句"); /* * if else 语句 */ // system.in就是标准输入，可以获取从键盘输入的值 // 通过scanner(jdk提供给我们的工具)来处理获取到的数据 System.out.println("请输入分数!"); Scanner sc = new Scanner(System.in); int j = sc.nextInt();// 把用户输入的数赋值给j System.out.println("控制台获取到的值是：" + j); if (j &gt; 60) &#123; System.out.println("通过"); &#125; else &#123; System.out.println("没通过"); &#125; System.out.println("当if else 执行后需要执行的内容"); /* * if else if else if ...else */ // 场景：将一个5(score)分制分为 :5分的评价等级A 4==B 3==C 其他是D Scanner sca = new Scanner(System.in); int score = sca.nextInt(); if (score &gt;= 0 &amp;&amp; score &lt;= 5) &#123; if (score == 5) &#123; System.out.println("A"); &#125; else if (score == 4) &#123; System.out.println("B"); &#125; else if (score == 3) &#123; System.out.println("C"); &#125; else &#123; System.out.println("D"); &#125; &#125; else &#123; System.out.println("输入不合法"); &#125; /* * 练习：百分制系统 90-100 优秀 75-89 良好 60-74 合格 其他 不合格 */ Scanner scan = new Scanner(System.in); int score1 = scan.nextInt(); if (score1 &gt;= 0 &amp;&amp; score1 &lt;= 100) &#123; if (score1 &gt;= 90 &amp;&amp; score1 &lt;= 100) &#123; System.out.println("优秀"); &#125; else if (score1 &gt;= 75) &#123; System.out.println("良好"); &#125; else if (score1 &gt;= 60) &#123; System.out.println("合格"); &#125; else &#123; System.out.println("不合格"); &#125; &#125; else &#123; System.out.println("输入不合法"); &#125; &#125; /* * switch case */ private static void SwitchCaseStudy() &#123; /* * 分支语句：switch case key：需要比较的表达式 value：与表达式进行比较的值 * 执行流程：如果key和value比较的结果为true，那么将执行case部分的代码，case部分可以有多个 类似于else if 部分 * 区别是key和value之间的比较只能是== default部分是不满足以上任何去执行的代码 ，类似于else * * switch 后面括号中的表达式的值必须是符合byte，char，short，int类型的常量表达式 jdk1.7以后可以使用string * ，而不能用浮点型或long类型 * * switch(key) &#123; case value: break; default: break; &#125; */ // 场景：将一个5(score)分制分为 :5分的评价等级A 4==B 3==C 其他是D Scanner sc = new Scanner(System.in); int score = sc.nextInt(); switch (score) &#123; case 5: System.out.println("A"); break;// 标准写法 break不能少 跳出当前语句块，如果没有break会直接进入下一个case语句 case 4: System.out.println("B"); break; case 3: System.out.println("C"); break; default: System.out.println("D"); break; &#125; &#125; /* * while 循环和do while */ private static void WhileStudy() &#123; /* * 执行流程： 当条件表达式为true的时候进入代码块，执行需要执行的代码 当条件表达式为false的时候执行后面的语句 * * while(条件表达式)&#123; 需要执行的代码部分 &#125; 后面的语句 */ /* * 场景：输入1-100的整数分析：给输出的值一个变量I，当i在1-100之间的时候输出 */ int i = 1;// 循环的起点 while (i &lt;= 100) &#123; System.out.println(i); // 给出循环的步长 i++; &#125; System.out.println("打印结束"); /* * do while * * do&#123; * &#125;while(条件表达式) */ int a=1; do&#123;//语句块中的内容无论条件是否满足都会先执行一次 System.out.println(a); a++; &#125; while(a&lt;=0); &#125; /* * for循环 */ private static void ForStudy() &#123; /* * 场景：打印1-100 int i=1是循环的起点 i++ 循环的补偿 i&lt;=100 循环的条件 */ for (int i = 1; i &lt;= 100; i++) &#123; System.out.println(i); &#125; System.out.println("打印结束"); &#125;&#125; Java 数组数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。 Java 语言中提供的数组是用来存储固定大小的同类型元素。 你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，….，number99。 本教程将为大家介绍 Java 数组的声明、创建和初始化，并给出其对应的代码。 声明数组变量首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法： dataType[] arrayRefVar; // 首选的方法 或 dataType arrayRefVar[]; // 效果相同，但不是首选方法 注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。 实例 下面是这两种语法的代码示例： double[] myList; // 首选的方法 或 double myList[]; // 效果相同，但不是首选方法 创建数组Java语言使用new操作符来创建数组，语法如下： 1arrayRefVar = new dataType[arraySize]; 上面的语法语句做了两件事： 一、使用 dataType[arraySize] 创建了一个数组。 二、把新创建的数组的引用赋值给变量 arrayRefVar。 数组变量的声明，和创建数组可以用一条语句完成，如下所示： 1dataType[] arrayRefVar = new dataType[arraySize]; 另外，你还可以使用如下的方式创建数组。 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。 实例 下面的语句首先声明了一个数组变量 myList，接着创建了一个包含 10 个 double 类型元素的数组，并且把它的引用赋值给 myList 变量。 TestArray.java 文件代码： 123456789101112131415161718192021222324public class TestArray &#123; public static void main(String[] args) &#123; // 数组大小 int size = 10; // 定义数组 double[] myList = new double[size]; myList[0] = 5.6; myList[1] = 4.5; myList[2] = 3.3; myList[3] = 13.2; myList[4] = 4.0; myList[5] = 34.33; myList[6] = 34.0; myList[7] = 45.45; myList[8] = 99.993; myList[9] = 11123; // 计算所有元素的总和 double total = 0; for (int i = 0; i &lt; size; i++) &#123; total += myList[i]; &#125; System.out.println("总和为： " + total); &#125;&#125; 以上实例输出结果为： 1总和为： 11367.373 下面的图片描绘了数组 myList。这里 myList 数组里有 10 个 double 元素，它的下标从 0 到 9。 处理数组数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 foreach 循环。 示例 该实例完整地展示了如何创建、初始化和操纵数组： TestArray.java 文件代码： 12345678910111213141516171819202122public class TestArray &#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 打印所有数组元素 for (int i = 0; i &lt; myList.length; i++) &#123; System.out.println(myList[i] + " "); &#125; // 计算所有元素的总和 double total = 0; for (int i = 0; i &lt; myList.length; i++) &#123; total += myList[i]; &#125; System.out.println("Total is " + total); // 查找最大元素 double max = myList[0]; for (int i = 1; i &lt; myList.length; i++) &#123; if (myList[i] &gt; max) max = myList[i]; &#125; System.out.println("Max is " + max); &#125;&#125; 以上实例编译运行结果如下： 1234561.92.93.43.5Total is 11.7Max is 3.5 foreach 循环JDK 1.5 引进了一种新的循环类型，被称为 foreach 循环或者加强型循环，它能在不使用下标的情况下遍历数组。 示例 该实例用来显示数组myList中的所有元素： TestArray.java 文件代码： 12345678910public class TestArray &#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 打印所有数组元素 for (double element: myList) &#123; System.out.println(element); &#125; &#125;&#125; 以上实例编译运行结果如下： 12341.92.93.43.5 数组作为函数的参数数组可以作为参数传递给方法。 例如，下面的例子就是一个打印 int 数组中元素的方法: 12345public static void printArray(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + " "); &#125;&#125; 下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2： printArray(new int[]{3, 1, 2, 6, 4, 2}); 数组作为函数的返回值12345678public static int[] reverse(int[] list) &#123; int[] result = new int[list.length]; for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) &#123; result[j] = list[i]; &#125; return result;&#125; 以上实例中 result 数组作为函数的返回值。 多维数组多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如： String str[][] = new String[3][4]; 多维数组的动态初始化（以二维数组为例） 直接为每一维分配空间，格式如下： type arrayName = new type[arraylenght1][arraylenght2]; type 可以为基本数据类型和复合数据类型，arraylenght1 和 arraylenght2 必须为正整数，arraylenght1 为行数，arraylenght2 为列数。 例如： int a[][] = new int[2][3]; 解析： 二维数组 a 可以看成一个两行三列的数组。 从最高维开始，分别为每一维分配空间，例如： 12345678String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String("Good");s[0][1] = new String("Luck");s[1][0] = new String("to");s[1][1] = new String("you");s[1][2] = new String("!"); 解析： s[0]=new String[2] 和 s[1]=new String[3] 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 s0=new String(“Good”) 等操作。 多维数组的引用（以二维数组为例）对二维数组中的每个元素，引用方式为 arrayName[index1][index2]，例如： num[1][0]; Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法,按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 具体说明请查看下表： 序号 方法和说明 1 public static int binarySearch(Object[] a, Object key)用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 2 public static boolean equals(long[] a, long[] a2)如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 3 public static void fill(int[] a, int val)将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 4 public static void sort(Object[] a)对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 笔记列表 数组倒序实例： 123456789101112131415161718192021public class Test2 &#123; public static void main(String[] args)&#123; int[] test= &#123;1,2,4,5,7&#125;; for (int i : test) &#123; System.out.print(i+&quot; &quot;); &#125; System.out.println(&quot;\n&quot;); test = Test2.reverse(test); for (int i : test) &#123; System.out.print(i+&quot; &quot;); &#125; &#125; public static int[] reverse(int[] arr)&#123; int[] result = new int[arr.length]; for (int i = 0,j=result.length-1; i &lt; arr.length; i++,j--) &#123; result[j] = arr[i]; &#125; return result; &#125;&#125; ​ 1234567891011// 声明二维数组：有两行，列数待定，数组结构 = &#123; &#123; &#125;, &#123; &#125; &#125;String s[][] = new String[2][]; // 确定每行的元素个数，第一行有2个元素，第二行有3个元素，// 数组结构 = &#123;&#123;&quot;E1&quot;, &quot;E2&quot;&#125;, &#123;&quot;E1&quot;, &quot;E2&quot;, &quot;E3&quot;&#125;&#125;s[0] = new String[2];s[1] = new String[3]; 实现数组和字符串的转换处理 123456789101112public class Test &#123; public static void main(String args[]) &#123; String str = &quot;helloworld&quot;; char[] data = str.toCharArray();// 将字符串转为数组 for (int x = 0; x &lt; data.length; x++) &#123; System.out.print(data[x] + &quot; &quot;); data[x] -= 32; System.out.print(data[x] + &quot; &quot;); &#125; System.out.println(new String(data)); &#125;&#125; 冒泡排序 123456789101112131415161718192021222324252627282930public class BubbleSort &#123;/** * N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数。 * @param args */ public static void main(String[] args) &#123; int arr[] = &#123;26,15,29,66,99,88,36,77,111,1,6,8,8&#125;; for(int i=0;i &lt; arr.length-1;i++) &#123;//外层循环控制排序趟数 for(int j=0; j&lt; arr.length-i-1;j++) &#123; //内层循环控制每一趟排序多少次 // 把小的值交换到前面 if (arr[j]&gt;arr[j+1]) &#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.print(&quot;第&quot;+(i+1)+&quot;次排序结果：&quot;); //列举每次排序的数据 for(int a=0;a&lt;arr.length;a++) &#123; System.out.print(arr[a] + &quot;\t&quot;); &#125; System.out.println(&quot;&quot;); &#125; System.out.println(&quot;最终排序结果：&quot;); for(int a = 0; a &lt; arr.length;a++) &#123; System.out.println(arr[a] + &quot;\t&quot;); &#125; &#125;&#125; 选择排序：（比冒泡排序更快，运行次数更少）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Start&#123; public static void main(String[] args) &#123; int[] arr=&#123;20,60,51,81,285,12,165,51,81,318,186,9,70&#125;; for(int a:arr) &#123; System.out.print(a+&quot; &quot;); &#125; System.out.println(&quot;\n&quot;+&quot;---------------从大到小---------------&quot;); arr=toSmall(arr); for(int a:arr) &#123; System.out.print(a+&quot; &quot;); &#125; System.out.println(&quot;\n&quot;+&quot;---------------从小到大---------------&quot;); arr=toBig(arr); for(int a:arr) &#123; System.out.print(a+&quot; &quot;); &#125; &#125;// 从大到小 public static int[] toSmall(int[] arr) &#123;//遍历数组里除最后一个的其他所有数，因为最后的对象没有与之可以相比较的数 for(int i=0;i&lt;arr.length-1;i++) &#123;/*遍历数组里没有排序的所有数，并与上一个数进行比较 *“k=i+1”因为自身一定等于自身，所以相比没有意义 *而前面已经排好序的数，在比较也没有意义 */ for(int k=i+1;k&lt;arr.length;k++) &#123; if(arr[k]&lt;arr[i])//交换条件（排序条件） &#123; int number=arr[i]; arr[i]=arr[k]; arr[k]=number; &#125;//交换 &#125; &#125; return arr; &#125;// 从小到大//和前面一样 public static int[] toBig(int[] arr) &#123; for(int i=0;i&lt;arr.length-1;i++) &#123; for(int k=i+1;k&lt;arr.length;k++) &#123; if(arr[k]&gt;arr[i]) &#123; int number=arr[i]; arr[i]=arr[k]; arr[k]=number; &#125; &#125; &#125; return arr; &#125;&#125; ​ java.util.Arrays类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能： ** 给数组赋值：通过fill方法。 ** 对数组排序：通过sort方法,按升序。 ** 比较数组：通过equals方法比较数组中元素值是否相等。 ** 查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Arrays;public class TestArrays &#123; public static void output(int[] array) &#123; if (array != null) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + &quot; &quot;); &#125; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int[] array = new int[5]; // 填充数组 Arrays.fill(array, 5); System.out.println(&quot;填充数组：Arrays.fill(array, 5)：&quot;); TestArrays.output(array); // 将数组的第2和第3个元素赋值为8 Arrays.fill(array, 2, 4, 8); System.out.println(&quot;将数组的第2和第3个元素赋值为8：Arrays.fill(array, 2, 4, 8)：&quot;); TestArrays.output(array); int[] array1 = &#123; 7, 8, 3, 2, 12, 6, 3, 5, 4 &#125;; // 对数组的第2个到第6个进行排序进行排序 Arrays.sort(array1, 2, 7); System.out.println(&quot;对数组的第2个到第6个元素进行排序进行排序：Arrays.sort(array,2,7)：&quot;); TestArrays.output(array1); // 对整个数组进行排序 Arrays.sort(array1); System.out.println(&quot;对整个数组进行排序：Arrays.sort(array1)：&quot;); TestArrays.output(array1); // 比较数组元素是否相等 System.out.println(&quot;比较数组元素是否相等:Arrays.equals(array, array1):&quot; + &quot;\n&quot; + Arrays.equals(array, array1)); int[] array2 = array1.clone(); System.out.println(&quot;克隆后数组元素是否相等:Arrays.equals(array1, array2):&quot; + &quot;\n&quot; + Arrays.equals(array1, array2)); // 使用二分搜索算法查找指定元素所在的下标（必须是排序好的，否则结果不正确） Arrays.sort(array1); System.out.println(&quot;元素3在array1中的位置：Arrays.binarySearch(array1, 3)：&quot; + &quot;\n&quot; + Arrays.binarySearch(array1, 3)); // 如果不存在就返回负数 System.out.println(&quot;元素9在array1中的位置：Arrays.binarySearch(array1, 9)：&quot; + &quot;\n&quot; + Arrays.binarySearch(array1, 9)); &#125;&#125; 输出结果： 12345678910111213141516填充数组：Arrays.fill(array, 5)：5 5 5 5 5 将数组的第2和第3个元素赋值为8：Arrays.fill(array, 2, 4, 8)：5 5 8 8 5 对数组的第2个到第6个元素进行排序进行排序：Arrays.sort(array,2,7)：7 8 2 3 3 6 12 5 4 对整个数组进行排序：Arrays.sort(array1)：2 3 3 4 5 6 7 8 12 比较数组元素是否相等:Arrays.equals(array, array1):false克隆后数组元素是否相等:Arrays.equals(array1, array2):true元素3在array1中的位置：Arrays.binarySearch(array1, 3)：1元素9在array1中的位置：Arrays.binarySearch(array1, 9)：-9 Java面向对象基础知识总结 面向对象将跟对象有关的功能都封装在其内 面向对象三大特征：封装，继承，多态 找对象，创建对象，使用对象，并维护对象之间的关系 类：对现实中事物的描述 对象：就是实实在在 存在的事物映射到java中，描述就是class定义的类具体对象就是对应java在堆内存new建立的实体 类与对象：设计图纸就是类，里面包含对象的描述：比如说车的颜色，轮胎数，发动机…. Note：对象建立的时候，属性值都会先置为null，显式初始化后才会变成具体的值 成员变量VS局部变量根据定义变量位置的不同，可以将变量分为成员变量和局部变量 成员变量是在类范围内定义的变量 局部变量是在一个方法内定义的变量 成员变量可以分为： 实例属性 （不用static修饰） 随着实例属性的存在而存在 类属性 （static修饰）随着类的存在而存在 成员变量无需显式初始化，系统会自动对其进行默认初始化 局部变量可分为： 形参（形式参数）//在整个方法内有效 方法局部变量 （方法内定义）// 从定义这个变量开始到方法结束这一段时间内有效 代码块局部变量 （代码块内定义） //从定义这个变量开始到代码块结束这一段时间内有效 局部变量除了形参外，都必须显示初始化，也就是要指定一个初始值，否则不能访问。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package object;/ * 成员变量和局部变量 * * */public class VariableTest &#123; //成员变量 public static String staticname = "类属性"; public String nostaticname = "实例属性"; //没有初始化的成员变量 public static String staticname1; public String nostaticname1; //定义一个方法 public void info()&#123; //在方法中定义一个局部变量i //int i; //直接输出是输出不出来的，因为没有初始化 //System.out.println(i); //定义一个局部变量i并初始化 int i = 10; //输出i System.out.println(i); &#125; //定义了一个静态的方法 public static void infos()&#123; int i = 20; System.out.println(i); &#125; public static void main(String[] args) &#123; /*第一问：类属性和实例属性的范围一样吗？*/ //在没创建实例之前 可以调用类属性,但不能调用实例属性 System.out.println(VariableTest.staticname);//结果：类属性 //实例化对象之后,就可以调用实例属性了 VariableTest vt = new VariableTest(); System.out.println(vt.nostaticname);//结果：实例属性 /*--- 结论：在成员变量中，类属性的范围比实例属性大一点 ---*/ System.out.println("----------"); /*第二问：成员变量需要显性初始化吗？*/ //直接调用没有初始化的类属性 System.out.println(VariableTest.staticname1);//结果：null //用实例化对象调用没有初始化的实例属性 System.out.println(vt.nostaticname1);//结果：null /*--- 结论：成员变量会自动隐性初始化，赋给变量一个默认值 ---*/ System.out.println("----------"); /*第三问：如果用实例化后的对象去调用类属性会怎么样？*/ //vt.staticname; //这样会报错 //Syntax error, insert "VariableDeclarators" to complete LocalVariableDeclaration //翻译：语法错误,插入“变量声明符”来完成局部变量声明 /*为什么会报错。一开始我以为是因为eclipse出错了 *后来我直接用文本文档重写了一个test *编译文件后，报不是语句的错，然后我又试了一下 *VariableTest.staticname *也是报错，说明这种写法是不正确的，具体为什么有待研究*/ vt.staticname = "改变了的类属性"; //如果同时给类属性赋值，就不会报错...有警告 //The static field Variable Test.static name should be accessed in a static way //翻译：静态字段变量测试。静态的名字应该在一个静态方法访问 System.out.println(vt.staticname);//结果：改变了的类属性 //这样就不会报错，但是会有警告，同上↑ /*结论：用实例化后的对象调用类属性，格式正确的情况下，是可以调用的，但有警告 *通过对象调用类属性，同样可以改变类属性的值*/ System.out.println("----------"); //定义在方法中的局部变量 /*第四问：定义在方法中的局部变量，出了方法还能访问吗？*/ //调用方法 vt.info();//结果：10 //现在还能用info中的i吗？ //System.out.println(i); //报错：i cannot be resolved to a variable //翻译：i 不能转换成一个变量 /*结论：定义在方法中的局部变量，出了方法就不能被访问了*/ System.out.println("----------"); //定义在代码块中的局部变量 /*第五问：定义在代码块中的局部变量，出了代码块还能访问吗？*/ &#123; int j = 11; System.out.println(j);//结果：11 &#125; //出了代码块 //System.out.println(j); //同样报错，内容与上面的一样 /*定义在代码块中的局部变量，出了代码块就不能访问了*/ System.out.println("----------"); //后续：一个静态方法 infos();//结果：20 //这样依然报错 //System.out.println(i); &#125;&#125; java允许局部变量和成员变量重名，局部变量会覆盖成员变量的值 代码示例： 123456789101112131415161718192021222324252627282930313233343536package object;/ * 局部变量覆盖成员变量 * */public class VariableCover &#123; /*当实例变量与方法中的局部变量同名时， *局部变量的值会覆盖实例变量*/ //定义实例变量 public String city = "合肥"; private static String citys = "滁州"; //定义一个方法 public void function()&#123; String city = "蚌埠"; //输出 //方法中的同名局部变量会覆盖实例变量 System.out.println(city);//结果：蚌埠 //要想调用实例变量，可以用this System.out.println(this.city);//结果：合肥 &#125; public static void main(String[] args) &#123; String citys = "南京"; //方法中的同名局部变量会覆盖实例变量 System.out.println(citys);//结果：南京 //可以通过类名调用被覆盖的类属性 System.out.println(VariableCover.citys);//结果：滁州 String city = "上海"; System.out.println(city);//结果：上海 //这样也可以 System.out.println(new VariableCover().city);//结果：合肥 new VariableCover().function(); &#125;&#125; 匿名对象：没有定义名称的对象匿名对象的传值调用：调用结束后，在堆内存新生成的对象成为垃圾（无指向）,因此过一段时间就会被垃圾回收机制回收. new Car().run(); 封装隐藏对象的属性和实现细节，仅仅提供公共访问方式；关键字：private 权限修饰符，只在本类中有效私有只是封装的一种表现形式；一般情况下，把属性都隐藏，提供公共访问方式访问；对访问的数据进行操作，提高代码的健壮性。 对外提供公开的用于设置对象属性的public方法 ​ 设置set 获取get 在set方法中加入逻辑判断，过滤掉非法数据。 将所有的成员变量封装加上private，提供get、set方法 构造函数函数名和类名一致，不能用return；对象一建立就会调用构造函数，可以用于对特定对象进行初始化； 若类中没有定义构造函数，系统会默认加入一个空参数的构造函数；构造函数也可以私有化，私有化后不能使用该函数创建对象；如果所有构造函数都私有化，那么就不能创建对象；一般方法是对象调用才运行，可以被调用多次；构造代码块：给所有对象的共性进行初始化，对象一建立就运行，优先于构造函数执行 构造函数的最大作用就是创建对象时完成初始化，当我们在new一个对象并传入参数的时候，会自动调用构造函数并完成参数的初始化。 this代表当前调用对象（当变量前面加了this，该变量可以认为是成员变量） 当本类功能内部需要使用本类对象时，都用this来表示 static静态，修饰成员（包括变量和方法,不能修饰局部），表示共性数据可以被类名调用：类名.静态成员被所有对象共享，只占一块内存（方法区，共享区，数据区）随着类的加载而加载，随着类的消失而消失，生命周期最长优先于对象存在被所有对象所共享可以直接被类名调用（可以不创建对象） String name；//成员变量，实例变量，随着对象的建立而存在 static String country = “CN”;//静态变量，类变量 静态变量和成员变量的区别 存放位置： 实例变量随着对象的建立存在于堆内存中， 类变量随着类的加载存在于方法区中 生命周期： 实例变量随着对象消失而消失 类变量随着类消失而消失 使用注意事项： 静态方法只能访问静态成员 静态方法中不可以定义this, super关键字（因为静态有限于对象存在） 主函数是静态的，作为程序入口，可以被jvm调用 利： 对共享数据进行单独空间存储，节省空间. 可以直接被类名调用 弊： 生命周期过长，访问出现局限性（只能访问静态） public static void main(String[] args)解析： /* public：代表这该函数访问权限最大 static：代表主函数随着类的加载就已经存在 void：没有返回值 main:特殊单词，可以被jvm识别 String[] args:参数是一个数组，该数组中的元素是字符串 */ 静态变量：当对象中出现共享数据时 静态函数： 当功能内部没有访问到非静态数据时 若编译时，当前调用的class不存在时，会先去当前目录下找相应的java文件，如果有，则会直接编译，生成class文件 静态代码块：随着类的加载而执行，只执行一次，优先于主函数 用于给类进行初始化 构造代码块会执行多次； 运行顺序：静态代码块，构造代码块，构造函数 一个对象的建立过程： Person p= new Person(“zhangsan”,20); 找到Person.class文件并加载到内存中 执行static代码块 在堆内存中开辟空间，分配内存地址（main函数开始） 在堆内存中建立对象的特有属性，并进行默认初始化 对属性进行显示初始化 对对象进行构造代码块初始化 对对象进行对应的构造函数初始化 将内存地址赋值给栈内存中的p变量 初始化过程：默认初始化，显式初始化，构造初始化 继承将类的共有属性提取出来，将之变为超类，父类提高了代码复用性、让类与类之间产生了关系，因此有了多态的特性，只支持单继承，不支持多继承。 （容易带来安全隐患：当多个父类中定义了相同功能，但内容不同时，子类不确定执行哪个功能） 但是java保留了这种机制，并用另一种体现形式来完成表示(接口的多实现);java支持多层继承，爷爷类-父亲类-孙子类，也叫做继承体系;在具体调用时，只需创建最子类的对象；父类可能不能创建对象;创建子类对象可以使用更多功能，包括共有的和特有的;查阅父类功能，创建子类对象使用功能; 聚集，聚合，组合 若子类和父类有同名变量： 子类访问本类中的变量，前面加this； 子类要访问父类的变量，前面加super； 若变量不同名，则this和super（如果父类中有该变量）指向同一个变量 若子类和父类中函数同名，则会使用子类的函数；父类的函数被覆盖（重写,overide） 沿袭父类功能，但是重写功能内容. 子类方法覆盖父类方法条件： 静态只能覆盖静态 必须保证子类权限大于父类,（父类的权限不能为(private)） public &gt;默认权限&gt;private 重载：只看参数列表 重写：两个方法需要一模一样(包括返回值，参数类型) 子类和父类的构造函数：绝对不能重写！ 父类先于子类加载，因为在子类的所有构造函数之前都有一句隐世的super()（空参数的父类构造函数）； 父类中若有空参数的父类构造函数，子类中的构造函数可以不写super(); 父类中若没有空参数的构造函数，则子类的每个构造函数第一句需要显式的写明super(XXX); 父类中的数据子类可以直接获取，子类对象在建立时，需要先查看父类是如何对这些数据进行初始化的； 因此子类在对象初始化时，要先访问父类中的构造函数。 this();或者super();都只能写在第一行，只能存在一个. 子类中至少有一个构造函数会访问父类中的构造函数； extends Object（所有类的上帝，默认父类） final修饰类，函数，变量 被修饰的类不可以被继承 被修饰的方法不可以被复写 被修饰的变量是一个常量，只能赋值一次，可以修饰成员变量和局部变量 所有字母都大写 修饰类：public final 抽象类和抽象方法abstract class Student//抽象方法必须存在于抽象类中，不能用该类创建对象，因为没有意义 { abstract void study();//抽象方法，内容待定，要被使用，必须有子类复写该方法 } 子类如果不覆盖所有的抽象方法，则子类还是一个抽象类 父类可以强制子类执行抽象方法； 抽象类和一般类：抽象类多了一些不确定的功能（抽象方法），需要子类具体执行 接口Interface,不能创建对象 特点： 1.所以变量都是public static final 2.所有方法都是public abstract class interfaceTest implements Interface1 接口可以被类多实现，一个类中可以实现多个interface：因为多个接口的方法都没有主体； 一个类在继承一个父类的同时，可以实现多个接口； 接口之间可以继承，并且一个接口可以继承多个接口 接口的特点：降低了耦合性 多态函数的多态体现：重载和覆盖 多态的体现： 父类的引用指向了自己的子类对象 父类的引用也可以接受自己的子类对象 多态的前提： 类与类有关系，要么是继承，要么是实现; 存在覆盖; 多态的好处： 提高了程序的扩展性，但是只能使用父类的引用访问父类中的成员 多态的应用: 多态中（非静态）成员函数的特点： 编译时期：参阅引用型变量所属的类中是否有调用的方法，如果有，则编译可以通过 运行时期：参阅对象所属类中是否有调用方法 Fu z = new zi(); 编译时，看左边的Fu类 运行时，看右边的zi类 面试注意点： 多态中成员变量和（静态）成员函数的特点： 无论编译或运行，都参考左边 静态绑定，只看引用，只参考左边； 动态绑定， 如果每个子类每次都要调用父类中的共性方法，可以在主函数中或者一个类中创建一个共性方法， 参数以父类对象为准，调用的时候只需要将子类对象传入即可. object类：所有类的直接或间接父类 内部类在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。 内部类不用建立对象就可以访问外部类的成员变量和函数，包括私有；外部类要访问内部类，必须建立内部类对象；建立在非所属类中时，需先建立外部类，Outer.Inner in = new Outer().new Inner();内部类可以私有 内部类访问外部类成员变量 Outer.this.x。 注意：当内部类中定义了静态成员，则该内部类必须也是静态的 当外部类中的静态方法访问内部类时，内部类也必须是静态的 局部内部类不能静态 内部类定义在局部时，不可以被成员修饰符修饰 可以直接访问外部类中的成员 但是不可以访问所在局部中的变量，只能访问被final修饰的局部变量 成员修饰符(Static,private…)只能修饰成员变量 匿名内部类： 前提，内部类必须是继承一个类或者实现接口 123456789101112131415abstract class Absdemo&#123; abstract void show();&#125; class Outer&#123; ... public void function()&#123; new Absdemo()//这是一个Absdemo的一个匿名子类对象 &#123; void show()&#123; System.out.println("匿名内部类！")； &#125; &#125;.show(); &#125;...&#125; 格式：new 父类或者接口(){定义子类内容}； 其实匿名内部类是一个匿名子类对象，而且这个对象是带有内容的 匿名内部类中定义的方法最好不要超过3个(方法比较多的话就直接创建一个有名字的子类) 内部类参考: https://www.cnblogs.com/dolphin0520/p/3811445.html Java常用类——Object的通用方法Java类层次结构的顶层是Object类，所有的其他类都隐式的继承于它。因此，所有的类也都从Object中继承了方法，其中最重要的几个方法如下表： 方法 描述 protected Object clone() 创建并返回当前对象的一份拷贝 protected void finalize() 当垃圾回收器判断出该对象不再被引用时，就会调用finalize()方法。在对象的创建与销毁中有对finalizers的介绍。 boolean equals(Object obj) 判断另外一个对象是否与当前对象相等 int hasCode() 返回当前对象的哈希值 String toString() 返回一个表示当前对象的字符串 void notify() 唤醒一个等待当前对象的锁监视器的线程。我们将会在第9篇文章并发最佳实践中详细介绍此方法 void notifyAll() 唤醒所有等待当前对象的锁监视器的线程。我们将会在第9篇文章并发最佳实践中详细介绍此方法 void wait() void wait(long timeout) void wait(long timeout, int nanos) 使当前线程进入等待状态直到其他线程调用了当前对象的notify()或notifyAll()方法。我们将会在第9篇文章并发最佳实践中详细介绍此方法 表1 重点介绍equals、hashCode、toString和clone方法。 equlas和hashCode方法默认情况下，Java 中任何两个对象引用(或类实例引用)只有指向相同的内存地址时才认为是相等的(引用相等)。但是Java允许通过重载Object的equals()方法给类自定义判等规则。听起来这是个很强大的概念，然而在适当的equals()方法实现需要满足以下几个规则限制： 自反性：对象x必须与其自身相等，equals(x)返回true 对称性：如果equals(y)为true，则y.equals(x)也要返回true 传递性：如果equals(y)为true，并且y.equals(z)也为true，则x.equals(z)也要为true 一致性：多次调用equals()方法应该返回相同值，除非对用于判等的任何一个属性进行了修改 与null判等：equals(null)总是要返回false 不幸的是Java编译器并不会在编译时对以上规则进行检查。然而，不遵守上述规则时可能会引入非常怪异并难以解决的问题。通用的建议是：如果需要重写equals()方法，请至少思考两次重写的必要性。遵循以上规则，我们为Person类重写一个简单的equals()实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.javacodegeeks.advanced.objects;public class Person &#123; private final String firstName; private final String lastName; private final String email; public Person( final String firstName, final String lastName, final String email ) &#123; this.firstName = firstName; this.lastName = lastName; this.email = email; &#125; public String getEmail() &#123; return email; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; // Step 0: Please add the @Override annotation, it will ensure that your // intention is to change the default implementation. @Override public boolean equals( Object obj ) &#123; // Step 1: Check if the 'obj' is null if ( obj == null ) &#123; return false; &#125; // Step 2: Check if the 'obj' is pointing to the this instance if ( this == obj ) &#123; return true; &#125; // Step 3: Check classes equality. Note of caution here: please do not use the // 'instanceof' operator unless class is declared as final. It may cause // an issues within class hierarchies. if ( getClass() != obj.getClass() ) &#123; return false; &#125; // Step 4: Check individual fields equality final Person other = (Person) obj; if ( email == null ) &#123; if ( other.email != null ) &#123; return false; &#125; &#125; else if( !email.equals( other.email ) ) &#123; return false; &#125; if ( firstName == null ) &#123; if ( other.firstName != null ) &#123; return false; &#125; &#125; else if ( !firstName.equals( other.firstName ) ) &#123; return false; &#125; if ( lastName == null ) &#123; if ( other.lastName != null ) &#123; return false; &#125; &#125; else if ( !lastName.equals( other.lastName ) ) &#123; return false; &#125; return true; &#125; &#125; 在此部分介绍hashCode()方法并不是偶然的，至少要记住下面这条规则：任何时候重载equals()方法时，需要一并重载hashCode()方法。如果两个对象通过equals()方法判等时返回true，则每个对象的hashCode()方法需要返回相同的整数值（反过来并没有限制：如果两个对象通过equals()方法返回false，则hashCode()方法可以返回相同或不同的整数值）。下面看一下Person类的hashCode()方法： 12345678910111213// Please add the @Override annotation, it will ensure that your// intention is to change the default implementation.@Overridepublic int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ( ( email == null ) ? 0 : email.hashCode() ); result = prime * result + ( ( firstName == null ) ? 0 : firstName.hashCode() ); result = prime * result + ( ( lastName == null ) ? 0 : lastName.hashCode() ); return result;&#125; 为了避免得到不可预期的结果，尽可能在实现equals()和hashCode()方法时使用final字段，从而保证方法的结果不会受到字段变化的影响(尽管真实场景中未必发生)。 最后，要确保在实现equals()和hashCode()方法是使用相同的字段，以确保在不可预期的字段调整时保证这两个方法行为的一致性。 toString方法toString()是最让人感兴趣的方法，并且被重载的频率也更高。此方法的目的是提供对象(类实例)的字符串表现。如果对toString()方法重载恰当，能极大的简化debug难度和分析解决问题的过程。 默认情况下，toString()的结果仅仅返回以@符分隔的全类名与对象哈希值串，然而这个结果在大多场景下并没什么用途。如下： 1com.javacodegeeks.advanced.objects.Person@6104e2ee 我们来通过重写Person和toString()方法以使其输出更有用，下面是其中一种实例： 1234567// Please add the @Override annotation, it will ensure that your// intention is to change the default implementation.@Overridepublic String toString() &#123; return String.format( "%s[email=%s, first name=%s, last name=%s]", getClass().getSimpleName(), email, firstName, lastName );&#125; 现在我们在toString()方法中包含了Person的所有字段，然后执行下面的代码片段： 12final Person person = new Person( "John", "Smith", "john.smith@domain.com" );System.out.println( person.toString() ); 控制台中将输出以下结果： 1Person[email=john.smith@domain.com, first name=John, last name=Smith] 遗憾的是在Java标准库中对toString()方法实现的支持有限，不过还是有几个有用的方法：Objects.toString(), Arrays.toString() / Arrays.deepToString()。下面看一下Office类以及其toString()的实现。 123456789101112131415161718192021package com.javacodegeeks.advanced.objects;import java.util.Arrays;public class Office &#123; private Person[] persons; public Office( Person ... persons ) &#123; this.persons = Arrays.copyOf( persons, persons.length ); &#125; @Override public String toString() &#123; return String.format( "%s&#123;persons=%s&#125;", getClass().getSimpleName(), Arrays.toString( persons ) ); &#125; public Person[] getPersons() &#123; return persons; &#125;&#125; 相应的控制台输出如下(同时也有Person实例的字符串值)： 1Office&#123;persons=[Person[email=john.smith@domain.com, first name=John, last name=Smith]]&#125; Java社区实例了大量有用的类库以简化toString()的实现。其中广泛使用的有Google Guava的Objects.toStringHelper和Apache Commons Lang的ToStringBuilder clone方法如果举出Java中最声名狼藉的方法，当属clone()无疑。clone()方法的目的很简单——返回对象实例的拷贝，然而有一堆理由可证明其使用并不像听起来那么轻而易举。 首先，实现自定义的clone()方法时需要遵守Java文档)中列出的一系列约定。其次，在Object类中clone()方法被声明为protected，所以为了提高方法的可见性，在重载时需要声明为public并把返回值类型调整为重载类自身类型。再次，重载类需要实现Cloneable接口(尽管该接口作为一种声明，并未提供任何方法定义)，否则将会抛出CloneNotSupportedException异常。最后，在实现clone()方法时要先调用super.clone()然后再执行其他需要的动作。下面看一下Person类中的实现： 12345678public class Person implements Cloneable &#123; // Please add the @Override annotation, it will ensure that your // intention is to change the default implementation. @Override public Person clone() throws CloneNotSupportedException &#123; return ( Person )super.clone(); &#125;&#125; 上面的实现看起来简单直接，然而却隐藏着错误。当类实例的clone动作被执行时，未调用任何构造方法，后果将导致预料外的数据泄露。下面再看下Office类中的定义： 1234567891011121314151617181920package com.javacodegeeks.advanced.objects;import java.util.Arrays;public class Office implements Cloneable &#123; private Person[] persons; public Office( Person ... persons ) &#123; this.persons = Arrays.copyOf( persons, persons.length ); &#125; @Override public Office clone() throws CloneNotSupportedException &#123; return ( Office )super.clone(); &#125; public Person[] getPersons() &#123; return persons; &#125;&#125; 在这个实现中，Office实例克隆出来的所有对象都将共享相同的person数组，然而这并不是我们预期的行为。为了让clone()实现正确的行为，我们还要做一些额外的工作： 123456@Overridepublic Office clone() throws CloneNotSupportedException &#123; final Office clone = ( Office )super.clone(); clone.persons = persons.clone(); return clone;&#125; 看起来是正确了，但如果对persons字段声明为final就将破坏这种正确性，因此final字段不能被重新赋值，从而导致数据再次被共享。 总之，当需要类实例的拷贝时，尽可能避免使用clone() / Cloneable，相反可以选择其他更简单的替代方案(例如：C++程序员熟悉的复制构造方法，或者工厂方法——在对象的创建与销毁中讨论过的一种有用的构造模式)。 equals方法与”==”操作符在Java中，==操作符与equals()方法有种奇怪的关系，却会引入大量的问题与困惑。大多数情况下(除比较基本数据类型)，==操作符执行的是引用相等：只要两个引用指向同一个对象时为true，否则返回false。下面举例说明二者的区别： 123final String str1 = new String( "bbb" );System.out.println( "Using == operator: " + ( str1 == "bbb" ) );System.out.println( "Using equals() method: " + str1.equals( "bbb" ) ); 从我们人类的视角来看，str1 == “bbb” 和 str1.equals(“bbb”)并无区别：str1仅仅是”bbb”的一个引用，所以结果应该是相同的；但对于Java来说却不尽然： 12Using == operator: falseUsing equals() method: true 尽管两个字符串看起来完全一样，但事实上却是两个不同的String实例。作为建议，在处理对象引用时要使用equals()或Objects.equals()进行判等，除非你真的是要判断两个引用是否指向同一个实例。 有用的帮助类从Java 7发布以来，一批有用的帮助类加入到了标准Java库中，Objects便是其中之一。具体来说，以下三个方法可以简化你的equals()和hashCode()方法实现。 方法 描述 static boolean equals(Object a, Object b) 当参数中的两个对象相等时返回true，否则返回false static int hash(Object...values) 为参数列表生成哈希值 static int hashCode(Object o) 为非null参数生成哈希值，如果参数为null返回0 如果使用上面的方法来重写Person的equals()和hashCode()实现，代码量将会大大缩减，同时代码的可读性也将大大增强。 123456789101112131415161718192021222324252627282930@Overridepublic boolean equals( Object obj ) &#123; if ( obj == null ) &#123; return false; &#125; if ( this == obj ) &#123; return true; &#125; if ( getClass() != obj.getClass() ) &#123; return false; &#125; final PersonObjects other = (PersonObjects) obj; if( !Objects.equals( email, other.email ) ) &#123; return false; &#125; else if( !Objects.equals( firstName, other.firstName ) ) &#123; return false; &#125; else if( !Objects.equals( lastName, other.lastName ) ) &#123; return false; &#125; return true;&#125; @Overridepublic int hashCode() &#123; return Objects.hash( email, firstName, lastName );&#125; Java API ——StringBuffer类StringBuffer类概述 1）我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。而StringBuffer就可以解决这个问题 2）线程安全的可变字符序列 3）StringBuffer和String的区别 · 前者长度和内容可变，后者不可变。 ​ · 如果使用前者做字符串的拼接，不会浪费太多的资源。 构造方法​ StringBuffer 方法 以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s)将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end)移除此序列的子字符串中的字符。 4 public insert(int offset, int i)将 int 参数的字符串表示形式插入此序列中。 5 replace(int start, int end, String str)使用给定 String 中的字符替换此序列的子字符串中的字符。 下面的列表里的方法和 String 类的方法类似： 序号 方法描述 1 int capacity()返回当前容量。 2 char charAt(int index)返回此序列中指定索引处的 char 值。 3 void ensureCapacity(int minimumCapacity)确保容量至少等于指定的最小值。 4 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)将字符从此序列复制到目标字符数组 dst。 5 int indexOf(String str)返回第一次出现的指定子字符串在该字符串中的索引。 6 int indexOf(String str, int fromIndex)从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 7 int lastIndexOf(String str)返回最右边出现的指定子字符串在此字符串中的索引。 8 int lastIndexOf(String str, int fromIndex)返回 String 对象中子字符串最后出现的位置。 9 int length() 返回长度（字符数）。 10 void setCharAt(int index, char ch)将给定索引处的字符设置为 ch。 11 void setLength(int newLength)设置字符序列的长度。 12 CharSequence subSequence(int start, int end)返回一个新的字符序列，该字符序列是此序列的子序列。 13 String substring(int start)返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 14 String substring(int start, int end)返回一个新的 String，它包含此序列当前所包含的字符子序列。 15 String toString()返回此序列中数据的字符串表示形式。 12345678910111213141516171819202122public class StringBufferDemo01 &#123; public static void main(String[] args) &#123; // public StringBuffer():无参构造方法 StringBuffer sb = new StringBuffer(); System.out.println("sb:"+sb); System.out.println("sb.capacity:"+sb.capacity()); //16 System.out.println("sb.length:"+sb.length()); //0 System.out.println("--------------------------"); // public StringBuffer(int capacity):指定容量的字符串缓冲区对象 StringBuffer sb2 = new StringBuffer(50); System.out.println("sb2:"+sb2); System.out.println("sb2.capacity:"+sb2.capacity()); //50 System.out.println("sb2.length:"+sb2.length()); //0 System.out.println("--------------------------"); // public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 StringBuffer sb3 = new StringBuffer("hello"); System.out.println("sb3:"+sb3); //"hello" System.out.println("sb3.capacity:"+sb3.capacity()); //21 System.out.println("sb3.length:"+sb3.length());//5 System.out.println("--------------------------"); &#125;&#125; 注意返回值，可以查看源码，默认空间是16。 123456789101112131415161718192021222324252627282930/ * Constructs a string buffer with no characters in it and an * initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); &#125; / * Constructs a string buffer with no characters in it and * the specified initial capacity. * * @param capacity the initial capacity. * @exception NegativeArraySizeException if the &lt;code&gt;capacity&lt;/code&gt; * argument is less than &lt;code&gt;0&lt;/code&gt;. */ public StringBuffer(int capacity) &#123; super(capacity); &#125; / * Constructs a string buffer initialized to the contents of the * specified string. The initial capacity of the string buffer is * &lt;code&gt;16&lt;/code&gt; plus the length of the string argument. * * @param str the initial contents of the buffer. * @exception NullPointerException if &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; */ public StringBuffer(String str) &#123; super(str.length() + 16); append(str); &#125; StringBuffer类的成员方法添加功能​ · public StringBuffer append(String str)：可以把任意类型数据添加到字符串缓冲区里面，并返回字符串缓冲区本身 ​ · public StringBuffer insert(int offset,String str)：在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串缓冲区本身 12345678910111213141516171819202122232425public class StringBufferDemo02 &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); //返回对象本身 StringBuffer sb2 = sb.append("hello"); System.out.println("sb:"+sb); //sb:hello System.out.println("sb2:"+sb2); //sb2:hello System.out.println(sb == sb2); //true //一步一步的添加数据 StringBuffer sb3 = new StringBuffer(); sb3.append("hello"); sb3.append(true); sb3.append(12); sb3.append(34.56); System.out.println("sb3:"+sb3); //sb3:hellotrue1234.56 //链式编程 StringBuffer sb4 = new StringBuffer(); sb4.append("hello").append(true).append(12).append(34.56); System.out.println("sb4:"+sb4); //sb4:hellotrue1234.56 //StringBuffer insert(int offset,Stringstr):插入数据 sb3.insert(5,"hello"); System.out.println("sb3:"+sb3); //sb3:hellohellotrue1234.56 &#125;&#125; 删除功能​ · public StringBuffer deleteCharAt(int index)：删除指定位置的字符，并返回本身 ​ · public StringBuffer delete(int start,int end)：删除从指定位置开始指定位置结束的内容，并返回本身 12345678910111213141516171819202122232425public class StringBufferDemo03 &#123; public static void main(String[] args) &#123; // 创建对象 StringBuffer sb1 = new StringBuffer(); // 创建对象 sb1.append("hello").append("world").append("java"); System.out.println("sb1:"+sb1); //sb1:helloworldjava // public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身 // 需求：我要删除e这个字符 sb1.deleteCharAt(1); // 需求:我要删除第一个l这个字符 sb1.deleteCharAt(1); System.out.println("sb1:"+sb1); //sb1:hloworldjava System.out.println("----------------"); // public StringBuffer delete(int start,int end):删除从指定位置开始指定位置结束的内容，并返回本身 StringBuffer sb2 = new StringBuffer("Hello World Java"); System.out.println("sb2:"+sb2); //sb2:Hello World Java // 需求：我要删除World这个字符串 sb2.delete(5,11); System.out.println("sb2:"+sb2); //sb2:Hello Java // 需求:我要删除所有的数据 sb2.delete(0, sb2.length()); System.out.println("sb2:"+sb2); //sb2: &#125;&#125; 替换功能​ · public StringBuffer replace(int start,int end,String str)：使用给定String中的字符替换词序列的子字符串中的字符 123456789101112131415public class StringBufferDemo04 &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加数据 sb.append("hello"); sb.append("world"); sb.append("java"); System.out.println("sb:" + sb); //sb:helloworldjava // public StringBuffer replace(int start,int end,String str):从start开始到end用str替换 // 需求：我要把world这个数据替换为"节日快乐" sb.replace(5,10,"节日快乐"); System.out.println("sb:"+sb); //sb:hello节日快乐java &#125;&#125; 反转功能​ · public StringBuffer reverse()：将此字符序列用其反转形式取代，返回对象本身 123456789101112public class StringBufferDemo05 &#123; public static void main(String[] args) &#123; //创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); //添加数据 sb.append("林青霞爱我"); System.out.println("sb:"+sb); //sb:林青霞爱我 //public StringBuffer reverse() sb.reverse(); System.out.println("sb:"+sb); //sb:我爱霞青林 &#125;&#125; 截取功能​ · public String substring(int start)：返回一个新的String，它包含此字符序列当前所包含的字符子序列 ​ · public String substring(int start,int end)：返回一个新的String，它包含此序列当前所包含的字符子序列 ​ 注意：截取功能和前面几个功能的不同 ​ · 返回值类型是String类型，本身没有发生改变 123456789101112131415public class StringBufferDemo06 &#123; public static void main(String[] args) &#123; //创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); sb.append("hello").append("world").append("java"); System.out.println("sb:"+sb); //sb:helloworldjava //截取功能 String s = sb.substring(5); System.out.println("s:"+s); //s:worldjava System.out.println("sb:"+sb); //sb:helloworldjava String ss = sb.substring(5,10); System.out.println("ss:"+ss); //ss:world System.out.println("sb:"+sb); //sb:helloworldjava &#125;&#125; String与StringBuffer的相互转换12345678910111213141516171819202122232425public class StringBufferDemo07 &#123; public static void main(String[] args) &#123; //String --&gt; StringBuffer String s = "hello"; // 注意：不能把字符串的值直接赋值给StringBuffer // StringBuffer sb = "hello"; // StringBuffer sb = s; //方式一：通过构造方法 StringBuffer sb = new StringBuffer(s); //方式二：通过append方法 StringBuffer sb2 = new StringBuffer(); sb2.append(s); System.out.println("sb:"+sb); //sb:hello System.out.println("sb2:"+sb2); //sb2:hello System.out.println("-------------------------"); //StringBuffer --&gt; String StringBuffer buffer = new StringBuffer("java"); //方式一：通过构造方法 String str = new String(buffer); //方式二：通过toString()方法 String str2 = buffer.toString(); System.out.println("str:"+str); //str:java System.out.println("str2:"+str2); //str2:java &#125;&#125; 把数组拼接成一个字符串12345678910111213141516171819202122232425262728293031323334353637383940public class StringBufferDemo08 &#123; public static void main(String[] args) &#123; //定义一个数组 int[] arr = &#123;44,33,55,11,22&#125;; //定义功能 //方式一：用String做拼接的方式 String result1 = arrayToString1(arr); System.out.println("result1:"+result1); //result1:[44,33,55,11,22] //方式二：用StringBuffer做拼接的方式 String result2 = arrayToString2(arr); System.out.println("result2:"+result2); //result2:[44,33,55,11,22] &#125; public static String arrayToString1(int[] arr)&#123; String s = ""; s += "["; for(int x = 0; x &lt; arr.length; x++)&#123; if (x == arr.length - 1)&#123; s += arr[x]; &#125;else&#123; s += arr[x]; s += ','; &#125; &#125; s += ']'; return s; &#125; public static String arrayToString2(int[] arr)&#123; StringBuffer sb = new StringBuffer(); sb.append("["); for(int x = 0; x &lt; arr.length; x++)&#123; if (x == arr.length-1)&#123; sb.append(arr[x]); &#125;else&#123; sb.append(arr[x]).append(","); &#125; &#125; sb.append("]"); return sb.toString(); &#125;&#125; 把字符串反转1234567891011121314151617181920public class StringBufferDemo09 &#123; public static void main(String[] args) &#123; String s = "I love Java"; String result1 = myReverse1(s); System.out.println("result1:"+result1); //result1:avaJ evol I String result2 = myReverse2(s); System.out.println("result2:"+result2); //result2:avaJ evol I &#125; public static String myReverse1(String s)&#123; String result = ""; char[] ch = s.toCharArray(); for(int x = s.length()-1; x &gt;= 0; x--)&#123; result += ch[x]; &#125; return result; &#125; public static String myReverse2(String s)&#123; return new StringBuffer(s).reverse().toString(); &#125;&#125; 判断一个字符串是否是对称的12345678910111213141516171819202122232425public class StringBufferDemo10 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入一个字符串："); String str = sc.nextLine(); //abcba boolean result1 = isSymmertrical1(str); System.out.println("result1:"+result1); //result1:true boolean result2 = isSymmertrical2(str); //result2:true System.out.println("result2:"+result2); &#125; public static boolean isSymmertrical1(String s)&#123; boolean flag = true; char ch[] = s.toCharArray(); for(int start = 0, end = ch.length-1; start &lt;= end;start++,end--)&#123; if (ch[start] != ch[end])&#123; flag = false; break; &#125; &#125; return flag; &#125; public static boolean isSymmertrical2(String s)&#123; return new StringBuffer(s).reverse().toString().equals(s); &#125;&#125; 了解一下StringBuilder类​ 一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。 ​ 只要将StringBuffer的功能替换到StringBuilder就可以了。 String,StringBuffer,StringBuilder的区别 1）String是内容不可变的，而StringBuffer,StringBuilder都是内容可变的。 2）StringBuffer是同步的，数据安全,效率低;StringBuilder是不同步的,数据不安全,效率高 10、StringBuffer和数组的区别？ ​ A：二者都可以看出是一个容器，装其他的数据。 ​ B：但是呢，StringBuffer的数据最终是一个字符串数据。 ​ C：而数组可以放置多种数据，但必须是同一种数据类型的。 11、 ​ A：String作为参数传递 ​ B：StringBuffer作为参数传递 ​ 形式参数： 基本类型：形式参数的改变不影响实际参数 引用类型：形式参数的改变直接影响实际参数 ​ 注意： String作为参数传递，效果和基本类型作为参数传递是一样的。 123456789101112131415161718192021222324public class StringBufferDemo11 &#123; public static void main(String[] args) &#123; String s1 = "hello"; String s2 = "world"; System.out.println(s1 + "---" + s2);//hello---world change(s1, s2); System.out.println(s1 + "---" + s2);//hello---world StringBuffer sb1 = new StringBuffer("hello"); StringBuffer sb2 = new StringBuffer("world"); System.out.println(sb1 + "---" + sb2);//hello---world change(sb1, sb2); System.out.println(sb1 + "---" + sb2);//hello---worldworld &#125; //Stringz作为形参传递不会改变实参 public static void change(String s1, String s2) &#123; s1 = s2; s2 = s1 + s2; &#125; //StringBuffer作为形参，如果直接赋值则不会影响实参，但是如果是使用方法改变形参则会影响实参 public static void change(StringBuffer sb1, StringBuffer sb2) &#123; sb1 = sb2; sb2.append(sb1); &#125;&#125; Java 常用类——String类String类在java.lang包中，java使用String类创建一个字符串变量，字符串变量属于对象。java把String类声明的final类，不能有类。String类对象创建后不能修改，由0或多个字符组成，包含在一对双引号之间。 下面是 String 类支持的方法，更多详细，参看 Java String API 文档: SN(序号) 方法描述 1 char charAt(int index)返回指定索引处的 char 值。 2 int compareTo(Object o)把这个字符串和另一个对象比较。 3 int compareTo(String anotherString)按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str)按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str)将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb)当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data)返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count)返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix)测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject)将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString)将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName)使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)将字符从此字符串复制到目标字符数组。 15 int hashCode()返回此字符串的哈希码。 16 int indexOf(int ch)返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex)返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex)返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex)返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str)返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length()返回此字符串的长度。 26 boolean matches(String regex)告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar)返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit)根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix)测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset)测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex)返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray()将此字符串转换为一个新的字符数组。 40 String toLowerCase()使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase()使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale)使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim()返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x)返回给定data type类型x参数的字符串表示形式。 String类对象的创建字符串声明：String stringName;字符串创建：stringName = new String(字符串常量);或stringName = 字符串常量; String类构造方法 public String() 无参构造方法，用来创建空字符串的String对象。 1 String str1 = new String(); public String(String value)用已知的字符串value创建一个String对象。1 String str2 = new String(“asdf”); 2 String str3 = new String(str2); public String(char[] value)用字符数组value创建一个String对象。 121 char[] value = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;&#125;;2 String str4 = new String(value);//相当于String str4 = new String(&quot;abcd&quot;); public String(char chars[], int startIndex, int numChars)用字符数组chars的startIndex开始的numChars个字符创建一个String对象。 121 char[] value = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;&#125;;2 String str5 = new String(value, 1, 2);//相当于String str5 = new String(&quot;bc&quot;); public String(byte[] values)用比特数组values创建一个String对象。 121 byte[] strb = new byte[]&#123;65,66&#125;;2 String str6 = new String(strb);//相当于String str6 = new String(&quot;AB&quot;); String类常用方法 求字符串长度public int length()//返回该字符串的长度 121 String str = new String(&quot;asdfzxc&quot;);2 int strlength = str.length();//strlength = 7 求字符串某一位置字符public char charAt(int index)//返回字符串中指定位置的字符；注意字符串中第一个字符索引是0，最后一个是length()-1。 121 String str = new String(&quot;asdfzxc&quot;);2 char ch = str.charAt(4);//ch = z 提取子串用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数:1)public String substring(int beginIndex)//该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。2)public String substring(int beginIndex, int endIndex)//该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。 1231 String str1 = new String(&quot;asdfzxc&quot;);2 String str2 = str1.substring(2);//str2 = &quot;dfzxc&quot;3 String str3 = str1.substring(2,5);//str3 = &quot;dfz&quot; 字符串比较1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。2)public int compareToIgnore(String anotherString)//与compareTo方法相似，但忽略大小写。3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。 1234561 String str1 = new String(&quot;abc&quot;);2 String str2 = new String(&quot;ABC&quot;);3 int a = str1.compareTo(str2);//a&gt;04 int b = str1.compareTo(str2);//b=05 boolean c = str1.equals(str2);//c=false6 boolean d = str1.equalsIgnoreCase(str2);//d=true 字符串连接public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。 121 String str = &quot;aa&quot;.concat(&quot;bb&quot;).concat(&quot;cc&quot;);2 相当于String str = &quot;aa&quot;+&quot;bb&quot;+&quot;cc&quot;; 字符串中单个字符查找1)public int indexOf(int ch/String str)//用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。2)public int indexOf(int ch/String str, int fromIndex)//改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。3)public int lastIndexOf(int ch/String str)//该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。4)public int lastIndexOf(int ch/String str, int fromIndex)//该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。 1234561 String str = &quot;I am a good student&quot;;2 int a = str.indexOf(&apos;a&apos;);//a = 23 int b = str.indexOf(&quot;good&quot;);//b = 74 int c = str.indexOf(&quot;w&quot;,2);//c = -15 int d = str.lastIndexOf(&quot;a&quot;);//d = 56 int e = str.lastIndexOf(&quot;a&quot;,3);//e = 2 字符串中字符的大小写转换1)public String toLowerCase()//返回将当前字符串中所有字符转换成小写后的新串2)public String toUpperCase()//返回将当前字符串中所有字符转换成大写后的新串 1231 String str = new String(&quot;asDF&quot;);2 String str1 = str.toLowerCase();//str1 = &quot;asdf&quot;3 String str2 = str.toUpperCase();//str2 = &quot;ASDF&quot; 字符串中字符的替换1)public String replace(char oldChar, char newChar)//用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。2)public String replaceFirst(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。3)public String replaceAll(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。 123451 String str = &quot;asdzxcasd&quot;;2 String str1 = str.replace(&apos;a&apos;,&apos;g&apos;);//str1 = &quot;gsdzxcgsd&quot;3 String str2 = str.replace(&quot;asd&quot;,&quot;fgh&quot;);//str2 = &quot;fghzxcfgh&quot;4 String str3 = str.replaceFirst(&quot;asd&quot;,&quot;fgh&quot;);//str3 = &quot;fghzxcasd&quot;5 String str4 = str.replaceAll(&quot;asd&quot;,&quot;fgh&quot;);//str4 = &quot;fghzxcfgh&quot; 其他类方法1)String trim()//截去字符串两端的空格，但对于中间的空格不处理。 12341 String str = &quot; a sd &quot;;2 String str1 = str.trim();3 int a = str.length();//a = 64 int b = str1.length();//b = 4 2)boolean statWith(String prefix)或boolean endWith(String suffix)//用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。 1231 String str = &quot;asdfgh&quot;;2 boolean a = str.statWith(&quot;as&quot;);//a = true3 boolean b = str.endWith(&quot;gh&quot;);//b = true 3)regionMatches(boolean b, int firstStart, String other, int otherStart, int length)//从当前字符串的firstStart位置开始比较，取长度为length的一个子字符串，other字符串从otherStart位置开始，指定另外一个长度为length的字符串，两字符串比较，当b为true时字符串不区分大小写。4)contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。 1231 String str = &quot;student&quot;;2 str.contains(&quot;stu&quot;);//true3 str.contains(&quot;ok&quot;);//false 5)String[] split(String str)//将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。 121 String str = &quot;asd!qwe|zxc#&quot;;2 String[] str1 = str.split(&quot;!|#&quot;);//str1[0] = &quot;asd&quot;;str1[1] = &quot;qwe&quot;;str1[2] = &quot;zxc&quot;; 字符串与基本类型的转换 字符串转换为基本类型java.lang包中有Byte. Short、Integer、Float、Double类的调用方法：1)public static byte parseByte(String s)2)public static short parseShort(String s)3)public static short parseInt(String s)4)public static long parseLong(String s)5)public static float parseFloat(String s)6)public static double parseDouble(String s)例如： 1231 int n = Integer.parseInt(&quot;12&quot;);2 float f = Float.parseFloat(&quot;12.34&quot;);3 double d = Double.parseDouble(&quot;1.124&quot;); 基本类型转换为字符串类型String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。1)static String valueOf(char data[])2)static String valueOf(char data[], int offset, int count)3)static String valueOf(boolean b)4)static String valueOf(char c)5)static String valueOf(int i)6)static String valueOf(long l)7)static String valueOf(float f)8)static String valueOf(double d)例如： 121 String s1 = String.valueOf(12);2 String s1 = String.valueOf(12.34); 进制转换使用Long类中的方法得到整数之间的各种进制转换的方法：Long.toBinaryString(long l)Long.toOctalString(long l)Long.toHexString(long l)Long.toString(long l, int p)//p作为任意进制Java类——Math类 java.math.Math类常用的常量和方法12345678910111213141516171819202122232425262728293031323334Math.PI //记录的圆周率Math.E//记录e的常量Math.abs //求绝对值Math.sin //正弦函数 Math.asin 反正弦函数Math.cos //余弦函数 Math.acos 反余弦函数Math.tan //正切函数 Math.atan 反正切函数&amp;amp;nbsp;Math.atan2 商的反正切函数Math.toDegrees //弧度转化为角度 Math.toRadians 角度转化为弧度Math.ceil //得到不小于某数的最大整数Math.floor //得到不大于某数的最大整数例如：Math.floor(12.7) =12.0ceil()//是天花板，即向上取整。floor是地板，向下取整。round是四舍五入。Math.IEEEremainder //求余Math.max //求两数中最大Math.min //求两数中最小Math.sqrt //求开方Math.pow //求某数的任意次方, 抛出ArithmeticException处理溢出异常Math.sqrt(x)：//平方根Math.pow(x,y)：//x的y次方Math.exp //求e的任意次方Math.log10 //以10为底的对数Math.log //自然对数Math.rint //求距离某数最近的整数（可能比某数大，也可能比它小）Math.round //同上，返回int型或者long型（上一个函数返回double型）Math.random //返回0，1之间的一个随机数&lt;/p&gt;java.math.BigInteger(大整数)：BigInteger bi1=new BigInteger("1234567890123456890");BigInteger bi2=BigInteger.valueOf(123L);bi1=bi1.add(bi2);//b1+b2bi1=bi1.multiply(bi2);//b1*bbi1=bi1.subtract(bi2);//b1-b2bi1=bi1.divide(bi2);// b1/b2java.math.BigDecimal(大浮点数):BigDecimal bd = new BigDecimal("3.1415926");bd = bd.setScale(2,BigDecimal.ROUND_DOWN);//取3.1415926小数点后面二位 Java的Math类封装了很多与数学有关的属性和方法，大致如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(Math.E);//比任何其他值都更接近 e（即自然对数的底数）的 double 值。 System.out.println(Math.PI);//比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值。 /* * 1.abs绝对值函数 * 对各种数据类型求绝对值 */ System.out.println(Math.abs(-10));//输出10 /* * 2.三角函数与反三角函数 * cos求余弦 * sin求正弦 * tan求正切 * acos求反余弦 * asin求反正弦 * atan求反正切 * atan2(y,x)求向量(x,y)与x轴夹角 */ System.out.println(Math.acos(-1.0));//输出圆周率3.14... System.out.println(Math.atan2(1.0, 1.0));//输出 π/4 的小数值 /* * 3.开根号 * cbrt(x)开立方 * sqrt(x)开平方 * hypot(x,y)求sqrt(x*x+y*y)在求两点间距离时有用sqrt((x1-x2)^2+(y1-y2)^2) */ System.out.println(Math.sqrt(4.0));//输出2.0 System.out.println(Math.cbrt(8.0));//输出2.0 System.out.println(Math.hypot(3.0, 4.0));//输出5.0 /* * 4.最值 * max(a,b)求最大值 * min(a,b)求最小值 */ System.out.println(Math.max(1, 2));//输出2 System.out.println(Math.min(1.9, -0.2));//输出-0.2 /* * 5.对数 * log(a) a的自然对数(底数是e) * log10(a) a 的底数为10的对数 * log1p(a) a+1的自然对数 * 值得注意的是，前面其他函数都有重载，对数运算的函数只能传double型数据并返回double型数据 */ System.out.println(Math.log(Math.E));//输出1.0 System.out.println(Math.log10(10));//输出1.0 System.out.println(Math.log1p(Math.E-1.0));//输出1.0 /* * 6.幂 * exp(x) 返回e^x的值 * expm1(x) 返回e^x - 1的值 * pow(x,y) 返回x^y的值 * 这里可用的数据类型也只有double型 */ System.out.println(Math.exp(2));//输出E^2的值 System.out.println(Math.pow(2.0, 3.0));//输出8.0 /* * 7.随机数 * random()返回[0.0,1.0)之间的double值 * 这个产生的随机数其实可以通过*x控制 * 比如(int)(random*100)后可以得到[0,100)之间的整数 */ System.out.println((int)(Math.random()*100));//输出[0,100)间的随机数 /* * 8.转换 * toDegrees(a) 弧度换角度 * toRadians(a) 角度换弧度 */ System.out.println(Math.toDegrees(Math.PI));//输出180.0 System.out.println(Math.toRadians(180));//输出 π 的值 /* * 9.其他 */ //copySign(x,y) 返回 用y的符号取代x的符号后新的x值 System.out.println(Math.copySign(-1.0, 2.0));//输出1.0 System.out.println(Math.copySign(2.0, -1.0));//输出-2.0 //ceil(a) 返回大于a的第一个整数所对应的浮点数(值是整的，类型是浮点型) //可以通过强制转换将类型换成整型 System.out.println(Math.ceil(1.3443));//输出2.0 System.out.println((int)Math.ceil(1.3443));//输出2 //floor(a) 返回小于a的第一个整数所对应的浮点数(值是整的，类型是浮点型) System.out.println(Math.floor(1.3443));//输出1.0 //rint(a) 返回最接近a的整数的double值 System.out.println(Math.rint(1.2));//输出1.0 System.out.println(Math.rint(1.8));//输出2.0 //nextAfter(a,b) 返回(a,b)或(b,a)间与a相邻的浮点数 b可以比a小 System.out.println(Math.nextAfter(1.2, 2.7));//输出1.2000000000000002 System.out.println(Math.nextAfter(1.2, -1));//输出1.1999999999999997 //所以这里的b是控制条件 //nextUp(a) 返回比a大一点点的浮点数 System.out.println(Math.nextUp(1.2));//输出1.2000000000000002 //nextDown(a) 返回比a小一点点的浮点数 System.out.println(Math.nextDown(1.2));//输出1.1999999999999997 &#125;&#125; 另外，当我尝试这样使用数学类的时候是错误的： 1Math m = new Math();m.sqrt(4.0); 为什么呢？ 查了下Math的源码，惊呆了！它的构造方法居然是这样写的： 1private Math() &#123;&#125; 构造方法写成私有的 所以根本就不能创建对象。 Java中Date各种相关用法计算某一月份的最大天数Java代码 1Calendar time=Calendar.getInstance(); time.clear(); time.set(Calendar.YEAR,year); time.set(Calendar.MONTH,i-1);//注意,Calendar对象默认一月为0 int day=time.getActualMaximum(Calendar.DAY_OF_MONTH);//本月份的天数 注：在使用set方法之前，必须先clear一下，否则很多信息会继承自系统当前时间 Calendar和Date的转化(1) Calendar转化为Date Java代码 1Calendar cal=Calendar.getInstance(); Date date=cal.getTime(); (2) Date转化为Calendar Java代码 123Date date=new Date(); Calendar cal=Calendar.getInstance(); cal.setTime(date); 格式化输出日期时间Java代码 12Date date=new Date(); SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); System.out.println(df.format(date)); 计算一年中的第几星期(1)计算某一天是一年中的第几星期 Java代码 12345Calendar cal=Calendar.getInstance(); cal.set(Calendar.YEAR, 2006); cal.set(Calendar.MONTH, 8); cal.set(Calendar.DAY_OF_MONTH, 3); int weekno=cal.get(Calendar.WEEK_OF_YEAR); (2)计算一年中的第几星期是几号 Java代码 123456SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd"); Calendar cal=Calendar.getInstance(); cal.set(Calendar.YEAR, 2006); cal.set(Calendar.WEEK_OF_YEAR, 1); cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); System.out.println(df.format(cal.getTime())); 输出： 12006-01-02 add()和roll()的用法(1)add()方法 Java代码 1234567891011SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd"); Calendar cal=Calendar.getInstance(); cal.set(Calendar.YEAR, 2006); cal.set(Calendar.MONTH, 8); cal.set(Calendar.DAY_OF_MONTH, 3); cal.add(Calendar.DATE, -4); Date date=cal.getTime(); System.out.println(df.format(date)); cal.add(Calendar.DATE, 4); date=cal.getTime(); System.out.println(df.format(date)); 输出： 122006-08-302006-09-03 (2)roll方法 Java代码 123456789cal.set(Calendar.YEAR, 2006); cal.set(Calendar.MONTH, 8); cal.set(Calendar.DAY_OF_MONTH, 3); cal.roll(Calendar.DATE, -4); date=cal.getTime(); System.out.println(df.format(date)); cal.roll(Calendar.DATE, 4); date=cal.getTime(); System.out.println(df.format(date)); 输出： 122006-09-292006-09-03 可见，roll()方法在本月内循环，一般使用add()方法； 计算两个任意时间中间的间隔天数(1)传进Calendar对象 Java代码 12345678910111213141516171819/ *//计算两个时间之间相隔天数 * @param startday 开始时间 * @param endday 结束时间 * @return */ public int getIntervalDays(Calendar startday,Calendar endday)...&#123; //确保startday在endday之前 if(startday.after(endday))...&#123; Calendar cal=startday; startday=endday; endday=cal; &#125; //分别得到两个时间的毫秒数 long sl=startday.getTimeInMillis(); long el=endday.getTimeInMillis(); long ei=el-sl; //根据毫秒数计算间隔天数 return (int)(ei/(1000*60*60*24)); &#125; (2)传进Date对象 Java代码 12345678910111213141516171819/ *//计算两个时间之间相隔天数 * @param startday 开始时间 * @param endday 结束时间 * @return */ public int getIntervalDays(Date startday,Date endday)...&#123; //确保startday在endday之前 if(startday.after(endday))...&#123; Date cal=startday; startday=endday; endday=cal; &#125; //分别得到两个时间的毫秒数 long sl=startday.getTime(); long el=endday.getTime(); long ei=el-sl; //根据毫秒数计算间隔天数 return (int)(ei/(1000*60*60*24)); &#125; 同理，可以用相同的方法计算出任意两个时间相隔的小时数，分钟数，秒钟数等 注：以上方法是完全按时间计算，有时并不能令人满意，如： 12startday=&quot;2006-10-11 20:00:00&quot;endday=&quot;2006-10-12 8:00:00&quot; 计算结果为0，但是我们也许相让计算结果变为1，此时可以用如下方法实现： 在传参之前，先设定endday的时间，如： Java代码 1234endday.set(Calendar.HOUR_OF_DAY, 23); endday.set(Calendar.MINUTE, 59); endday.set(Calendar.SECOND, 59); endday.set(Calendar.MILLISECOND, 59); 这样再传进去startday,endday，则结果就如我们所愿了。不过，如果嫌以上方法麻烦，可以参考以下方法： (3)改进精确计算相隔天数的方法 Java代码 1234567891011121314151617public int getDaysBetween (Calendar d1, Calendar d2) ...&#123; if (d1.after(d2)) ...&#123; // swap dates so that d1 is start and d2 is end java.util.Calendar swap = d1; d1 = d2; d2 = swap; &#125; int days = d2.get(Calendar.DAY_OF_YEAR) - d1.get(Calendar.DAY_OF_YEAR); int y2 = d2.get(Calendar.YEAR); if (d1.get(Calendar.YEAR) != y2) ...&#123; d1 = (Calendar) d1.clone(); do ...&#123; days += d1.getActualMaximum(Calendar.DAY_OF_YEAR);//得到当年的实际天数 d1.add(Calendar.YEAR, 1); &#125; while (d1.get(Calendar.YEAR) != y2); &#125; return days; &#125; 获取系统当前时间Java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static String getSystemTime()&#123; Date date=new Date(); SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return df.format(date); &#125; //字符串转化成时间类型（字符串可以是任意类型，只要和SimpleDateFormat中的格式一致即可） java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("M/dd/yyyy hh:mm:ss a",java.util.Locale.US); java.util.Date d = sdf.parse("5/13/2003 10:31:37 AM"); SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String mDateTime1=formatter.format(d); //当前时间 Calendar cal = Calendar.getInstance(); // SimpleDteFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); SimpleDateFormat formatter =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss G E D F w W a E F"); String mDateTime=formatter.format(cal.getTime()); //1年前日期 java.util.Date myDate=new java.util.Date(); long myTime=(myDate.getTime()/1000)-60*60*24*365; myDate.setTime(myTime*1000); String mDate=formatter.format(myDate); //明天日期 myDate=new java.util.Date(); myTime=(myDate.getTime()/1000)+60*60*24; myDate.setTime(myTime*1000); mDate=formatter.format(myDate); //两个时间之间的天数 SimpleDateFormat myFormatter = new SimpleDateFormat("yyyy-MM-dd"); java.util.Date date= myFormatter.parse("2003-05-1"); java.util.Date mydate= myFormatter.parse("1899-12-30"); long day=(date.getTime()-mydate.getTime())/(24*60*60*1000); //加半小时 SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); java.util.Date date1 = format.parse("2002-02-28 23:16:00"); long Time=(date1.getTime()/1000)+60*30; date1.setTime(Time*1000); String mydate1=formatter.format(date1); //年月周求日期 SimpleDateFormat formatter2 = new SimpleDateFormat("yyyy-MM F E"); java.util.Date date2= formatter2.parse("2003-05 5 星期五"); SimpleDateFormat formatter3 = new SimpleDateFormat("yyyy-MM-dd"); String mydate2=formatter3.format(date2); //求是星期几 mydate= myFormatter.parse("2001-1-1"); SimpleDateFormat formatter4 = new SimpleDateFormat("E"); String mydate3=formatter4.format(mydate); &#125; 在 开发web应用中，针对不同的数据库日期类型，我们需要在我们的程序中对日期类型做各种不同的转换。若对应数据库数据是oracle的Date类型，即只 需要年月日的，可以选择使用java.sql.Date类型，若对应的是MSsqlserver数据库的DateTime类型，即需要年月日时分秒的，选 择java.sql.Timestamp类型 你可以使用dateFormat定义时间日期的格式，转一个字符串即可 Java代码 1234567891011121314151617181920212223package personal.jessica; import java.util.Date; import java.util.Calendar; import java.sql.Timestamp; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Locale; class Datetest&#123; / *method 将字符串类型的日期转换为一个timestamp（时间戳记java.sql.Timestamp） *@param dateString 需要转换为timestamp的字符串 *@return dataTime timestamp */ public final static java.sql.Timestamp string2Time(String dateString) throws java.text.ParseException &#123; DateFormat dateFormat; dateFormat = new SimpleDateFormat("yyyy-MM-dd kk:mm:ss.SSS", Locale.ENGLISH);//设定格式 //dateFormat = new SimpleDateFormat("yyyy-MM-dd kk:mm:ss", Locale.ENGLISH); dateFormat.setLenient(false); java.util.Date timeDate = dateFormat.parse(dateString);//util类型 java.sql.Timestamp dateTime = new java.sql.Timestamp(timeDate.getTime());//Timestamp类型,timeDate.getTime()返回一个long型 return dateTime; &#125; 将字符串类型的日期转换为一个Date（java.sql.Date）12345678910111213141516171819202122232425262728293031323334353637383940414243/ *method 将字符串类型的日期转换为一个Date（java.sql.Date） *@param dateString 需要转换为Date的字符串 *@return dataTime Date */ public final static java.sql.Date string2Date(String dateString) throws java.lang.Exception &#123; DateFormat dateFormat; dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH); dateFormat.setLenient(false); java.util.Date timeDate = dateFormat.parse(dateString);//util类型 java.sql.Date dateTime = new java.sql.Date(timeDate.getTime());//sql类型 return dateTime; &#125; public static void main(String[] args)&#123; Date da = new Date(); //注意：这个地方da.getTime()得到的是一个long型的值 System.out.println(da.getTime()); //由日期date转换为timestamp //第一种方法：使用new Timestamp(long) Timestamp t = new Timestamp(new Date().getTime()); System.out.println(t); //第二种方法：使用Timestamp(int year,int month,int date,int hour,int minute,int second,int nano) Timestamp tt = new Timestamp(Calendar.getInstance().get( Calendar.YEAR) - 1900, Calendar.getInstance().get( Calendar.MONTH), Calendar.getInstance().get( Calendar.DATE), Calendar.getInstance().get( Calendar.HOUR), Calendar.getInstance().get( Calendar.MINUTE), Calendar.getInstance().get( Calendar.SECOND), 0); System.out.println(tt); try &#123; String sToDate = "2005-8-18";//用于转换成java.sql.Date的字符串 String sToTimestamp = "2005-8-18 14:21:12.123";//用于转换成java.sql.Timestamp的字符串 Date date1 = string2Date(sToDate); Timestamp date2 = string2Time(sToTimestamp); System.out.println("Date:"+date1.toString());//结果显示 System.out.println("Timestamp:"+date2.toString());//结果显示 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; Java获取系统时间的年份 Java代码 12345678910111213141516public static String getYear()&#123; Calendar ca = Calendar.getInstance(); ca.setTime(new java.util.Date()); String year = ""+ca.get(Calendar.YEAR); return year; &#125; public void getYear()&#123; Calendar ca = Calendar.getInstance(); ca.setTime(new java.util.Date()); SimpleDateFormat simpledate = new SimpleDateFormat("yyyyMMdd"); String date = simpledate.format(ca.getTime()); int year = ca.get(Calendar.YEAR); int month = ca.get(Calendar.MONTH); int day = ca.get(Calendar.DAY_OF_MONTH); System.out.println(date+"||"+year+"||"+month+"||"+day); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java成神之路-jQuery和XML（四）]]></title>
    <url>%2Fblog%2F31297.html</url>
    <content type="text"><![CDATA[Java成神之路-jQuery和XML jQuery 的选择器1234$("#myELement")//选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 $("div")// 选择所有的div标签元素，返回div元素数组 $(".myClass") //选择使用myClass类的css的所有元素 $("*") //选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$("#myELement,div,.myclass") 层叠选择器1234$("form input") 选择所有的form元素中的input元素 $("#main &gt; *") 选择id值为main的所有的子元素 $("label + input") 选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素 $("#prev ~ div") 同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 基本过滤选择器123$("tr:first") 选择所有tr元素的第一个 $("tr:last") 选择所有tr元素的最后一个 $("input:not(:checked) + span") 过滤掉：checked的选择器的所有的input元素 1234567$("tr:even") 选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） $("tr:odd") 选择所有的tr元素的第1，3，5... ...个元素 $("td:eq(2)") 选择所有的td元素中序号为2的那个td元素 $("td:gt(4)") 选择td元素中序号大于4的所有td元素 $("td:ll(4)") 选择td元素中序号小于4的所有的td元素 $(":header") $("div:animated") 内容过滤选择器1234$("div:contains('John')") 选择所有div中含有John文本的元素 $("td:empty") 选择所有的为空（也不包括文本节点）的td元素的数组 $("div:has(p)") 选择所有含有p标签的div元素 $("td:parent") 选择所有的以td为父节点的元素数组 可视化过滤选择器12$("div:hidden") 选择所有的被hidden的div元素 $("div:visible") 选择所有的可视化的div元素 属性过滤选择器1234567$("div[id]") 选择所有含有id属性的div元素 $("input[name='newsletter']") 选择所有的name属性等于'newsletter'的input元素 $("input[name!='newsletter']") 选择所有的name属性不等于'newsletter'的input元素 $("input[name^='news']") 选择所有的name属性以'news'开头的input元素 $("input[name$='news']") 选择所有的name属性以'news'结尾的input元素 $("input[name*='man']") 选择所有的name属性包含'news'的input元素 $("input[id][name$='man']") 可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 子元素过滤选择器1234$("ul li:nth-child(2)"),$("ul li:nth-child(odd)"),$("ul li:nth-child(3n + 1)") $("div span:first-child") 返回所有的div元素的第一个子节点的数组 $("div span:last-child") 返回所有的div元素的最后一个节点的数组 $("div button:only-child") 返回所有的div中只有唯一一个子节点的所有子节点的数组 表单元素选择器1234567891011$(":input") 选择所有的表单输入元素，包括input, textarea, select 和 button $(":text") 选择所有的text input元素 $(":password") 选择所有的password input元素 $(":radio") 选择所有的radio input元素 $(":checkbox") 选择所有的checkbox input元素 $(":submit") 选择所有的submit input元素 $(":image") 选择所有的image input元素 $(":reset") 选择所有的reset input元素 $(":button") 选择所有的button input元素 $(":file") 选择所有的file input元素 $(":hidden") 选择所有类型为hidden的input元素或表单的隐藏域 表单元素过滤选择器123456789101112131415161718$(":enabled") 选择所有的可操作的表单元素 $(":disabled") 选择所有的不可操作的表单元素 $(":checked") 选择所有的被checked的表单元素 $("select option:selected") 选择所有的select 的子元素中被selected的元素 选取一个 name 为”S_03_22″的input text框的上一个td的text值$(”input[@ name =S_03_22]“).parent().prev().text() 名字以”S_”开始，并且不是以”_R”结尾的$(”input[@ name ^='S_']“).not(”[@ name $='_R']“) 一个名为 radio_01的radio所选的值$(”input[@ name =radio_01][@checked]“).val(); $("A B") 查找A元素下面的所有子节点，包括非直接子节点$("A&gt;B") 查找A元素下面的直接子节点$("A+B") 查找A元素后面的兄弟节点，包括非直接子节点$("A~B") 查找A元素后面的兄弟节点，不包括非直接子节点 总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748为了方便记忆，将功能相关的选择器进行总结：1. $('#id')与$('.calss')$('#id'); // 根据id选择元素$('.class'); // 根据class选择元素 2.$('div:first')与$('div:last')$('div:first'); // 选择div元素集合中的第一个 $('div:last'); // 选择div元素集合中的最后一个 3.$('div:odd')与$('div:even')$('div:odd'); // 选择div元素集合中的奇数个元素 $('div:even'); // 选择div元素集合中的偶数个元素 4.$('div:gt(i)')与$('div:lt(i)')$('div:gt(i)'); // 选择div元素集合中索引大于i的元素 $('div:lt(i)'); // 选择div元素集合中索引小于i的元素 5.$('div:empty')与$('div:parent')$('div:empty'); // 选择div元素集合中空元素$('div:parent'); // 选择div元素集合中非空元素 6.$('div:visible')与$('div:hidden')$('div:visible'); // 选择div元素集合中可见元素$('div:hidden'); // 选择div元素集合中隐藏元素 7.$('ul li:first')与$('ul li:first-child')$('ul li:first'); // 选择所有ul后代元素li元素集合中的第一个 $('ul li:first-child'); // 选择每个ul后代元素li元素集合中的第一个 8.$(':disable')与$(':enable')$(':disable'); // 选择所有可以操作的表单元素$(':enable'); // 选择所有不可以操作的表单元素 范例 $(“A B”) 查找A元素下面的所有子节点，包括非直接子节点 例子：找到表单中所有的 input 元素 HTML 代码: 123456789&lt;form&gt;&lt;label&gt;Name:&lt;/label&gt;&lt;input name="name" /&gt;&lt;fieldset&gt; &lt;label&gt;Newsletter:&lt;/label&gt; &lt;input name="newsletter" /&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;input name="none" /&gt; jQuery 代码: 1$("form input") 结果: 1[ &lt;input name=&quot;name&quot; /&gt;, &lt;input name=&quot;newsletter&quot; /&gt; ] $(“A&gt;B”) 查找A元素下面的直接子节点 例子：匹配表单中所有的子级input元素。 HTML 代码: 123456789&lt;form&gt;&lt;label&gt;Name:&lt;/label&gt;&lt;input name="name" /&gt;&lt;fieldset&gt; &lt;label&gt;Newsletter:&lt;/label&gt; &lt;input name="newsletter" /&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;input name="none" /&gt; jQuery 代码: 1$("form &gt; input") 结果: 1[ &lt;input name=&quot;name&quot; /&gt; ] $(“A+B”) 查找A元素后面的兄弟节点，包括非直接子节点例子：匹配所有跟在 label 后面的 input 元素 HTML 代码: 123456789&lt;form&gt;&lt;label&gt;Name:&lt;/label&gt;&lt;input name="name" /&gt;&lt;fieldset&gt; &lt;label&gt;Newsletter:&lt;/label&gt; &lt;input name="newsletter" /&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;input name="none" /&gt; jQuery 代码: 1$("label + input") 结果: 1[ &lt;input name=&quot;name&quot; /&gt;, &lt;input name=&quot;newsletter&quot; /&gt; ] $(“A~B”) 查找A元素后面的兄弟节点，不包括非直接子节点例子：找到所有与表单同辈的 input 元素 HTML 代码: 123456789&lt;form&gt;&lt;label&gt;Name:&lt;/label&gt;&lt;input name="name" /&gt;&lt;fieldset&gt; &lt;label&gt;Newsletter:&lt;/label&gt; &lt;input name="newsletter" /&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;input name="none" /&gt; jQuery 代码: 1$("form ~ input") 结果: 1[ &lt;input name=&quot;none&quot; /&gt; ] JQuery的Dom操作样式操作1、直接样式操作 语法： css(name,value); //设置单个属性 css({name:value,name:value,....}) //同时设置多个属性，大括号包裹、冒号分割name与value，不同属性之间用逗号分隔 2、追加样式和移除样式 语法： addClass(“class”) //追加单个样式 addClass(“class1 class2 …”) //追加多个样式，同空格分隔 3、移除样式 语法： removClass(“class”) //移除单个样式 removClass(“class1 class2”) //移除多个样式，有空格分隔12345678910111213141516171819202122//示例&lt;script type="text/javascript"&gt;$(document).ready(function()&#123;//触发button的单击事件时，移除p标签的intro样式 $("button").click(function()&#123; $("p").removeClass("intro"); &#125;);&#125;);&lt;/script&gt;&lt;style type="text/css"&gt;.intro&#123; font-size:120%; color:red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id="h1"&gt;This is a heading&lt;/h1&gt;&lt;p class="intro"&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt;&lt;button&gt;从第一个段落中删除类&lt;/button&gt;&lt;/body&gt; 4、切换样式 123使用toggle()方法可以切换元素的可见状态，而使用toggleClass()方法可以切换不同元素的类样式。语法：toggleClass(&quot;class&quot;); 123456789101112131415161718192021222324//示例&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("button").click(function()&#123; //触发单击事件时，切换为main样式，再次单击，回到原来样式 $("p").toggleClass("main"); &#125;);&#125;);&lt;/script&gt;&lt;style type="text/css"&gt;.main&#123;font-size:120%;color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id="h1"&gt;This is a heading&lt;/h1&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt;&lt;button class="btn1"&gt;切换段落的 "main" 类&lt;/button&gt; 内容操作1、HTML代码操作 1234567语法：html([&quot;content&quot;]);定义和用法html() 方法返回或设置被选元素的内容 (inner HTML)。如果该方法未设置参数，则返回被选元素的当前内容。 返回元素内容 当使用该方法返回一个值时，它会返回第一个匹配元素的内容。 1234567891011121314 //示例 &lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $(".btn1").click(function()&#123; //未设置参数，返回p元素的值：This is a paragraph. alert($("p").html()); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;button class="btn1"&gt;改变 p 元素的内容&lt;/button&gt;&lt;/body&gt; 设置元素内容当使用该方法设置一个值时，它会覆盖所有匹配元素的内容。 123456789101112131415//示例&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $(".btn1").click(function()&#123; //所有p元素的值被修改为 Hello World! $("p").html("Hello &lt;b&gt;world!&lt;/b&gt;"); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt;&lt;button class="btn1"&gt;改变 p 元素的内容&lt;/button&gt;&lt;/body&gt; 使用函数来设置元素内容 使用函数来设置所有匹配元素的内容。 123456语法：$(selector).text(function(index,oldcontent))描述：必需。规定返回被选元素的新文本内容的函数。index - 可选。接受选择器的 index 位置。oldcontent- 可选。接受选择器的当前内容。 123456789101112131415161718192021 //示例&lt;script type="text/javascript"&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("p").html(function(n,oldcontent)&#123; //可以获得选择器的当前内容（这是一个段落、这是另一个段落） alert(oldcontent); //返回新的内容（这个p元素的index是0，这个p元素的index是1） return "这个 p 元素的 index 是：" + n; &#125;); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另一个段落。&lt;/p&gt; &lt;button&gt;改变 p 元素的内容&lt;/button&gt;&lt;/body&gt; 123456782.标签内容操作 语法：text([content]); text() 方法设置或返回被选元素的文本内容。（content为空时返回，有值时设置）a.返回文本内容当该方法用于返回一个值时，它会返回所有匹配元素的组合的文本内容（会删除 HTML 标记）。 123456789101112131415//示例$(document).ready(function()&#123; $(&quot;.btn1&quot;).click(function()&#123; //返回所有匹配的p标签内容（This is a paragraph.、This is another paragraph.） alert($(&quot;p&quot;).text()); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt;&lt;button class=&quot;btn1&quot;&gt;获得 p 元素的文本内容&lt;/button&gt;&lt;/body&gt; 设置文本内容当该方法用于设置值时，它会覆盖被选元素的所有内容。 123456789101112131415//示例&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $(".btn1").click(function()&#123; //将所有匹配的p元素的值设置为Hello world! $("p").text("Hello world!"); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt;&lt;button class="btn1"&gt;改变所有 p 元素的文本内容&lt;/button&gt;&lt;/body&gt; html()与text()方法的区别 语法格式 参数说明 功能描述 html() 无参数 用于获取第一个匹配元素的HTML内容或文本内容 html([content]) content参数为元素的HTML内容 用于设置所有匹配元素的HTML内容或文本内容 text() 无参数 用于设置所有匹配元素的文本内容 text([content]) content参数为元素的文本内容 用于设置所有匹配元素的文本内容 属性值操作在jQuery中，除了可以使用html()方法和text()方法获取与设置元素内容外，还提供了获取元素value属性值的方法val()。该方法非常常用，多用于操作表单的元素。 语法： val([value]); val() 方法返回或设置被选元素的值。元素的值是通过 value 属性设置的。该方法大多用于 input 元素。如果该方法未设置参数，则返回被选元素的当前值。1、返回 Value 属性返回第一个匹配元素的 value 属性的值。 123456789101112131415//示例&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("button").click(function()&#123; //返回第一个匹配元素的value属性的值：Bill alert($("input:text").val()); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Firstname: &lt;input type="text" name="fname" value="Bill" /&gt;&lt;br /&gt;Lastname: &lt;input type="text" name="lname" value="Gates" /&gt;&lt;br /&gt;&lt;br /&gt;&lt;button&gt;获得第一个文本域的值&lt;/button&gt;&lt;/body&gt; 2、设置 Value 属性的值 12345678910111213141516//示例&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("button").click(function()&#123; //将value值设置为Bill Gates $("input:text").val("Bill Gates"); //意外发现：input:text 等同于 input[type=text] //$("input[type=text]").val("Bill Gates"); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Name: &lt;input type="text" name="user" /&gt;&lt;/p&gt;&lt;button&gt;设置文本域的值&lt;/button&gt;&lt;/body&gt; 3.使用函数设置 Value 属性的值 123456789101112131415//示例&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("input:text").val(function(n,c)&#123; //n是获取元素的index，c是返回值 return c + " Gates"; &#125;); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Name: &lt;input type="text" name="user" value="Bill" /&gt;&lt;/p&gt;&lt;button&gt;设置文本域的值&lt;/button&gt;&lt;/body&gt; html()、text()、val()共同点： 1、都包含无参方法，等于无参方法时，返回各自的value 2、都包含有参方法，等于有参方法时，设置各自的value 3、都可以用函数设置value，其中，函数包含两个值，index和oldvalue，index是匹配元素的索引，oldvalue是匹配元素当前的value，都可以省略。 节点与属性操作1:节点操作 在jQuery中，节点操作主要分为查找、创建、插入、删除、替换和复制6种操作方式。其中，查找、创建、插入、删除和替换节点是日常开发中使用最多，也是最重要的。 a、查找节点 想要对节点进行操作，即增、删、改和复制，首先必须找到要操作的元素。 所以，查找的语法示例： $(&quot;h1&quot;).hide(); 查找h1的元素，并将其隐藏。 其实，查找元素，就是通过选择器获取元素。 b、创建节点元素 在之前的文章中，讲解过函数$()。该函数就是用于将匹配的DOM元素转换为jQuery对象的，它就好像一个零件的生产工厂，所以被形象地称为工厂函数。 $()语法： $(selector) //选择器。使用jQuery选择器匹配元素 $(element) //DOM元素。以DOM元素来创建jQuery对象 $(html) //HTML代码，使用HTML字符串创建jQuery对象 HTML代码创建jQuery对象示例： var $newNode1 = $(““) //创建空的li元素节点 var $newNode2 = $(“HTML“) //创建包含文本的li元素节点 var $newNode3 = $(“HTML“) //创建包含文本与属性的li元素节点 c、插入节点 插入节点方法 插入方式 方法 描述 内部插入 appen(content) 向所选的元素内部插入内容，即(A).append(B)表示将B追加到A中。如 (“ul”).append($newNode2);追加的位置在元素的最后 appendTo(content) 把所选择的元素追加到另一个指定的元素集合中，既(A).appendTo(B)，表示把A追加到B中，如($newNode2).appendTo(“ul”);与append的唯一区别是语法顺序相反 prepend(content) 向每个选择的元素内部前置内容，即(A).prepend(B)表示将B追加到A中，如(“ul”).perpend($newNode2); prependTo(content) 将所有匹配元素前置到指定元素中。该方法仅颠倒了常规prepend()插入元素的操作，即$(A).perpendTo(B)表示将A前置到B中，如(newNode2).prependTo(“ul”) 外部插入 after(content) 在每个匹配元素之后插入内容，即(A).after(B)表示将B插入到A之后，如(“ul”).after($newNode2); insertAfter(content) 将所有匹配的元素插入到指定元素的后面。该方法颠倒了常规after()插入元素的操作，$(A).insertAfter(B)表示将A插入到B之后，如(newNode2).insertAfter(“ul”); before(content) 向所选择的元素外面前面插入元素，即$(A).before(B)表示将B插入至A之前，如(“ul”).before(newNode2); insertBefore(content) 将所匹配的元素插入到指定元素的前面，该方法仅是颠倒了常规before()插入元素的操作，即$(A).insertBefore(B)表示将A插入至B之前，如(newNode2).insertBefore(“ul”); 注意：每个语句之前都需要添加$符号。 d、删除节点123456789语法：(selector).remove([expr]);参数expr为可选参数，如果接受参数，则该参数为筛选元素的jQuery表达式，通过该表达式获取指定元素，并进行删除。示例：$(&quot;ul li:eq(1)&quot;).remove();定义和用法remove() 方法移除被选元素，包括所有文本和子节点。该方法不会把匹配的元素从 jQuery 对象中删除，因而可以在将来再使用这些匹配的元素。但除了这个元素本身得以保留之外，remove() 不会保留元素的 jQuery 数据。其他的比如绑定的事件、附加的数据等都会被移除。这一点与 detach() 不同。 更多解说，查看这里 12语法：$(selector).empty()empty() 方法从被选元素移除所有内容，包括所有文本和子节点。 更多解说，查看这里 1234语法：$(selector).detach();detach() 方法移除被选元素，包括所有文本和子节点。这个方法会保留 jQuery 对象中的匹配的元素，因而可以在将来再使用这些匹配的元素。detach() 会保留所有绑定的事件、附加的数据，这一点与 remove() 不同。 更多解说，查看这里 e、替换节点12345678使用的方法： replaceWith()方法和replaceAll()方法示例： $(&quot;ul li:eq(1)&quot;).replaceWith($newNode2); $($newNode2).replaceAll(&quot;ul li:eq(1)&quot;); 两种方法的作用相同，只是颠倒了顺序。 f、复制节点123语法：$(selecrot).clone([includeEvents]);includeEvents为可选值，为布尔值，规定是否复制元素的所有事件处理。true复制，flase不复制。 12345678910111213141516171819//示例&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("button").click(function()&#123; //复制第一个p元素，包括事件处理，然后添加到body中。 $("body").append($("p:first").clone(true)); &#125;); $("p").click(function()&#123; $(this).animate(&#123;fontSize:"+=1px"&#125;); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;点击本段落可以增加文本的大小。事件处理器同样被复制到新的段落。&lt;/p&gt;&lt;button&gt;复制每个 p 元素，然后追加到 body 元素&lt;/button&gt;&lt;/body&gt; 节点遍历a.在jQuery中，遍历子元素的方法只有一个，即children()方法。 12345678910111213语法：$(childred).children([expr])expr可选，用于过滤子元素的表达式children() 方法返回被选元素的所有直接子元素。该方法只会向下一级对 DOM 树进行遍历。示例：//p.c用于过滤子元素$(&quot;div&quot;).children(&quot;p.c&quot;).css(&#123;&quot;color&quot;:&quot;red&quot;,&quot;border&quot;:&quot;2px solid red&quot;&#125;); 更多信息，查看这里1，查看这里2b.遍历同辈元素 遍历同辈元素的方法说明 方法 描述 next([expr]) 用于获取紧邻匹配元素之后的元素。参数expr可选，用于过滤同辈元素的表达式，如$(“li:eq(1)”).next().css(“color”,”red”); prev([expr]) 用于获取紧邻匹配元素之前的元素。参数expr可选，用于过滤同辈元素的表达式，如$(“li:eq(1)”).prev().css(“color”,”red”); siblings([expr]) 用于获取紧邻匹配元素前面和后面的所有同辈元素。参数expr可选，用于过滤同辈元素的表达式，如$(“li:eq(1)”).siblings().css(“color”,”red”); c.遍历前辈元素用与遍历父辈元素的方法主要有parent()和parents()。 parent()方法和parents()方法的参数说明 方法 描述 parent([selector]) 参数可选。获取当前匹配元素集合中每个元素的父级元素 parents([selector]) 参数可选。获取当前匹配元素集合中每个元素的祖先元素 注意：除了以上介绍的节点遍历方法之外，jQuery中还有许多遍历的方法，如each()、find()、filter()等，查看更多 CSS-DOM操作 CSS-DOM相关操作方法说明 参数 描述 示例 css() 设置或返回匹配元素的样式属性 $(“#box”).css(“color”,”red”) heigh([value]) 参数可选。设置或返回匹配元素的高度。如果没有规定长度单位，则使用默认px作为单位 $(“#box”).heigh(180) width([value]) 参数可选。设置或返回匹配元素的宽度。如果没有规定长度单位，则使用默认px作为单位 $(“#box”).width(180) offset([value]) 返回以像素为单位的top和left坐标。此方法仅对可见元素有效 $(“#box”).offset() offsetParent([value]) 返回最近的已定位的祖先元素。定位元素指的是元素的CSS position值被设置为relative、absolute或fixed的元素 $(“#box”).offsetParent() scrollLeft([position]) 参数可选。设置或返回匹配元素相对滚动条左侧的偏移 $(“#box”).scorllLeft(20) scrollTop([posttion]) 参数可选。设置或返回匹配元素相对滚动条顶部的偏移 $(“#box”).scrollTop(120) 此外，注意，选取元素的高度除了可以使用height()方法之外，还能使用css()方法，其获取高度值的代码为$(“#box”).css(“height”)。两者的区别在于使用css获取元素高度与样式设置有关，可能会得到“auto”，也可能得到“60px”之类的字符串；而height()方法获取的高度值则是元素在页面中的实际高度，与样式的设置无关，且不带单位。获取元素宽度的方式也是同理。 更多介绍，查看这里 jquery中的动画和事件一.事件(重要)jquery绑定事件jQuery对象.bind(“事件名”,可选参数,事件处理函数) 注意: 第二个参数为可选参数, 作为event.data属性值传递给事件对象的额外数据对象. 事件名不要加on jquery对象.bind(&quot;事件名&quot;,function(){ }) 需求: 点击 h5标题后,显示h5下的div 演示代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;演示事件&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; body &#123; font-size: 13px; line-height: 130%; padding: 60px; &#125; #panel &#123; width: 300px; border: 1px solid #0050D0; &#125; .head &#123; padding: 5px; background: #96E555; cursor: pointer; &#125; .content &#123; padding: 10px; text-indent: 2em; border-top: 1px solid #0050D0; display: none; &#125; &lt;/style&gt; &lt;scriptsrc="../js/jquery/jquery-1.7.2.js" type="text/javascript" charset="utf-8"&gt; &lt;/script&gt; &lt;scripttype="text/javascript"&gt; $(function() &#123; //需求:点击标题后显示标题下面的div $("#panelh5.head").bind("click",function()&#123; //让标题下面的div显示 $(this).next().show(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel"&gt; &lt;h5class="head"&gt;什么是jQuery?&lt;/h5&gt; &lt;divclass="content"&gt;jQuery是继Prototype之后又一个优秀的JavaScript库，它是一个由 John Resig 创建于2006年1月的开源项目。jQuery凭借简洁的语法和跨平台的兼容性，极大地简化了JavaScript开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax。它独特而又优雅的代码风格改变了JavaScript程序员的设计思路和编写程序的方式。 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 取消绑定1.取消click事件的所有事件处理函数 jQuery对象.unbind(&quot;click&quot;) 2.取消click事件的事件处理函数f2 jQuery对象.unbind(&quot;click&quot;,f2); fn1=function(){} 这个也可以作为函数的参数,相当于function(){},并且这个函数叫fn1 只执行一次事件对象.one(&quot;事件名&quot;,事件处理函数);//只执行一次 触发某一个事件对象.trigger(&quot;click&quot;); //相当于对象.click(); div的显示和隐藏123div.show("slow");div.show("normal");div.show("fast"); 可见就隐藏,不可见就显示 12345if(div对象.is(":visible"))&#123; div对象.hide(3000);&#125;else&#123; div对象.show(3000);&#125; 改变绑定事件的类型mouseover mouseout 演示代码: 1234567891011121314151617181920212223242526272829303132$(function() &#123; //需求: 点击标题后 显示标题下面的div $("#panel").bind("mouseover", function() &#123; $(this).find("div.content").show(); &#125;); $("#panel").bind("mouseout", function() &#123; $(this).find("div.content").hide(); &#125;);&#125;);或者合成一句$(function() &#123; //需求: 点击标题后 显示标题下面的div $("#panel").bind("mouseover", function() &#123; $(this).find("div.content").show(); &#125;).bind("mouseout", function() &#123; $(this).find("div.content").hide(); &#125;);&#125;);或者$(function() &#123; //需求: 点击标题后 显示标题下面的div $("#panel").mouseover(function() &#123; $(this).find("div.content").show(); &#125;).mouseout(function() &#123; $(this).find("div.content").hide(); &#125;);&#125;); 选项卡的制作演示代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTDHTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;网页选项卡&lt;/title&gt; &lt;metahttp-equiv="content-type" content="text/html;charset=UTF-8"&gt; &lt;scriptsrc="../../js/jquery/jquery-1.7.2.js" type="text/javascript" charset="utf-8"&gt; &lt;/script&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; font: 12px/19px Arial, Helvetica, sans-serif; color: #666; &#125; .tab &#123; width: 240px; &#125; .tab_menu &#123; clear: both; &#125; .tab_menuli &#123; float: left; text-align: center; cursor: pointer; list-style: none; padding: 1px 6px; margin-right: 4px; background: #F1F1F1; border: 1px solid #898989; border-bottom: none; &#125; .tab_menuli:hover &#123; background: #DFDFDF; &#125; .tab_menuli.selected &#123; color: #FFF; background: #6D84B4; &#125; .tab_box &#123; clear: both; border: 1px solid #898989; height: 100px; &#125; .hide &#123; display: none &#125; &lt;/style&gt; &lt;script src="../../js/jquery/jquery-1.7.2.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; //给所有的li绑定单击事件 var$menu_li = $("div.tab_menu li"); $menu_li.click(function() &#123; //1.将点击的li高亮 $(this).addClass("selected"); //并去掉其他的高亮 $(this).siblings().removeClass("selected"); //2.让对应的div显示 //点击第1个li 显示第1个div 点击第2个li 显示第2个div //首先获得点击了第几个li var clickedLiIndex = $menu_li.index($(this)); $("div.tab_box&gt;div").eq(clickedLiIndex).show(); $("div.tab_box&gt;div").eq(clickedLiIndex).siblings().hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="tab"&gt; &lt;divclass="tab_menu"&gt; &lt;ul&gt; &lt;liclass="selected"&gt;时事&lt;/li&gt; &lt;li&gt;体育&lt;/li&gt; &lt;li&gt;娱乐&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;divclass="tab_box"&gt; &lt;div&gt;时事&lt;/div&gt; &lt;div class="hide"&gt;体育&lt;/div&gt; &lt;div class="hide"&gt;娱乐&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 合成事件 2个jQuery有两个合成事件—–hover()方法和toggle()方法. 1.hover(enter,leave);hover = mouseover + mouseout ; hover()方法用于模拟光标悬停事件.当光标移动到元素上时,执行第一个函数(enter),当光标移出这个元素时,会触发第二个函数(leave). 上面的例子可以改写成hover()方法 演示代码: 12345$("#panel").hover(function() &#123; $(this).find("div.content").show();&#125;,function()&#123; $(this).find("div.content").hide();&#125;); 2.toggle(事件处理函数1，事件处理函数2,….); //开关函数jQuery1.9 以后取消了toggle事件 toogle(fn1,fn2,…fnN) toogle()方法用于模拟鼠标连续单击事件。第1次单击元素,触发第一个函数(fn1),第二次单击同一个元素,触发fn2…如果有多个函数,依次触发,直到最后一个,随后的每次单击从头开始轮番调用这几个函数。 前面的单击标题例子中,使用了如下代码: 虽然能实现效果,但是这种方法不是最合适的.如果需要连续单击”标题”,来达到使”内容”显示和隐藏的目的,那么很适合使用toggle()方法 演示代码: 12345678910111213141516171819$(function() &#123; $("#btn1").click(function() &#123; vardiv1 = ("#div1"); if ($div1.is(":visible")) &#123; $div1.hide(3000); &#125; else &#123; $div1.show(3000); &#125; &#125;);&#125;); toggle()方法还有另外一个作用:切换元素的可见状态.如果元素是可见的,单击切换后则隐藏； 如果元素是隐藏的,单击切换后则为可见的. 对于层来说 div对象.toggle();//显示的层变隐藏、隐藏的层变显示 加强效果为了能有更好的用户体验,现在需要在用户单击”标题”后,不仅显示内容,而且高亮显示”标题”。 单击标题后,标题高亮显示 为了完成这一功能,首先在CSS中定义一个高亮的样式,CSS代码如下: 1.highlight &#123; background-color:#ff3300;&#125; 演示代码: 1234567$(function() &#123; //需求: 点击标题后 显示标题下面的div $("#panel").click(function() &#123; $(this).find("div.content").toggle(); $(this).find("h5").toggleClass("highlight"); &#125;); &#125;); 二.动画内置动画1.show()和hide()1234div.show("slow");//0.6秒div.show("normal");//0.4秒div.show("fast");//0.2秒div.show(毫秒); 如果不加参数直接调用show()是立即显示 没有动画效果 增加宽度(从左到右增大)、增加高度(从上到下增大),同时增加内容的不透明度 2.fadeIn()和fadeOut()淡入淡出效果对象.fadeIn();//淡入 增加不透明度 对象.fadeOut();//淡出 减少不透明度 直到元素完全消失(display:none) 与show()方法不同,fadeIn()和fadeOut()方法只改变元素的不透明度. 3.slideUp()、slideDown()收缩、展开效果(用于层)slideUp()、slideDown() 只会改变元素的高度 动画积累问题解决当用户快速在某个元素上执行animate()动画时,就会出现动画积累.解决方法是判断元素是否处于动画状态,如果元素不处于动画状态,才为元素添加新的动画,如果元素正处于动画状态不添加动画. 12345678910111213$(function() &#123; //需求: 点击标题后 显示标题下面的div $("#panel").toggle(function() &#123; if (!$("#panel").find("div.content").is(":animated")) &#123; //不处在动画状态中 $("#panel").find("div.content").slideDown("slow"); &#125; &#125;, function() &#123; if (!$("#panel").find("div.content").is(":animated")) &#123; $("#panel").find("div.content").slideUp("slow"); &#125; &#125;);&#125;); 自定义动画animate()\1. 自定义简单动画 1animate(&#123;left:"500px"&#125;,3000,function()&#123;alert(3);&#125;); 参数1：让div向右移动500px 参数2：移动所需的时间(可以省略) 参数3: 移动完成调用回调函数(可以省略) 完整演示代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;演示事件&lt;/title&gt; &lt;style type="text/css"&gt; #panel &#123; width: 100px; height: 100px; background-color: yellowgreen; position: relative; cursor: pointer; &#125; &lt;/style&gt; &lt;script src="../jquery-1.7.2.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;scripttype="text/javascript"&gt; $(function()&#123; $("#panel").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000,function()&#123; $(this).fadeOut(2000); &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel"&gt; 保存成功 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 多重动画 (1)同时执行多个动画 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;演示事件&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; #img1 &#123; position: relative; &#125; &lt;/style&gt; &lt;scriptsrc="../jquery-3.1.0.js" type="text/javascript" charset="utf-8"&gt; &lt;/script&gt; &lt;scripttype="text/javascript"&gt; $(function()&#123; $("#img1").click(function()&#123; $(this).animate(&#123;left:"500px",height:"200px"&#125;,3000); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img id="img1" src="../../../image/smile.png" /&gt;&lt;/body&gt;&lt;/html&gt; (2)按顺序执行多个动画 上例中是移动和调整宽度同时进行,如果想按顺序执行动画,例如先向右滑动,然后再放大它的高度,只需把代码拆开 123456$(function() &#123; $("#img1").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000); $(this).animate(&#123;width:"200px"&#125;,3000); &#125;);&#125;); 因为animate都是对同一个jQuery对象操作的,也可以改为链式操作 123456$(function() &#123; $("#img1").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000). animate(&#123;width:"200px"&#125;,3000); &#125;);&#125;); 像这样动画效果的执行具有先后顺序,称为”动画队列”. 综合动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;演示事件&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; #panel &#123; width: 100px; height: 100px; background-color: burlywood; position: relative; &#125; &lt;/style&gt; &lt;scriptsrc="../../../js/jquery/jquery-1.7.2.js" type="text/javascript" charset="utf-8"&gt; &lt;/script&gt; &lt;scripttype="text/javascript"&gt; $(function()&#123; $("#panel").css("opacity","0.5");//设置不透明度 $("#panel").click(function()&#123; $("#panel").animate(&#123;left:"400px",height:"200px",opacity:"1"&#125;,3000) .animate(&#123;top:"200px",width:"200px"&#125;,3000) .fadeOut("slow"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动画回调函数 如果想在最后一步切换元素的CSS样式,而不是隐藏元素. 需要把最后fadeOut(“slow”)改为.css(&quot;border&quot;,&quot;5px solid blue&quot;); 但是这样并不能得到预期效果,预期效果是在动画的最后一步改变元素的样式,而实际效果是刚开始执行的时候,css()方法就执行了.出现这个问题的原因是css()方法并不会加入到动画队列中,而是立即执行.可以使用回调函数(callback)对非动画方法实现排队.只要把css()方法写在最后一个动画的回调函数里即可.代码如下: 1234567891011121314151617$(function() &#123; $("#panel").css("opacity", "0.5"); //设置不透明度 $("#panel").click(function() &#123; $("#panel").animate(&#123; left: "400px", height: "200px", opacity: "1" &#125;, 3000) .animate(&#123; top: "200px", width: "200px" &#125;, 3000, function() &#123; $("#panel").css("border", "5pxsolid blue"); &#125;); &#125;);&#125;); 停止动画 123$("#btn1").click(function()&#123; $("#panel").stop();//只能停止一个动画&#125;); 延迟动画 123456789101112131415161718192021222324252627$(function() &#123; $("#panel").css("opacity", "0.5"); //设置不透明度 $("#panel").click(function() &#123; $("#panel").animate(&#123; left: "400px", height: "200px", opacity: "1" &#125;, 3000) .delay(3000) .animate(&#123; top: "200px", width: "200px" &#125;, 3000, function() &#123; $("#panel").css("border", "5pxsolid blue"); &#125;); &#125;); //停止动画 $("#btn1").click(function() &#123; $("#panel").stop(); &#125;);&#125;); 其他动画方法toggle()、slideToggle()、fadeTo()和fadeToToggle(); fadeTo() 把元素的不透明度调整到指定的值 1234567$(function() &#123; //需求: 点击标题后 显示标题下面的div $("#panelh5.head").click(function() &#123; $(this).next().fadeTo(600, 0.2); //600毫秒 不透明度调整到0.2 &#125;);&#125;) 在css中调整不透明度 123456.content &#123; padding: 10px; text-indent: 2em; border-top: 1px solid #0050D0; background-color: rgba(255,0,0,0.5);//alpha参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 &#125; fadeToToggle(); 对应fadeIn()和fadeOut() 原生和jQuery的ajax用法form数据的序列化： 123456789$('#submit').click(function()&#123; $('#form').serialize(); //会根据input里面的name，把数据序列化成字符串；eg：name=yang $('#form').serializeArray(); //会根据input里面的name，把数据序列化成数组；eg：[object] //注意：没有name会获取不到值 //下面两种不是jQuery的方法 JSON.parse() //json字符串转化为json对象 JSON.stringify() //json对象转化为json字符串&#125;); jQuery的ajax方法： 123456789101112131415161718192021222324252627$.ajax(&#123; url:'/comm/test1.php', type:'POST', //GET async:true, //或false,是否异步 data:&#123; name:'yang',age:25 &#125;, timeout:5000, //超时时间 dataType:'json', //返回的数据格式：json/xml/html/script/jsonp/text beforeSend:function(xhr)&#123; console.log(xhr) console.log('发送前') &#125;, success:function(data,textStatus,jqXHR)&#123; console.log(data) console.log(textStatus) console.log(jqXHR) &#125;, error:function(xhr,textStatus)&#123; console.log('错误') console.log(xhr) console.log(textStatus) &#125;, complete:function()&#123; console.log('结束') &#125;&#125;) 原生的ajax方法： 123456789101112131415161718192021$('#send').click(function()&#123; //请求的5个阶段，对应readyState的值 //0: 未初始化，send方法未调用； //1: 正在发送请求，send方法已调用； //2: 请求发送完毕，send方法执行完毕； //3: 正在解析响应内容； //4: 响应内容解析完毕； var data = 'name=yang'; var xhr = new XMLHttpRequest(); //创建一个ajax对象 xhr.onreadystatechange = function(event)&#123; //对ajax对象进行监听 if(xhr.readyState == 4)&#123; //4表示解析完毕 if(xhr.status == 200)&#123; //200为正常返回 console.log(xhr) &#125; &#125; &#125;; xhr.open('POST','url',true); //建立连接，参数一：发送方式，二：请求地址，三：是否异步，true为异步 xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded'); //可有可无 xhr.send(data); //发送&#125;); jQuery Ajax 操作函数jQuery 库拥有完整的 Ajax 兼容套件。其中的函数和方法允许我们在不刷新浏览器的情况下从服务器加载数据。 函数 描述 jQuery.ajax() 执行异步 HTTP (Ajax) 请求。 .ajaxComplete() 当 Ajax 请求完成时注册要调用的处理程序。这是一个 Ajax 事件。 .ajaxError() 当 Ajax 请求完成且出现错误时注册要调用的处理程序。这是一个 Ajax 事件。 .ajaxSend() 在 Ajax 请求发送之前显示一条消息。 jQuery.ajaxSetup() 设置将来的 Ajax 请求的默认值。 .ajaxStart() 当首个 Ajax 请求完成开始时注册要调用的处理程序。这是一个 Ajax 事件。 .ajaxStop() 当所有 Ajax 请求完成时注册要调用的处理程序。这是一个 Ajax 事件。 .ajaxSuccess() 当 Ajax 请求成功完成时显示一条消息。 jQuery.get() 使用 HTTP GET 请求从服务器加载数据。 jQuery.getJSON() 使用 HTTP GET 请求从服务器加载 JSON 编码数据。 jQuery.getScript() 使用 HTTP GET 请求从服务器加载 JavaScript 文件，然后执行该文件。 .load() 从服务器加载数据，然后把返回到 HTML 放入匹配元素。 jQuery.param() 创建数组或对象的序列化表示，适合在 URL 查询字符串或 Ajax 请求中使用。 jQuery.post() 使用 HTTP POST 请求从服务器加载数据。 .serialize() 将表单内容序列化为字符串。 .serializeArray() 序列化表单元素，返回 JSON 数据结构数据。 jQuery插件前端实用插件 Highcharts 图表插件，个人所接触上第一个插件，记得没错的话当初应该是由几个大神编写，官网也还没有现在这么强大。掌握基础用法比较简单。当初算是它让我知道什么是插件，怎么样用插件，也是它使我发现插件的美。 所以感触感悟较深，让我第一次感觉强大的功能实现起来如此简单。 当时心境：只要从官网找一些例子，看一看api然后写一些简单的Dome。需要注意的就是它的数据来源全部是JSON格式，简单理解为 拿到Data 转化相应的JSON丢入插件中，图表出现。 官网地址：https://www.hcharts.cn/demo/highcharts ECharts 百度图表，网上资料较多，由百度推出及维护。这没的说，公认的图表插件，好用实在免费. 官网地址：http://echarts.baidu.com Layer web弹出层组件，使用简便小巧并且免费开源，重要的是它采用MIT开源协议永久免费. 官网地址：http://layer.layui.com/ UEditor web编辑器组件，同样是百度旗下的，可支持定制，代码开源于Git Hub，使用也简单方便，主要用于论坛类。它主要是将你图片视频包括等文件转化为html代码后显示。 官网地址：http://ueditor.baidu.com/website/index.html 综合类 Bootstrap 后台模板，类似于导航那种，可以通过它找到一些资源. 网站地址：http://www.jqueryfuns.com/ H+ 后台主题UI框架 一个很强大的网站，资源丰富. 啧啧，这个网站是一做PHP的同事告诉我的，但就是有些服务收费. 网站地址：http://www.zi-han.net/theme/hplus/ Jquery插件库，也类似于导航类，收藏还是不错滴，可以根据相应的功能进行搜索。资源不错呐虽然我也没用过，只是收藏. 网站地址：http://www.jq22.com/ dowebok 插件导航吧算，有的收费，我没用过找资料时觉着将来可能用得着就着手收藏啦，前端的可能用的多. 网站地址：http://www.dowebok.com/ Bootstrap 模板，包含了很多Bootstrap1，Bootstrap2,…. 有教程等，跟第一个好像是一回事只是不是同一个网站 网站地址：http://www.bootcss.com/ Web开发 金丝燕网，对于Java Web而言用处还是很大的，收藏用还是不错滴。 网站地址：http://swiftlet.net/ 实用类 AjaxFileUpload 批量上传插件，实用性特别高，但相对来讲资料比较杂，并未成体系，很实用很实用的插件，尤其是在批量上传时用到。 参考网址：http://fwhyy.com/2010/01/jquery-upload-plugin-uploadify-use-explanation/ open深度开源——服务器相关，网址实用性高，涵盖量比较广. 参考网址：http://www.open-open.com/lib/list/76?pn=1 XML和约束模式一、XML语法xml 可扩展标记语言，w3c组织发布的，用于保存有关系的数据，作为配置文件，描述程序模块之间的关系 xml 文件开头必须包括下面的标签： 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt; encoding 用来指定XML文档的字符编码，一般都是 UTF-8 standalone 用来说明文档是否独立，默认是no，通常用不到这属性（如果是 yes 则表示XML既不需要约束文件来验证标记是否有效，也不需要XSL、CSS控制外观显示） 元素：由一个标记来定义，包括开始和结束标记以及其中的内容，如 深入体验java web开发内幕 （标记可以嵌套；格式良好的xml文档有且仅有一个根标签，其他标签都是根标签的子孙标签；在xml中空行和空格都会被作为原始内容解析）。XML只可有一个根节点。 命名规范：区分大小写，和是两种不同的标签；不能以数字、下划线或者xml开头；不能包含空格、冒号： 属性：XML解析属性的速度比解析子标记快，属性值必须用双引或单引引起来，属性也可被改为子标签的形式存储 1234&lt;input name=&quot;txt1&quot; /&gt;&lt;input&gt; &lt;name&gt;txt1&lt;/name&gt;&lt;/input&gt; CDATA区：其中的内容不会被xml解析引擎解析，而是作为原始内容显示，如 &lt;![CDATA[这是是CDATA区的内容]]&gt; 处理指令：简称PI，用来指挥xml解析引擎如何解析xml，以“&lt;?”开头，以“?&gt;”结尾，例如：文档声明 &lt;?xml version=”1.0” ?&gt; ； &lt;?xml-stylesheet type=”text/css” href=”1.css” ?&gt; ，它用来通知xml解析引擎使用css文件控制xml显示外观 二、XML约束模式约束模式定义了XML文档的标记和结构，类似于数据表结构。XML约束模式的内容也要遵循一定的语法规则，其中主流有2种：XML DTD 和 XML Schema 2.1、XML DTDDTD约束即可以作为一个单独的文件（以.dtd为后缀）编写，也可以在XML文件内编写。其中包括元素之间的关系定义、元素属性定义、实体和符号的定义。 定义dtn文件bookshelf.dtd（“书”和括号“()”之间有空格，“名称”和“(#PCDATA)”之间同样也有） 12345&lt;!ELEMENT 书架 (书+)&gt;&lt;!ELEMENT 书 (名称,作者,售价)&gt;&lt;!ELEMENT 名称 (#PCDATA)&gt;&lt;!ELEMENT 作者 (#PCDATA)&gt;&lt;!ELEMENT 售价 (#PCDATA)&gt; 在book.xml引入dtd约束文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE 书架 SYSTEM &quot;bookshelf.dtd&quot; &gt;&lt;书架&gt; &lt;书&gt; &lt;名称&gt;深入体验java web开发内幕&lt;/名称&gt; &lt;作者&gt;张孝祥&lt;/作者&gt; &lt;售价&gt;59元&lt;/售价&gt; &lt;/书&gt;&lt;/书架&gt; 在chrome浏览器中的显示如下 XML文档引用外部DTD约束的2种方式 引用本地dtd文件 &lt;!DOCTYPE 文档根结点 SYSTEM “DTD文件的URL”&gt; 引用公用dtd文件 &lt;!DOCTYPE 文档根结点 PUBLIC “DTD名称” “DTD文件的URL”&gt; 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 也可以把dtd约束写在xml文件中 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE 书架[ &lt;!ELEMENT 书架 (书+)&gt; &lt;!ELEMENT 书 (名称,作者,售价)&gt; &lt;!ELEMENT 名称 (#PCDATA)&gt; &lt;!ELEMENT 作者 (#PCDATA)&gt; &lt;!ELEMENT 售价 (#PCDATA)&gt;]&gt;&lt;书架&gt; &lt;书&gt; &lt;名称&gt;深入体验java web开发内幕&lt;/名称&gt; &lt;作者&gt;张孝祥&lt;/作者&gt; &lt;售价&gt;59元&lt;/售价&gt; &lt;/书&gt;&lt;/书架&gt; 2.2、XML Schemaschema比dtd好，已经成为w3c组织的标准，正逐步取代dtd 名称空间：使用名称空间来区分每个约束模式文档，每个名称空间都用一个唯一的URI表示。 名称空间声明：在XML文件中为一个约束模式文档的名称空间指定一个临时的简称，这个简称将作为元素和属性的前缀名。名称空间声明和元素的属性定义非常类似，可以位于任何一个元素的开始标记中，并且一个元素中可以声明多个名称空间；名称空间声明的基本格式为 xmlns:前缀名称=”URI” ，其中的前缀名称就是临时的简称。 （xmlns是xml namespace的简写）。默认名称空间 xmlns=”URI” ，即省略掉前缀名称。 1&lt;html xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; 使用名称空间引入XML Schema文档 由上面的标记只能知道 “http://www.w3.org/2001/XMLSchema&quot; 是代表某个名称空间的URI，并不能知道名称空间XML Schema文档的访问地址，那就无法对XML文档进行校验。 使用 xs:schemaLocation 以键值对的形式指定名称空间和其对应的xsd文件地址。使用之前，必须先引入xs的命名空间，这样才能使用 xs:schemaLocation 。因为 xmlns:xs=”http://www.w3.org/2001/XMLSchema&quot; 这个名称空间众所周知，所有无需指定它的访问地址。 1234567&lt;书架 xmlns=&quot;http://www.xxx.com/bookshelfSchema&quot; xmlns:test=&quot;http://www.demo.com/testSchema&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; xs:schemaLocation=&quot;http://www.xxx.com/bookshelfSchema http://www.xxx.com/xsd/bookshelf.xsd http://www.demo.com/testSchema http://www.xxx.com/xsd/test.xsd &quot;&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java成神之路-JavaScript（三）]]></title>
    <url>%2Fblog%2F13520.html</url>
    <content type="text"><![CDATA[Java成神之路-JavaScript JavaScript基本语法分类ECMAScript js基本语法与标准DOM Document Object Model文档对象模型BOM Browser Object Model浏览器对象模型 tips：DOM和BOM都是一套API（Application programing interface） 注释方式1234567style /* */body &lt;!-- --!&gt;script // /* */ /** * js说明文档注释 */ 简单指令123456alert(&quot;&quot;); 提示框；confirm(&quot;&quot;); 确认框，点击后会响应返回true或false； prompt(); 弹出一个输入框；document.write(&quot;&quot;);console.log(&quot;&quot;); 在控制台打印相应的信息；console.dir(&quot;&quot;); 在控制台打印出该对象的所有信息； 变量命名数字（0-9）、字母（a-z，A-Z）、下划线（_）； tips:应避免保留字和关键字； NaN和isNaNisNaN(number),如果number不是数字，则为true；Number(number),在转换为数字类型时，若number不是数字，则返回NaN； 转义字符12345\ \r 回车\n 空格\t 缩进\\ 反斜杠 逻辑短路、逻辑中断12true || 6; 逻辑或短路，左边为ture返回右值；6 &amp;&amp; true; 逻辑与短路，左边false返回右值； 优先级123456 * / % + - &amp;&amp; || ?tips：自上而下优先级越来越高 类型转换（type）12345678parseInt(&quot;12a3&quot;); 转为数字，尝试强转；parseFloat(&quot;123.123&quot;);data.toString();String(data);tips:变量声明未赋值，其值为undefined； 对象为空，其值为null； 三元表达式1234eg : a&gt;b?a=1:a=2;格式: 判断条件？true的时候执行的操作：false的时候执行的操作； 数组Array123456789（1）、定义法 构造函数： var arr = new Array(&quot;123&quot;,&quot;abc&quot;,&quot;xxx&quot;); 字面量： var arr = [&quot;123&quot;,&quot;646&quot;,&quot;abc&quot;]; 数组长度： var arr = new Array(6);(数组长度为6)；（2）、赋值 arr[0]=1; 形参和实参1234定义函数时，function funcA(a,b,c)&#123;&#125;，其中的a、b、c即为形参；调用函数时，funcA(1,2,3);其中的1、2、3即为实参；tips：function里面有一个arguments对象，里面存有所有传进函数的实参； 函数function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172（1）、函数命名 1、 可以使用字符、数字、下划线、$； 2、 不能以数字开头； 3、 不能使用关键字和保留字； 4、 区分大小写； 5、 建议要有意义 -- 动词+名字结构； 6、 驼峰命名法； 7、 函数名不能重名，后面写的重名函数会把前面写的函数给覆盖掉；（2）、函数的返回值返回值： 当函数执行完毕之后，所得到的结果就是一个函数返回值 任意函数都有返回值1、 在函数内部没有显示的写有return的时候，函数的返回值是undefined；2、 当函数内部有return，但是return后面没有跟着任何内容或者数据的时候，函数的返回值是undefined，并且return后面的代码不会执行；3、 当return后面跟着内容或者数据的时候，函数的返回值就是这个跟着的内容或者数据；（3）、函数的四种形式： 1、没有参数，没有return； 通常在于封装一段过程； 2、没有参数，有return； 通常用于内部封装引用其他函数（闭包，回调）； 3、有参数，没有return； 通常用于执行操作的封装； 4、有参数，有return； 常见形式；（4）、匿名函数 匿名函数的name属性值为anonymous； 函数仅用一次的情况，即用即废； eg: setTimeout(function()&#123; console.log(this.name); &#125;,1000); tips:在1秒后在控制台打印出本函数的名称；（5）、回调函数 在一个函数当中，另一个函数作为参数传入该函数中，另一个的这个函数即为回调函数； eg: function atack(callback)&#123; return callback; &#125; tips:在调用该函数时，指定callback是哪个函数； atack（func）；（6）、短路运算 作用：防止传入函数的数据不足，造成无法运行； eg： function getResult(a,b,fn) &#123; fn &amp;&amp; fn(); &#125;（通常使用逻辑与的短路来决定是否执行回调函数；） function getResult_2(a,b)&#123; a || 0; &#125;（通常用逻辑或的短路来防止实参不足的情况，强行赋值；）（7）、自执行函数 （function func2()&#123; &#125;）() tips:在函数定义的结束最后写入一个（），该函数定义完成后直接被调用执行；（8）、递归 在函数执行的最后再一次的调用自身； tips:递归是一种非常耗资源的做法，通常为了简化运算，还会结合缓存进行； 并且注意，递归必须要有结束判断条件（if），否则该函数被调用后就是死循环； 数据类型1234567891011121314（1）、简单数据类型 string、number、boolean（2）、复杂数据类型 String、Number、Boolean、Array、Math、Date、Obeject、function、RegExp(正则表达式)（3）、空数据类型 * Null ---→Null的数据类型会返回一个Object * undifined tips：用typeof可以进行判断数据类型； tips：定义的简单数据类型变量，其数据保存在变量中； 而复杂数据类型，其变量保存的是数据所在的内存地址； 内置对象1Array、Date、Math、String； （Math）数学对象123456789101112131415161718向上取整 Math.ceil(number);向下取整 Math.floor(number);四舍五入 Math.round(number);求多个数字之间的最大值 Math.max();求多个数字之间的最小值 Math.min();求x的y次幂 Math.pow(x,y);求正弦值 Math.sin(x); example: 求一个角度的正弦值，要求x必须是一个额弧度值 角度和弧度的转换公式： 弧度 = 角度 * 2 * Math.PI / 360; Math.sin(30*2*Math.PI/360)Math.abs(x); 得到一个数字的绝对值 （Array）数组对象123456789101112131415161718192021222324252627282930313233343536373839404142434445（1）、arr1.concat(arr2); 数组拼接，结果为将arr2拼接到arr1的最后；（2）、arr.join()； 数组字符串输出，括号内可以指定元素连接的符号； eg: arr=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]; console.log(arr.join(&quot;|&quot;)); (结果为&quot;a|b|c|d&quot;)（3）、arr.pop(); 切除数组的最后一个元素，返回值为该元素；（4）、arr.slice(start,end) 获取，获取数组的指定片段，start必须有，如果参数为负数则从末尾开始选取； 返回值为该片段组成的，一个新的数组；（5）、arr.push 添加，用于向数组的末尾添加新的元素，参数可以是多个； 返回值为数组的新长度；（6）、arr.splice 1、用于向数组中指定的索引添加元素； arr.splice(2, 0, &quot;William&quot;,&quot;asdfasdf&quot;); 在第2个元素开始，删除的元素个数（可以为0，为0到结尾）， 加入元素为&quot;William&quot;、&quot;asdfasdf&quot;； 2、用于替换数组中的元素； arr.splice(2,1,&quot;William&quot;)； 3、用于删除数组中的元素； arr.splice(2,2);（7）、arr.indexOf(element); 查找，在数组中查找element，返回值为索引，如果没有该元素返回-1；（8）、arr.sort(function); 排序，function为一个函数； eg: function sortNumber(a,b)&#123; return a-b; &#125; arr.sort(sortNumber);(从小到大排序) tips：如果a-b改成b-a，那么执行的操作为从大到小； tips:字符串对象（String）的方法与Array的方法类似； （Date）日期对象1234567891011date.getTime()date.getMilliseconds()date.getSeconds()date.getMinutes()date.getHours()date.getDay()date.getDate()date.getMonth()date.getFullYear()tips:很多，查文档 （String）对象1234567891011121314151617181920212223242526charAt(index)str[index] 获取字符串指定位置的字符concat() 拼接字符串---------------------------slice(start,end)/substring(start,end) 截取从start开始，end结束的字符， 返回一个新的字符串，若start为负数，那么从最后一个字符开始；substr(start,length) 截取从start开始，length长度的字符，得到一个新的的字符串---------------------------indexOf(char) 获取指定字符第一次在字符串中的位置lastIndexOf(char) 获取指定字符最后一次出现在字符串中的位置trim() 去除字符串前后的空白---------------------------toUpperCase()toLocaleUpperCase() 转换为大写toLowerCase()toLocaleLowerCawse() 转换为小写---------------------------replace() 替换字符split() 分割字符串为数组 自定义对象12345678910111213141516171819202122对象：无序属性的集合； 特征：属性（key）； 行为：方法（value）；js是基于对象的弱类型语言；继承：基于类，子类可以从父类得到的特征； 工厂模式：定义一个function构造函数，作为对象，要创建对象直接调用该构造函数，加new关键字；构造函数：定义对象的函数，里面存有该对象拥有的基本属性和方法； 命名首字母大写，this会自动指代当前对象；访问对象属性： obj[key]; obj.key;遍历对象： for(key in obj)&#123; key 为属性名； obj[key] 为属性值（value）； &#125; JSON1234567891011&#123; &quot;name&quot; : &quot;李狗蛋&quot;, &quot;age&quot; : 18, &quot;color&quot; : &quot;yellow&quot;&#125;1、 所有的属性名，必须使用双引号包起来；2、 字面量侧重的描述对象，JSON侧重于数据传输；3、 JSON不支持undefined；4、 JSON不是对象，从服务器发来的json一般是字符串，通过JSON.parse(jsonDate.json)可以将其转换成js对象； JS解析12345678（1）、作用域全局作用域：整个代码所有地方都可以调用；局部作用域：在函数内部声明的变量，只可以在函数内部使用；（2）、变量提升和函数提升预解析：在解析的时候，var和function都会被提升到代码的最顶端； 但是赋值操作不会被提升，定义和函数才会被提升； if里面的变量定义也会被提升，但是赋值操作不会； 其他细节（tips）12345678910111213141516171819202122232425(1)、元素由对象组成的数组进行排序 eg： var data = [ &#123;title: "老司机", count: 20&#125;, &#123;title: "诗人", count: 5&#125;, &#123;title: "歌手", count: 10&#125;, &#123;title: "隔壁老王", count: 30&#125;, &#123;title: "水手", count: 7&#125;, &#123;title: "葫芦娃", count: 6&#125;, ]; //该数组的元素都为对象。我们需求为根据count的值给数组重新排序。 //解决方案：使用sort方法，对传入的函数做手脚。 function sortArr(a,b)&#123; return a.count &gt; b.count; &#125; data.sort(sortArr); //原本的a和b的比较方法变成a.count和b.count； //原本的比较方法可以参见17，数组对象 //至此，data将以count值从小到大排列。 tips:Array对象的sort方法传入的为比较函数，比较函数里return排序比较的方法； 原始的sort方法传入的函数内部return的值为a&gt;b， 通过修改sort传入的函数，可以实现对元素为对象的数组的排序！ JavaScript的内部对象按创建方式不同分为：使用变量声明的隐性对象，使用new创建的显性对象 隐性对象在赋值和声明后就是一个隐性对象，隐性对象不支持prototype属性，也无法随意扩展对象属性。 显性对象显性对象支持prototype属性，支持新建对象属性。 JavaScript提供了十一种内部对象Boolean对象 Boolean对象是一种数据类型，提供构造函数可以创建布尔数据类型的对象 objboolean=new Boolean(); Funcation对象 JavaScript函数就是一个funcation对象，Funcation对象是函数，如果函数有参数，这些传入的参数都是argument对象 Global对象 Global对象不能使用new来创建，在脚本语言初始化时会自动创建此对象。 Number对象 Number对象，用于创建数值类型的变量 Object对象 使用Object对象创建自定义对象 RegExp对象 JavaScript的正则表达式对象 5-2JavaScript的string对象 创建string对象var obj=”javascript”;或var obj2=new string(“JavaScript”);两种方式 string对象提供了一系列的格式编排方法####String 对象方法 方法 描述 anchor() 创建 HTML 锚。 big() 用大号字体显示字符串。 blink() 显示闪动字符串。 bold() 使用粗体显示字符串。 fixed() 以打字机文本显示字符串。返回string中内容 fontcolor() 使用指定的颜色来显示字符串。 fontsize() 使用指定的尺寸来显示字符串。 fromCharCode() 从字符编码创建一个字符串。 link() 将字符串显示为链接。 italics() 使用斜体显示字符串。 localeCompare() 用本地特定的顺序来比较两个字符串。 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。 small() 使用小字号来显示字符串。 strike() 使用删除线来显示字符串。 sub() 把字符串显示为下标。 sup() 把字符串显示为上标。 toSource() 代表对象的源代码。 toString() 返回字符串。 valueOf() 返回某个字符串对象的原始值。 1234567891011121314151617&lt;script type ="text/javascript"&gt; var obj = "JavaScript程序设计"; document.write("anchor():" + obj.anchor() + "&lt;br/&gt;"); document.write("big():" + obj.big() + "&lt;br/&gt;"); document.write("blink():" + obj.blink() + "&lt;br/&gt;"); document.write("bold():" + obj.bold() + "&lt;br/&gt;"); document.write("fixed():" + obj.fixed() + "&lt;br/&gt;"); document.write("fontcolor(red):" + obj.fontcolor("red") + "&lt;br/&gt;"); document.write("fontsize(6):" + obj.fontsize(6) + "&lt;br/&gt;"); document.write("italics()" + obj.italics() + "&lt;br/&gt;"); document.write("link()" + obj.link("https://home.cnblogs.com/u/cyjy/") + "&lt;br/&gt;"); document.write("small()" + obj.small() + "&lt;br/&gt;"); document.write("strike():" + obj.strike() + "&lt;br/&gt;"); document.write("sub():" + obj.sub() + "&lt;br/&gt;"); document.write("sup():" + obj.sup() + "&lt;br/&gt;"); &lt;/script&gt; 字符串的长度与大小写length属性是用于获取字符串的长度 toLocaleLowerCase() 把字符串转换为小写。 toLocaleUpperCase() 把字符串转换为大写。 toLowerCase() 把字符串转换为小写。 toUpperCase() 把字符串转换为大写。 12345678910&lt;script type ="text/javascript"&gt; var obj = "JavaScript"; var obj2 = new String("程序设计"); document.write("英文测试字符串：" + obj + "&lt;br/&gt;"); document.write("中文测试字符串：" + obj2 + "&lt;br/&gt;"); document.write("英文测试字符串length：" + obj.length + "&lt;br/&gt;"); document.write("中文测试字符串length：" + obj2.length+ "&lt;br/&gt;"); document.write("英文测试字符串小写：" + obj.toLowerCase() + "&lt;br/&gt;"); document.write("英文测试字符串大写：" + obj.toUpperCase() + "&lt;br/&gt;"); &lt;/script&gt; 获取字符串的指定字符charAt(index) 返回在指定位置的字符。 charCodeAt(index) 返回在指定的位置的字符的 Unicode 编码。 12345678&lt;script type ="text/javascript"&gt; var obj = "JavaScript"; var obj2 = new String("程序设计"); document.write("英文测试字符串：" + obj + "&lt;br/&gt;"); document.write("中文测试字符串：" + obj2 + "&lt;br/&gt;"); document.write("英文测试字符串.charAt(4)：" + obj.charAt(4) + "&lt;br/&gt;"); document.write("英文测试字符串charCodeAt(4)：" + obj.charCodeAt(4) + "&lt;br/&gt;"); &lt;/script&gt; 子字符串的搜索indexOf(string,index) 检索字符串。返回第一次找到字符串的索引位置，没有找到返回-1，传入的string是要搜索的参数，index为要搜索的索引位置 lastIndexOf(string) 从后向前搜索字符串。 match(string) 找到一个或多个正则表达式的匹配。没有找到返回null search(string) 检索与正则表达式相匹配的值。 123456789101112&lt;script type ="text/javascript"&gt; var obj = "JavaScript"; var obj2 = new String("程序设计"); document.write("英文测试字符串indexOf('a')：" + obj.indexOf('a') + "&lt;br/&gt;"); document.write("英文测试字符串indexOf('a',2)：" + obj.indexOf('a',2) + "&lt;br/&gt;"); document.write("中文测试字符串.indexOf('程序')：" + obj2.indexOf('程序') + "&lt;br/&gt;"); document.write("英文测试字符串.lastIndexOf('a') ：" + obj.lastIndexOf('a') + "&lt;br/&gt;"); document.write("英文测试字符串.match('Java')：" + obj.match('Java') + "&lt;br/&gt;"); document.write("中文测试字符串.match('程序')：" + obj2.match('程序') + "&lt;br/&gt;"); document.write("英文测试字符串.search('Java')：" + obj.search('Java') + "&lt;br/&gt;"); document.write("中文测试字符串.search('学校')：" + obj2.search('学校') + "&lt;br/&gt;"); &lt;/script&gt; 子字符串的处理replace(string1，string2) 替换与正则表达式匹配的子串。将string1换成string2 split() 把字符串分割为字符串数组。返回数组对象。 substr(index,length) 从起始索引号提取字符串中指定数目的字符。从index开始取出length个字符串 substring(index1，index2) 提取字符串中两个指定的索引号之间的字符。 concat(string) 连接字符串。将string字符串添加到string对象的字符串之后. 12345678910&lt;script type ="text/javascript"&gt; var obj = "JavaScript"; var obj2 = new String("程序设计"); document.write("英文测试字符串：" + obj + "&lt;br/&gt;"); document.write("中文测试字符串：" + obj2 + "&lt;br/&gt;"); document.write("英文测试字符串.replace('Script', '')" + obj.replace('Script', '') + "&lt;br/&gt;"); document.write("中文测试字符串.split('序')" + obj2.split('序') + "&lt;br/&gt;"); document.write("英文测试字符串.substr(2,4)" + obj.substr(2, 4) + "&lt;br/&gt;"); document.write("英文测试字符串obj2.substring(2,5)" + obj2.substring(2, 5) + "&lt;br/&gt;"); &lt;/script&gt; 将12/5/2012变为2012-5-12； var obj = “12/5/2012”;​ var obj = obj.replace(/\//g,”-“); var obj2=obj.replace(/(\d{2})-(\d{1}|\d{2})-(\d{4})/g,’$3-$2-$1’);​ alert(obj2); JavaScript的Array对象 JavaScript数据类型中没有数组，而是使用Array对象来创建数组，每一个数组元素事实上就是Array对象的属性。 创建一维数组 new Array(); new Array(size); new Array(element0, element1, …, elementn); 123456789101112131415&lt;script type ="text/javascript"&gt; var arr = new Array(1,2,3,4); var arr2 = new Array(3); arr2[0] = "one"; arr2[1] = "two"; arr2[2] = "three"; //用循环显示数组值 for (var i = 0; i &lt;=arr.length; i++) &#123; document.write(arr[i] + "&lt;br/&gt;"); &#125; for (var i = 0; i &lt;3; i++) &#123; document.write(arr2[i] + "&lt;br/&gt;"); &#125; &lt;/script&gt; Array对象的属性与方法length属性获取数组长度 方法 描述concat(arry) 连接两个或更多的数组，并返回结果。将参数合并到当前的数组中join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。shift() 删除并返回数组的第一个元素slice() 从某个已有的数组返回选定的元素splice() 删除元素，并向数组添加新元素。toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。reverse() 颠倒数组中元素的顺序。sort(arry)将数组的所有元素排序** 123456789101112131415161718192021&lt;script type ="text/javascript"&gt; var arr = new Array(1,2,3,4); var arr2 = new Array(3); arr2[0] = "one"; arr2[1] = "two"; arr2[2] = "three"; function showarr(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; document.write(arr[i] + ","); &#125; &#125; document.write("数组长" + arr2.length + "&lt;br/&gt;"); document.write(arr2.join() + "&lt;br/&gt;"); arr2.reverse();//反转数组 document.write("&lt;br/&gt;"); showarr(arr); document.write("&lt;br/&gt;"); arr = arr.concat(arr2);//连接两个数组 showarr(arr); &lt;/script&gt; JavaScript的多维数组 123456789101112131415161718192021&lt;script type ="text/javascript"&gt; var arr = new Array(3); for (var i = 0; i &lt; 3; i++) &#123; arr[i] = new Array(2); &#125; arr[0][0] = "1"; arr[0][1] = "2"; arr[1][0] = "3"; arr[1][1] = "4"; arr[2][0] = "5"; arr[2][1] = "6"; for (var j= 0; j&lt; arr.length;j++) &#123; for (i = 0; i &lt; arr[i].length; i++) &#123; document.write(arr[j][i]); &#125; document.write("&lt;br/&gt;"); &#125; &lt;/script&gt; JavaScript的Date对象Date对象可以获取计算机的系统时间和日期，并且提供相关的方法将它转化为所需的日期数据。 创建Date对象 var youDate=new Date() Date 对象会自动把当前日期和时间保存为其初始值。 Date() 返回当日的日期和时间。getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)，也就是星期日到星期六。getMonth() 从 Date 对象返回月份 (0 ~ 11)。getFullYear() 从 Date 对象以四位数字返回年份。getYear() 请使用 getFullYear() 方法代替。getHours() 返回 Date 对象的小时 (0 ~ 23)。getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 123456&lt;script type ="text/javascript"&gt; var youDate = new Date(); document.write("系统日期：" + youDate.getDate()); document.write("&lt;br/&gt;"); document.write("系统时间：" + youDate.getHours() + ":" + youDate.getMinutes()+":"+youDate.getSeconds()); &lt;/script&gt; 设置时间和日期 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。setMonth() 设置 Date 对象中月份 (0 ~ 11)。setFullYear() 设置 Date 对象中的年份（四位数字）。setYear() 请使用 setFullYear() 方法代替。setHours() 设置 Date 对象中的小时 (0 ~ 23)。setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。setTime() 以毫秒设置 Date 对象。 JavaScript的Date对象可以获取系统时间，只需定时执行JavaScript函数就可以建立一个网页时钟，同时需要使用setTimeout（），参数中可以设置间隔多少时间来执行函数，clearTimeout（）可以清除定时器 JavaScript的Math对象Math对象不同于其他JavaScript对象，Math对象是由脚本语言引擎所创建的，不需要使用new来创建。 max(x,y) 返回 x 和 y 中的最高值。min(x,y) 返回 x 和 y 中的最低值。pow(x,y) 返回 x 的 y 次幂。random() 返回 0 ~ 1 之间的随机数。 需要获得更大的随机数乘以相关的倍数就可以了 1234&lt;script type ="text/javascript"&gt; var num = Math.round(Math.random() * 100); document.write("0~100之间的随机数"+num); &lt;/script&gt; JavaScript的Error对象 try catch finally处理例外。 JavaScript对象的共享属性和方法 属性 constructor属性可以获取创建对象使用的构造函数的函数名称 tostring（）方法和value（）可以显示对象的内容。 js中的DOM操作汇总一、DOM创建DOM节点（Node）通常对应于一个标签，一个文本，或者一个HTML属性。DOM节点有一个nodeType属性用来表示当前元素的类型，它是一个整数： Element，元素 Attribute，属性 Text，文本 DOM节点创建最常用的便是document.createElement和document.createTextNode方法： 12var node1 = document.createElement('div');var node2 = document.createTextNode('hello world!'); 二、DOM查询1234567891011121314151617181920212223242526272829303132333435363738394041// 返回当前文档中第一个类名为 "myclass" 的元素var el = document.querySelector(".myclass");// 返回一个文档中所有的class为"note"或者 "alert"的div元素var els = document.querySelectorAll("div.note, div.alert");// 获取元素var el = document.getElementById('xxx');var els = document.getElementsByClassName('highlight');var els = document.getElementsByTagName('td');Element也提供了很多相对于元素的DOM导航方法：// 获取父元素、父节点var parent = ele.parentElement;var parent = ele.parentNode;//只读，没有兼容性问题var offsetParent=ele.offsetParent;//只读，找到最近的有定位的父节点。 //没有定位父级时，默认是body;但在IE7以下，如果当前元素没有定位属性，返回body，如果有，返回HTML; //如果当前元素某个父级触发了haslayout，则返回触发了haslayout这个元素。// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断var nodes = ele.children;//标准下、非标准下都只含元素类型，但对待非法嵌套的子节点，处理方式与childNodes一致。 var nodes = ele.childNodes;//非标准下：只包含元素类型，不会包含非法嵌套的子节点。 //标准下：包含元素和文本类型，会包含非法嵌套的子节点。 //获取元素属性列表var attr = ele.attributes;// 查询子元素var els = ele.getElementsByTagName('td');var els = ele.getElementsByClassName('highlight');// 当前元素的第一个/最后一个子元素节点var el = ele.firstChild;//对待标准和非标准模式，如childNodsvar el = ele.lastChild;var el = ele.firstElementChild;//非标准不支持var el = ele.lastElementChild;// 下一个/上一个兄弟元素节点var el = ele.nextSibling;var el = ele.previousSibling;var el = ele.nextElementSibling;var el = ele.previousElementSibling; 兼容的获取第一个子元素节点方法： var first=ele.firstElementChild||ele.children[0]; 三、DOM更改123456789101112// 添加、删除子元素ele.appendChild(el);ele.removeChild(el);// 替换子元素ele.replaceChild(el1, el2);// 插入子元素parentElement.insertBefore(newElement, referenceElement);//克隆元素ele.cloneNode(true) //该参数指示被复制的节点是否包括原节点的所有属性和子节点 四、属性操作12345678910111213// 获取一个&#123;name, value&#125;的数组var attrs = el.attributes;// 获取、设置属性var c = el.getAttribute('class');el.setAttribute('class', 'highlight');// 判断、移除属性el.hasAttribute('class');el.removeAttribute('class');// 是否有属性设置el.hasAttributes(); innerHTML与outerHTML的区别？ 比如对于这样一个HTML元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。 innerHTML：内部HTML，content&lt;br/&gt;； outerHTML：外部HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;； innerText：内部文本，content； outerText：内部文本，content； 上述四个属性不仅可以读取，还可以赋值。outerText和innerText的区别在于outerText赋值时会把标签一起赋值掉，另外xxText赋值时HTML特殊字符会被转义。 下图来源于：http://walsh.iteye.com/blog/261966 jQuery的html()与innerHTML的区别？jQuery的.html()会调用.innerHTML来操作，但同时也会catch异常，然后用.empty(), .append()来重新操作。 这是因为IE8中有些元素(比如input等)的.innerHTML是只读的。见：http://stackoverflow.com/questions/3563107/jquery-html-vs-innerhtml 引用资料： http://stackoverflow.com/questions/3563107/jquery-html-vs-innerhtml http://walsh.iteye.com/blog/261966 http://harttle.com/2015/10/01/javascript-dom-api.html javascript中的BOM浏览器对象模型BOM，提供了访问浏览器的接口。这些功能大多和网页内容无关，多年来，由于缺乏规范导致BOM中的不同方法在不同浏览器中的实现有所差异，直到html5，才将BOM的主要方面纳入规范。 BOM常用的特性包括： 一、window对象window对象在浏览器中具有双重角色：它既是ECMAscript规定的全局global对象，又是javascript访问浏览器窗口的一个接口。 获取窗口相对于屏幕左上角的位置 123//获取窗口相对于屏幕左上角的位置var leftPos=(typeof window.screenLeft==='number')?window.screenLeft:window:screenX;var topPos=(typeof window.screenLeft==='number')?window.screenTop:window:screenY; 需要注意的一点是，在IE，opera中，screenTop保存的是页面可见区域距离屏幕左侧的距离，而chrome,firefox,safari中，screenTop/screenY保存的则是整个浏览器区域距离屏幕左侧的距离。也就是说，二者差了一个浏览器工具栏的像素高度。 移动窗口，调整窗口大小 1234window.moveTo(0,0)window.moveBy(20,10)window.resizeTo(100,100);window.resizeBy(100,100); 注意，这几个方法在浏览器中很可能会被禁用。 获得浏览器页面视口的大小 12var pageWith=document.documentElement.clientWidth||document.body.clientWidth;var pageHeight=document.documentElement.clientHeight||document.body.clientHeight; 导航和打开窗口 window.open()既可以导航到特定的URL，也可以打开一个新的浏览器窗口，其接收四个参数，要加载的url，窗口目标（可以是关键字_self,_parent,_top,_blank）,一个特性字符串，以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需要传递第一个参数。 注意，在很多浏览器中，都是阻止弹出窗口的。 几个时序相关的函数（原来这是BOM的实现，而非ECMAjavascript的实现） setInterval() setTimeout() 系统对话框，这些对话框外观由操作系统/浏览器设置决定，css不起作用，所以很多时候可能需要自定义对话框 alert():带有一个确定按钮 confirm()：带有一个确定和取消按钮 prompt():显示OK和Cancel按钮之外，还会显示一个文本输入域 二、location对象location对象提供了当前窗口加载的文档的相关信息，还提供了一些导航功能。事实上，这是一个很特殊的对象，location既是window对象的属性，又是document对象的属性。 123456789101112131415location.hash #contents 返回url中的hash，如果不包含#后面的内容，则返回空字符串location.host www.wrox.com:80 返回服务器名称和端口号location.port 80 返回端口号location.hostname www.wrox.com 返回服务器名称location.href http://www.wrox.com 返回当前加载页面的完整urllocation.pathname /index.html 返回url中的目录和文件名location.protocol http 返回页面使用的协议location.search ?q=javascript 返回url中的查询字符串 改变浏览器的位置： 12345location.href=http://www.baidu.comlocation.replace('http://www.baidu.com')//不会在历史记录中生成新纪录，用户不能回到前一个页面。location.reload()：//重置当前页面，可能从缓存，也可能从服务器；如果强制从服务器取得，传入true参数 三，navigator对象这个对象代表浏览器实例，其属性很多，但常用的不太多。如下： 12345navigator.userAgent：//用户代理字符串，用于浏览器监测中、navigator.plugins://浏览器插件数组，用于插件监测navigator.registerContentHandler //注册处理程序，如提供RSS阅读器等在线处理程序。 四、history对象history对象保存着用户上网的历史记录，使用go()实现在用户的浏览记录中跳转： 1234history.go(-1) 等价于history.back()history.go(1) 等价于 history.forward()history.go(1) //前进两页history.go('wrox.com') JS函数的几种定义方式分析本文实例讲述了JS函数的几种定义方式。分享给大家供大家参考，具体如下： JS函数的定义方式比较灵活，它不同于其他的语言，每个函数都是作为一个对象被维护和运行的。 先看几种常用的定义方式： 12345678910function func1([参数])&#123; /*函数体*/&#125;var func2=function([参数])&#123; /*函数体*/&#125;;var func3=function func4([参数])&#123; /*函数体*/&#125;;var func5=new Function(); 上述 第一种方式是最常用的方式，不用多说。 第二种是将一匿名函数赋给一个变量，调用方法：func2([函数]); 第三种是将func4赋给变量func3，调用方法：func3([函数]);或func4([函数]); 第四种是声明func5为一个对象。 再看看它们的区别： 1234567function func()&#123; //函数体&#125;//等价于var func=function()&#123; //函数体&#125; 但同样是定义函数，在用法上有一定的区别。 12345678&lt;script&gt;//这样是正确的func(1);function func(a)&#123; alert(a);&#125;&lt;/script&gt; 1234567891011121314&lt;script&gt;//这样是错误的，会提示func未定义，主要是在调用func之前没有定义func(1);var func = function(a)&#123; alert(a);&#125;//这样是正确的，在调用func之前有定义var func = function(a)&#123; alert(a);&#125;func(1);&lt;/script&gt; 用同样的方法可以去理解第三种定义方式。 第四种定义方式也是需要声明对象后才可以引用。 JS定义（声明）函数的几种方式1. 函数式声明1234function funName(arg1, arg2)&#123; alert(arg1 + “,” + arg2); &#125; 特点：此种方式可定义命名的函数变量，而无需给变量赋值，这是一种独立的结构，不能嵌套在非功能模块中。函数名在自身作用域和父作用域内是可获取的（其他域是娶不到的）。当解析器读取js代码时，会先读取函数的声明，此种方式定义的函数在执行任何代码之前都可以访问（调用）。 2、 函数表达式（函数字面量）1234567891011var fun = function(arg1, arg2)&#123; alert(arg1 + “,” + arg2);&#125;var fun = function funName(arg1,arg2)&#123; alert(arg1 + “,” + arg2);&#125;(function hello()&#123; alert(“HelloWorld!!!”);&#125;)(); // 自调用 特点：地中方式是将函数定义为表达式语句的一部分。函数可以是命名的也可以是匿名的。而且必须等到解析器执行到它所在的代码行才能真正被解释执行。 3、 函数构造法，参数必须加引号1var fun = new Function(‘arg1’, ‘arg2’, ‘alert(arg1 + “,” + arg2)’); 特点：从技术角度讲，这是一个函数表达式。但是一般不推荐这种方式。 4、 对象直接量123456789var obj = &#123; name : “”, getName : function()&#123; return this.name; &#125;, setName : function(name)&#123; this.name = name; &#125; &#125;; 特点：将方法的定义看做为一个对象的成员变量，此时对象的变量值为一个方法，通过访问该对象的属性名称，达到调用方法的效果。 5、 原型继承12345678910var obj = new Function();obj.prototype = &#123; name : “”, getName : function()&#123; return this.name; &#125;, setName : function(name)&#123; this.name = name; &#125;&#125;; 特点：定义了一个函数对象，在其原型对象中定义方法。在使用prototype的方法时，必须实例化该对象才能调用其方法。 6、 工厂模式1234567891011function obj()&#123; var temp = new Object(); temp.name = “”; temp.getName = function()&#123; return this.name; &#125;; temp.setName(name)&#123; this.name = name; &#125;; return temp; &#125; 特点：工厂模式是软件工程领域一种广为人知的设计模式，由于在ECMAScript中无法创建类，因此用函数封装以特定接口创建对象。即在一个函数内创建一个对象，给对象赋予属性和方法再将其对象返回。 以上介绍的几种js中创建方法常用的方式，根据其特点和理解可以根据实际情况使用不同的方式声明函数。 js全局函数parseInt(String,radix):返回转换成整数的值。 注意：当参数radix的值为0，或者没有设置这个参数，parseInt()会根据string来判断数字的基数。 当忽略radix，JavaScript默认数字的基数规则为： 如果string以0x开头，parseInt()会把string的其余部分解析为十六进制的整数。 如果string以0开头，那么ECMAScript v3允许parseInt()的一个实现把其后的字符解析为八进制或十六进制的数。 如果string以1~9的数字开头，parseInt()将把它解析为十进制的整数。 如果字符串以合法字符开始，parseInt()会截取合法字符。 String开头和结尾的空格是允许的。 如果字符串的第一个字符不能被转换为数字，parseInt()会返回NaN。 在字符串以”0”为开始时旧的浏览器默认使用八进制基数。ECMAScript 5，默认的是十进制的基数。 parseFloat(string):返回转换成浮点型的值。 该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 isFinite(value):检测某个是是否是无穷值。 如果value是NaN或者+Infinity或者-Infinity的数，isFinite()返回false。 isNaN(value):检测某个值是否是NaN。 isNaN()检测是否是非数字值，如果值为NaN返回true，否则返回false。 encodeURI(uri):将字符串编码为URI。 使用 decodeURI() 方法可以编码URI（通用资源标识符:Uniform Resource Identifier,简称”URI”)。 对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的： , / ? : @ &amp; = + $ # (可以使用 encodeURIComponent() 方法分别对特殊含义的 ASCII 标点符号进行编码。) decodeURI(uri):解码某个编码的URI。encodeURIComponent(uri):将字符串编码为URI组件 该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。 其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），将由一个或多个十六进制的转义序列替换的。 decodeURIComponent():解码一个编码的URI组件escape():对字符串进行编码 该函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。 该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。 该函数不能用于编码 URIs(通用资源标识符（UniformResourceIdentifier,简称”URI”）） unescape():解码由escape()编码的字符串eval():将JavaScript字符串当作脚本来执行 如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。 eval()函数是一种由函数执行的动态代码，比直接执行脚本慢很多。 慎重使用eval()函数,尽量不用，保证程序的安全性。 Number(object):把对象的值转换为数字 如果对象的值无法转换为数字，Number()函数返回NaN。 如果参数的Date对象，Number()返回从1970年1月1日到现在所经历的毫秒数 String():把对象的值转换为字符串 String() 函数返回与字符串对象的toString()方法值一样。 顶层函数（全局函数） 函数 描述 decodeURI() 解码某个编码的 URI。 decodeURIComponent() 解码一个编码的 URI 组件。 encodeURI() 把字符串编码为 URI。 encodeURIComponent() 把字符串编码为 URI 组件。 escape() 对字符串进行编码。 eval() 计算 JavaScript 字符串，并把它作为脚本代码来执行。 getClass() 返回一个 JavaObject 的 JavaClass。 isFinite() 检查某个值是否为有穷大的数。 isNaN() 检查某个值是否是数字。 Number() 把对象的值转换为数字。 parseFloat() 解析一个字符串并返回一个浮点数。 parseInt() 解析一个字符串并返回一个整数。 String() 把对象的值转换为字符串。 unescape() 对由 escape() 编码的字符串进行解码。 顶层属性（全局属性） 方法 描述 Infinity 代表正的无穷大的数值。 java 代表 java.* 包层级的一个 JavaPackage。 NaN 指示某个值是不是数字值。 Packages 根 JavaPackage 对象。 undefined 指示未定义的值。 全局对象描述全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。全局对象不是任何对象的属性，所以它没有名称。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。但通常不必用这种方式引用全局对象，因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象。 在 JavaScript 代码嵌入一个特殊环境中时，全局对象通常具有环境特定的属性。实际上，ECMAScript 标准没有规定全局对象的类型，JavaScript 的实现或嵌入的 JavaScript 都可以把任意类型的对象作为全局对象，只要该对象定义了这里列出的基本属性和函数。例如，在允许通过 LiveConnect 或相关的技术来脚本化 Java 的 JavaScript 实现中，全局对象被赋予了这里列出的 java 和 Package 属性以及 getClass() 方法。而在客户端 JavaScript 中，全局对象就是 Window 对象，表示允许 JavaScript 代码的 Web 浏览器窗口。 JavaScript 事件事件是可以被 JavaScript 侦测到的行为。 JavaScript 使我们有能力创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数的事件。比方说，我们可以在用户点击某按钮时产生一个 onClick 事件来触发某个函数。事件在 HTML 页面中定义。 事件举例： 鼠标点击 页面或图像载入 鼠标悬浮于页面的某个热点之上 在表单中选取输入框 确认表单 键盘按键 注意：事件通常与函数配合使用，当事件发生时函数才会执行。 onload 和 onUnload当用户进入或离开页面时就会触发 onload 和 onUnload 事件。 onload 事件常用来检测访问者的浏览器类型和版本，然后根据这些信息载入特定版本的网页。 onload 和 onUnload 事件也常被用来处理用户进入或离开页面时所建立的 cookies。例如，当某用户第一次进入页面时，你可以使用消息框来询问用户的姓名。姓名会保存在 cookie 中。当用户再次进入这个页面时，你可以使用另一个消息框来和这个用户打招呼：”Welcome John Doe!”。 onFocus, onBlur 和 onChangeonFocus、onBlur 和 onChange 事件通常相互配合用来验证表单。 下面是一个使用 onChange 事件的例子。用户一旦改变了域的内容，checkEmail() 函数就会被调用。 1&lt;input type=&quot;text&quot; size=&quot;30&quot; id=&quot;email&quot; onchange=&quot;checkEmail()&quot;&gt; onSubmitonSubmit 用于在提交表单之前验证所有的表单域。 下面是一个使用 onSubmit 事件的例子。当用户单击表单中的确认按钮时，checkForm() 函数就会被调用。假若域的值无效，此次提交就会被取消。checkForm() 函数的返回值是 true 或者 false。如果返回值为true，则提交表单，反之取消提交。 1&lt;form method=&quot;post&quot; action=&quot;xxx.htm&quot; onsubmit=&quot;return checkForm()&quot;&gt; onMouseOver 和 onMouseOutonMouseOver 和 onMouseOut 用来创建“动态的”按钮。 下面是一个使用 onMouseOver 事件的例子。当 onMouseOver 事件被脚本侦测到时，就会弹出一个警告框： 123456&lt;a href=&quot;http://www.w3school.com.cn&quot;onmouseover=&quot;alert(&apos;An onMouseOver event&apos;);return false&quot;&gt;&lt;img src=&quot;w3school.gif&quot; width=&quot;100&quot; height=&quot;30&quot;&gt;&lt;/a&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java成神之路-HTML和CSS（二）]]></title>
    <url>%2Fblog%2F39276.html</url>
    <content type="text"><![CDATA[Java成神之路-HTML和CSS HTMLHTML整体结构HTML基础设施 文件应以“&lt;!DOCTYPE ……&gt;”首行顶格开始，推荐使用“&lt;!DOCTYPE html&gt;”。 必须申明文档的编码charset，且与文件本身编码保持一致，推荐使用UTF-8编码。 根据页面内容和需求填写适当的keywords和description。 页面title是极为重要的不可缺少的一项。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"/&gt;&lt;title&gt;NEC：更好的CSS方案&lt;/title&gt;&lt;meta name="keywords" content=""/&gt;&lt;meta name="description" content=""/&gt;&lt;meta name="viewport" content="width=device-width"/&gt;&lt;link rel="stylesheet" href="css/style.css"/&gt;&lt;link rel="shortcut icon" href="img/favicon.ico"/&gt;&lt;link rel="apple-touch-icon" href="img/touchicon.png"/&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 结构顺序和视觉顺序基本保持一致结构顺序和视觉顺序基本保持一致 按照从上至下、从左到右的视觉顺序书写HTML结构。 有时候为了便于搜索引擎抓取，我们也会将重要内容在HTML结构顺序上提前。 用div代替table布局，可以使HTML更具灵活性，也方便利用CSS控制。 table不建议用于布局，但表现具有明显表格形式的数据，table还是首选。 结构、表现、行为三者分离，避免内联 使用link将css文件引入，并置于head中。 使用script将js文件引入，并置于body底部。 保持良好的简洁的树形结构 每一个块级元素都另起一行，每一行都使用Tab缩进对齐（head和body的子元素不需要缩进）。删除冗余的行尾的空格。 使用4个空格代替1个Tab（大多数编辑器中可设置）。 对于内容较为简单的表格，建议将tr写成单行。 你也可以在大的模块之间用空行隔开，使模块更清晰。 123456789101112131415161718192021&lt;body&gt;&lt;!-- 侧栏内容区 --&gt;&lt;div class="m-side"&gt; &lt;div class="side"&gt; &lt;div class="sidein"&gt; &lt;!-- 热门标签 --&gt; &lt;div class="sideblk"&gt; &lt;div class="m-hd3"&gt;&lt;h3 class="tit"&gt;热门标签&lt;/h3&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;!-- 最热TOP5 --&gt; &lt;div class="sideblk"&gt; &lt;div class="m-hd3"&gt;&lt;h3 class="tit"&gt;最热TOP5&lt;/h3&gt; &lt;a href="#" class="s-fc02 f-fr"&gt;更多»&lt;/a&gt;&lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- /侧栏内容区 --&gt;&lt;/body&gt; 另外，请做到以下几点 结构上如果可以并列书写，就不要嵌套。 如果可以写成那么就不要写成 如果结构已经可以满足视觉和语义的要求，那么就不要有额外的冗余的结构。 比如已经能满足要求，那么就不要再写成 一个标签上引用的className不要过多，越少越好。 比如不要出现这种情况： 对于一个语义化的内部标签，应尽量避免使用className。 比如在这样一个列表中，li标签中的itm应去除： ​ HTML表单元素input元素最重要的表单元素是 元素。 元素根据不同的 type 属性，可以变化为多种形态。 注释：下一章讲解所有 HTML 输入类型。 select元素（下拉列表） 元素定义下拉列表： 123456&lt;select name="cars"&gt;&lt;option value="volvo"&gt;Volvo&lt;/option&gt;&lt;option value="saab"&gt;Saab&lt;/option&gt;&lt;option value="fiat"&gt;Fiat&lt;/option&gt;&lt;option value="audi"&gt;Audi&lt;/option&gt;&lt;/select&gt; option元素定义待选择的选项。列表通常会把首个选项显示为被选选项。 您能够通过添加 selected 属性来定义预定义选项。 1&lt;option value="fiat" selected&gt;Fiat&lt;/option&gt; textarea元素 元素定义多行输入字段（文本域）： 123&lt;textarea name="message" rows="10" cols="30"&gt;The cat was playing in the garden.&lt;/textarea&gt; 以上 HTML 代码在浏览器中显示为： 1The cat was playing in the garden. button元素 元素定义可点击的按钮： 1&lt;button type="button" onclick="alert('Hello World!')"&gt;Click Me!&lt;/button&gt; 以上 HTML 代码在浏览器中显示为： HTML5 增加了如下表单元素： datalist keygen output 注释：默认地，浏览器不会显示未知元素。新元素不会破坏您的页面。 HTML5 datalist元素 元素为 元素规定预定义选项列表。 用户会在他们输入数据时看到预定义选项的下拉列表。 元素的 list 属性必须引用 元素的 id 属性。 实例 通过 设置预定义值的 元素： 12345678910&lt;form action="action_page.php"&gt;&lt;input list="browsers"&gt;&lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt;&lt;/datalist&gt; &lt;/form&gt; CSS标签选择器顾名思议，标签选择器是直接将HTML标签作为选择器，可以是p、h1、dl、strong等HTML标签。如： 二、id选择器：每一个标签他都有一个共同属性id,所以我们通常给页面元素定义id。如图所示. 其中”p1”,”p2”,”p3”是你自己定义的id名称。注意在前面加”#”号。id选择器也同样支持后代选择器(针对嵌套标签) 如图所示: 三、类（class）选择器：每一个标签同样都有一个类属性,所以在CSS里用一个点开头表示类别选择器定义，例如： 在页面中，用class=”类别名”的方法调用,这个方法比较简单灵活，可以随时根据页面需要新建和删除。但需要避免多class综合症。 四、群组选择器：当几个元素样式属性一样时，可以共同调用一个声明，元素之间用逗号分隔。如： 下面来看(标签,id,类)群组选择器如图: 使用组群选择器，将会大大的减化CSS代码，将具有多个相同属性的元素，合并群组进行选择，定义同样的CSS属性，这大大的提高了编码效率与CSS文件体积。 五、后代选择器：后代选择器也称作为派生选择器,通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁。在 CSS 中，通过这种方式来应用规则的选择器被称为上下文选择器 (contextual selectors)，这是由于它们依赖于上下文关系来应用或者避免某项规则。在 CSS2 中，它们称为派生选择器，但是无论你如何称呼它们，它们的作用都是相同的。派生选择器允许你根据文档的上下文关系来确定某个标签的样式。通过合理地使用派生选择器，我们可以使 HTML 代码变得更加整洁。比方说，你希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器：请注意标记为 的蓝色代码的上下文关系： 在上面的例子中，只有 li 元素中的 strong 元素的样式为斜体字，无需为 strong 元素定义特别的 class 或 id，代码更加简洁。 结合使用上面的五种CSS选择器，基本满足了CSS布局的需要，主要在于灵活的使用，特别是后代选择器的使用能大大的简化HTML文档，使HTML做到结构化明确，最小的代码实现同样的效果。选择器讲完了,我们来看看选择器的优先级. 六 比较器的优先级比较同一级别的个数，数量多的优先级高，如果相同即比较下一级别的个数 ，至于各级别的优先级，大家应该已经很清楚了，就是： 1important &gt; 内联 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符 通配符 &gt; 继承1 这也就解释了为什么11个标签的定义会比不上1个类的定义，1个类加11个标签会比不上2个类的权重高。 选择器的优先级计算细则就显得很重要了。之前有人说选择器的优先级是tagname=1,classname=10,id=100, 因此选择器 #demo &gt; ul &gt; .active的优先级就是 100+10+1 = 111,实际上真是这么计算的嘛，难道10个class就和一个id的优先级是一样的？ 下面看看官方对选择器的定义：一个选择器的优先级由四个数字a,b,c,d确定。当比较两个选择器时，先比较a，a值大的优先级高，如果a相等则比较b，b值大的优先级高，以此类推。因此，无论b的值多大，也不会对a值的比较造成影响。 1234a由style确定，如果一个属性由元素上的style属性定义则a为1，否则a为0b是id的数量c是class和伪类以及属性的数量d是tagname以及伪元素的数量1234 按照这个规则，我们来看看下面这个选择器的优先级： 下面我们来看一下优先级的例子,如图所示: 上例中的元素是绿色的，因为内联元素的优先级最高同时也可以得出结论，低优先级选择器的叠加是不会影响高优先级的选择器的. CSS引入方式内嵌式通过&lt;style&gt; &lt;/style&gt;来书写CSS代码。 只能应用于当前网页，不能被其它网页共享。 注意：标记可以放在网页的任何地方，但一般放在。 外联式通过标记来引入外部的CSS文件(.css)。 可以被其它网页共享。public.css index.css news.css about.css 格式： 1&lt;link href=“CSS的URL” rel=“stylesheet” type=“text/css” /&gt; 注意：标记只能放在中 行内样式通过style的属性来书写CSS代码。 每一个HTML元素，都有 style、class、id、name、title 属性。 举例： 1&lt;p style=“font-size:24px;”&gt;&lt;/p&gt; CSS的字体/文本属性 Font-size：文字大小 Font-weight：加粗 Font-style：斜体 Color：颜色 Line-height：行高 Text-indent：首行缩进 Text-align：水平对齐 Letter-spacing：字符间距 CSS列表 List-style-type：列表类型，取值：none、circle、 square List-style-position：符号位置，取值：inside、outside List-style-image：图片路径，举例：list-style-image:url(images/li01.gif);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java成神之路——框架图（一）]]></title>
    <url>%2Fblog%2F62389.html</url>
    <content type="text"><![CDATA[Java工程师学习路线、知识框架图知识框架 JAVA学习路线图阶段一1：学习HTML 2:学习CSS 3:Javascript 4:jquery 5:xml解析 6：Bootstrap 阶段二7:JAVAse基础 8：mysql数据库 9：Powerdesigner 10:JDBC 11:JAVAWEB 阶段三12:oracle 13:struts2 14:Hibernate 15:Spring 阶段四16:Maven 17:SpringMVC 18:MyBatis 前端部分：​ 1. HTML：网页的核心语言，构成网页的基础 ​ 2. CSS：使网页更加丰富多彩灿烂的利器 ​ 3. JavaScript：使网页动起来的根本，加强了网页和用户之间的交互 ​ 4. HTML DOM：换一种更加形象化的角度来看待网页，让我们更加方便的控制网页 ​ 5. HTML BOM：与浏览器交互不可或缺的工具 ​ 6. JavaScript库，主要是：jQuery及其插件、YUI及其插件，使编写网页更加的方便快捷和健壮的强大工具 ​ 7. AJAX：异步提交，增强了用户使用网页的良好交互体验 ​ 8. JSON： 比 XML 更小、更快，更易解析的数据传输工具 ​ 9. FLEX：提供丰富多彩的动画效果 ​ 10. 普元工作流：更加清晰明了的帮助用户处理业务流程上面的工作 ​ 11. JSP：Servlet的展示层，使网页逻辑与网页设计的显示分离 ​ 12. JSTL：加强和简化了JSP页面的开发 ​ 13. EL：使JSP页面写起来更加简单 后台部分：​ 1. JAVA语言编程基础部分：内容丰富是Java知识体系结构的核心和基础 ​ 2. JDBC：提供了一种基准，据此可以构建更高级的工具和接口，使Java开发人员能够编写数据库应用程序 ​ 3. JavaMail：用于电子邮件的相关的编程工作 ​ 4. JUnit：单元测试，整个变成工作测试的地位始终非常重要 ​ 5. Log4j：使我们能够更加细致地控制日志的生成过程 ​ 6. Servlet：JavaWeb的核心 ​ 7. Struts2：JavaWeb编程中明星级的框架，优点多功能强使编程工作更简单，主要用于控制跳转 ​ 8. Spring：JavaWeb编程中明星级的框架，同样优点多功能强使编程工作更简单，主要用于管理对象 ​ 9. iBatis：JavaWeb编程中明星级的框架，同样也是优点多功能强使编程工作更简单，主要用于程序和数据库之间的交互 ​ 10. SQL：与数据库交互式编程的必备工具 版本控制： ​ 1. SVN：版本控制，方便团队协同工作 WEB服务器： ​ 1. Tomcat：优秀免费的中小型WEB服务器 ​ 2. Weblogic：功能很强大的WEB服务器 开发工具： ​ 1. Eclipse：开源强大的Java编程工具 ​ 2. MyEclipse：在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境 数据库： ​ 1. Oracle：数据库业界老大，这个常用一点当然，也仅仅是常用一些常用的功能而已，需要加强 ​ 2. MySQL：最好的关系型数据库之一 ​ 3. SqlServer：最好的关系型数据库之一 数据库客户端： ​ 1. Toad：非常棒的数据库客户端软件 操作系统： ​ 1. Windows ​ 2. Linux 远程登录的会话工具： ​ 1. SSH：一直在用，非常不错 其他： ​ 各种种类和版本的浏览器（推荐使用FireFox. 、office办公软件系列、各种文本编辑器（推荐Sublime. 、各种阅读器等等 Java程序员的学习路线图1：Java的知识体系结构 2：JavaWeb开发的基本学习路线图 3：JavaWeb开发的成长路线图]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程实践的八大常识]]></title>
    <url>%2Fblog%2F14284.html</url>
    <content type="text"><![CDATA[“常识” (Commonsense), 即多数人信以为真并自觉应用的知识, 受社会的普遍认同,反映当时社会的最一般观念。常识有“内心感官” 之称, 它如同外部感官(视、听、嗅、味和触) 一样, 能近乎“直觉” 和“本能” 地指导个体实践。概言之, 常识既是个体学习和实践的结晶, 又是个体学习和实践的法宝。 — 本文摘选自《软件工程核心知识》下卷第1093页，文中所提页码都出自该著作。 ​ 软件工程常识是软件实践者的法宝, 既包括一些已成功迁移至专业实践的生活常识, 又包括一些属于本领域独有的专业常识。本书一共阐述了55 项常识, 这些都是实践者最应掌握并自觉应用的核心知识。笔者从中归纳出最基本的八大常识, 列述如下。笔者认为, 这八大常识应当成为每一名专业实践者的“直觉” 或“本能”。 常识一：软件是一类人力、智力、知识和创造力密集的、充满“人性”的高复杂产品。 大师FrederickBrooks (布鲁克斯) 就说过, 软件是一类创造性的知识密集型产品, 是人类迄今为止最复杂的制品[Bro86]。 工程师的知识、创造力、技能和情感等因素共同造就了软件产品的“人性特征”, 表现为 产品具有强烈的“唯一性”, 而过程则表现出强烈的“不可重复性”。 常识二：没有普适的“万能”模型。(页162) 软件工程法则、定律、技术和过程等都仅针对特定应用场景, 无法同等有效地应用于不同团队和项目。经实践和研究凝聚而成的行业相关标准也明显不具有普适性。 常识三：不存在“完美的”软件产品。 业界著名专家NicholasZvegintzov 就说过, “软件永不完美, 也永不完整。” 软件开发团队永远得不到准确而完整的需求(页192), 也永远得不到所谓最佳的设计方案(页322), 最终也得不到完美的软件产品。 常识四：软件产品必须满足用户的现实需要, 进而实现价值/成本比的最大化。 软件是商品, 一切软件实践理所当然地应当考虑成本和价值Ê, 力求最大化价值/成本比(页24)。软件的价值主要体现为功能和质量, 即满足用户的现实功能和质量需求的程度。软件的成本主要是指开发和维护成本。 用户是软件产品的直接服务对象; 软件开发必须尽可能地满足用户的现实需要(页294)。注意, 并不是用户的所有需要都应得到满足。典型的, 所有不能为产品客户带来实质价值反馈的用户需要就不应得到满足。 常识五：人是软件实践的最重要因素。 软件是人力、智力和知识密集型产品, 实践者不要幻想能够全自动地开发出软件产品。 大型软件开发超出了单个工程师的脑力和能力范围, 必须依靠团队合力(页964)。诚如Tom DeMarco所言 “团队协作是推动平凡个体取得非凡成就的燃料” [DL99, 页178]。 常识六：以一种“足够简单”的方式, 完成软件实践。 软件产品本身已然具有高复杂度, 切勿再在开发过程中增添不必要的过程复杂度。为此, 软件管理者和工程师都应当选用最简单而又有效的策略和技术。 在保证设计方案适合于目标软件及其开发项目的前提之下, 尽可能地简化, 使之足够简单直接(页439)。类似的, 代码编写也应当简单明了(页513)。同时, 软件管理者应追求简单而有效的管理, 不要过度简化, 更不要复杂化(页769)。 常识七：阶段化开发。 阶段化反映出“分而治之” 的传统智慧。 软件生命期阶段化为三大主要阶段 开发、维护、演化(页88)。软件开发过程阶段化为四大主要阶段 需求工程、软件设计、构造和质量控制(包括测试和审查)(页94)。软件测试过程又阶段化为四大阶段 单元测试、集成测试、系统测试和验收测试(页591)。 常识八：将软件描述成文, 并存档。 著名软件工程学者MichaelJackson 就说过, “描述是软件开发之核。” 软件需求和设计方案都应当编写成具有合理结构的技术文档(页246)。同时, 软件过程必须成文, 并共享于团队(页891)。 文档编写必须讲究文风, 合理安排文档组织结构, 帮助读者快速而有效地阅读(页1007)。以敷衍态度匆忙编写的技术文档必定是低质量的(页1006)。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东亚教育浪费了太多生命]]></title>
    <url>%2Fblog%2F31929.html</url>
    <content type="text"><![CDATA[东亚国家现代的普鲁士教育体制阻碍了学生进行更为深入的探究，对他们独立思考的能力有害无益。2014年度诺贝尔物理学奖得主中村修二。 10月3日，2016年诺贝尔奖开奖第一天，日本科学家大隅良典获得诺贝尔生理学或医学奖。进入21世纪，日本科学家获奖人数快速增长。包括物理奖8位、化学奖6位、生理学或医学奖3位，共计17位，平均下来差不多一年一位。 日本获得这么多诺贝尔奖项，日本的科研环境、评价机制以及经费保障等因素都功不可没。但对于日本的教育现状，以及整个东亚教育体系，中村修二（2014年度诺贝尔物理学奖得主）表示担忧。 中村修二认为，亚洲的教育制度是浪费时间，年轻人应该学习不同的事情。东亚国家现代的普鲁士教育体制阻碍了学生进行更为深入的探究，对他们独立思考的能力有害无益。 大隅良典，2016年诺贝尔生理学或医学奖得主。 因研发蓝光LED而获得2014年度诺贝尔物理学奖的中村修二于2015年1月在东京的驻日外国记者协会举行记者会，批评了日本的专利制度和整个东亚教育体系。他抨击了日本的教育制度，称大学入学考试制度非常糟糕，中国和韩国也都如此，所有高中生的教育目标都是考入著名大学。他认为亚洲的教育制度是浪费时间，年轻人应该学习不同的事情。 中村修二是个非典型的日本科学家： 出身普通渔民家庭，考试能力也平平，上了日本三流大学德岛大学； 他动手能力非常强：上午调仪器，下午做实验； 自学能力非常强：中村对物理学具有深刻的理解，但他完全是靠自学而来的。他读的德岛大学甚至没有物理系。 中村修二，2014年度诺贝尔物理学奖得主 这样的人在日本饱受压制，他对于日本教育制度的批评，也是言出有因。 一、东亚教育：效率低下，所有人都深受其苦东亚的教育体制是比较特异的，经常是得到局外人的赞赏和局内人的诟病。日本的教育体制已经相对算这三国里比较宽松的了，有些国家就别提了，老师、学生、家长所有人都深受其苦。 至于韩国也是以极端的应试主义和学历主义闻名的。首尔大学（Seoul National University）、高丽大学（KoreaUniversity）和延世大学（Yonsei University）总称为”SKY”，韩国最大规模企业的总裁们，70%是这三所大学的毕业生，而80%的司法机构公务员来自这三所大学。 韩国孩子几乎都要上补习班，2009年韩国补习班获利总额约73亿美元，这比三星电子的盈利还多，教育支出庞大是韩国人不敢生育更多孩子的最大原因。2012年，经合组织进行了”国际学生能力评估计划”，在数学和阅读项目上，韩国学生在所有成员国中排名第一。但是，这项成就是以相当低的效率取得的，有评价说：“这些孩子是靠双倍的努力加双倍的花费……才得到这样的成绩。” 为何东亚会有这样的教育体系呢？我觉得，是因为东亚国家在现代教育体系本来就有的普鲁士的基因，再加上了东亚儒家和科举传统。而对于有的国家来说，可以说又加上了苏联式教育的实用速成导向和思想灌输功能。 二、东亚教育具有循规蹈矩的“普鲁士基因”在十九世纪之前，教育其实是个类似手工业的学徒制，不管是东方的私塾还是西方的家庭教师。但是随着科目的增加和对受基本教育的劳动人口的需求，出现了所谓的K-12（也就是我们亚洲的普通中小学）教育制度。 现代各国的标准教育模式，是我们已经以为天经地义的几个基本要素： 早上七八点钟走进教学楼； 在长达40-60分钟的课程中全程坐着听课，在课堂上，教师负责讲，学生负责听； 穿插在课程之间的有午餐以及体育课的时间； 放学后，学生回家做作业。 在标准化课程表的禁锢下，原本浩瀚而美不胜收的人类思想领域被人为地切割成了一块块，一块块便于管理的部分，并被称为”学科”。同样，原本行云流水、融会、融会贯通的概念被分成了成了一个个单独的”课程单元”。 这个模式，是在18世纪是由普鲁士人最先实施的。是他们最先发明了我们如今的课堂教学模式。普鲁士人的初衷并不是教育出能够独立思考的学生，而是大量炮制忠诚且易于管理的国民，他们在学校里学到的价值观让他们服从包括父母、老师和教堂在内的权威，当然，最终要服从国王。 当然，普鲁士教育体系在当时的很多方面都具有创新意义。这样的教育体系让上万人成了中产阶级，为德国成为工业强国提供了至关重要的原动力。基于当时的技术水平，要在普鲁士王国实现人人都接受教育的目标，最经济的方法或许就是采用普鲁士教育体制。 然而，该体制阻碍了学生进行更为深入的探究，对他们独立思考的能力有害无益。不过，在19世纪，高水平的创造力逻辑思维能力也许不如思想上服从指挥、行动上掌握基本技能那么重要。 在19世纪上半叶，美国基本照搬了普鲁士的教育体系，就像在普鲁士一样，这一举措能够大力推动中产阶级的构建，使他们有能力在蓬勃发展的工业领域谋得一份工作。除了美国，这个体系在十九世纪也被其他欧洲国家仿效，并推广到欧美以外其他国家。 但是，如今的经济现状已经不再需要顺从且遵守纪律的劳动阶层，相反，它对劳动者的阅读能力、数学素养和人文底蕴的要求越来越高。 当今社会需要的是具有创造力、充满好奇心并能自我引导的终身学习者，需他们有能力提出新颖的想法并付诸实施，不幸的是，普鲁士教育体的目标与这一社会需求恰恰相反。如今的教育完全忽视了人与人之间异常美妙的多样性与细微差别，而正是这些多样性性与细差别让人们在智力、想象力和天赋方面各不相同。 三、普鲁士基因以外，东亚教育还深受儒家传统和科举制度影响东亚三国在19世纪末为了追赶西方列强而开始引进这种现代教育制度时，又不可避免地由于自己的儒家传统和科举制度，而对这个制度作出了潜意识的扭曲和偏重。 1、对大学入学考试和科举制度的混淆 东亚国家对大学入学考试，总是会和他们长期的科举传统混在一起。古代社会对创造力没有那么大的需求，所以科举是个很好的制度，以最小的冲突完成了社会管理者的选拔，且完成了一个以智力取代门阀的准绳的建立。 如果要和科举模拟的话，现在的对应物应当是公务员考试或者某些大公司的入职考试。因为这些考试和科举一样，是需要选拔出已经训练有素的成年人，马上就可以从事某些工作。 而大学入学考试，目标则是要选出可塑性强而又有志向者进行下一步的教育，这样的人要好像从熔炉里取出的液态玻璃，可以旋转拉长，可塑性极强。而科举考试得到的人员，则要像上了釉彩的出窑瓷器，马上就可以使用，但是如果你做什么改动，不是破裂就是刮伤。 此外，考试是个用处非常有局限的工具。古代的科举对人才的遗漏尽人皆知，而现代不管哪种考试，能考得出考生的兴趣、志向、想象力和实际操作能力的有哪些呢？即使是已经看起来最客观最可衡量的数学考试，也会遗失很多东西。 可汗学院创始人萨尔曼可汗举了代数为例子。在学习代数时，学生们多半只专注于在考试中获得高分，考试的内容仅仅是各单元学习中最重要的部分。考生们只记住了一大堆X和y，只要将X和y代入死记硬背的公式，就可以得到它们的值。考试中的X和y体现不出代数的力量及其重要性。代数的重要性及魅力之处在于，所有这些X和y代表的是无穷的现象和观点。 在计算上市公司的生产成本时使用的等式，也可以用来计算物体在太空的动量；同样的等式不仅可以用来计算拋物线的最佳路径，还可以为新产品确定最合适的价格。 计算遗传病患病率的方法同样可以在橄榄球赛中用来判断是否应该在第四节发起进攻。在考试中，大部分学生并没有将代数视为探索世界时简单方便且用途多样的工具，反而其视为亟待跨越的障碍。 所以，虽然考试是很重要的，但是社会必须能认识到考试的极大局限性，并削弱它在选材中的位置。 美国的教育制度以双保险的方式抑制学生在在考试上过分浪费精力：其一，SAT的考分只是录取考虑的诸因素中的一项，过于重视SAT是不明智的；其二，SAT每年有6次报考机会。 台湾、中国的教育制度则以加倍的方式促使学生浪费青春：其一，联考分数是录取与否的决定性因素；其二，联考一年一度。 2、东亚国家对复习的过度重视 2009年释出的”中日韩美四国高中生权益状况比较研究报告”显示：78.3%的中国普通高中学生平时（不包括周末和节假日）每天在校学习时间在8小时以上，韩国为57.2%，而日本和美国几乎不存在这样的情况。中国学生每日学习的时间最长。各国学生所学内容的多少相差不会太大，那么如果学习时间过长，意味着什么?意味着复习时间所占比重过大。这是扼杀学生想象力、创造力的最大手段。 说起复习的重要性，人们经常会引用”学而时习之”，这个”习”就是复习。但是，孔子时代与今天社会有个巨大差异，是学习的内容。孔子时代的主要学习内容是”礼”，扮演者唯反复演练才可达到效果。 但是，人类的社会生活演化到近现代，学习的主要内容由”礼”转变为认知。认知是拓展和变化的，其本质是创造或学习新的东西。如果教育过度强化复习，是产生不出创新人才的。 而且，正如保罗葛兰素所说的”即使在最好的高中里学到的知识，和大学相比也是微不足道的。”以文科为例，那几本高中需要反复诵读的历史课本上的知识，和随便几本大学历史系必读书比起来如何?至于数学呢，即使是中学数学都掌握很好了，还没有学到十七世纪就出现的微积分。 何况，随着知识的爆炸，1900年所有的数学知识可以塞进1000本书里，到2000年已经需要10万卷书了（德夫林《数学犹聊天》）。可见，花了人一生中精力最充沛的几年时间反复学习这么有限的知识，是多么低效的学习法啊。 这几年有个流行的一万小时理论，对反复练习好像是个理论上的支持。但是，这种论述的多在【认知复杂性】较低的活动，如象棋、钢琴、篮球、出租车驾驶、拼写。但是，对于【认知复杂性】较高的活动，如创作、管理等作用就很难找到足够的证据。其实，这一点反而可以用来说明，为什么钢琴小提琴这类技艺的训练在西方业已式微，而在东亚国家却大为兴盛。 这类十九世纪就已经蔚为大成的技艺，特点是难度训练阶梯比较固定，知识总量也已经限定，只需要多加练习即可，而且学习的进度，又可以通过曲目难度或考级来衡量。这正好切合了东亚偏爱的学习法。 所以东亚国家这些琴童家长，多半既没有音乐爱好也不了解古典音乐背景知识，却让孩子花了大量时间练习，其内在出发点，就好像著名笑话中那位因为路灯比较亮，就只在路灯下找钥匙的愚人一样。 3、平均主义和匮乏心态的影响 很多对联考的辩解，都是说，虽然联考不尽如人意，但是是最公平的。这是儒家传统上”不患寡而患不均”思想的影响。公平并没有错，但是如果为了公平，就反而一刀切压制了不同类型的人才发展途径，那就很可悲了。东亚国家的人口基数那么大，这种人才浪费的机会成本也是高得很难估量。 举个其他国家的例子。欧洲学术界有个比较，像英国和德国都算是古典学术的学霸类国家，但是英国这方面的人才要出色不少。究其原因，反而是因为英国的教育制度不够公平。英国有一些中学进去后由于传统原因，上好大学的可能性非常高，这样里面的学生很早就可以不慌不忙地淫浸在庞大的古典学术中。 反过来，德国比较公平，所有学生上大学都要通过考核，这样，学生反而要花更多精力在通用的备考科目上面。结果英国这种表面的不公平反而有可能造就优质人才。 这就像彼得·提尔的《从0到1》中的举的商业上的例子，表面上完全竞争好像比较公平，实际上参加这样竞争的企业利润会变得像刀刃一样薄，朝不保夕，只能顾着眼前利益，不可能对未来做长远规划。 而类似谷歌这样的垄断企业，因为不用记挂着和其他企业竞争，反而可以由更大的自主权关心自己的产品和做各种长远得简直不靠谱的计划。所以学生如果长期处在考试的竞争压力下，自然也就不可能有长远的自我成长计划，而只能把心思集中在将会决定一生道路的一次次考试上。 另一方面，东亚国家从幼儿园开始到大学的学习卡位战和争夺战，其实质是对有限的高质量教育资源的争夺，这个并非没有一定的道理。但是为何这个地区的争夺会达到这样的火热程度呢？那也许要归咎于长期物质匮乏导致的稀缺心态。 去年大热门的《匮乏经济学：为什么老是在赶Deadline？为什么老是觉得时间和金钱不够用?》指出，当人陷入稀缺的状态（物质或是时间）时，稀缺会俘获大脑时，人注意力的俘获，不仅会影响我们的所见的速度，而且也会影响我们对周遭世界的认识。而当我们为了解决眼下的难题而极度专注时，就无法有效地规划未来。 我觉得稀缺是东亚民族特有的状况。因为这些国家几千年来都是水稻密集型种植经济，一方面是可以在同等耕地情况下养活更多人，一方面当然是需要付出更多劳动和忍受更大拥挤。到了十七世纪后，就都陷入了内卷化的陷阱。 就以日本为例，15至19世纪，日本人口波动在1000万到2000万之间，约为英国同期人口的四倍。庞大的人口赖以生存的适耕土地，面积仅相当于英格兰的一个县，生产力却又不及英格兰的一个郡县。所以在德川时期，为了维持生存，日本人不但把勤劳节约发挥到了极点，甚至有两个匪夷所思的现象。 一个是日本政府出面来鼓励溺婴，以至于300年间人口零增长。另外，因为宝贵的土地不能用来给家畜提供饲料，日本人系统性地取消了车轮和家畜的使用这两项基础性农业技术，其结果呢，来一个形象的比喻，他们把鼻子保持在水以上，只要发生意外灾难或意外支出，就可能惨遭溺毙。这种东亚民族特有的匮乏和焦虑心态，不管是东南亚的土著民，欧美人，甚至非洲人，都无法理解。 所以对于教育资源，如果是狭义地理解为配备良好的教室、高阶教师之类的，那确实是有限的，对于长期处于稀缺的心理状态的东亚人来说，是一定要参与争夺的。 但是，实际上，孩子要成才，更重要的教育资源，其实是各自家庭的文化背景、价值观的言传身教、志向和视野的潜移默化，那根本和那种”你上了这个学校我就上不了”那样的零和博弈无关了。 而且，如果家长在稀缺心态的驱动下，让孩子从小沉浸在补习班和题海里，希望能先去抢到眼前看起来很稀缺的学校资源，也许从长远来看，就反而浪费了孩子最大的资源-有无限可能性的少年时光和天生的好奇心，那就是爱之适足以害之了。 4、工业化追赶带来的心态 影响近代工业化的起源在西欧，所以他们不管是经济社会还是教育体系，都有个比较和缓的自然进化发展期。而东亚国家是被裹挟进现代社会的，为了赶上其他国家，在工业体系上无一例外的采取了国家层面上有计划的指导下的发展。日本的工业化要归功于通产省的官僚们，韩国则是政府支持几个财阀来配合整个发展计划，而中国现在还有那么个五年计划在指导。 这种国家级计划是建立在十九世纪的理性主义的基础上，其内含的想法，是认为世界上没有问题是不能解决的，因而可以通过科学的考察而预测出事物将来准确的发展方向。 这种想法运用在教育体制上，就是假定某个机构可以准确地预测某个年纪的孩子需要掌握什么样的知识，某种考试可以选拔出什么样的人才等等，这种自信令人细思恐极。 而具体到学校和学习的具体操作上，为了适应工业化的人才需求而专门设立的东亚教育制度，比起自然发展的西方体系来说，更有工业化追赶期那种对效率的疯狂追求。这样，这些后进工业国的教育体系，反而比前驱工业国更像工厂的流水线一些。 在二十世纪初，泰勒制（Taylorism）在美国产业界盛行一时。泰勒认为、管理的根本目的在于提高效率。为此，他采取了制定工作定额、选择最好的工人、实施标准化管理、实施刺激性的付酬制度、强调雇主与工人合作的”精神革命”等。 这就将工人的潜能发挥到无以复加的程度，有人形容，在实行泰勒制的工厂里，找不出一个多余的工人，每个工人都像机器一样一刻不停地工作。泰勒理论的前提是把作为管理对象的”人”看作是”经济人”，利益驱动是该学派用以提高效率的主要法宝。现代最著名的泰勒制工厂莫过于富士康了。从报道中大家也可以猜想到这种高压环境对工人心理的影响。 而如果把东亚教育制度和泰勒制工厂来对比的话，我们会发现几乎是一一对应的关系，制定很高的学习量和需要考核的大量知识点、选择成绩好的学生组成重点学校、全国统一的考核标准、大量考试形成的刺激性奖惩、还有学校内部的各种打鸡血活动。学校目标也是要发挥学生的潜能，每一分钟都要致力于得到最好的成绩。 所以批评这种教育体系的人经常说，孩子好像是流水在线的工业制品，或者说，学生是老师的童工，他们的成绩就成为老师的绩效，所以师生的利益关系经常不是一致的，是相反的。这并不是简单的激愤之词，而是有一定的内在逻辑。 当然，因为东亚国家的勤劳传统，孩子们这么辛苦，如果确有效果，也不是不能接受。但问题就在于这个有效性上。 这种教育上的泰勒制，本质上是把学生当成体力工作者来对待。对于体力工作者，因为他们的工作状态是可见的，所以工厂管理比较容易，对他们的要求是”把事情做对”，而不是”做对的事情”。 而现代学生呢，我觉得更像德鲁克所定义的”知识工作者”（知识工作者不生产有形的东西，而是生产知识、创意和信息，谁也看不出他们到底在想些什么），而且从培养目的上也是要大多成为知识工作者。学生时代的真正成果，不是他们交上去的作业和考卷，而是他们所真正学习到和思考的内容。这些在技术上是无法进行严密的督导的。 所以要成为好学生，不是像体力劳动者一样忠实地完成老师的作业，而是要像知识工作者一样，具有有效性，也就是”做好该做的事情”。好学生一定得做到：要自我决定学习的侧重，衡量自己知识的掌握度，管理自己的学习时间。这就需要具有极大的主动性和自由度。 所以，悲剧的是，由于东亚教育体制的工业时代基因，他们是用训练体力劳动者的做法，来培养他们心目中未来的学者和企业家，这不免就南辕北辙了。 四、东亚教育急需改革，却越发走向僵硬东亚教育体制长期以来是利多于弊的。在工业化时期，可以为新建立的工业短期造就大量可堪一用的工人和初级工程师。所以东亚各国在二十世纪的飞速发展，这种教育体制有很大贡献。但是随着技术和经济的演变，这种体制就变得越发不合时宜。 这一点可以模拟成苏联时期的重工业。在这种体制下，采煤业是为了冶钢，冶钢是为了机械业，而机械业又是致力于生产采掘和冶炼机器，这样形成了内部的自我循环，而无视市场和竞争的实际需要。这种重工业在苏联的工业化时期，确实制造了大量本来缺少的工业制品，很有用处。但是到了某个发展阶段，其缺乏效率和国际竞争力的弱点就暴露出来了。到如今，苏联这个曾经的第二工业强国，他的汽车工业、机械工业还有什么价值呢?同样，东亚教育体制曾经批量培养出的大量标准化人才，不是也将会在新时代里变得越来越没有价值么? 更有甚者，为了脱离这种体制，很多东亚家庭送了孩子去欧美留学，可是除非他们留在国外，如果回国就业，海归们还是要以他们毕业的各种学校为求职砝码，这就又陷入了比较学校名气的漩涡。就好像中世纪时印度很多低阶种姓为了摆脱种姓制度的压迫，皈依了外来的伊斯兰教，但是在无所不在的种姓思想下，穆斯林也被视为一种种姓，同样还是陷入这个等级体系之中。所以托福、SAT这些美国考试制度，在东亚也无形中被融合到富有东方风情的应试主义和学历主义的体系里。 这种体制由于造就了多个既得利益阶层，所以很难撼动，甚至会像上面说的苏联重工业综合体或印度种姓制度一样，”病得至死方休”。苏联时期的重工业不停地制造对社会无益的武器，形成一个利益相关势力，浪费了大量社会资源，直到整个国家体制崩溃。而印度种姓制度，从佛陀时代就饱受批评，却一直祸害了印度几千年，直到今天还是印度前进道路上的巨大障碍，就是因为背后有大量的高种姓的既得利益者。 东亚的教育体制呢，一方面，养活了庞大的低效率又思想陈旧的各类公私教育机构（这一点类似苏联工业集团），另一方面，通过对学历的看重，占据社会中高阶层的，多半都是最适应这个体制者，而这个阶层又通过在应试教育上的更多支出，保证自己的下一代在这个考试体系中也能脱颖而出，从而把自己在社会地位上的优势又传给了下一代（这一点又有点像种姓制度）。 这个急需改革的体制，就这样在各个社会集团的共谋下愈发僵硬了。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熵：宇宙的终极规则]]></title>
    <url>%2Fblog%2F39900.html</url>
    <content type="text"><![CDATA[有人曾经问我：“成年后，有没有书籍改变过你的世界观？” 我想了想，还真有这样的书。那时，我已经工作好几年了，偶然在图书馆翻到一本旧书《熵：一种新的世界观》（上海译文出版社，1987）。 那本书是科普著作，介绍物理学概念“熵”。中学毕业后，我再没有碰过物理学，但是没想到读完以后，我看待世界的眼光都变了。作者：阮一峰 “熵”这个概念非常简单，很容易理解，但又异常强大，可以解释很多事情。这篇文章，我就来谈谈，为什么你应该懂得熵是什么，它可能也会改变你的世界观。 为了理解熵，必须讲一点物理学。 19世纪，物理学家开始认识到，世界的动力是能量，并且提出“能量守恒定律”，即能量的总和是不变的。但是，有一个现象让他们很困惑。 （上图的单摆，在两侧的最高点，势能最大，动能为零；在中间的低点，动能最大，势能为零，能量始终守恒。） 物理学家发现，能量无法百分百地转换。比如，蒸汽机使用的是热能，将其转换为推动机器的机械能。这个过程中，总是有一些热能损耗掉，无法完全转变为机械能。 一开始，物理学家以为是技术水平不高导致的，但后来发现，技术再进步，也无法将能量损耗降到零。他们就将那些在能量转换过程中浪费掉的、无法再利用的能量称为熵。 后来，这个概念被总结成了“热力学第二定律”：能量转换总是会产生熵，如果是封闭系统，所有能量最终都会变成熵。 熵既然是能量，为什么无法利用？它又是怎么产生的？为什么所有能量最后都会变成熵？这些问题我想了很久。 物理学家有很多种解释，有一种我觉得最容易懂：能量转换的时候，大部分能量会转换成预先设定的状态，比如热能变成机械能、电能变成光能。但是，就像细胞突变那样，还有一部分能量会生成新的状态。这部分能量就是熵，由于状态不同，所以很难利用，除非外部注入新的能量，专门处理熵。 （上图，能量转换过程中，创造出许多新状态。） 总之，能量转换会创造出新的状态，熵就是进入这些状态的能量。 现在请大家思考：状态多意味着什么？ 状态多，就是可能性多，表示比较混乱；状态少，就是可能性少，相对来说就比较有秩序。因此，上面结论的另一种表达是：能量转换会让系统的混乱度增加，熵就是系统的混乱度。 （上图中，熵低则混乱度低，熵高则混乱度高。） 转换的能量越大，创造出来的新状态就会越多。高能量系统不如低能量系统稳定，不仅因为前者更容易发生能量转换，还因为在转化过程中会创造出更多的状态（即更多的熵）。而且，凡是运动的系统都会有能量转换，热力学第二定律就是在说，所有封闭系统最终都会趋向混乱度最大的状态，除非外部注入能量。 （上图中，冰块是分子的有序排列，吸收能量后，变成液体水，分子排列变得无序。） 熵让我理解了一件事，如果不施加外力影响，事物永远向着更混乱的状态发展。比如，房间如果没人打扫，只会越来越乱，不可能越来越干净。 （上图中，如果不花费能量打扫，房间总是越来越乱。） 为什么“世间好物不坚牢，彩云易散琉璃脆”？就是因为事物维持美好的状态是需要能量的，如果没有能量输入，美好的状态就会结束。 这就是我世界观的变化。我从此认识到，人类社会并非一定会变得更进步、更文明。相反地，人类如同宇宙的其他事物一样，常态和最终命运一定是变得更混乱和无序。过去五千年，人类文明的进步只是因为人类学会利用外部能量（牲畜、火种、水力等等）。越来越多的能量注入，使得人类社会向着文明有序的方向发展。 从小，我受到的教育是“明天会更好”。现在我明白了，这句话是有条件的。正常情况下，明天其实会更糟，因为熵在累积，只有不断注入新的能量处理熵，明天才会更好。 （上图中，经过130多亿年的膨胀，宇宙变得越来越无序了。） 工业革命以后，人类社会的进步速度加快了，变得更加先进有序，消耗的能量也指数级地增长：水力不够了用煤炭，煤炭不够了用石油，石油不够了用核能。 能量消耗越大，就会产生越多的熵。因此，人类社会始终处于一种矛盾状态：整个社会变得更加有序和严密的同时，无序和混乱也在暗处不断滋长。 我们只是依靠更大的能量输入，在压制熵的累积。不断增加的熵，正在各种方面爆发出来：垃圾污染、地球变暖、土地沙化、PM2.5、物种灭绝……甚至心理疾病、孤独感和疏离感的暴增，我认为都是熵的增加对人类精神造成的结果。 我们需要能量，让世界变得有秩序，但这样是有代价的。物理学告诉我们，没有办法消除熵和混乱，我们只是让某些局部变得更有秩序，把混乱转移到另一些领域。 人类社会正在加速发展。表面上，我们正在经历一个减熵过程，一切变得越来越有秩序，自动化带来了便捷。但是，能量消耗也在同步放大，为了解决越来越多的熵，我们不得不寻找更多的能量，这又导致熵的进一步增加，从而陷入恶性循环。 迄今为止，人类一直能够找到足够的能量，解决熵带来的混乱。但是，这种解决方式正变得捉襟见肘。如果我们继续像现在这样加速发展，那么终有一天会出现能量缺口，地球上的能量不足以解决熵，那时一切就会发生逆转，仿佛细小的裂缝演变成巨大的雪崩，秩序开始崩塌，世界走向混乱。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现分页功能]]></title>
    <url>%2Fblog%2F27809.html</url>
    <content type="text"><![CDATA[JS分页 使用 引入JS文件 1234567891011&lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/dist/MyPaging.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; // 调用下拉插件 $("#AirsList").find(".airsList").MyPaging(&#123; 'btnNum': 5, //分页按钮显示的数目 'perItem': 10 //每页显示的数目 &#125;); &#125;);&lt;/script&gt; 页面模板 1234567&lt;ul class="selecter"&gt; &lt;li&gt;&lt;/li&gt; . . . &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; MyPaging.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148(function($)&#123; $.fn.MyPaging = function( options ) &#123; var $this = this; var defaults = &#123; 'btnNum': 5, 'perItem': 10 &#125;; var settings = $.extend(defaults, options); return this.each(function() &#123; //插入分页按钮 if(!($("#pageGro").length&gt;0))&#123; $("head").append(function()&#123; var $style ="&lt;style&gt;"; $style +="#pageGro *&#123;padding:0px;margin:0px;list-style:none;text-align:center;&#125;"; $style +="#pageGro&#123;clear:both;color:#333;padding:5px 0px 5px 0px;margin:0px auto;padding-top:30px;display:-webkit-box;display:-moz-box;display:-ms-flexbox;display:-webkit-flex;display:flex;align-items:center;justify-content:center;&#125;"; $style +="#pageGro:after&#123;content:'';display:table;clear:both;&#125;"; $style +="#pageGro span,#pageGro li&#123;float:left;box-sizing:border-box;height:32px;line-height:30px;border-radius:2px;font-size:15px;color:#333;margin-left:5px;&#125;"; $style +="#pageGro .list&#123;display:-webkit-box;display:-moz-box;display:-ms-flexbox;display:-webkit-flex;display:flex;&#125;"; $style +="#pageGro li&#123;border:1px solid #999;padding:0 7px;cursor:pointer;text-decoration:none;background:#fff;&#125;"; $style +="#pageGro .prev,#pageGro .next,#pageGro .start,#pageGro .end&#123;width:63px;border:1px solid #999;cursor:pointer;&#125;"; $style +="#pageGro li.on,#pageGro li:hover,#pageGro span:hover&#123;background:#003399;color:#fff;border:1px solid #003399;&#125;"; $style +="#pageGro .dis,#pageGro .dis:hover&#123;border:1px solid #DFDFDF;background-color:#FFF;color:#DFDFDF;cursor:default;&#125;"; $style +="&lt;/style&gt;"; return $style; &#125;); $this.after("&lt;div id='pageGro'&gt;&lt;span class='start dis'&gt;首页&lt;/span&gt;&lt;span class='prev dis'&gt;上一页&lt;/span&gt;&lt;ul class='list'&gt;&lt;/ul&gt;&lt;span class='next'&gt;下一页&lt;/span&gt;&lt;span class='end'&gt;尾页&lt;/span&gt;"); &#125; //根据总页数判断，如果小于5页，则显示所有页数，如果大于5页，则显示5页。根据当前点击的页数生成 var btnNum = settings.btnNum; //每页显示的数目 var perItem = settings.perItem; //获取content对象里面，数据的数量 var totalItems = $this.children().size(); //计算页面显示的总页数 var pageCount =1; if (totalItems&gt;perItem) &#123; pageCount = Math.ceil(totalItems / perItem); $("#pageGro span").removeClass("dis"); $("#pageGro .start").addClass("dis"); $("#pageGro .prev").addClass("dis"); &#125;else&#123; $("#pageGro span").addClass("dis"); &#125; //默认值 var startPage = 1; var currentPage = 1; var lastPage = pageCount; var startOn,endOn; //隐藏该对象下面的所有子元素 $this.children().hide(); //显示第n（perItem）元素 $this.children().slice(0, perItem).show(); //生成分页按钮 creatBtn(1, pageCount, 0); if (pageCount &gt; btnNum) &#123; showBtn(0, btnNum); &#125; else &#123; showBtn(0, pageCount); &#125; //点击分页按钮触发 $this.parent().on("click", "#pageGro .list li", function() &#123; var newCount = $(this).parent().children().size();//获取现在总页数 if (newCount&gt;1) &#123; currentPage = parseInt($(this).html()); //获取当前页数 //开始 startOn = (currentPage-1) * perItem; //结束 endOn = startOn + perItem; //隐藏内容ul的所有子元素，获取特定项目并显示它们 $this.children().hide().slice(startOn, endOn).show(); $(this).addClass("on").siblings("li").removeClass("on"); if (newCount &gt; btnNum) &#123; //显示页面 pageGroup(currentPage, pageCount); console.log(1) &#125; if (newCount==1) &#123; $("#pageGro span").addClass("dis"); &#125; else if (currentPage==1&amp;&amp;newCount!=1) &#123; $("#pageGro span").removeClass("dis"); $("#pageGro .start").addClass("dis"); $("#pageGro .prev").addClass("dis"); &#125; else if(currentPage==newCount&amp;&amp;newCount!=1) &#123; $("#pageGro span").removeClass("dis"); $("#pageGro .end").addClass("dis"); $("#pageGro .next").addClass("dis"); &#125; else &#123; $("#pageGro span").removeClass("dis"); &#125; &#125;; &#125;); //点击上一页触发 $this.parent().on("click", "#pageGro .prev", function() &#123; var currentPage = parseInt($("#pageGro li.on").html());//获取当前页 var newCount = $(this).siblings(".list").children().size();//获取现在总页数 if (currentPage&lt;=newCount&amp;&amp;currentPage&gt;1) &#123; $(this).siblings(".list").find("li").eq(currentPage-2).click(); &#125; &#125;); //点击下一页触发 $this.parent().on("click", "#pageGro .next", function() &#123; var currentPage = parseInt($("#pageGro li.on").html());//获取当前页 var newCount = $(this).siblings(".list").children().size();//获取现在总页数 if (currentPage&lt;newCount) &#123; $(this).siblings(".list").find("li").eq(currentPage).click(); &#125; &#125;); //点击首页 $this.parent().on("click", "#pageGro .start", function() &#123; var currentPage = parseInt($("#pageGro li.on").html());//获取当前页 var newCount = $(this).siblings(".list").children().size();//获取现在总页数 if (currentPage&lt;=newCount&amp;&amp;currentPage&gt;1) &#123; $(this).siblings(".list").find("li").eq(0).click(); &#125; &#125;); //点击尾页 $this.parent().on("click", "#pageGro .end", function() &#123; var currentPage = parseInt($("#pageGro li.on").html());//获取当前页 var newCount = $(this).siblings(".list").children().size();//获取现在总页数 if (currentPage&lt;newCount) &#123; $(this).parents("#pageGro").find(".list li").last().click(); &#125; &#125;); //根据当前选中页生成页面点击按钮 function creatBtn(page, count, eq) &#123; var $htm_ = ""; for (var i = page; i &lt;= count; i++) &#123; $htm_ += "&lt;li&gt;" + i + "&lt;/li&gt;"; &#125; $this.parent().find("#pageGro .list").html($htm_); $this.parent().find("#pageGro ul li").eq(eq).addClass('on'); &#125; function showBtn(page, count)&#123; $this.parent().find("#pageGro .list").children().hide().slice(page, count).show(); &#125; //点击跳转页面 function pageGroup(pageNum, pageCount) &#123; if (pageNum&lt;Math.ceil(btnNum/2)) &#123; showBtn(0, btnNum); &#125; else if(pageNum&gt;=pageCount-Math.ceil(btnNum/2)) &#123; showBtn(pageCount-btnNum, pageCount); &#125;else&#123; showBtn(pageNum - Math.ceil(btnNum/2 -1), pageNum + Math.ceil(btnNum/2 +1)); &#125; &#125; &#125;); &#125;;&#125;)(jQuery); index.html123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Jquery分页插件&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="../dist/MySelect.css"&gt; &lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../dist/MyPaging.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $("#AirsList").find(".airsList").MyPaging(&#123; 'btnNum': 5, //分页按钮显示的数目 'perItem': 10 //每页显示的数目 &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body style="font-size:14px;width:100%;height:100%;"&gt; &lt;ul class="selecter" style="text-align:center;"&gt; &lt;li&gt;109222&lt;/li&gt; &lt;li&gt;109222&lt;/li&gt; &lt;li&gt;109222&lt;/li&gt; &lt;li&gt;109222&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 种最常见的 Javascript 错误]]></title>
    <url>%2Fblog%2F33823.html</url>
    <content type="text"><![CDATA[我们查看了数千个项目的数据库，发现了 JavaScript 中频度最高的 10 种错误。我们会告诉你什么原因导致了这些错误，以及如何防止这些错误发生。如果你能够避免落入这些 “陷阱”，你将会成为一个更好的开发者。 原文：https://rollbar.com/blog/top-10-javascript-errors/ 数据才是王道，我们收集并分析了出现频次排前 10 的 JavaScript 错误。 Rollbar 会收集每个项目的所有错误，并总结每个错误发生的次数。我们通过根据 “指纹”（rollbar 用到的一种算法，详见：https://rollbar.com/docs/grouping-algorithm/）对错误进行分组。基本上，如果第二个错误只是第一个错误的重复，我们会把两个错误分到同一组。这会给用户一个很好的概括，而不是像在日志文件中看到的那样直接一大堆让人感觉到十分压迫的 dump。 我们专注于最有可能影响您和您的用户的错误。为此，我们通过研究各种不同公司的项目集来对于错误进行排列。如果我们只查看每个错误发生的总次数，那么客户量大的的项目产生的错误可能会压倒其他错误，导致实际收集到的是与大多数读者无关的错误数据集。 JavaScript 错误 Top 10： 为了便于阅读，我们将每个错误描述都缩短了。接下来，让我们深入到每一个错误，来确定什么会导致它，以及如何避免创建它。 1. Uncaught TypeError: Cannot read property如果你是一个 JavaScript 开发人员，可能你看到这个错误的次数比你敢承认的要多（LOL…）。当你读取一个未定义的对象的属性或调用其方法时，这个错误会在 Chrome 中出现。 您可以很容易的在 Chrome 开发者控制台中进行测试（尝试）。 发生这种情况的原因很多，但常见的一种是在渲染 UI 组件时对于状态的初始化操作不当。 我们来看一个在真实应用程序中发生的例子：我们选择 React，但该情况也同样适用于 Angular、Vue 或任何其他框架。 12345678910111213141516class Quiz extends Component &#123; componentWillMount() &#123; axios.get('/thedata').then(res =&gt; &#123; this.setState(&#123;items: res.data&#125;); &#125;); &#125; render() &#123; return ( &lt;ul&gt; &#123;this.state.items.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; ); &#125;&#125; 这里有两件重要的事情要实现： 组件的状态（例如 this.state）从 undefined 开始。 当异步获取数据时，不管它是在构造函数componentWillMount还是componentDidMount中获取的，组件在数据加载之前至少会呈现一次，当 Quiz 第一次呈现时，this.state.items 是未定义的。 这又意味着 ItemList 将 items 定义为 undefined，并且在控制台中出现错误 - “Uncaught TypeError: Cannot read property ‘map’ of undefined”。 这很容易解决。最简单的方法：在构造函数中用合理的默认值来初始化 state。 123456789101112131415161718192021222324class Quiz extends Component &#123; // Added this: constructor(props) &#123; super(props); // Assign state itself, and a default value for items this.state = &#123; items: [] &#125;; &#125; componentWillMount() &#123; axios.get('/thedata').then(res =&gt; &#123; this.setState(&#123;items: res.data&#125;); &#125;); &#125; render() &#123; return ( &lt;ul&gt; &#123;this.state.items.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; ); &#125;&#125; 在你的应用程序中的具体代码可能是不同的，但我们希望我们已经给你足够的线索，以解决或避免在你的应用程序中出现的这个问题。如果还没有，请继续阅读，因为我们将在下面覆盖更多相关错误的示例。 2. TypeError: ‘undefined’ is not an object这是在 Safari 中读取属性或调用未定义对象上的方法时发生的错误。您可以在 Safari Developer Console 中轻松测试。这与 1 中提到的 Chrome 的错误基本相同，但 Safari 使用了不同的错误消息提示语。 3. TypeError: null is not an object这是在 Safari 中读取属性或调用空对象上的方法时发生的错误。 您可以在 Safari Developer Console 中轻松测试。 有趣的是，在 JavaScript 中，null 和 undefined 是不一样的，这就是为什么我们看到两个不同的错误信息。undefined 通常是一个尚未分配的变量，而 null 表示该值为空。 要验证它们不相等，请尝试使用严格的相等运算符 ===： 在现实世界的例子中，这种错误可能发生的一种场景是：如果在加载元素之前尝试在 JavaScript 中使用元素。 因为 DOM API 对于空白的对象引用返回值为 null。 任何执行和处理 DOM 元素的 JS 代码都应该在创建 DOM 元素之后执行。 JS 代码按照 HTML 中的规定从上到下进行解释。 所以，如果 DOM 元素之前有一个标签，脚本标签内的 JS 代码将在浏览器解析 HTML 页面时执行。 如果在加载脚本之前尚未创建 DOM 元素，则会出现此错误。 在这个例子中，我们可以通过添加一个事件监听器来解决这个问题，这个监听器会在页面准备好的时候通知我们。 一旦 addEventListener被触发，init() 方法就可以使用 DOM 元素。 123456789101112131415161718&lt;script&gt; function init() &#123; var myButton = document.getElementById("myButton"); var myTextfield = document.getElementById("myTextfield"); myButton.onclick = function() &#123; var userName = myTextfield.value; &#125; &#125; document.addEventListener('readystatechange', function() &#123; if (document.readyState === "complete") &#123; init(); &#125; &#125;);&lt;/script&gt;&lt;form&gt; &lt;input type="text" id="myTextfield" placeholder="Type your name" /&gt; &lt;input type="button" id="myButton" value="Go" /&gt;&lt;/form&gt; 4. (unknown): Script error当未捕获的 JavaScript 错误（通过window.onerror处理程序引发的错误，而不是捕获在try-catch中）被浏览器的跨域策略限制时，会产生这类的脚本错误。 例如，如果您将您的 JavaScript 代码托管在 CDN 上，则任何未被捕获的错误将被报告为“脚本错误” 而不是包含有用的堆栈信息。这是一种浏览器安全措施，旨在防止跨域传递数据，否则将不允许进行通信。 要获得真正的错误消息，请执行以下操作： 发送 ‘Access-Control-Allow-Origin’ 头部 将 Access-Control-Allow-Origin 标头设置为 * 表示可以从任何域正确访问资源。 如有必要，您可以将域替换为您的域：例如，Access-Control-Allow-Origin：www.example.com。 但是，处理多个域会变得棘手，如果你使用 CDN，可能由此产生更多的缓存问题会让你感觉到这种努力并不值得。 在这里看到更多。 这里有一些关于如何在各种环境中设置这个头文件的例子： Apache 在 JavaScript 文件所在的文件夹中，使用以下内容创建一个 .htaccess 文件： 1Header add Access-Control-Allow-Origin &quot;*&quot; Nginx 将 add_header 指令添加到提供 JavaScript 文件的位置块中： 1234&gt; location ~ ^/assets/ &#123;&gt;&gt; add_header Access-Control-Allow-Origin *;&gt; &#125; HAProxy 将以下内容添加到您为 JavaScript 文件提供资源服务的后端： 1&gt; rspadd Access-Control-Allow-Origin: * 在 &lt;script 中设置 crossorigin=”anonymous” 在您的 HTML 代码中，对于您设置了Access-Control-Allow-Origin header 的每个脚本，在 script 标签上设置crossorigin =“anonymous”。在脚本标记中添加 crossorigin 属性之前，请确保验证上述 header 正确发送。 在 Firefox 中，如果存在crossorigin属性，但Access-Control-Allow-Origin头不存在，则脚本将不会执行。 5. TypeError: Object doesn’t support property这是您在调用未定义的方法时发生在 IE 中的错误。 您可以在 IE 开发者控制台中进行测试。 这相当于 Chrome 中的 “TypeError：”undefined“ is not a function” 错误。 是的，对于相同的逻辑错误，不同的浏览器可能具有不同的错误消息。 对于使用 JavaScript 命名空间的 Web 应用程序，这是一个 IE l浏览器的常见的问题。 在这种情况下，99.9％ 的原因是 IE 无法将当前名称空间内的方法绑定到 this 关键字。 例如：如果你 JS 中有一个命名空间 Rollbar 以及方法 isAwesome 。 通常，如果您在 Rollbar 命名空间内，则可以使用以下语法调用isAwesome方法： 1&gt; this.isAwesome(); Chrome，Firefox 和 Opera 会欣然接受这个语法。 另一方面 IE，不会。 因此，使用 JS 命名空间时最安全的选择是始终以实际名称空间作为前缀。 1&gt; Rollbar.isAwesome(); 6. TypeError: ‘undefined’ is not a function当您调用未定义的函数时，这是 Chrome 中产生的错误。 您可以在 Chrome 开发人员控制台和 Mozilla Firefox 开发人员控制台中进行测试。 随着 JavaScript 编码技术和设计模式在过去几年中变得越来越复杂，回调和关闭中的自引用范围也相应增加，这是这种/那种混淆的相当常见的来源。 考虑这个代码片段： 123456function testFunction() &#123; this.clearLocalStorage(); this.timer = setTimeout(function() &#123; this.clearBoard(); // what is "this"? &#125;, 0);&#125;; 执行上面的代码会导致以下错误：“Uncaught TypeError：undefined is not a function”。 你得到上述错误的原因是，当你调用setTimeout()时，实际上是调用window.setTimeout()。 因此，在窗口对象的上下文中定义了一个传递给setTimeout()的匿名函数，该函数没有clearBoard()方法。 一个传统的，旧浏览器兼容的解决方案是简单地将您的 this 保存在一个变量，然后可以由闭包继承。 例如： 1234567function testFunction () &#123; this.clearLocalStorage(); var self = this; // save reference to 'this', while it's still this! this.timer = setTimeout(function()&#123; self.clearBoard(); &#125;, 0);&#125;; 或者，在较新的浏览器中，可以使用bind()方法传递适当的引用： 1234567function testFunction () &#123; this.clearLocalStorage(); this.timer = setTimeout(this.reset.bind(this), 0); // bind to 'this'&#125;;function testFunction()&#123; this.clearBoard(); //back in the context of the right 'this'!&#125;; 7. Uncaught RangeError: Maximum call stack这是 Chrome 在一些情况下会发生的错误。 一个是当你调用一个不终止的递归函数。您可以在 Chrome 开发者控制台中进行测试。 此外，如果您将值传递给超出范围的函数，也可能会发生这种情况。 许多函数只接受其输入值的特定范围的数字。 例如：Number.toExponential(digits) 和 Number.toFixed(digits) 接受 0 到 20 的数字，Number.toPrecision(digits) 接受 1 到 21 的数字。 1234567891011var a = new Array(4294967295); //OKvar b = new Array(-1); //range errorvar num = 2.555555;document.writeln(num.toExponential(4)); //OKdocument.writeln(num.toExponential(-2)); //range error!num = 2.9999;document.writeln(num.toFixed(2)); //OKdocument.writeln(num.toFixed(25)); //range error!num = 2.3456;document.writeln(num.toPrecision(1)); //OKdocument.writeln(num.toPrecision(22)); //range error! 8. TypeError: Cannot read property ‘length’这是 Chrome 中发生的错误，因为读取未定义变量的长度属性。 您可以在 Chrome 开发者控制台中进行测试。 您通常会在数组中找到定义的长度，但是如果数组未初始化或者变量名称在另一个上下文中隐藏，则可能会遇到此错误。让我们用下面的例子来理解这个错误。 1234567var testArray = ["Test"];function testFunction(testArray) &#123; for (var i = 0; i &lt; testArray.length; i++) &#123; console.log(testArray[i]); &#125;&#125;testFunction(); 当你用参数声明一个函数时，这些参数变成了函数作用域内的本地参数。这意味着即使你函数外有名为 testArray 的变量，在一个函数中具有相同名字的参数也会被视为本地参数。 您有两种方法可以解决您的问题： 删除函数声明语句中的参数（事实上你想访问那些声明在函数之外的变量，所以你不需要函数的参数）： 12345678var testArray = ["Test"];/* Precondition: defined testArray outside of a function */function testFunction(/* No params */) &#123; for (var i = 0; i &lt; testArray.length; i++) &#123; console.log(testArray[i]); &#125;&#125;testFunction(); 用声明的数组调用该函数： 1234567var testArray = ["Test"];function testFunction(testArray) &#123; for (var i = 0; i &lt; testArray.length; i++) &#123; console.log(testArray[i]); &#125;&#125;testFunction(testArray); 9. Uncaught TypeError: Cannot set property当我们尝试访问一个未定义的变量时，它总是返回 undefined，我们不能获取或设置任何未定义的属性。 在这种情况下，应用程序将抛出 “Uncaught TypeError: Cannot set property”。 例如，在 Chrome 浏览器中： 如果测试对象不存在，错误将会抛出 “Uncaught TypeErrorUncaught TypeError: Cannot set property”。 10. ReferenceError: event is not defined 当您尝试访问未定义的变量或超出当前范围的变量时，会引发此错误。 您可以在 Chrome 浏览器中轻松测试。 如果在使用事件处理系统时遇到此错误，请确保使用传入的事件对象作为参数。像 IE 这样的旧浏览器提供了一个全局变量事件，但并不是所有浏览器都支持。像 jQuery 这样的库试图规范化这种行为。尽管如此，最好使用传入事件处理函数的函数。 123456function myFunction(event) &#123; event = event.which || event.keyCode; if(event.keyCode===13)&#123; alert(event.keyCode); &#125;&#125; 结论我们希望你学到了新的东西，可以避免将来的错误，或者本指南帮助你解决了头痛的问题。 尽管如此，即使有最佳实践，生产中也会出现意想不到的错误。能够查看影响用户的错误，并拥有快速解决问题的好工具，这一点非常重要。推荐 Rollbar。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（Design pattern）之一]]></title>
    <url>%2Fblog%2F13897.html</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式简介设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的使用设计模式在软件开发中的两个主要用途。 开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）、抽象工厂模式（Abstract Factory Pattern）、单例模式（Singleton Pattern）、建造者模式（Builder Pattern）、原型模式（Prototype Pattern） 2 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）、桥接模式（Bridge Pattern）、过滤器模式（Filter、Criteria Pattern）、组合模式（Composite Pattern）装饰器模式、（Decorator Pattern）、外观模式（Facade Pattern）、享元模式（Flyweight Pattern）、代理模式（Proxy Pattern） 3 行为型模式这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）、命令模式（Command Pattern）、解释器模式（Interpreter Pattern）、迭代器模式（Iterator Pattern）、中介者模式（Mediator Pattern）、备忘录模式（Memento Pattern）、观察者模式（Observer Pattern）、状态模式（State Pattern）、空对象模式（Null Object Pattern）、策略模式（Strategy Pattern）、模板模式（Template Pattern）、访问者模式（Visitor Pattern） 4 J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）、业务代表模式（Business Delegate Pattern）、组合实体模式（Composite Entity Pattern）、数据访问对象模式（Data Access Object Pattern）、前端控制器模式（Front Controller Pattern）、拦截过滤器模式（Intercepting Filter Pattern）、服务定位器模式（Service Locator Pattern）、传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 笔记： 开闭原则：实现热插拔，提高扩展性。 里氏代换原则：实现抽象的规范，实现子父类互相替换； 依赖倒转原则：针对接口编程，实现开闭原则的基础； 接口隔离原则：降低耦合度，接口单独设计，互相隔离； 迪米特法则，又称不知道原则：功能模块尽量独立； 合成复用原则：尽量使用聚合，组合，而不是继承； ​ Java就是要搞对象啊 创建型模式–&gt;对象怎么来 结构型模式–&gt;对象和谁有关 行为型模式–&gt;对象与对象在干嘛 J2EE 模式–&gt;对象合起来要干嘛（表现层,文中表示层个人感觉用的不准确）java是面向对象的语言,所以要搞好对象,模式（套路）就是用来更加好的搞对象滴。 工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现 Hibernate 换数据库只需换方言和驱动就可以。 优点： 一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。 FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 步骤 1创建一个接口。 Shape.java 12345package com.test;public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。 Rectangle.java 12345678package com.test;public class Rectangle implements Shape &#123; public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; Circle.java 12345678package com.test;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; Square.java 12345678package com.test;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 步骤 3创建一个工厂，生成基于给定信息的实体类的对象。 ShapeFactory.java 1234567891011121314151617package com.test;public class ShapeFactory &#123; public Shape getShape(String shapeType)&#123; if (shapeType==null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125;else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125;else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; return null; &#125;&#125; 步骤 4使用该工厂，通过传递类型信息来获取实体类的对象。 FactoryPatternDemo.java 12345678910111213141516171819package com.test;public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); // 获取 CIRCLE 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape("CIRCLE"); // 调用 Circle 的 draw 方法 shape1.draw(); // 获取 rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape("RECTANGLE"); // 调用 rectangle 的 draw 方法 shape2.draw(); // 获取 square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape("SQUARE"); // 调用 square 的 draw 方法 shape3.draw(); &#125;&#125; 步骤 5验证输出。 123Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method. 笔记: 使用反射机制可以解决每次增加一个产品时，都需要增加一个对象实现工厂的缺点 1234567891011121314151617public class ShapeFactory &#123; public static Object getClass(Class&lt;?extends Shape&gt; clazz) &#123; Object obj = null; try &#123; obj = Class.forName(clazz.getName()).newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 使用的使用采用强制转换 1234Rectangle rect = (Rectangle) ShapeFactory.getClass(Rectangle.class);rect.draw();Square square = (Square) ShapeFactory.getClass(Square.class);square.draw(); 这样就只需要一个对象实现工厂 ​ 1234567891011121314151617public class ShapeFactory &#123; public static &lt;T&gt; T getClass(Class&lt;? extends T&gt; clazz) &#123; T obj = null; try &#123; obj = (T) Class.forName(clazz.getName()).newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 省略类型强制转换，支持多态 12345Rectangle rect = ShapeFactory.getClass(Rectangle.class);rect.draw();Shape square = ShapeFactory.getClass(Square.class);square.draw(); 抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 介绍意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： QQ 换皮肤，一整套一起换。 生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 步骤 1为形状创建一个接口。 Shape.java 123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。 Rectangle.java 1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; Square.java 1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; Circle.java 1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 步骤 3为颜色创建一个接口。 Color.java 123public interface Color &#123; void fill();&#125; 步骤4创建实现接口的实体类。 Red.java 1234567public class Red implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Red::fill() method."); &#125;&#125; Green.java 1234567public class Green implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Green::fill() method."); &#125;&#125; Blue.java 1234567public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Blue::fill() method."); &#125;&#125; 步骤 5为 Color 和 Shape 对象创建抽象类来获取工厂。 AbstractFactory.java 1234public abstract class AbstractFactory &#123; abstract Color getColor(String color); abstract Shape getShape(String shape);&#125; 步骤 6创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。 ShapeFactory.java 12345678910111213141516171819202122public class ShapeFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; return null; &#125; @Override Shape getShape(String shapeType) &#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125; &#125; ColorFactory.java 1234567891011121314151617181920212223public class ColorFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; if (color == null) &#123; return null; &#125; if (color.equalsIgnoreCase("RED")) &#123; return new Red(); &#125; else if (color.equalsIgnoreCase("GREEN")) &#123; return new Green(); &#125; else if (color.equalsIgnoreCase("BLUE")) &#123; return new Blue(); &#125; return null; &#125; @Override Shape getShape(String shapeType) &#123; return null; &#125;&#125; 步骤 7创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。 FactoryProducer.java 12345678910public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if (choice.equalsIgnoreCase("SHAPE")) &#123; return new ShapeFactory(); &#125;else if (choice.equalsIgnoreCase("COLOR")) &#123; return new ColorFactory(); &#125; return null; &#125;&#125; 步骤 8使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。 AbstractFactoryPatternDemo.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor("RED"); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor("Green"); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor("BLUE"); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 步骤 9验证输出。 123456Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method. 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 一个党只能有一个主席。 Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2. 避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。 SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1创建一个 Singleton 类。 SingleObject.java 1234567891011121314151617public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println("Hello World!"); &#125;&#125; 关于对象的实例化 大家想到的通常是直接new，除了这个，还有些单实例模式，层次间调用等等 getInstance的使用: 在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。 getInstance 和 new的区别；大部分类都可以用new，new就是通过生产一个新的实例对象，或者在栈上声明一个对象，每部分的调用都是用的一个新的对象 getInstance在单例模式(保证一个类仅有一个实例，并提供一个访问它的全局访问点)的类中常见，用来生成唯一的实例，getInstance往往是static的。 1234567891011121314&gt; public abstract class TestInstance &#123; &gt; static int i = 1; &gt; public static TestInstance getInstance() &#123; &gt; System.out.println(i++); &gt; return null; &gt; &#125; &gt; &#125; &gt; public class TestGetInstance &#123; &gt; public static void main(String[] args) &#123; &gt; TestInstance ins1 = TestInstance.getInstance(); &gt; TestInstance ins2 = TestInstance.getInstance(); &gt; &#125; &gt; &#125; &gt; 使用实例，在定义的新类当中加入getInstance()方法，返回值即为该类的一个对象，此方法常常应用在Java的单例模式当中 12345678&gt; public class OAuthConstant &#123; &gt; public static synchronized OAuthConstant getInstance()&#123; &gt; if(instance == null) &gt; instance = new OAuthConstant(); &gt; return instance; &gt; &#125; &gt; &#125;&gt; //主函数当中使用此类的getInstance()函数，即可得到系统当前已经实例化的该类对象，若当前系统还没有实例化过这个类的对象，则调用此类的构造函数 //实例化一个对象，并返回 OAuthConstant.getInstance(); 对象使用之前通过getInstance得到而不需要自己定义，用完之后不需要delete； new 一定要生成一个新对象，分配内存；getInstance() 则不一定要再次创建，它可以把一个已存在的引用给你使用，这在效能上优于new； new创建后只能当次使用，而getInstance()可以跨栈区域使用，或者远程跨区域使用。所以getInstance()通常是创建static静态实例方法的。 对于抽象类，是只能用getInstance()方法,是不能new出来的， 总结： getInstance这个方法在单例模式用的甚多，为了避免对内存造成浪费，直到需要实例化该类的时候才将其实例化，所以用getInstance来获取该对象，至于其他时候，也就是为了简便而已，为了不让程序在实例化对象的时候，不用每次都用new关键字，索性提供一个instance方法，不必一执行这个类就初始化，这样做到不浪费系统资源！单例模式 可以防止 数据的冲突，节省内存空间。 步骤 2从 singleton 类获取唯一的对象。 SingletonPatternDemo.java 1234567891011121314public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 步骤 3验证输出。 1Hello World! 单例模式的几种实现方式单例模式的实现有多种方式，如下所示： 1、懒汉式，线程不安全是否 Lazy 初始化：是 是否多线程安全：否 实现难度：易 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 代码实例： 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 2、懒汉式，线程安全是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 代码实例： 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3、饿汉式是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 代码实例： 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4、双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 代码实例： 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 5、登记式/静态内部类是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 代码实例： 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 6、枚举JDK 版本：JDK1.5 起 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。 代码实例： 12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 介绍意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 应用实例： 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 JAVA 中的 StringBuilder。 优点： 建造者独立，易扩展。 便于控制细节风险。 缺点： 产品必须有共同点，范围有限制。 如内部变化复杂，会有很多的建造类。 使用场景： 需要生成的对象具有复杂的内部结构。 需要生成的对象内部属性本身相互依赖。 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 实现我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。 我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。 然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。 步骤 1创建一个表示食物条目和食物包装的接口。 Item.java 12345public interface Item &#123; public String name(); public Packing packing(); public float price(); &#125; Packing.java 123public interface Packing &#123; public String pack();&#125; 步骤 2创建实现 Packing 接口的实体类。 Wrapper.java 1234567public class Wrapper implements Packing &#123; @Override public String pack() &#123; return "Wrapper"; &#125;&#125; Bottle.java 1234567public class Bottle implements Packing &#123; @Override public String pack() &#123; return "Bottle"; &#125;&#125; 步骤 3创建实现 Item 接口的抽象类，该类提供了默认的功能。 Burger.java 12345678910public abstract class Burger implements Item &#123; @Override public Packing packing() &#123; return new Wrapper(); &#125; @Override public abstract float price();&#125; ColdDrink.java 12345678910public abstract class ColdDrink implements Item &#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125; 步骤 4创建扩展了 Burger 和 ColdDrink 的实体类。 VegBurger.java 123456789101112public class VegBurger extends Burger &#123; @Override public float price() &#123; return 25.0f; &#125; @Override public String name() &#123; return "Veg Burger"; &#125;&#125; ChickenBurger.java 123456789101112public class ChickenBurger extends Burger &#123; @Override public float price() &#123; return 50.5f; &#125; @Override public String name() &#123; return "Chicken Burger"; &#125;&#125; Coke.java 123456789101112public class Coke extends ColdDrink &#123; @Override public float price() &#123; return 30.0f; &#125; @Override public String name() &#123; return "Coke"; &#125;&#125; Pepsi.java 123456789101112public class Pepsi extends ColdDrink &#123; @Override public float price() &#123; return 35.0f; &#125; @Override public String name() &#123; return "Pepsi"; &#125;&#125; 步骤 5创建一个 Meal 类，带有上面定义的 Item 对象。 Meal.java 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item)&#123; items.add(item); &#125; public float getCost()&#123; float cost = 0.0f; for (Item item : items) &#123; cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Item item : items) &#123; System.out.print("Item : "+item.name()); System.out.print(", Packing : "+item.packing().pack()); System.out.println(", Price : "+item.price()); &#125; &#125; &#125; 步骤 6创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。 MealBuilder.java 12345678910111213141516public class MealBuilder &#123; public Meal prepareVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; 步骤 7BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。 BuilderPatternDemo.java 123456789101112131415public class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println("Veg Meal"); vegMeal.showItems(); System.out.println("Total Cost: " +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println("\n\nNon-Veg Meal"); nonVegMeal.showItems(); System.out.println("Total Cost: " +nonVegMeal.getCost()); &#125;&#125; 步骤 8验证输出。 12345678910Veg MealItem : Veg Burger, Packing : Wrapper, Price : 25.0Item : Coke, Packing : Bottle, Price : 30.0Total Cost: 55.0Non-Veg MealItem : Chicken Burger, Packing : Wrapper, Price : 50.5Item : Pepsi, Packing : Bottle, Price : 35.0Total Cost: 85.5]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（Design pattern）简介]]></title>
    <url>%2Fblog%2F5503.html</url>
    <content type="text"><![CDATA[根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。 设计模式的类型这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 主要解决：在运行期建立和删除原型。 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。 适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 桥接模式桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。 意图：将抽象部分与实现部分分离，使它们都可以独立的变化。 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。 何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。 如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。 关键代码：抽象类依赖实现类。 过滤器模式过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 组合模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。 关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。 外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。 如何解决：客户端不与系统耦合，外观类与系统耦合。 关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。 享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。 代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用：在处理消息的时候以过滤很多道。 如何解决：拦截的类都实现统一接口。 关键代码：Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 命令模式命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。 关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口 解释器模式解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决：对于一些固定文法构建一个解释句子的解释器。 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决：构件语法树，定义终结符与非终结符。 关键代码：构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。 迭代器模式迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 迭代器模式属于行为型模式。 意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要解决：不同的方式来遍历整个整合对象。 何时使用：遍历一个聚合对象。 如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。 关键代码：定义接口：hasNext, next。 应用实例：JAVA 中的 iterator。 中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 何时使用：多个类相互耦合，形成了网状结构。 如何解决：将上述网状结构分离为星型结构。 关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。 备忘录模式备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。 如何解决：通过一个备忘录类专门存储对象状态。 关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。 应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。 观察者模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 状态模式在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用：代码中包含大量与对象状态有关的条件语句。 如何解决：将各种具体的状态类抽象出来。 关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 空对象模式在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。 在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。 策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：实现同一个接口。 应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。 模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决：一些方法通用，却在每一个子类都重新写了这一方法。 何时使用：有一些通用的方法。 如何解决：将这些通用算法抽象出来。 关键代码：在抽象类实现，其他步骤在子类实现。 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 访问者模式在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 意图：主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。 MVC 模式MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 业务代表模式业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。 客户端（Client） - 表示层代码可以是 JSP、servlet 或 UI java 代码。 业务代表（Business Delegate） - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。 查询服务（LookUp Service） - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。 业务服务（Business Service） - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。 组合实体模式组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。 组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。 粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。 依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。 策略（Strategies） - 策略表示如何实现组合实体。 数据访问对象模式数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。 数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。 数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。 模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。 前端控制器模式前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。 调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。 视图（View） - 视图是为请求而创建的对象。 拦截过滤器模式拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。 过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。 Target - Target 对象是请求处理程序。 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。 客户端（Client） - Client 是向 Target 对象发送请求的对象。 服务定位器模式服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。 服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。 Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用。 服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。 缓存（Cache） - 缓存存储服务的引用，以便复用它们。 客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象。 传输对象模式传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。 业务对象（Business Object） - 为传输对象填充数据的业务服务。 传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。 客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。 设计模式相关的网站 Wiki Page for Design Patterns) - 以一种非常通用的方式检查设计模式。 Java Programming/Design Patterns - 一篇关于设计模式的好文章。 The JavaTM Tutorials - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。 JavaTM 2 SDK, Standard Edition - JavaTM 2 SDK, Standard Edition 的官网。 Java DesignPatterns - 关于设计模式的短文。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（Design pattern）导学]]></title>
    <url>%2Fblog%2F56017.html</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 基础知识 设计模式概述 从招式与内功谈起——设计模式概述（一）：设计模式从何而来？ 从招式与内功谈起——设计模式概述（二）：设计模式是什么？ 从招式与内功谈起——设计模式概述（三）：设计模式有什么用？附：个人观点 面向对象设计原则 面向对象设计原则概述 面向对象设计原则之单一职责原则 面向对象设计原则之开闭原则 面向对象设计原则之里氏代换原则 面向对象设计原则之依赖倒转原则 面向对象设计原则之接口隔离原则 面向对象设计原则之合成复用原则 面向对象设计原则之迪米特法则 六个创建型模式 简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 工厂三兄弟之简单工厂模式（一）：图表库的设计 工厂三兄弟之简单工厂模式（二）：简单工厂模式概述 工厂三兄弟之简单工厂模式（三）：图表库的简单工厂模式解决方案 工厂三兄弟之简单工厂模式（四）：图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结 工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】 工厂三兄弟之工厂方法模式（一）：日志记录器的设计 工厂三兄弟之工厂方法模式（二）：工厂方法模式概述 工厂三兄弟之工厂方法模式（三）：日志记录器的工厂方法模式解决方案，反射与配置文件 工厂三兄弟之工厂方法模式（四）：重载的工厂方法，工厂方法的隐藏，工厂方法模式总结 抽象工厂模式-Abstract Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】 工厂三兄弟之抽象工厂模式（一）：界面皮肤库的初始设计 工厂三兄弟之抽象工厂模式（二）：产品等级结构与产品族 工厂三兄弟之抽象工厂模式（三）：抽象工厂模式概述 工厂三兄弟之抽象工厂模式（四）：界面皮肤库的抽象工厂模式解决方案 工厂三兄弟之抽象工厂模式（五）：“开闭原则”的倾斜性，抽象工厂模式总结 单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 确保对象的唯一性——单例模式 （一）：单例模式的动机，单例模式概述 确保对象的唯一性——单例模式 （二）：负载均衡器的设计与实现 确保对象的唯一性——单例模式 （三）：饿汉式单例与懒汉式单例的讨论 确保对象的唯一性——单例模式 （四）：一种更好的单例实现方法（静态内部类） 确保对象的唯一性——单例模式 （五）：单例模式总结 原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 对象的克隆——原型模式（一）：大同小异的工作周报，原型模式概述 对象的克隆——原型模式（二）：工作周报的原型模式解决方案 对象的克隆——原型模式（三）：带附件的周报【浅克隆，深克隆】 对象的克隆——原型模式（四）：原型管理器的引入和实现，原型模式总结 建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】 复杂对象的组装与创建——建造者模式（一）：游戏角色设计，建造者模式概述 复杂对象的组装与创建——建造者模式（二）：游戏角色设计的建造者模式解决方案 复杂对象的组装与创建——建造者模式（三）：关于Director的进一步讨论，建造者模式总结 七个结构型模式 适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】 不兼容结构的协调——适配器模式（一）：没有源码的算法库，适配器模式概述 不兼容结构的协调——适配器模式（二）：没有源码的算法库的适配器模式解决方案 不兼容结构的协调——适配器模式（三）：类适配器，双向适配器 不兼容结构的协调——适配器模式（四）：缺省适配器，适配器模式总结 桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：**★★★☆☆**】 处理多维度变化——桥接模式（一）：跨平台图像浏览系统 处理多维度变化——桥接模式（二）：桥接模式概述 处理多维度变化——桥接模式（三）：跨平台图像浏览系统的桥接模式解决方案 处理多维度变化——桥接模式（四）：适配器模式与桥接模式的联用，桥接模式总结 组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 树形结构的处理——组合模式（一）：设计杀毒软件的框架结构 树形结构的处理——组合模式（二）：组合模式概述 树形结构的处理——组合模式（三）：杀毒软件的框架结构的组合模式解决方案 树形结构的处理——组合模式（四）：透明组合模式与安全组合模式 树形结构的处理——组合模式（五）：公司组织结构，组合模式总结 装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 扩展系统功能——装饰模式（一）：图形界面构件库的设计 扩展系统功能——装饰模式（二）：装饰模式概述 扩展系统功能——装饰模式（三）：图形界面构件库的装饰模式解决方案 扩展系统功能——装饰模式（四）：透明装饰模式与半透明装饰模式，装饰模式注意事项，装饰模式总结 外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】 深入浅出外观模式（一）：外观模式概述，外观模式结构与实现 深入浅出外观模式（二）：外观模式应用实例（文件加密模块） 深入浅出外观模式（三）：抽象外观类，外观模式效果与适用场景 享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 实现对象的复用——享元模式（一）：围棋棋子的设计，享元模式概述（上） 实现对象的复用——享元模式（二）：享元模式概述（下） 实现对象的复用——享元模式（三）：围棋棋子的享元模式解决方案 实现对象的复用——享元模式（四）：带外部状态的围棋棋子解决方案 实现对象的复用——享元模式（五）：单纯享元模式和复合享元模式，关于享元模式的几点补充，享元模式总结 代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 代理模式（一）：代理模式概述，代理模式结构与实现 代理模式（二）：代理模式应用实例（收费商务信息查询系统） 代理模式（三）：远程代理，虚拟代理，缓冲代理 代理模式（四）：代理模式效果与适用场景 十一个行为型模式 职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 请求的链式处理——职责链模式（一）：采购单的分级审批 请求的链式处理——职责链模式（二）：职责链模式概述 请求的链式处理——职责链模式（三）：采购单分级审批的职责链模式解决方案 请求的链式处理——职责链模式（四）：纯与不纯的职责链模式，职责链模式总结 命令模式-Command Pattern【学习难度：★★★☆☆**，使用频率：★★★★☆】** 请求发送者与接收者解耦——命令模式（一）：自定义功能键，命令模式概述 请求发送者与接收者解耦——命令模式（二）：自定义功能键的命令模式解决方案 请求发送者与接收者解耦——命令模式（三）：命令队列的实现 请求发送者与接收者解耦——命令模式（四）：撤销操作的简单实现 请求发送者与接收者解耦——命令模式（五）：请求日志 请求发送者与接收者解耦——命令模式（六）：宏命令，命令模式总结 解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】 自定义语言的实现——解释器模式（一）：机器人控制程序 自定义语言的实现——解释器模式（二）：文法规则和抽象语法树 自定义语言的实现——解释器模式（三）：解释器模式概述 自定义语言的实现——解释器模式（四）：机器人控制程序的解释器模式解决方案 自定义语言的实现——解释器模式（五）：再谈Context的作用 自定义语言的实现——解释器模式（六）：解释器模式总结 迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 遍历聚合对象中的元素——迭代器模式（一）：销售管理系统中数据的遍历 遍历聚合对象中的元素——迭代器模式（二）：迭代器模式概述 遍历聚合对象中的元素——迭代器模式（三）：销售管理系统中数据的遍历的迭代器模式解决方案 遍历聚合对象中的元素——迭代器模式（四）：使用内部类实现迭代器 遍历聚合对象中的元素——迭代器模式（五）：JDK内置迭代器的使用 遍历聚合对象中的元素——迭代器模式（六）：迭代器模式总结 中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 协调多个对象之间的交互——中介者模式（一）：客户信息管理窗口的初始设计 协调多个对象之间的交互——中介者模式（二）：中介者模式概述 协调多个对象之间的交互——中介者模式（三）：客户信息管理窗口的中介者模式解决方案 协调多个对象之间的交互——中介者模式（四）：中介者与同事类的扩展 协调多个对象之间的交互——中介者模式（五）：中介者模式总结 备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】 撤销功能的实现——备忘录模式（一）：可悔棋的中国象棋 撤销功能的实现——备忘录模式（二）：备忘录模式概述 撤销功能的实现——备忘录模式（三）：中国象棋的备忘录模式解决方案 撤销功能的实现——备忘录模式（四）：实现多次撤销 撤销功能的实现——备忘录模式（五）：再谈备忘录的封装，备忘录模式总结 观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 对象间的联动——观察者模式（一）：多人联机对战游戏的设计 对象间的联动——观察者模式（二）：观察者模式概述 对象间的联动——观察者模式（三）：多人联机对战游戏的观察者模式解决方案 对象间的联动——观察者模式（四）：JDK对观察者模式的支持 对象间的联动——观察者模式（五）：观察者模式与Java事件处理 对象间的联动——观察者模式（六）：观察者模式与MVC，观察者模式总结 状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 处理对象的多种状态及其相互转换——状态模式（一）：银行系统中的账户类设计 处理对象的多种状态及其相互转换——状态模式（二）：状态模式概述 处理对象的多种状态及其相互转换——状态模式（三）：账户类的状态模式解决方案 处理对象的多种状态及其相互转换——状态模式（四）：共享状态的实现 处理对象的多种状态及其相互转换——状态模式（五）：使用环境类实现状态转换 处理对象的多种状态及其相互转换——状态模式（六）：状态模式总结 策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 算法的封装与切换——策略模式（一）：电影票打折方案 算法的封装与切换——策略模式（二）：策略模式概述 算法的封装与切换——策略模式（三）：电影票打折方案的策略模式解决方案 算法的封装与切换——策略模式（四）：策略模式的两个典型应用，策略模式总结 模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 模板方法模式深度解析（一）：模板方法模式概述，模板方法模式结构与实现 模板方法模式深度解析（二）：模板方法模式应用实例（银行利息计算模块） 模板方法模式深度解析（三）：钩子方法的使用，模板方法模式效果与适用场景 访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 操作复杂对象结构——访问者模式（一）：OA系统中员工数据汇总 操作复杂对象结构——访问者模式（二）：访问者模式概述 操作复杂对象结构——访问者模式（三）：OA系统中员工数据汇总的访问者模式解决方案 操作复杂对象结构——访问者模式（四）：访问者模式与组合模式联用，访问者模式总结 设计模式趣味学习（复习） 设计模式与足球（一）：创建型模式 设计模式与足球（二）：结构型模式 设计模式与足球（三）：行为型模式（上） 设计模式与足球（四）：行为型模式（下） 设计模式综合应用实例 多人联机射击游戏 多人联机射击游戏中的设计模式应用（一）：抽象工厂模式，建造者模式，工厂方法模式，迭代器模式，命令模式 多人联机射击游戏中的设计模式应用（二）：观察者模式，单例模式，状态模式，适配器模式 数据库同步系统 设计模式综合实例分析之数据库同步系统（一）：数据库同步系统概述，建造者模式，简单工厂模式 设计模式综合实例分析之数据库同步系统（二）：享元模式，单例模式，观察者模式，模板方法模式 设计模式综合实例分析之数据库同步系统（三）：策略模式，组合模式，命令模式，职责链模式 【作者：刘伟 http://blog.csdn.net/lovelion】]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品设计-产品架构和业务逻辑]]></title>
    <url>%2Fblog%2F36961.html</url>
    <content type="text"><![CDATA[在分析产品的时候，快速理解产品架构；产品细节设计时，能围绕核心业务逻辑展开；能独立开始搭建产品架构和业务逻辑 目标 在分析产品的时候，快速理解产品架构 产品细节设计时，能围绕核心业务逻辑展开 能独立开始搭建产品架构和业务逻辑 1.了解产品架构、业务逻辑和业务流程1.1 如何理解流程化产品设计 设计产品，就是设计流程 流程不是独立存在的，而是在一个整体体系下发生的 体系=产品架构+业务逻辑+业务流程 Fig 1.1 流程.png 1.1.1产品架构=设计图=目标 未来一段时间你希望完成的蓝图 1.1.2业务逻辑=框架设计图=功能模块 用户要解决问题需要走过的路径 不同的模块之间的关联性 1.1.3业务流程=施工图=实施方法如： 注册流程图 下单流程图 支付流程图 小结：做产品如盖楼，不断逐级解构，剥橘子般一片片分离的过程 2.搭建产品架构2.1为什么做产品要先理解产品架构 深入了解一个产品的运作逻辑 看产品的时候，不再只看界面与交互，而是背后的逻辑 指导产品设计和运营 进可观星：评估产品的生命力 退可照妖：识别忽悠型产品 2.1.1 为什么做产品要先理解产品架构？ Fig 1.2三节课官网产品架构.png 2.1.2 从产品的角度理解产品 Fig 1.3 17APP产品架构.png 2.1.3 识别忽悠型产品2.2 产品架构的关键点是什么？ 最关注人、信息、渠道和流转过程 内容从哪里来，到哪里去 用户从哪里来，到哪里去 Fig 1.4 关键点.png 2.3 有哪些人（角色）参与产品 分别有哪些人先后会做什么动作？ 不同的角色，会做什么事？ 人和人之间的关系是什么？ 2.4 会产生什么信息？ 有哪些信息产生 信息由谁产生的？ 信息与信息之间的关系是什么？ Fig 1.6 信息与信息之间的关系.png 2.5 流转过程与渠道 Fig 1.7 流程过程与渠道.png 小结：产品架构可以调研相关产品获得，如果已经被市场验证的，没必要搞独创。 3.搭建产品业务逻辑3.1为什么要理解业务逻辑？ 业务逻辑是功能模块设计，关键功能与参与者流程 业务逻辑有助于统一各参与者的角色与分工 有助于产品业务流程的设计 Fig 1.8 业务逻辑.png Fig 1.9 三节课官网开课业务逻辑.png 3.3 如何开始业务逻辑设计？ 有哪些功能模块 有哪些页面 不同模块之间是如何关联的 Fig 1.10过程.png 3.4 以内容为主线、明确数据流向 关键数据是什么？ 数据从哪里来？到哪里去？需要经过哪些系统？ 3.5 以用户为主线，明确行为 重要的角色是什么？辅助的角色是什么？ 不同的角色的行为分别是什么？ 用户从哪里来，到哪里去？会经过哪些系统，用到哪些功能？ 3.6 以渠道（终端）为界面，区分类型 有哪些渠道（终端）？ 这些终端是如何展现内容的？ 用户在不同终端的操作行为有哪些不同？ 3.7 把以上模块串联起来 用户、系统、终端等之间是如何关联的？ 先通顺再细化 先能用再美化 小结：业务逻辑是指导产品经理的工作方向的，明确需求解决什么环节的问题。 4.设计产品业务流程图4.1业务流程图关注后续《业务流程设计》的课程 4.2 产品架构、业务逻辑、业务流程 Fig 1.11 三种图.png 小结：业务流程是业务逻辑中模块的细化，是每个需求文档中必备的内容 总结： 1.如何理解产品架构、业务逻辑和业务流程 产品架构-&gt;业务逻辑-&gt;业务流程 2.如何开展搭建产品架构 以用户为中心，人与人，人与信息，信息与信息之间的关系 3.如何开始搭建业务逻辑 内容主线-&gt;用户主线-&gt;终端-&gt;关联起来]]></content>
      <categories>
        <category>Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说软件产品和业务、业务过程(流程)、业务逻辑]]></title>
    <url>%2Fblog%2F16499.html</url>
    <content type="text"><![CDATA[作为一名程序猿，需要懂产品，不懂产品的程序猿不是好程序猿猴。而业务逻辑是软件产品的支柱，所以，要懂产品，就必须懂业务逻辑。 介绍业务逻辑之前，先介绍下相关的一些概念。 什么叫业务？从企业的角度来讲，业务是企业运用科学方法和生产工艺生产出可交付用户使用的产品与服务，并以此为企业带来利益的行为。 举例： 对服装企业来说，业务一般是生产服装；对银行企业来说，业务可以是办理贷款；对软件公司来说，业务可以是开发某种类型的软件，比如开发防火墙软件；对医院来说，业务可以是提供医疗服务。 什么叫业务过程？“业务流程”和“业务过程”是两个经常出现的词，含义相似，但有轻微区别，这里暂且不做区分，都统一叫做业务过程。 1）业务过程开始于客户需求，终止于客户需求的满足，为客户创造价值。 2）业务过程是为了产生产品或服务而设计的一系列步骤，一些过程的结果可能是由组织外的客户所接受的产品或服务，称为主要过程；另一些过程的产出不为外部客户所见，但是有效管理所必须的，称为支持过程。 举例： 业务过程，对于服装工厂来说，可以是产出可穿戴衣物的一系列活动；对医院来说，可以是提供医疗服务的一系列活动；对软件公司来说，可以是开发出满足客户需求的软件产品的一系列活动。 软件产品和业务过程 软件产品具有它的特殊性，通常情况下，企业提供的软件产品、服务，主要用于外部组织、用户实现其业务过程。 举例： 假设有两家公司,A公司和B公司。A公司的业务是提供医疗服务；B公司是开发医疗相关的软件。A公司找到B公司说，我需要你们帮忙开发一个系统，实现XXX功能。这时，B公司考虑的不仅是自己的业务过程：产品，设计，测试，开发，运维等怎么配合去做这件事情，而且还要考虑A公司的业务过程：病人挂号，就诊，住院，缴费结算等等。 什么是业务逻辑？业务逻辑是系统架构中体现核心价值的部分，典型的三层结构模型中（如下图），介于表现层和数据访问层之间。 通俗的讲，业务逻辑就是个“怎么做”的问题，是产品的灵魂，它的关注点主要集中在业务流程的实现，业务规则的定制等与业务过程相关的。 细说业务逻辑 业务实体 业务实体完整性约束 业务流程(业务过程) 业务规则 业务实体关键业务相关的动态的概念性对象 比如，电商企业，业务过程中的买家，商品，就是业务实体，软件实现过程中先将其抽象为概念模型(通常用E-R图表示)，然后对其建立结构模型，展现在计算机世界中，可能表现为买家表中或商品表中的一条表记录。 实体业务完整性约束（Validation）业务实体完整性约束简单说就是对业务实体的约束，比如对商品实体，商品编号必须唯一 注：关于业务实体和业务实体完整性约束，可以看下数据库的相关资料，理解会比较深刻一点 业务流程(业务过程)如果把产品比作一个人，那么这个业务过程就是产品的骨架。产品只有实现了这个流程，用户才能用它来实现业务。 例子：购物网站为例子 购买者登录网站 -&gt; 浏览商品 -&gt;下单 -&gt; 结算 -&gt; 确认收货 -&gt; 评价 例：以学校申请助学金为例子 学生登陆终端 -&gt; 提交申请 -&gt; 班主任审批 -&gt; 分院负责人审批 -&gt; 学工处审批 -&gt; 资领处审批 业务规则定义1：业务规则是与特定行业中的特定业务功能有关的决策逻辑的表示形式 定义2：业务规则是对业务的某些方面进行定义和约束的声明 例1：以学校申请助学金为例子 “申请助学金的学生必须是贫困生”，这便是一条业务规则，对申请助学金的做了一个前提申明。 那又为何说是决策逻辑呢？程序中，实现经常会这样： if 学生 is not 平困生 then 拒绝申请 例2：以购物网站为例子 未登录顾客点击购买商品时，提示先登录 例3：以购物网站为例子 买家下单后，通知卖家商品被拍下。 从上面的例子可以看出，业务规则它不会告诉你怎么做，仅是“决策”，告诉你要做什么，而不会告诉你怎么做。比如，上面的贫困生的例子，它不会告诉你怎么申请贫困生，但是会告诉你要去申请贫困生，再如，上面购物网站的例子，它约定说要去通知卖家，但是不会告诉你怎么通知卖家(通过邮件、电话、短信还是其它？？) 小知识点：一般做系统，都避免不了数据验证，完整性约束是业务逻辑的一部分，按理应该放在业务层。但是实际不然，不提倡在“表示层的服务端”放置过多完整性验证。因为，表示层的职责应该仅仅是接收数据并传递给业务层，不应对数据是否合法负责。过多的数据验证，不但令表示层代码臃肿，而且使得表示层职责变得不明确。 可以在“表示层的服务端”放置一些简单的验证，如空值验证，两次输入密码是否一致等，但业务关系紧密的验证，最好放在业务层，甚至有些验证只能在业务层验证，如“当前用户名不能与已有用户名重复”，这种验证需要访问持久化数据，需要由业务层完成。 这里之所以强调“表示层的服务端”，是因为一般在B/S系统中，都会在JavaScript里加入一些基本的数据验证，如空值检查，格式正则匹配 等。这主要是为了减轻服务器负担，将大多数显然包含不合法数据的请求拒绝掉，而不发给服务端验证。当然，因为可能会出现JS被屏蔽或黑客恶意攻击行为，所以，所有验证不论JS中是否验证过，服务端（可能是表示层的服务端部分或业务层）一定要再进行验证。 难题：什么是业务逻辑？业务是指一个实体单元向另一个实体单元提供的服务。逻辑是指根据已有的信息推出合理的结论的规律。 业务逻辑是指一个实体单元为了向另一个实体单元提供服务，应该具备的规则与流程。 就像你家的规矩–“吃饭前必须洗手”“有客人来要起立”“睡觉前各自说晚安”-就是业务逻辑的生活化实例。 软件系统架构一般分为三个层次表示层、业务逻辑层和数据访问层： 表示层：负责界面和交互； 业务逻辑层：负责定义业务逻辑（规则、工作流、数据完整性等），接收来自表示层的数据请求，逻辑判断后，向数据访问层提交请求，并传递数据访问结果，业务逻辑层实际上是一个中间件，起着承上启下的重要作用； 数据访问层：负责数据读取。 业务逻辑的内容包括四部分 领域实体：定义了业务中的对象，对象有属性和行为； 业务规则：定义了需要完成一个动作，必须满足的条件； 数据完整性：某些数据不可少； 工作流：定义了领域实体之间的交互关系。 以大毛网购裤子为例 领域实体：大毛、资金账户、订单、裤子、发货单 业务规则：大毛点击购买就会生成订单，但必须付了钱，才会发货，生成发货单。 数据完整性：淘宝网下订单必须登录账号，没有账号就不能成功购买。 工作流：搜索裤子-找到合意裤子-下单购买-付账-收货。 业务逻辑：搜索“裤子”-找到合意裤子-下单-必须登录账号-结算-付账-收货。 当当必须登录账号才能下单成功，亚马逊就不需要，今天发现淘宝也不需要登录账号就能购买商品了，所以每个网站的规则的不同，就形成了不同的业务逻辑，业务逻辑不仅仅包括规则，还包括实体、数据完整性、工作流。如图： 业务逻辑图：业务逻辑也需要画图，叫做业务逻辑图，它跟业务流程图有什么区别呢？ 业务流（工作流）是业务逻辑的一部分，它定义了对象之间的交互关系，但不涉及到规则的制定，数据的完整性方面。其实，我们平常画的业务流程图多数是业务逻辑图。 表示层 分层是为了实现“高内聚，低耦合”。采用“分而治之”的思想，把问题划分开来各个解决，易于控制，延展和分配资源。 所谓的三层开发就是将系统的整个业务应用划分为表示层，业务逻辑层和数据访问层，这样有利于系统的开发、维护、部署和扩展。 分层是为了实现“高内聚，低耦合”。采用“分而治之”的思想，把问题划分开来各个解决，易于控制，延展和分配资源。 业务逻辑层负责系统领域业务的处理，负责逻辑性数据的生成、处理及转换。对所输入的逻辑性数据的正确性及有效性负责，但对输出的逻辑性数 据及用户性数据的正确性不负责，对数据的呈现样式不负责。 JavaEE三层架构MVC，把视图控制器模型分开来 那么在这里业务逻辑就是M。 但是什么样的算是业务逻辑如：上传一个文件，上传代码算是一个业务逻辑吗？ 数据库操作增加时需要判断，和一些其它这算业务逻辑吗？（我觉得算） 但是hibernate又提供了一个离线查询对象（DetachedCriter），提供这个接口的意思我想是在外面处理业务逻辑。 但是三层架构不是独立的吗？互相不干涉吗？在service层出现sql，hql，criter不是又把dao与service连在一起了吗？ DTO（VO），POJO，BO这些是什么，POJO对应数据库，BO对应业务逻辑，DTO对应页面的传输与显示。 业务逻辑就是处理数据的逻辑啦。 后台代码分三层 action(controller) service DAO （这里的三层不是MVC） 比如 我得到用户名 但是在存入数据库的时候 用户名字段应该是前台的用户名加上当前日期拼成的字符串 action或者controller层是第一层 一般是用来及接受数据并且做数据的非空啊 格式是否正确的验证 如用户名是否为空 是不是安全字符串之类的 service层一般是用来做一个业务逻辑的实现 这时候 userName = userName + new Date(); DAO层 就是与数据库交互层 也就是读写数据库 将逻辑层得到的新的userName插入到数据库 MVC和三层架构并没有可比性 三层架构是指将程序分为数据访问、业务处理、界面三个层次，是软件整体架构 MVC是仅仅是界面架构，也就是它其实只是三层架构的界面部分 M是指实体模型或者实体模型的一个代理，而非领域模型 C是指控制器，仅仅是做转向，不应该包含任何业务逻辑 V就是视图 至于那些个什么什么O，都是实体在不同层的映射。另外值得一提的是，MVC在一些小的程序中也经常被当做软件整体架构，那个时候M往往就是实体模型了，但是这种时候，V就对M产生了直接引用，也就是界面对实体产生依赖，这是很不好的（但小程序问题不大），此时可以尝试使用MVP模式解耦。至于业务，看你怎么定义领域模型了，一般像上传文件这种操作并不会牵扯企业的业务，那就不应该当做一个业务，但如果这个上传是在工作流或者一些特殊处理中，则有可能上升到业务。怎么做，要看具体问题。]]></content>
      <categories>
        <category>Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计规范]]></title>
    <url>%2Fblog%2F13930.html</url>
    <content type="text"><![CDATA[数据库设计规范 1 基本原则Ø 产品根据业务功能的不同，划分为多个相对独立的业务子系统。对应于一个业务子系统，数据库中都应建立一个用户，该业务子系统中的数据、业务规则都在此用户下的对象中描述。如：数据库中建立MES用户，来对应制造执行系统，制造执行系统中的数据、业务逻辑都由MES用户下的对象（如表、包及存储过程等等）来描述，系统管理由APPSYS用户来管理； Ø 除两个公共用户APPS，APPVIEW外，其他用户下的所有对象，都需要在APPS中建立同义词，并对APPS授权； Ø 除两个公共用户APPS，APPVIEW外，其他用户下的所有的视图， 都需要在APPVIEW中建立对应的表； Ø 系统管理部分的表，需用设置多语言； 2 表及字段规范2.1 表命名约定数据库中以描述表中内容的英文为表名，前面以该表所属的用户+下划线作为开头，具体遵循以下规则： 用户 + ‘_’+ 英文，如MDS_Route表示MDS用户下的工艺路线表， 英文如果是两个单词及以上，单词之间尽量用下划线分割。如果英文有公共熟知的缩写，可以使用缩写。如MES_Control_Dept表示MES用户下的受控部门表 2.2 表字段约定 每个表中必须包含7个字段： 字段名称及作用 字段代码 类型 表ID，作为表主键 ID Number(16,0) 创建人 CREATED_BY Number(16,0) 创建时间 CREATION_DATE Date 最后修改人 LAST_UPDATED_BY Number(16,0) 最后修改时间 LAST_UPDATE_DATE Date 最后更新IP LAST_UPDATE_IP VARCHAR2(20) 版本 VERSION Number(16,0) 主键字段：每个表必须以ID作为主键，通过建立UniqueKey来实现实际的主键组合。如部门表中，将部门代码建立为Unique Key 外键字段：系统不显式建立外键，表中的字段如果需要引用其他表的主键，尽量以其他表的表名+ ‘_ID’作为此字段名，并在注释中显式说明，如：员工表中引用部门表的主键的字段，命名为HR_Dept_ID；如果表中有两个及以上的字段需要引用同一个表的主键，需要在此规则的基础上，前面添加用途，如两个字段都引用部门表主键，制造部门命名为：Manufact_HR_Dept_ID，使用部门命名为：User_HR_Dept_ID。 字段注释：每个字段必须有注释，说明该字段的含义，值的来源。对于标识，状态之类的字段，必须注明其每个可能的取值，及每个取值的含义。如对于标识字段，注释需要标明：Y-是，N-否，说明此字段的取值为Y和N，含义分别为是和否。 字段数据类型：对于标识，状态字段，一般取值为一个字符（Varchar2(1)），如果状态较多，可以设置为2个字符（Varchar2(2)）；对于数量等字段，设置为数值（Number(20，7)）；对于代码、名称、说明、描述的字段，一般为Varchar2，字符的多少可根据需要设置。 字段取值：对于涉及到是和否的标识字段，取值必须为Y/N，但 “是否显示”字段除外，其取值为0/1；对于状态字段，一般取值为0，1，2……,对应不同的状态。 3 序列规范每个表都必须有一个主键序列，作为主键ID的值. 命名：表名 + ‘_S’， 如：MDS_Route_S; 取值：初始值，最小值，步长均为1，最大值为999999999 在后来的数据库设计中，不再需要为每个表创建一个序列，用以产生主键ID。表主键的数据类型变为Varchar2(32)，用Oracle函数SYS_GUID()产生，具体方法如下： Select SYS_GUID() into v_tableId from dual; 4 包及存储过程规范对于业务系统的逻辑处理，需要建立包及存储过程来实现。如果多个存储过程实现同一业务，尽量封装在包中。 包的命名：与表的命名规则类似，但需要以’ _P’结尾，如：MES_Route_P 存储过程命名规范：命名尽量表示此存储过程功能； 存储过程参数规范：最后两个参数必须为返回值，并遵循以下约定： 倒数第二个参数为Number，表示执行的结果，成功/失败等等 ，其取值为Codecollection里的Success/Fail/Warn 倒数第一个参数为Varchar2, 表示执行中出现的错误或警告信息 传入的参数中如果需要有日期或时间，需要设置为字符串 存储过程中必须包含的处理： 如果传入的参数中如日期或时间字符串，必须进行转换的异常处理，转换时，使用Codecollection里的Date_Format_Date/Date_Format_Datetime来进行时间格式设置 插入数据时，7个必须的字段必须赋值，其中主键使用相应的序列取值，Version设为1，涉及到人员的，使用Get_Session_Info里的Get_User_Id，涉及到时间的，使用当前系统时间，IP使用Get_Session_Info里的Get_Logon_Ip 更新数据时，最后修改人，最后修改时间，最后更新IP，版本 必须更新，取值同样来源于Get_Session_Info，Version 增1 异常处理：如果执行成功，返回值中Return_Int 设为Codecollection里的 Success 如果捕捉到异常，需要返回Codecollection里的Fail/Warn，并设置Return_String的内容 需要读取配置文件中的设置时，使用Sys_Profile_Option_p的Get_Profile_Option_Value方法，来取得值。如：末工序的最大号 存储过程的参数、变量命名规范 传入参数：命名以 i_开头，譬如i_Sys_Function_Tl_Id，具体参照appsys用户下sys_form_p包中的存储过程Delete_Form_Tl_Id的定义， PROCEDUREDelete_Form_Tl_Id(i_Sys_Form_Tl_Id VARCHAR2,o_Return_Int OUT INT,o_Return_String OUT VARCHAR2); 返回值：命名以o_开头，目前只支持两个返回值，o_Return_Int和o_Return_String，分别表示执行的结果及消息； 变量：命名以v_开头，如果变量是用来存储数据库表中某列的数值，其数据类型一般会采取tableName.columnName%TYPE的定义方式，如v_Sys_Function_IdSys_Function.Id%TYPE; 存储过程及函数的注释 对存储过程和函数的注释主要包括功能描述、编写人、编写日期信息，一般写在包体中存储过程或函数的名称前面。如appsys用户下sys_form_p包中的存储过程Delete_Form_Tl_Id： /*** 功能描述:级联删除form_with_tl信息 编写人：刘岩 编写日期: 2008-04-22 ***/ PROCEDURE Delete_Form_Tl_Id(i_Sys_Form_Tl_IdVARCHAR2, ​ o_Return_Int OUT INT, ​ o_Return_String OUT VARCHAR2) IS ​ v_Sys_Form_Id Sys_Form.Id%TYPE; BEGIN ​ SELECT Sys_Form_Id ​ INTO v_Sys_Form_Id ​ FROM Sys_Form_Tl ​ WHERE Id = i_Sys_Form_Tl_Id; ​ Delete_Form(v_Sys_Form_Id, o_Return_Int,o_Return_String); EXCEPTION ​ WHEN OTHERS THEN ​ o_Return_Int := Codecollection.Fail; ​ o_Return_String := ‘删除表单失败：’ || SQLERRM; END Delete_Form_Tl_Id; 5 视图规范每个表必须建立视图，命名规范为： 如果没有多语言，则视图名为：表名 + ‘_V’ 如果有多语言，则视图名为：表名 + ‘_VL’ 如果在视图的基础上再建立视图，命名规范为：视图名 +‘V’ 如果视图带数据权限，则视图名为：表名 + ‘_VS’ 6 常用包及用途APPSYS.Codecollection:常量设置 APPSYS.Sys_Profile_Option_p:读取配置文件 APPSYS.Get_Session_Info:获取当前用户信息 APPS.Gen_Appview：根据视图在APPVIEW中建立表 APPS.Sys_Auto_Code_p：管理编码 APPS.Sys_Util_p：将字符串表示的计算式格式化，计算值]]></content>
      <categories>
        <category>Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程文档汇编]]></title>
    <url>%2Fblog%2F54252.html</url>
    <content type="text"><![CDATA[实用软件工程文档汇编 1《立项建议书》《立项建议书》编写参考指南 1．引言（Introduction） 1.1 目的（Purpose） 本文档是软件立项书，目的是代替可行性分析。 1.2 范围（Scope） 本文档只适应于软件立项。 1.3 术语定义（Terms Glossary） 对软件组织内部和外部有关的行业术语、专用名词进行定义。 [1] …… [2] …… 1.4 参考资料（References） 对书写该立项书所用到的有关资料进行说明。 [1] …… [2] …… 1.5 相关文档（Related Documents） 当该文档变更时，可能对其他文档产生影响，受影响的文档叫做相关文档，需将它们一一列出。 [1] …… [2] …… 1.6 版本更新记录（Version Updated Record） 任何一次版本创建或维护更新，都要追加一条记录。一个版本创建只有一次，但对它的维护更新可能有多次。大版本升级一次，定义为创建一次，如V1.0到V2.0。而V1.0到V1.1，只是维护更新一次。版本更新记录格式，如表3-2所示。 表3-2 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/01/03 — — — V1.0.1 — — 王小林 2001/02/10 网络版功能维护 2．项目概述及架构（Project Summary and Framework） 2.1 项目概述（Project Summary） 宏观上说明该项目是什么、能干什么、要求干得怎么样。 2.2 项目架构（Project Framework） 宏观上描述该项目的架构：单机结构、C/S结构、B/S结构。并说明结构具体详细的运行平台：硬件的要求、操作系统的要求、数据库管理系统的要求、对外接口的要求。 3．客户群分析（Client Analysis） 3.1 客户群定位（Client Orientation） 单机结构、C/S结构、B/S结构对应哪三种客户群，每种客户群的数量、素质、市场前景等。 3.2 当前客户群分析（Current Client Analysis） 当前客户群是指已签订合作协议或将要签订合作协议的客户群，分析他们的数量、素质、市场前景等。 3.3 潜在客户群分析（Latency Client Analysis） 潜在客户群是指将来可能发展的客户群，分析他们的数量、素质、市场前景等。 4．项目功能（Project Function） 4.1 单机版功能（Stand-alone Function） 单机版功能，如表3-3所示。 表3-3 单机版功能 编号 功能名称 功能描述 输入内容 输出内容 1 2 4.2 网络版功能（Network Function） 网络版功能，如表3-4所示。 表3-4 网络版功能 编号 功能名称 功能描述 输入内容 输出内容 1 2 4.3 互联网络版功能（Internet Function） 互联网络版功能，如表3-5所示。 表3-5 互联网络版功能 编号 功能名称 功能描述 输入内容 输出内容 1 2 5．项目性能（Project Performance） 5.1 响应时间（Response Time） 单机结构（包括主机多用户结构，即H/T结构）、C/S结构、B/S结构三种架构的终端数量，要求响应时间小于0.XX秒。 5.2 处理速度（Disposal Speed） C/S结构、B/S结构两种架构的后台结算方式，结算速度分析。 5.3 最大终端负载（The Highest Terminal Load） C/S结构、B/S结构两种架构的并发处理最大终端（用户）负载数量分析。 以上性能要求，最好也用列表的形式给出。 6．项目接口（Project Interface） 6.1 金融接口（Finance Interface） 金融接口列表，如表3-6所示。 表3-6 金融接口列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 6.2 政府接口（Government Interface） 政府接口列表，如表3-7所示。 表3-7 政府接口列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 6.3 互联网接口（Internet Interface） 互联网接口列表，如表3-8所示。 表3-8 互联网接口列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 7．投入产出分析（Analysis of the Devotion and the Output） 7.1 人力资源投入（Manpower Devotion） 人力资源投入，如表3-9所示。 表3-9 人力资源投入 阶段名称 需求岗位 需求人数 工作量（人/月） 到岗日期 需求分析 分析师 概要设计 设计师 详细设计 设计师 / 高级程序员 编码 程序员 测试 测试员 包装与发布 包装师 总人数： 总工作量（人/月）： 7.2 设备资源投入（Facility Devotion） 设备资源投入，如表3-10所示。 表3-10 设备资源投入 设备名称 规格型号 数量 单价（元） 金额（元） 到位日期 7.3 其他经费资源投入（Other Outlay Devotion） 其他经费资源投入，如表3-11所示。 表3-11 其他经费资源投入 开支项目 开支金额（元） 支付日期 支付方式（现金/支票） 备注 项目总投入（人力费用+设备费用+其他经费资源投入）经费（元）： 7.4 产出分析（Output Analysis） 产出分析，如表3-12所示。 表3-12 产 出分 析 单机版单价（元） 单机版 数量 C/S版单价（元） C/S版数量 B/S版单价（元） B/S版数量 年产出合计金额（元） 第1年 第2年 第3年 8．开发计划（Development Scheme） 8.1 进度计划（Plan Scheme） 开发进度计划，如表3-13所示。 表3-13 进 度计 划 阶段名称 需求分析 概要设计 详细设计 编码 测试 包装与发布 第1周进度 第2周进度 第3周进度 第4周进度 第5周进度 …… 8.2 评审计划（Review Scheme） 各里程碑的评审计划，如表3-14所示。 表3-14 评 审计 划 阶段名称 评审日期 评审地点 主持人 参加人 应交文档 需求分析 概要设计 详细设计 测试报告 包装 9．案例分析（Cases Analysis） 案例分析包括成功案例和失败案例分析。 9.1 国外案例分析（Cases Analysis in Foreign Countries） 案例1：…… 案例2：…… 9.2 国内案例分析（Cases Analysis in China） 案例1：…… 案例2：…… 10．风险分析（Risk Analysis） 10.1 需求风险（Risk of Requirement） 指项目组对用户需求获取的途径和能力有何风险，用户主动配合需求的程度。 10.2 政策风险（Risk of Policy） 指国家政策、行业政策、企业内部政策的变化对项目将会产生有利或不利的影响。 10.3 资源风险（Risk of Resource） 指开发和运行所需资源的风险程度。 10.4 技术风险（Risk of Technology） 指项目组采用新技术的风险程度。如最新开发工具的风险程度、最新设计思想的风险程度。 10.5 技能风险（Risk of Skill） 指项目组成员掌握新技术的风险程度。 2《软件项目投标书》表3-15 《软件项目投标书》编写参考指南 序号 章节名称 章节内容 1 项目概况 按照招标书的内容，陈述项目概况 2 总体解决方案 按照招标书的要求，提出项目的总体解决方案： 网络结构总体方案 系统软件配置方案 应用软件设计方案 系统实施方案 3 项目功能、性能和接口描述 应用软件的具体功能点列表 应用软件的具体性能点列表 应用软件的具体接口列表 续表 序号 章节名称 章节内容 4 项目工期、进度和经费估算 项目工期（单位：人月）估算 项目进度估算：需求、设计、编程、测试、验收的时间表 项目经费（单位：人民币元）估算 5 项目质量管理控制 质量标准 质量管理控制方法 项目开发和管理的组织结构及人员配备 6 附录 附录1：本软件公司的特点与强项简介 附录2：本软件公司的成功案例 附录3：本软件公司的资质证明材料 3《软件产品开发任务书》《软件产品开发任务书》正文样本 任务书名称：大型商业MIS产品开发任务书。 下达日期：1999/04/01。 发出部门：XX公司研发中心。 接受部门：研发中心商业软件部。 1．目标 （1）做成商业MIS产品，其产品化程度要求很高。因此，一切信息都要规范化、标准化、代码化。保证在产品实施时，其客户化工作只需录入代码和修改代码，绝对不允许修改数据结构和表结构； （2）配合市场销售部门、全国各地的分支机构和产品代理商，第一年开拓市场3~5个客户，第二年占领10% 的商业MIS市场。 2．功能模块划分及要求 大型商业MIS软件产品拟分为以下6个功能模块，要求每个功能模块具有高内聚、低耦合、信息隐蔽的性质，如表3-16所示。 表3-16 大型商业MIS产品的6个功能模块 序号 模块名称 功能要求 1 商业物流配送中心管理 商业物流采购、配送 2 大型商场（大型连锁超市）管理 商品零售 3 便利店（小型连锁超市）管理 商品零售 4 远程数据交换管理 点对点通信 5 电子商务模块 网上订货、销售 6 商业类库管理 基础类库、商业类库、构件库管理 3．功能模块详述 大型商业MIS软件，从组织结构上来说包括三个层次： （1）物流配送中心 （2）大型商场（大型连锁超市） （3）便利店（小型连锁超市） 作为一个完整的商业MIS系统来说，物流配送中心与大型商场（大型连锁超市）之间会发生物流、资金流、信息流的关系；大型商场（大型连锁超市）与便利店（小型连锁超市）之间也会发生物流、资金流、信息流的关系；而物流配送中心与便利店（小型连锁超市）之间没有任何关联。若将这三个模块分开来看，它们又可以各自独立成为一个单独的小型商业系统来使用。实际上，本大型商业MIS系统完成后，可以对功能模块进行组合或拆分，使其成为如下5个不同的小型商业MIS系统，供用户选择： （1）物流配送中心 ＋ 大型商场（大型连锁超市）＋ 便利店（小型连锁超市）的完整的商业MIS软件。 （2）物流配送中心 ＋ 大型商场（大型连锁超市）的商业MIS软件。 （3）大型商场（大型连锁超市）＋ 便利店（小型连锁超市）的商业MIS系统。 （4）物流配送中心MIS系统。 （5）大型商场的商业MIS系统。 作为本软件的第一层，物流配送中心可以具有多个配送仓库，它根据大型商场（大型连锁超市）的需要以及各个仓库库存情况，向供应商订货，进行货物采购；并根据订货的情况进行配货，组织运输工具进行发货；期间，还伴随着向供应商付款、索取发票，以及向客户催款、开出发票等等。大型商场（大型连锁超市）作为本软件的第二层，除了要进行本商场的各种业务管理外，还要向上级物流配送中心订货、付款、索取发票，向下级便利店（小型连锁超市）送货，收取钱款等等。便利店（小型连锁超市）作为本软件的第三层，一要进行本商场的各种业务管理；二要根据库存情况，向大型商场（大型连锁超市）要货，并定期将销售金额上交给大型商场（大型连锁超市）。 考虑到目前有些商场，已经有了其他的商业管理软件，虽然软件还有不完善的地方，但已经购买前台POS机。为了给客户节省开支，有效地将前台POS机利用好，所以，本系统的前台销售软件就要做两个版本：Windows 版本与DOS 版本。 由于配送中心与大型商场（大型连锁超市）之间、大型商场（大型连锁超市）与便利店（小型连锁超市）之间在物理位置上有一定的距离，所以，它们之间的网络连接也是一个需要重视的大问题。本系统考虑采用两种解决方案：一是采用DDN专线（或光缆），本方案数据传输速度快，性能高，程序设计、实现都很简单，但用户每月都要支付价格不低的线路费用，这种方案比较适合那些经济实力比较雄厚的用户；二是采用电话线，用X.25通信协议，此方案数据传输速度稍慢，但也能满足用户需要，程序设计和实现要复杂许多，用户每月支付的线路费用将大幅度下降。 随着计算机网络技术的飞速发展，电子商务在流通领域的应用也越来越多。本MIS系统也准备在电子商务方面有所扩展，条件允许，可以实现网上订货、网上销售，甚至网上货币支付。 作为一个软件企业，应该不断地提取、积累自己的软件资源。不同开发平台的开发规范、商业类库、应用框架、构件、中间件等都是十分重要的软件资源，是软件公司的基础建设。因此，在设计、编码之前，要制订相应的开发规范，要组织开发、设计、管理一些类库和构件库。 软件产品是软件公司的财富来源，而软件的有效加密是保护公司产品、产权的有效手段，更是保障公司效益的有效途径。所以，还要考虑软件加密算法设计。 4．功能模块任务分配 根据研发中心商业软件部目前的人员情况，本系统的项目经理由商业软件部副经理亲自担任，负责整个系统的规划、设计、协调与实施；商业软件部主任工程师担任产品经理，负责项目的整体需求、数据库设计与Alpha测试。整个项目分为4个任务组，各个任务组组长在项目实施阶段，承担小项目经理职责。4个任务组的人数及开发任务，如表3-17所示。 表3-17 任务组的人数及开发任务 任务组 人数 具体开发任务 第1任务组 4 1）POS机模块改造 2）利用X.25协议进行远程数据交换 3）电子商务模块 第2任务组 6 物流配送中心管理模块。本模块的主要功能包括：货物的采购管理，配送中心的库存管理，货物的销售管理三大部分 1）货物的采购管理包括：供应商管理，采购计划管理，订货管理，货物验收管理，退货管理，应付账款管理，应收发票管理，往来账管理等 2）库存管理包括：货位管理，入库管理，出库管理，盘库管理等 3）销售管理包括：客户管理，销售定单管理，配货管理，运输工具管理，发货管理，退货管理，应收账款管理，应付发票管理，往来账管理等 第3任务组 6 1）全局数据库设计 2）商业管理模块（包括大型商场与便利店的管理）。本模块的主要功能包括：货物的采购管理，退货管理（退给供应商），价格管理，库存管理，销售管理，前台销售管理，退货管理（客户退货管理），应付、应收账款管理，发票管理，送货管理（给便利店送货），收款管理（便利店上交金额）等等 第4任务组 2 1）PowerBuilder 开发规范 2）PowerBuilder 类库建设 3）构件的提取和构件库的管理 4）产品的加密处理 5）安装盘的制作 5．数据库与开发工具的选择 考虑到数据库的性能与价格比，数据库首选Sybase，其次是MS SQL Server。由于这两个数据库的天然联系，使得两个版本的程序设计的差异将十分微小。数据库设计工具采用PowerDesigner，程序开发工具选择为PowerBuilder 。某些PowerBuilder 不宜实现的功能，可由 VC++ 去完成。文档制作工具为Office 和PowerDesigner。 6．开发进度计划 研发中心商业软件部现有18人进入了本项目组。根据以往的实际工作经验，下面列出研发进度，如表3-18所示。 表3-18 进度计划（1999/04/01-1999/10/15） 阶段名称 需求分析 概要设计 详细设计 编码 测试 包装 发布 第1周进度 需求培训 第2周进度 需求获取 第3周进度 需求获取 第4周进度 需求获取 第5周进度 需求确认 第6周进度 概要设计 第7周进度 概要设计 第8周进度 概要设计 第9周进度 详细设计 第10周进度 详细设计 第11周进度 详细设计 第12周进度 详细设计 第13周进度 编码 第14周进度 编码 第15周进度 编码 第16周进度 编码 第17周进度 编码 第18周进度 编码 第19周进度 编码 第20周进度 Alpha测试 第21周进度 Alpha测试 第22周进度 Alpha测试 第23周进度 Alpha测试 第24周进度 Beta测试 第25周进度 Beta测试 第26周进度 包装 第27周进度 发布 第28周进度 机动 7．评审计划 各里程碑的评审计划，如表3-19所示。 表3-19 里程碑评审计划 阶段名称 评审日期 评审地点 主持人 参加人 应交文档 需求分析 1999/05/05 公司第一会议室 部门经理 项目组成员 用户需求报告/需求规格说明书 概要设计 1999/05/26 公司第一会议室 部门经理 项目组成员 概要设计说明书 详细设计 1999/06/25 公司第一会议室 项目经理 项目组成员 详细设计说明书 Alpha测试 1999/09/12 公司第一会议室 项目经理 测试人员 Alpha测试报告 Beta测试 1999/09/26 客户单位 项目经理 客户代表 Beta测试报告 包装 1999/09/31 公司第一会议室 部门经理 销售人员 包装光盘，用户指南，广告材料 附件：《商业MIS立项建议书》，此处省略。 4《软件开发计划书》《软件开发计划书》编写参考指南 1．引言（Introduction） 1.1 目的（Purpose） 本章提供整个软件开发计划的综述。主要是确定以下内容： （1）软件生存周期的选取及裁剪。 （2）软件规范、方法和标准的选择。 （3）软件工作产品的规模估计。 （4）软件工作量和成本的估计。 （5）软件进度表的制定。 （6）软件风险的估计。 （7）软件项目培训计划。 1.2 范围（Scope） 说明该软件开发计划的范围，简要描述软件开发计划的内容。一般而言，对于一个较大的软件项目（工期6个人月以上），计划书包括如下内容： （1）软件规模估计 （2）工作模块计划 （3）人力资源计划 （4）其他资源计划 （5）进度安排计划 （6）配置管理计划（可单独做一个计划） （7）质量保证计划（可单独做一个计划） 1.3 术语定义（Terms Glossary） 将该软件开发计划中的术语、缩写词进行定义。包括用户应用领域与计算机领域的术语与缩写词等。例如： [1] 软件相关组：指软件配置管理组、文档支持组、测试组。 [2] 软件质量保证组：指计划和实施软件质量保证活动的人员的集合。 1.4 参考资料（References） 说明该软件开发计划使用的参考资料，如项目的用户需求报告、商务合同、用户领域的资料等，每一个文件、文献要有标题、索引号或文件号，发布或发表日期以及出版单位。 [1] …… [2] …… 1.5 相关文档（Related Documents） 当该文档变更时，可能对其他文档产生影响，受影响的文档叫相关文档，需将它们列出。 [1] …… [2] …… 1.6 版本更新记录（Version Updated Record） 版本更新记录格式，如表4-8所示。 表4-8 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/02/06 — — — V1.0.1 — — 王小林 2001/02/25 成本估算维护 …… 2．项目概述（Project Summary） 2.1 项目的目的（Project Purpose） 说明该软件项目的目的。 2.2 项目的范围（Project Scope） 本章的内容，主要参照《立项建议书》/《合同》与《用户需求报告》中相关章节，简要描述该软件项目的实现范围： （1）主要功能点列表 （2）主要性能点列表 （3）主要接口列表 （4）本软件项目与其他软件项目之间的关系 （5）项目实施方面的限制等内容 2.3 项目的使用对象（Project Reader） 在本章节中，要识别出顾客与最终用户，对顾客与最终用户的情况要有简单描述，如最终用户的教育水平、技术水平及本系统的使用频度等。 3．项目组织（ProjectOrganization） 项目组织是为开发项目而组建的队伍。建议以框图的方式表示项目的组织结构，并对每一组织的负责人和职责加以说明。可能的项目组织单元，如： （1）项目管理组 （2）质量保证组 （3）配置管理组 （4）软件工程组 （5）测试组 （6）需求管理组 各组织说明如下： （1）项目管理组，执行SPP和SPTO过程，对项目实施负全部责任。 （2）质量保证组，执行SQA过程，负责项目过程与产品的质量控制和报告。 （3）配置管理组，执行SCM过程，负责项目产品的版本、配置管理以及配置库状态报告。 （4）软件工程组，执行软件项目工程过程，负责项目产品的开发和维护工作。 （5）测试组，执行软件项目测试过程，负责项目产品的测试。 （6）需求管理组，负责对需求基线和需求变更进行管理。 4．软件生存周期（Software Life Cycle） 本章节记录项目策划生存期定义的工作结果，需要描述的主要内容： （1）项目生存期框图 （2）项目生存期说明 5．规范、方法和标准（Criterion，Means，Standard） 本章节中需要描述采用的供开发和维护软件用的规范、方法和标准。 6．任务与工作产品（Task and Work Products） 项目任务和工作产品，是指根据项目生存期阶段划分的任务，和相应阶段的工作产品。记录项目生存期各阶段确定的需重点控制的阶段任务和工作产品。建议以表格的形式，列出生存期各阶段的任务和工作产品。项目包含的任务，如： （1）需求分析 （2）系统设计 （3）系统实现 （4）测试 （5）产品交付 （6）产品维护 项目可能包含的产品，如： （1）需求分析说明书 （2）规格分析说明书 （3）系统设计说明书 （4）源代码 （5）各种测试报告 （6）用户手册 （7）软件问题维护记录 7．工作产品、任务规模、工作量估计（Estimates of Work Product，Task Size and Workload） 项目规模估算是为了确定项目所需的人工。需要描述的主要内容有： （1）对软件工作产品规模估计依据的简要描述。 （2）每种任务和工作产品规模估计的结果。 （3）规模估算的结果，建议用《任务规模和工作量估算表》的形式列出。 8．成本估计（Estimates of Costs） 成本估计，是指对项目完成过程中耗费的人力、物力、财力资源的估算。成本估计应按类别进行估算，可能的成本估算类别，如： （1）直接人工 （2）直接费用 （3）间接成本 （4）制造费用 （5）管理费用 （6）不可预见费用 9．关键计算机资源计划（Critical Computer Resource Plan） 项目的关键计算机资源计划，是指系统在开发环境、测试环境、及用户目标环境中，对关键计算机资源，如计算机存储能力、计算机处理器速度、通信通道容量、服务器处理能力等的估计，使之能满足软件开发、测试、运行的要求。 10．软件项目进度计划（Software Project Schedule） 件项目进度计划，是对项目的进度、人员工作分工所做的计划，此计划依据上述各章的估算和分析结果，计划方式建议采用表格的形式。若采用工具制定项目计划，应将工具生成的图表作为项目计划的附件。本章节中需要描述的主要内容有： （1）软件项目每个阶段的进度时间表 （2）设定的里程碑 （3）评审时间 （4）缓冲时间 11．配置管理计划（可单独做一个计划）（Configuration ManagementPlanning） 本书单独作为一章论述。 12．质量保证计划（可单独做一个计划）（Software Quality AssurancePlanning） 本书单独作为一章论述。 13．风险分析（Risks Analysis） 项目风险分析，是指对可能发生的将会对项目按预期时间、资源和预算完成产生重大影响的事件的分析包括： （1）被识别出的重大风险事件：政策风险、技术风险、技能风险等。 （2）易发生重大风险事件的高风险区域：用户需求、设计、测试、运行平台等。 （3）重大风险事件的级别：功能不全、性能不稳、迅速受限制等。 （4）拟采取的预防措施：增加投入、纠错、延时等。 （5）风险事件发生后建议采用的处理措施：更改计划、降低难度系数等。 14．设备工具计划（Equipment and Tools Planning） 项目设备工具计划，是根据项目的工作指派及进度确定项目所需要的设备和工具，以确保设备工具在任务执行前到位，保证项目任务的顺利执行，在本计划中应包含以下几方面的内容： （1）所需的设备 （2）基本的要求 （3）应到位的时间 15．培训计划（Training Planning） 项目的培训计划，应根据项目的特点和项目组成员技能情况，制定出项目组成员所需的培训内容，培训计划中应包含以下几方面： （1）培训内容 （2）培训时间 （3）教员 （4）接受培训的人员 （5）培训目的（应达到的效果） 16．项目评审（Project Reviews） 项目评审，是对项目策划过程所做的定期性评审。其内容可分为： （1）评审点 （2）评审周期 （3）评审层次 （4）评审条款和措施 （5）管理评审活动中提交的工作产品（列出被评审的工作产品） 17．度量（Measurement） 度量是按规定在项目进行过程中，需要采集的度量数据，以便量化地反映项目的进展情况，为管理者提供对项目进展的适当的可视性，同时度量数据是项目过程改善的数据基础。应规定项目度量值的记录人（一般为项目经理或其指定人员）、记录时间（一般以定期评审为基础）和记录的数据。常用的度量数据如： （1）项目过程的评审次数 （2）项目计划修改次数 （3）项目各阶段的人员投入（各阶段投入的人月数） （4）各类任务耗用时间统计（如设计、编码、测试、文档编写等） （5）工作产品统计（如文档字数、功能点数、用况数、源代码行数等） 5《用户需求报告》《用户需求报告》编写参考指南 1．概述（Summary） 本文档是进行需求规格定义、项目策划、概要设计的基础，也是用户进行验收的依据。 1.1 用户简介（User Synopsis） 在本章节中要将用户的基本情况描述清楚，以便于分析人员划定系统范围，进行关于功能、进度、成本、性能等方面的平衡决策。 对于产品开发类项目，需要在此将该产品定义的用户群的特点描述清楚。 1.2 项目的目的与目标（Purpose and Aim of Project） 项目的目的是对开发本系统意图的总概括。项目的目标是将目的细化后的具体描述。项目目标应是明确的、可度量的、可以达到的, 项目的范围应能确保项目的目标可以达到。 对于项目的目标可以逐步细化，以便与系统的需求建立对应关系，检查系统的功能是否覆盖了系统目标。 1.3 术语定义（Terms Glossary） 将该用户需求报告中的术语、缩写进行定义, 包括用户应用领域与计算机领域的术语与缩写等。 1.4 参考资料（References） 说明该用户需求报告使用的参考资料，如： [1] 商务合同 [2] 招标书 [3] 用户领域的资料 [4] 用户需求调查表 [5] 参照的标准 每一个文件、文献要有标题、或文件号，发布或发表日期以及出版单位。 1.5 相关文档（Related Documents） 说明用户需求报告的变更，以及可能受变更影响的其他相关文档，如： [1] 项目开发计划 [2] 需求规格说明书 1.6 版本更新信息（Version Updated Record） 版本更新记录格式，如表5-11所示。 表5-11 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/02/18 — — — V1.0.1 — — 王小林 2001/02/26 账本格式维护 2．现有系统描述（System in Existence） 2.1 组织结构与职责（Organizing Framework and Function） 将用户的组织结构逐层详细描述，建议采用树状的组织结构图进行表达，每个部门的职责也应进行简单的描述。组织结构是用户企业业务流程与信息的载体，对分析人员理解企业的业务、确定系统范围很有帮助。取得用户的组织结构，是需求获取步骤中的工作任务之一。 2.2 岗位定义（Role Definition） 用户环境中的企业岗位和组织结构一样，也是分析人员理解企业业务的基础，是需求获取的工作任务，同时也是分析人员提取对象的基础。每个岗位的职责可以进行详细的描述，建议采用表格的形式，如表5-12所示。 表5-12 岗 位定 义 编 号 岗 位 所在部门 职 责 相关的业务 1008 采购员 业务部 商品采购、合同签订、供应商选择 进货、合同管理 1009 …… 对用户岗位的识别，也包括使用了计算机系统后的系统管理人员岗位。 2.3 作业流程（Busywork Flow） 企业的作业流程，首先要有一个总的业务流程图，将企业中各种业务之间的关系描述出来，然后对每种业务进行详细的描述，使业务流程与部门职责结合起来。详细业务流程图可以采用直式业务流程图、Use case图、程序流程图加上文字说明。 图形可以将流程描述得很清楚，但是还要附加一些文字说明，如关于业务发生的频率、意外事故的处理、高峰期的业务频率等，不能在流程图中描述的内容，需要用文字进行详细描述。 2.4 单据、账本、报表（Bill of Document，Account and Report） 现行系统中用户正在使用的正式的或非正式的单据、账本、报表等可以收集起来，并进行穷举、分类、归纳。单据、账本、报表是用户系统中信息的载体，是进行系统需求分析的基础，无论采用哪种分析方法，这都是必不可少的信息源。 2.4.1 单据（Bill of Document） 单据的格式可用表格描述，如表5-13所示。 表5-13 单据的描述格式 单据名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 类型、长度、精度 数据项的取值范围 1 2 3 2.4.2 账本（Account） 因为账本上的数据是统计数据，所以一个账本一般对应一张中间表，账本的格式可用表格描述，如表5-14所示。 表5-14 账本的描述格式 账本名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 数据项类型、长度、精度 数据来源 1 2 3 2.4.3 报表（Report） 因为报表上的数据是统计数据，所以一个报表一般对应一张中间表，报表的格式可用表格描述，如表5-15所示。 2.5 存在的问题（Existent Question） 在现行的系统中，决策层、管理层、操作层各存在哪些方面的问题需要计算机来解决，尤其是决策层、管理层这些问题中包含了用户的需求与期望，有些问题是新系统可以解决的，有些问题则不是。 表5-15 报表的描述格式 报表名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 数据项类型、长度、精度 数据来源 1 2 3 2.6 可能的变化（Possible Change） 对于现行的系统，将来可能会有哪些变化，需要在此描述。企业中的变化是永恒的，系统分析员需要描述哪些变化可能引起系统范围变更。 3．目标系统功能需求（Function of Target System） 3.1 功能需求分析（Function Analysis） 决策层、管理层、操作层各有哪些具体功能要求。 3.2 功能需求点列表（Function List） 在功能需求分析完成后，要详细列出用户需求功能点列表，提供给后续设计、编程、测试中使用，更是为了用户测试验收中使用。功能需求点列表的格式，如表5-16所示。 表5-16 功能需求点列表 编 号 功 能 名 称 使 用 部 门 使 用 岗 位 功 能 描 述 输 入 内 容 输 出 内 容 1 2 3 4．目标系统性能需求（Performance of Target System） 4.1 时间要求（Time Request） 如： （1）响应时间，如查询的最长等待时间。 （2）更新处理时间，如记账的最长时间。 （3）数据的转换和传送时间，如远程数据传输的时间要求。 （4）解题时间。 4.2 空间要求（Space Request） 如： （1）支持的终端数。 （2）支持的并行操作的使用者数。 （3）处理的文件和记录数。 （4）表和文件的大小规模（要按可预见的增长，对数据及其分量的存储要求做出估算）。 （5）处理任务的数量。 （6）在正常情况下和峰值工作条件下，在一定时间周期中要处理的数据总数。 （7）对输入和输出数据的精度要求。 （8）对处理和传输过程中的精度要求。 4.3 性能需求点列表（Performance List） 详细列出用户性能点列表，提供给后续分析、设计、编程、测试中使用，更是为了用户测试验收中使用。需求性能点列表的格式，如表5-17所示。 表5-17 性能需求点列表 编 号 性能名称 使用部门 使用岗位 性能描述 输入内容 输出内容 1 2 3 5．目标系统界面与接口需求（Interface of Target System） 5.1 界面需求（Interphase Requirement） 界面的原则要求，如方便、简洁、美观、一致等。整个系统的界面风格定义，某些功能模块的特殊的界面要求。 （1）输入设备：键盘、鼠标、条码扫描器、扫描仪等； （2）输出设备：显示器、打印机、光盘刻录机、磁带机、音箱等； （3）显示风格：图形界面、字符界面、IE界面等； （4）显示方式：1024768、640480等； （5）输出格式：显示布局、打印格式等。 5.2 接口需求（Interface Requirement） 与其他系统的接口，如监控系统、控制系统、银行结算系统、税控系统、财务系统、政府网络系统及其他系统等。 （1）与系统特殊外设的接口，如CT机、磁共振、柜员机（ATM）、IC卡、盘点机等。 （2）与中间件的接口，要列出接口规范、入口参数、出口参数、传输频率等。 应在此列举出所有的外部接口名称、接口标准、规范。外部接口列表，如表5-18所示。 表5-18 外部接口需求点列表 编 号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 3 6．目标系统其他需求（Other Requirements of Target System） 6.1 安全性（Security） 6.2 可靠性（Dependability） 6.3 灵活性（Agility） 6.4 特殊需求（Special requirements） 如： （1）进度需求：系统的阶段进度要求。 （2）资金需求：投资额度。 （3）运行环境需求：平台、体系结构、设备要求。 （4）培训需求：用户对培训的需求，是否提供多媒体教学光盘。 （5）推广需求：推广的要求，如在上百个远程部门推广该系统，是否要有推广的支持软件。 7．目标系统假设与约束条件（Suppose and Restriction ofTarget System） 假设与约定条件是对预计的系统风险的描述, 如： （1）法律、法规和政策方面的限制。 （2）硬件、软件、运行环境和开发环境方面的条件和限制。 （3）可利用的信息和资源。 （4）系统投入使用的最晚日期。 （5）需求中的风险分析：技术风险、技能风险、时间风险、资源风险。 6《需求规格说明书》《需求规格说明书》编写参考指南 1．概述（Summary） 本文档是进行项目策划、概要设计和详细设计的基础，也是软件企业测试部门进行内部验收测试的依据。 1.1 用户简介（User Synopsis） 在本章节中要将用户的基本情况描述清楚，以便于分析人员划定系统范围，进行功能、进度、成本、性能等方面的平衡决策。 对于产品开发类项目，需要在此将该产品定义的用户群的特点描述清楚。 1.2 项目的目的与目标（Purpose and Aim of Project） 项目的目的是对开发本系统的意图的总概括。项目的目标是将目的细化后的具体描述。项目目标应是明确的、可度量的、可以达到的, 项目的范围应能确保项目的目标可以达到。 对于项目的目标可以逐步细化，以便与系统的需求建立对应关系，检查系统的功能是否覆盖了系统的目标。 1.3 术语定义（Terms Glossary） 将该需求规格说明书中的术语、缩写进行定义, 包括用户应用领域与计算机领域的术语与缩写等。 1.4 参考资料（References） 说明该用户需求报告使用的参考资料，如： [1] 商务合同 [2] 招标书 [3] 用户领域的资料 [4] 用户需求调查表 [5] 用户需求报告 [6] 参照的标准 每一个文件、文献要有标题、或文件号，发布或发表日期以及出版单位。 1.5 相关文档（Related Documents） [1] 项目开发计划 [2] 概要设计说明书 [3] 详细设计说明书 1.6 版本更新信息（Version Updated Record） 版本更新记录格式，如表5-19所示。 表5-19 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/03/03 — — — V1.0.1 — — 王小林 2001/03/16 业务模型维护 2．目标系统描述（System in Target） 2.1 组织结构与职责（Organizing Framework and Function） 将目标系统的组织结构逐层详细描述，建议采用树状的组织结构图进行表达，每个部门的职责也应进行简单的描述。组织结构是用户企业业务流程与信息的载体，对分析人员理解企业的业务、确定系统范围很有帮助。取得用户的组织结构，是需求获取步骤中的工作任务之一。 2.2 角色定义（Role Definition） 用户环境中的企业角色，和组织机构一样，也是分析人员理解企业业务的基础，是需求获取的工作任务，同时也是分析人员提取对象的基础。每个角色的授权可以进行详细的描述，建议采用表格的形式，如表5-20所示。 表5-20 角 色定 义 编号 角色 所在部门 职 责 相关的业务 1008 采购员 业务部 商品采购、合同签订、供应商选择 进货、合同管理 1009 对用户角色的识别也包括使用了计算机系统后的系统管理人员。 2.3 作业流程（业务模型）（Busywork Flow）（Operation Model） 目标系统的作业流程是对现有系统作业流程的重组、优化与改进。企业的作业流程首先要有一个总的业务流程图，将企业中各种业务之间的关系描述出来，然后对每种业务进行详细的描述，使业务流程与部门职责结合起来。详细业务流程图可以采用直式业务流程图、Use case图、其他示意图的形式。 图形可以将流程描述得很清楚，但是还要附加一些文字说明，如关于业务发生的频率、意外事故的处理、高峰期的业务频率等，不能在流程图中描述的内容，需要用文字进行详细描述。 2.4 单据、账本、报表（Bill of Document，Account and Report） 目标系统中用户将使用的正式单据、账本、报表等，并进行穷举、分类、归纳。单据、账本、报表是用户系统中信息的载体，是进行系统需求分析的基础，无论采用哪种分析方法，这都是必不可少的信息源。 2.4.1 单据（Bill of Document） 因为单据上的数据是原始数据，所以一种单据一般对应一个实体，一个实体一般对应一张基本表。单据的格式可用表格描述，如表5-21所示。 表5-21 单据的描述格式 单据名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 属性中文名 属性英文名 属性类型、长度、精度 属性的值域 Pk/fk 2.4.2 账本（Account） 因为账本上的数据是统计数据，所以一个账本一般对应一张中间表，账本的格式可用表格描述，如表5-22所示。 表5-22 账本的描述格式 账本名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 数据项类型、长度、精度 数据项算法 1 2 3 2.4.3 报表（Report） 因为报表上的数据是统计数据，所以一个报表一般对应一张中间表，报表的格式可用表格描述，如表5-23所示。 表5-23 报表的描述格式 报表名称 用途 使用单位 制作单位 频率 高峰时数据流量 各数据项的详细说明如下： 序号 数据项中文名 数据项英文名 数据项类型、长度、精度 数据项算法 1 2 3 2.5 可能的变化（Possible Change） 对于目标系统，将来可能会有哪些变化，需要在此描述。企业中的变化是永恒的，系统分析员需要描述哪些变化可能引起系统范围变更。 3．目标系统功能需求（Function of Target System） 3.1 功能需求分析（Function Analysis） 决策层、管理层、操作层各有哪些具体功能要求。 3.2 功能需求点列表（功能模型）（Function List）（Function Model） 在功能需求分析完成后，要详细列出用户需求功能点列表，提供给续设计、编程、测试中使用，更是为了用户测试验收中使用。需求功能点列表的格式，如表5-24所示。 表5-24 功能需求点列表 编号 功能名称 使用部门 使用岗位 功能描述 输入 系统响应 输出 1 2 3 4．目标系统性能需求（Performance of Target System） 4.1 时间要求（Time Request） 如： （1）响应时间，如查询的最长等待时间。 （2）更新处理时间，如记账的最长时间。 （3）数据的转换和传送时间，如远程数据传输的时间要求。 （4）解题时间。 4.2 空间性能（Space Request） 如： （1）支持的终端数。 （2）支持的并行操作的使用者数。 （3）处理的文件和记录数。 （4）表和文件的大小规模（要按可预见的增长，对数据及其分量的存储要求做出估算）。 （5）处理任务的数量。 （6）在正常情况下和峰值工作条件下，在一定时间周期中要处理的数据总数。 （7）对输入和输出数据的精度要求。 （8）对处理和传输过程中的精度要求。 4.3 性能需求点列表（性能模型）（Performance List）（Performance Model） 详细列出用户性能点列表，提供给后续分析、设计、编程、测试中使用，更是为了用户测试验收中使用。需求性能点列表的格式，如表5-25所示。 表5-25 性能需求点列表 编号 性能名称 使用部门 使用岗位 性能描述 输入 系统响应 输出 1 2 3 5．目标系统界面与接口需求（Interface of Target System） 5.1 界面需求（Interphase Requirement） 界面的原则要求，如方便、简洁、美观、一致等。整个系统的界面风格定义，某些功能模块的特殊的界面要求。 （1）输入设备：键盘、鼠标、条码扫描器、扫描仪等； （2）输出设备：显示器、打印机、光盘刻录机、磁带机、音箱等； （3）显示风格：图形界面、字符界面、IE界面等； （4）显示方式：1024×768、640×480等； （5）输出格式：显示布局、打印格式等。 5.2 接口需求点列表（接口模型）（Interface Requirement）（Interface Model） （1）与其他系统的接口，如监控系统、控制系统、银行结算系统、税控系统、财务系统、政府网络系统及其他系统等。 （2）与系统特殊外设的接口，如CT机、磁共振、柜员机（ATM）、IC卡、盘点机等。 （3）与中间件的接口，要列出接口规范、入口参数、出口参数、传输频率等。 应在此列举出所有的外部接口名称、接口标准、规范。外部接口列表，如表5-26所示。 表5-26 接口需求点列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 3 6．目标系统其他需求（Oher Requirement of Target System） 6.1 安全性（Security） 6.2 可靠性（Dependability） 6.3 灵活性（Agility） 6.4 特殊需求（Special Requirement） 如： （1）进度需求：系统的阶段进度要求。 （2）资金需求：投资额度。 （3）运行环境需求：平台、体系结构、设备要求。 （4）培训需求：用户对培训的需求，是否提供多媒体教学光盘。 （5）推广需求：推广的要求，如在上百个远程的部门推广该系统，是否要有推广的支持软件。 7．目标系统假设与约束条件（Suppose and Restriction ofTarget System） 假设与约定条件是对预计的系统风险的描述,如： （1）法律、法规和政策方面的限制。 （2）硬件、软件、运行环境和开发环境方面的条件和限制。 （3）可利用的信息和资源。 （4）系统投入使用的最晚时间。 （5）需求中的风险分析：技术风险、技能风险、时间风险、资源风险。 7《需求报告 / 需求规格说明书评审记录表》《用户需求报告 / 需求规格说明书评审记录表》 （Review Table of Requirements） 项目名称 项目经理 评审阶段 用户需求报告/需求规格说明书 第 次评审 评审组组长 评审时间 评审地点 评审组成员 不符合项跟踪记录（Check list of noncompliance items） 不符合项名称 不符合项内容 限期改正时间 实际改正时间 测试合格时间 测试员签字 审计员签字 评审意见 评审结论 ​ 评审组长签字： 评审组成员签字： 表5-28 《需求变更管理表》 （Modification Tableof Requirements） 项目名称 申请日期 用户名称 审批日期 变更原因 实际变更日期 原来需求 变更内容 审批意见 ​ 申请人： 审批人： 8“图书馆信息系统”“图书馆信息系统”数据模型设计案例 “图书馆信息系统”的概念数据模型CDM（见图6-10）和物理数据模型PDM（见图6-11）分析。 首先，介绍一下在E-R图中实体的表示法，如图6-10所示。一个矩形框表示一个实体，框内第一部分（第一行）的文字表示该实体的名称，如“图书”。第二部分表示该实体的多个属性，每个属性占一行，如“图书号、书名、单价、作者”等。带下划线的属性为主关键字，即主键PK（或主码），如“图书号”。两个实体之间的关系，用一条连线表示。关系有三种：一对一关系，就是一条连线；一对多关系，多的一端是一个三叉线（ERwin工具中为一个黑色小圆球）；多对多关系，两端都是三叉线。连线的一端若有一个小圆圈，则表示非强制型的关系；连线的一端若有一个小十字架，则表示强制型的关系。 图6-10 “图书馆信息系统”的概念数据模型CDM 系统的E-R图又称为系统的概念数据模型CDM，有了它以后，利用PowerDesigner工具，就能自动生成物理数据模型PDM。 首先分析“图书馆信息系统”的概念数据模型CDM，如图6-10所示。因为图书馆的主要功能不外乎两点，藏书与为读者服务。其他许多功能都是围绕这两项功能而展开的。所以“图书馆信息系统”的主要实体是“图书”和“读者”。 “图书”的属性有图书号、书名、作者、出版社、单价等，“读者”的属性有读者号、姓名、电话等。 由于一本图书可以被多个读者在不同时间借阅，一名读者又可以一次或多次借阅多本图书，所以该两个实体之间是多对多的关系。为了消除这个多对多关系，在两者之间插入第3个实体，该实体取名为“借还书”。“借还书”至少有两个属性：借书还书时间、借书还书标志。另外，它还有两个外键，图书号和读者号。当增加“借还书”这个实体之后，原来一个多对多的关系，现在变为两个一对多的关系：“图书”对“借还书”，“读者”对“借还书”。 “图书馆信息系统”中还有许多其他实体，它们都是围绕这3个主要实体及其关系而展开的。这3个实体是“图书馆信息系统”的核心。例如，“书库”和“单位”这两个实体，就是分别围绕“图书”和“读者”而展开的。“书库”表示图书存放在什么地方，以及该书是否借出，即该本书的架位号、架位地址，以及借出标志位的状态。由于一个架位号上可放多本书，所以“书库”和“图书”是一对多的关系。同样，“单位”表示读者在什么单位，即该读者的单位名称、单位地址和单位电话等，由于一个单位可有多个读者，所以“单位”和“读者”是一对多的关系。以上实体、属性、关系如图6-10所示。 图6-11 “图书馆信息系统”的物理数据模型PDM 再来分析“图书馆信息系统”的物理数据模型PDM，如图6-11所示。此PDM是由CDM生成的。不难发现：在生成PDM的过程中，凡是CDM中的一对多的关系，主表中的主键PK都自动拷贝到子表中去，作为子表的外键FK，这就是数据库设计工具PowerDesigner的一项功能。该PDM比较整齐规范，那是因为在生成之后进行了手工调整。 9《概要设计说明书》《概要设计说明书》编写参考指南 1．导言（Introduction） 本章对该文档的目的、功能范围、术语、相关文档、参考资料、版本更新进行说明。 1.1目的（Purpose） 本文档的目旨在推动软件工程的规范化，使设计人员遵循统一的概要设计书写规范，节省制作文档的时间，降低系统实现的风险，做到系统设计资料的规范性与全面性，以利于系统的实现、测试、维护、版本升级等。 1.2范围（Scope） 本文档用于软件设计阶段的概要设计，它的上游（依据的基线）是《需求分析规格书》，它的下游是《详细设计说明书》，并为《详细设计说明书》提供测试的依据。 软件概要设计的范围是：软件系统总体结构设计、全局数据库和数据结构设计、外部接口设计、主要部件功能分配设计、部件之间的接口设计等方面的内容。该范围应覆盖《需求规格说明书》中的功能点列表、性能点列表、接口列表。 1.3 命名规则（Naming Rule） 变量对象命名规则：申明全局变量、局部变量对象的命名规则。 数据库对象命名规则：申明数据库表名、字段名、索引名、视图名等对象的命名规则。 1.4 术语定义（Terms Glossary） 术语定义或解释一般用表格形式给出，如表6-5所示。 表6-5 术语定义或解释表 序 号 术 语 名 称 术 语 定 义 1 总体结构 软件系统的总体逻辑结构。按照不同的设计方法，有不同的总体逻辑结构。若采用面向功能或面向数据的设计方法，则总体逻辑结构为一树形的功能模块结构图。若采用面向对象或面向部件（构件）的设计方法，则总体逻辑结构为部件（构件）的组装图 2 外部接口 本软件系统与其他软件系统之间的接口，接口设施可以是中间件。接口描述包括：传输方式、带宽、数据结构、传输频率、传输量、传输协议 3 数据结构 数据结构包括：数据库表的结构、其他数据结构等 4 概念数据 模型CDM 关系数据库的逻辑设计模型，叫做概念数据模型。主要内容包括一张逻辑E-R图及其相应的数据字典 5 物理数据 模型PDM 关系数据库的物理设计模型，叫做物理数据模型。主要内容包括一张物理表关系图及其相应的数据字典 6 视图 在基表或其他视图之上建立的一张虚表，叫做视图，它具有物理表的许多性质，在数据处理和授权上很有用 7 角色 数据库中享有某些特权操作的用户，叫做角色。角色的权利通过授权来实现 8 子系统 具有相对独立功能的小系统叫做子系统。一个大的软件系统可以划分为多个子系统，每个子系统可由多个模块或多个部件组成 9 模块 具有功能独立、能被调用的信息单元叫做模块。模块是结构化设计中的概念 10 内部接口 软件系统内部各子系统之间、各部件之间、各模板之间的接口，叫做内部接口。接口描述包括：调用方式、入口信息、出口信息等 11 相关文件 相关文件是指当本文件内容变更后，可能引起变更的其他文件。如需求分析报告、详细设计说明书、测试计划、用户手册 12 参考资料 参考资料是指本文件书写时用到的其他资料。如各种有关规范、模板、标准、准则 1.5 参考资料（References） [1] 用户需求报告 [2] 软件开发合同 [3] 数据库设计规范 [4] 命名规范 1.6 相关文档（Related Documents） [1] 《详细设计说明书》 [2] 源程序清单 [3] 测试计划及报告 [4] 《用户使用手册》 1.7版本更新记录（Version UpdatedRecord） 版本更新记录格式，如表6-6所示。 表6-6 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/02/18 — — — V1.0.1 — — 王小林 2001/02/26 E-R图维护 2．总体设计（Design ofCollective） 2.1 总体结构设计（Design ofCollective Structure） 软件系统的总体逻辑结构，按照不同的设计方法，有不同的总体逻辑结构。本指南以结构化设计方法为主，画出系统总体结构图，列出系统的功能模块清单编号、名称、功能，并尽可能描绘出功能模块之间的关系。若用面向对象的Rose工具进行分析和设计，则遵照Rose的要求进行。 总体结构示意图 ， 如图 6-13 所示。 图6-13 总体结构示意图 2.2 运行环境设计（Design of RunningEnvironment） 该软件系统的运行环境： 硬件平台： （1）服务器的最低配置要求 （2）工作站的最低配置要求 （3）外设的要求 软件平台： （1）服务器操作系统 （2）数据库管理系统 （3）中间件 （4）客户端的操作系统 （5）客户端的平台软件 网络平台： （1）通信协议 （2）通信带宽 2.3 子系统清单（Subsystem List） 子系统清单，如表6-7所示。 表6-7 子系统清单 子系统编号 子系统英文名 子系统功能简述 子系统之间的关系 SS1 SS2 SS3 2.4 功能模块清单（Function ModuleList） 功能模块清单，如表6-8所示。 表6-8 功能模块清单 模 块 编 号 模块英文名 模块功能简述 模块的接口简述 M 1-1 M 1-2 M 2-1 M 2-2 3．模块（部件）功能分配（FunctionalDistribution of Module） 具有功能独立、能被调用的信息单元叫做模块。模块是结构化设计中的概念，部件是面向对象设计中的概念。 模块功能分配的目的，就是为了将具有相同功能的模块合并，从中提取公用模块，形成公用部件，按照构件或中间件的方式加以实现，作为本系统的公用资源，甚至作为公司级组织的公用资源，从而充实公司级的构件库或中间件库，优化系统设计，加快开发速度，提高开发质量。 3.1 专用模块功能分配（FunctionalDistribution of Expert Module） 专用模块功能分配，如表6-9所示。 表6-9 专用模块功能分配 专用模块编号 模块英文名 模块详细功能分配 模块的接口标准 M1-1 M1-2 M2-1 M2-2 3.2 公用模块功能分配（FunctionDistribute of Public Module） 公用模块功能分，如表6-10所示。 表6-10 公用模块功能分配 公用模块编号 模块英文名 模块详细功能分配 模块的接口标准 G-1 G-2 G-3 4．数据结构设计（Design of Data Structure） 数据库设计的工具目前主要有3个：ERwin，PowerDesigner，OracleDesigner。后面两种工具都支持中文的概念数据模型设计，并能自动将概念数据模型转换为物理数据模型，自动生成建表程序和主键索引程序。前面一种工具只能支持英文的物理数据模型设计。3个工具的共同特点是都能生成E-R图及其相应的数据字典。 4.1 数据库表名清单（DB Table List） 数据库表名清单，如表6-11所示。 表6-11 数据库表名清单 序号 中文表名 英文表名 表功能说明 1 2 3 4.2 数据库表之间关系说明（Relation of DBTable） 可以用E-R图表示，也可以用文字说明。 4.3 数据库表的详细清单（Particular List ofDB Table） 每个表的详细清单内容包括：表名、字段中文名、字段英文名、字段的类型、宽度、精度、主键/外键、空否、取值约束（默认值、最大值、最小值）、索引否。同时要指出该表的索引：索引文件名、索引字段名、索引特性（主键索引、惟一索引unique、聚集索引clustered）。详细清单可以用列表给出，如表6-12所示。 表6-12 表名：XXXX 序号 字段中文名 字段英文名 类型、宽度、精度 取值约束 空否 默认值 主键/外键 索引否 1 2 3 4.4 视图设计（View Design） 视图设计与授权有关，设计时参照需求文档的用户授权范围。视图设计中要给出视图的中文名、英文名，视图中的中文列名、英文列名、类型、宽度、精度，每一列的具体算法，对应的基本表名。 4.5 其他数据结构设计（Design of OtherData Structure） 此小节描述系统的其他数据结构设计内容。 5．接口设计（Interface Design） 对应每一个接口，都要详细列出下列内容。 （1）接口名称 （2）接口内容 （3）接口设施 （4）接口的数据结构 （5）接口的传输速率（Mbps） （6）接口带宽 （7）接口协议 6．其他设计（Other Design） 本章描述前面没有说明的设计。 7．设计检查列表（Check-up List of Design） 按照需求文档的功能、性能和接口3个列表，设计出概要设计检查列表，以检查概要设计是否覆盖需求分析，没有覆盖就是不符合项，并将检查结果列出。 7.1 功能设计检查列表（Check-up List of Function Design） 功能设计检查列表，如表6-13所示。 表6-13 功能设计检查列表 编号 功能名称 使用部门 使用岗位 功能描述 输入内容 系统响应 输出内容 是否覆盖 1 2 3 7.2 性能设计检查列表（Check-up List of Performance Design） 性能设计检查列表，如表6-14所示。 表6-14 性能设计检查列表 编号 性能名称 使用部门 使用岗位 性能描述 输入内容 系统响应 输出内容 是否覆盖 1 2 3 7.3 接口设计检查列表（Check-up List of Interface Design） 接口设计检查列表，如表6-15所示。 表6-15 接口设计检查列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 是否覆盖 1 2 3 10《详细设计说明书》《详细设计说明书》编写参考指南 1．导言（Introduction） 本章对该文档的目的、功能范围、术语、相关文档、参考资料、版本更新进行说明。 1.1 目的（Purpose） 本文档的目旨在推动软件工程的规范化，使设计人员遵循统一的详细设计书写规范，节省制作文档的时间，降低系统实现的风险，做到系统设计资料的规范性与全面性，以利于系统的实现、测试、维护、版本升级等。详细设计的详细程度，应达到可以编写程序的程度。 1.2 范围（Scope） 本文档用于软件设计阶段的详细设计，它的上游（依据的基线）是《概要设计说明书》，它的下游是源程序清单及单元测试计划，并为单元测试报告提供测试依据。该范围应覆盖《概要设计说明书》中的功能点列表、性能点列表、接口列表。 软件详细设计的范围是：各子系统的公用模块实现设计、专用模块实现设计、存储过程实现设计、触发器实现设计、外部接口实现设计、部门角色授权设计、其他详细设计等。 按照3层结构（B/A/S）的布局，详细设计应从下面3个方面进行。数据库服务器上的面向数据的设计：数据字典物理设计、基本表物理设计、中间表物理设计（报表设计）、临时表物理设计、视图物理设计、存储过程物理设计、触发器物理设计。应用服务器上的面向业务逻辑的设计：接口数据设计、中间件设计、数据通信传输设计、可视构件设计、非可视构件设计、角色授权设计、功能点设计（功能点列表设计）。浏览器上的面向对象的设计：录入修改界面设计、浏览查询界面设计、登录注册界面设计、信息发布界面设计。 1.3 术语定义（Terms Glossary） 术语定义，如表6-16所示。 表6-16 术语定义 序号 术语名称 术 语 定 义 1 详细设计 在概要设计的基础上，对其功能模块或部件进行实现设计，使编程人员据此能顺利书写出程序代码 2 存储过程 存放在数据库服务器上的一段程序，它能被其他程序调用，以完成对数据库表的某些规定操作 3 触发器 存放在数据库服务器上的一段程序，当触发条件满足时它就被执行，以完成对数据库表的某些规定操作 4 算法 详细设计中实现某项功能的数据处理方法及处理流程 1.4 参考资料（References） [1] 《概要设计说明书》 [2] 《需求分析说明书》 [3] 《软件合同》 [4] 命名规范 [5] 程序设计规范 [6] 界面设计规范 1.5 相关文档（Related Documents） [1] 源程序清单 [2] 单元测试计划及报告 [3] 《用户使用手册》 1.6 版本更新记录（Version UpdatedRcord） 版本更新记录，如表6-17所示。 表6-17 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/0318 — — — V1.0.1 — — 王小林 2001/03/26 报表4格式维护 2．模块实现设计（Implemental Design of Module） 功能模块包括：登录注册模块、信息发布模块、菜单模块、录入修改模块、查询统计模块、数据处理模块、报表输出模块、前台网站模块、后台处理模块、数据传输与接收模块等等。详细设计是面向模块的，或者说是面向部件（或构件）的，不是面向组织结构或部门单位的。一个组织或单位，根据角色的授权，可以挂上某些功能模块。若为C/S或B/A/S结构，则要说明该模块运行在哪一层上。 2.1 公用模块设计（Design of Public Module） 公用模块的提取与设计特别重要，设计它的目的是为了复用，因此它直接影响到系统的详细设计、编程、运行的质量。每个公用模块的设计要包括如下内容： （1）模块编号：按照命名规则，如：G-XXX，将此公用模块编号写上。 （2）模块名称：此公用模块的英文名。 （3）模块功能：详细列出此公用模块的所有功能。 （4）模块背景描述：对背景进行简单的描述。为什么需要此模块功能，其上下文环境。涉及业务背景内容，与需求相结合。 （5）模块算法设计：用伪语言（例如，if…endif，case…endcase， do…enddo，…）详细描述出此公用模块的算法，标准是使程序人员据此能顺利地书写程序。 （6）模块调用方法：详细列出调用的方式、入口参数、出口参数、异常处理。 （7）模块编写者：编写者姓名。 （8）模块编写日期：编写日期：yyyy/mm/dd。 （9）模块修订者：修订者姓名。 （10）模块修订日期：修订日期：yyyy/mm/dd。 （11）模块测试者：测试者姓名。 （12）模块测试日期：测试日期：yyyy/mm/dd。 2.2 专用模块设计（Design of Expert Module） 非公用模块是为了处理一些特殊需求，它不可复用，每个非公用模块设计包括如下内容： （1）模块编号：按照命名规则，如：M1-XXX，将此专用模块编号写上。 （2）模块名称：此模块的中文名。 （3）模块功能：详细列出此模块的所有功能。 （4）模块背景描述：对背景进行简单的描述。为什么需要此模块功能，其上下文环境。涉及业务背景内容，与需求相结合。 （5）模块算法设计：用伪语言（例如，if…endif，case…endcase， do…enddo，…）详细描述出此专用模块的算法，标准是使程序人员据此能顺利地书写程序。 （6）模块编写者：编写者姓名。 （7）模块编写日期：编写日期：yyyy/mm/dd。 （8）模块修订者：修订者姓名。 （9）模块修订日期：修订日期：yyyy/mm/dd。 （10）模块测试者：测试者姓名。 （11）模块测试日期：测试日期：yyyy/mm/dd。 2.3 存储过程设计（Design of Storage Process） 存储过程是一种特殊的公用模块，它在数据库服务器上执行，这里将它单独列出来，规定其详细设计模板为： （1）存储过程中文名：此存储过程的中文名。 （2）存储过程英文名：此存储过程的英文名。 （3）存储过程功能: 详细描述其功能。 （4）存储过程算法: 用伪语言详细描述其算法，使编程人员据此能顺利书写程序。 （5）存储过程调用方式：详细列出调用的方式、入口参数、出口参数、异常处理。 （6）模块编写者：编写者姓名。 （7）模块编写日期：编写日期：yyyy/mm/dd。 （8）模块修订者：修订者姓名。 （9）模块修订日期：修订日期：yyyy/mm/dd。 （10）模块测试者：测试者姓名。 （11）模块测试日期：测试日期：yyyy/mm/dd。 2.4 触发器设计（Design of Trigger） 触发器也是一种公用模块，不过它是隐式执行，这里将它单独列出来，规定其详细设计模板为： （1）触发器中文名：此触发器的中文名。 （2）触发器英文名：此触发器的英文名。 （3）触发器功能：详细描述其功能。 （4）触发器算法：用伪语言详细描述其算法，使编程人员据此能顺利书写程序。 （5）触发器激活条件：详细描述其激活条件，使编辑人员据此能顺利书写程序。 （6）触发器编写者：编写者姓名。 （7）触发器编写日期：编写日期：yyyy/mm/dd。 （8）触发器修订者：修订者姓名。 （9）触发器修订日期：修订日期：yyyy/mm/dd。 （10）触发器测试者：测试者姓名。 （11）触发器测试日期：测试日期：yyyy/mm/dd。 注意：过多地使用触发器反而会使系统的效率降低。因此，凡是能用存储过程代替触发器功能的地方，一律用存储过程来实现。 3. 接口实现设计（Implemental Design ofInterface） 每个外部接口实现模块的设计要包括如下内容： （1）接口中文名称：此接口的中文名。 （2）接口英文名称：此接口的英文名。 （3）接口内容与功能：详细描述接口的内容与功能，如实现数据传输或数据交换。 （4）接口硬件设施：详细描述接口的硬件设施，如交换机、传感器或输出设备。 （5）接口软件或中间件：详细描述接口软件或中间件的名称、功能、使用方法、生产厂商。 （6）接口的数据结构：详细描述接口的数据结构，如文件结构、数据库表结构。 （7）接口的传输速率（Mbps）：定量说明每秒最大流量。 （8）接口带宽：定量说明带宽，如XXMbps。 （9）接口协议：说明具体协议。 （10）接口程序的算法：用伪语言详细描述其算法，使编码人员据此能顺利书写程序。 （11）接口编写者：编写者姓名。 （12）接口编写日期：编写日期：yyyy/mm/dd。 （13）接口修订者：修订者姓名。 （14）接口修订日期：修订日期：yyyy/mm/dd。 （15）接口测试者：测试者姓名。 （16）接口测试日期：测试日期：yyyy/mm/dd。 4．其他实现设计（Other Implemental Designs） 本章描述前面没有说明的设计。如部门角色授权设计、界面设计、包装设计、维护设计等。 4.1 角色授权设计（Accredited Designof Role） 授权表的横坐标表示角色（部件、单位或岗位），纵坐标表示功能模块，“●”表示授权。该授权表是工作站上菜单设计的依据，如表6-18所示。 表6-18 角色授权设计 模块名 角色1 角色2 角色3 角色4 角色5 模块英文名1 ● 模块英文名2 ● ● 模块英文名3 ● ● ● 模块英文名4 ● ● 模块英文名5 ● ● ● 模块英文名6 ● ● 模块英文名7 ● 模块英文名8 ● ● … ● ● 4.2 其他详细设计（Other ParticularDesigns） 根据需要进行设计。如界面设计、包装设计、维护设计等。 5．详细设计检查列表（Check-up List of Design） 按照概要设计文档的功能、性能和接口3个列表，设计出详细设计检查列表，以检查详细设计是否覆盖概要，没有覆盖就是不符合项，并将检查结果列出。 5.1 功能设计检查列表（Check-up List of Function Design） 功能设计检查列表，如表6-19所示。 表6-19 功能设计检查列表 编号 功能名称 使用部门 使用岗位 功能描述 输入内容 系统响应 输出内容 是否实现 1 2 3 5.2 性能设计检查列表（Check-up List of Performance Design） 性能设计检查列表，如表6-20所示。 表6-20 性能设计检查列表 编号 性能名称 使用部门 使用岗位 性能描述 输入内容 系统响应 输出内容 是否实现 1 2 3 5.3 接口设计检查列表（Check-up List of Interface Design） 接口设计检查列表，如表6-21所示。 表6-21 接口设计检查列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 是否实现 1 2 3 《概要设计说明书/详细设计说明书评审记录表》 （Review Table ofDesign） 项目名称 项目经理 评审阶段 概要设计说明书/详细设计说明书 第 次评审 评审组组长 评审时间 评审地点 评审组成员 不符合项跟踪记录 不符合项名称 不符合项内容 限期改正时间 实际改正时间 测试合格时间 测试员签字 审计员签字 评审意见 评审结论 评审组长签字： 评审组成员签字： 11《用户使用手册》《用户使用手册》编写参考指南 1．前言(Preface) 提供手册的概述，在此可以说明编写这份手册的目的、指明本手册的读者。 1.1 内容简介(Introduction) 简单地介绍编写背景，系统适用的用户。 1.2 基本概念(Basic Concept) 说明定义的术语在本手册中的含义。 1.3 主要功能(Mostly Function) 对系统进行简单讲解和功能介绍。 1.4 操作流程(Operate Flow) 操作流程说明。全面模拟用户操作，从安装、进入、初始化、到用户具体操作，对整个流程进行描述。 1.5 步骤说明(Step Show) 针对操作流程的每一步进行说明。如果在使用说明中有相应的解释，应指明用户查找的位置。 2．功能(Function) 这部分包括用户使用的所有功能，是用户使用手册的最重要的部分，要详细描述。 2.1 使用流程(Use Flow) 描述具体功能的使用顺序。如果功能之中有分类，比如，有些功能用户用不到，有些用得到，就要分开写流程。 2.2 具体描述(Description) 描述顺序是按照使用流程的每一步进行的。 2.3 进行此功能的业务介绍(Operation Introduce) 对此功能进行简单介绍，说明所能完成的功能。 2.4 操作步骤(Handle Step) 用鼠标选择相应的功能，进入相应的界面，进行功能键以及栏目的介绍。 2.5 举例(Example) 针对某一功能，对于一些比较难的问题，应该进行举例说明。 2.6 特殊提示及注意事项(Prompt and Notice) 在使用说明中，每一部分都会归纳一些问题，需要提示用户或者让用户注意，应按照以下规定的格式进行编写：字体采用仿宋字，字号采用小五号字。 3．附录(Appendix) 对一些在正文中描述不够详尽的地方，可在附录中进行补充；用户经常遇到的问题及问题解答也可放在附录中。 12《用户安装手册》《用户安装手册》编写参考指南 1．前言(Preface) 指明编制该手册的目的和预期的读者，简介该系统的运行环境：操作系统OS，数据库系统DBMS，C/S二层结构或B/A/S三层结构，界面特点，以及技术特色。 1.1 内容简介(Introduction) 介绍本书提供的几个部分：简单介绍大概内容。 1.2 使用约定(Use Assumpsit) 提示：安装过程的一些好的方法。 注意：安装过程中特殊注意的地方。 警告：指出危险动作或状态，否则，会对您的安装造成破坏。 2．单机版的安装及配置(Installation and Configuration for PC) 2.1 运行环境(Run Environment) （1）硬件环境：列出运行本系统所要求的硬设备的最小配置。微机要求包括型号、内存、硬盘，显示器要求，以及一些其他的I/O设备。 （2）软件环境：列出运行本系统所需要的支持软件。如操作系统，程序语言以及数据库管理系统。 2.2 安装单机版(Installation for PC) （1）简单介绍单机版打包光盘的定义和内容。 （2）介绍该系统单机版的安装步骤。 2.3 安装后的系统配置(Configuration After Installation) 介绍系统安装之后，查看该系统配置信息的情况，以确定是否需要改动，是否是最优配置。 另外，运行系统的时候，有时会出现数据库联接不成功。在这部分应介绍会有哪几种可能的原因，并分别简述。 3．网络版的安装及配置(Installation and Configuration for Network) 3.1 运行环境(Run Environment) 除了对硬件环境提出要求外，对软件环境的要求应列出运行本系统所需的操作系统、与操作系统兼容的网络环境、程序语言以及数据库管理系统。 另外，还应简单介绍一下安装网络和数据库所需注意事项和可参考的工具书。 3.2 安装网络版(Installation for Network) 介绍该系统网络版的安装步骤。 如何进行系统环境配置。 数据库的默认用户及口令等。 3.3 安装后的系统配置(Configurationafter Installation) 4．附录(Appendix) 附录1 安装过程提供的技术支持。说明技术支持的几种方式，及常见安装疑难问题解答。 附录2 参考资料，应写上书名、版本号、作者、出版社、出版日期。 13《测试报告》《测试报告》编写参考指南 概述(Summary) 1.1 项目简介(Project Synopsis) 在本章节中简介项目的基本情况。 1.2 术语定义(Terms Glossary) 将该测试报告中的术语、缩写进行定义, 包括用户应用领域与计算机领域的术语与缩写等。 1.3 参考资料(References) 说明该测试报告使用的参考资料，如： [1]《商务合同》 [2]《用户需求报告》 [3]《需求规格说明书》 1.4 版本更新信息(Version Updated Record) 版本更新记录格式，如表9-3所示。 表9-3 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2002/02/18 — — — V1.0.1 — — 王小林 2002/02/26 不符合项测试 目标系统功能需求(Function of Target System) 由《用户需求报告》/《需求规格说明书》拷贝到的功能需求点列表，如表9-4所示。 表9-4 功能需求点列表 编号 功能名称 使用部门 使用岗位 功能描述 输入内容 输出内容 1 2 3 目标系统性能需求(Performance of Target System) 由《用户需求报告》/《需求规格说明书》拷贝到的需求性能点列表，如表9-5所示。 表9-5 性能需求点列表 编号 性能名称 使用部门 使用岗位 性能描述 输入内容 输出内容 1 2 3 目标系统接口需求(Interface of Target System) 由《用户需求报告》/《需求规格说明书》拷贝到的接口列表，如表9-6所示。 表9-6 外部接口需求点列表 编号 接口名称 接口规范 接口标准 入口参数 出口参数 传输频率 1 2 3 功能测试报告(Report forFunction Test) 搭建功能测试平台，使测试平台与运行平台一致。按照功能点列表内容，设计测试用例（输入/输出内容），进行现场测试，记录测试数据，评定测试结果。测试活动的记录格式，如表9-7所示。 表9-7 功能测试记录 编号 功能名称 功能描述 用例输入内容 用例输出内容 发现问题 测试结果 测试时间 测试人 1 √ 2 √ 3 √ 4 × 性能测试报告(Rreport forPerformance Test) 搭建性能测试平台，使测试平台与运行平台一致。按照性能点列表内容，设计测试用例（输入/输出内容），进行现场测试，记录测试数据，评定测试结果。测试活动的记录，如表9-8所示。 表9-8 性能测试记录 编号 性能名称 性能描述 用例输入内容 用例输出内容 发现问题 测试结果 测试时间 测试人 1 √ 2 √ 3 × 4 √ 7. 接口测试报告(Report forInterface Test) 搭建接口测试平台，使测试平台与运行平台一致。按照接口列表内容，设计测试用例(输入/输出内容)，进行现场测试，记录测试数据，评定测试结果。测试活动的记录，如表9-9所示。 表9-9 接口测试记录 编号 接口名称 入口参数 出口参数 传输频率 发现问题 测试结果 测试时间 测试人 1 × 2 √ 3 √ 不符合项列表(Check List of Noncompliance Items) 将测试中的所有不符合项(Bug项)，整理后分别记录到表9-10、表9-11和表9-12中。 表9-10 功能测试不符合项列表 编号 功能名称 功能描述 用例输入内容 用例输出内容 发现问题 测试结果 测试时间 测试人 1 × 2 × 3 × 4 × 表9-11 性能测试不符合项列表 编号 性能名称 性能描述 用例输入内容 用例输出内容 发现问题 测试结果 测试时间 测试人 1 × 2 × 3 × 4 × 表9-12 接口测试不符合项列表 编号 接口名称 入口参数 出口参数 传输频率 发现问题 测试结果 测试时间 测试人 1 × 2 × 3 × 以上不符合项，限期XX天内改正。改正完毕后重新进行回归测试。 9. 测试结论(Test Verdict) 当测试完成之后，测试组应对本次测试做出结论。格式如下： 测试日期： 测试地点： 测试环境： 参与测试的人员： 列出系统的强项： 列出系统的弱项： 列出不符合项的统计结果： 测试组组长签字： 测试组成员签字： 14软件质量保证关键过程域SQACMM2中“软件质量保证”关键过程域SQA详细说明文档 Software Quality Assurance (a key process area for Level2：Repeatable) 软件质量保证的目的，是向管理者提供软件项目正在使用的过程和正在构造的产品的可视性。 软件质量保证包括评审和审计软件产品及活动，以验证它们符合相应的规程和标准，给项目经理和其他有关经理提供评审和审计结果。 在软件项目的早期阶段，软件质量保证组与软件项目一起工作，制定计划、标准和规程等。这些计划、标准和规程，将增加软件项目的价值，并将满足项目和组织方针上的要求。通过参与制定计划、标准和规程，软件质量保证组帮助确保这些计划、标准和规程适合项目的需要，并且帮助验证这些计划、标准和规程对完成整个软件生存周期中的评审和审计将是适用的。软件质量保证组在整个生存周期内评审项目活动，审计软件工作产品，并就软件项目是否遵守已制定的计划、标准和规程等，为管理者提供可视性。 首先，在软件项目内部处理符合性问题，如可能的话就解决它。对于那些无法在软件项目组内部解决的问题，软件质量保证组逐级上递该问题到恰当层次的管理者那里以求解决。 这个关键过程域，只包括该组履行软件质量保证功能的实践。而识别软件质量保证组要评审和审计的具体活动和工作产品的实践，一般包含在其他关键过程域的验证实施共同特性之中。 （作者注：为了实现软件质量保证的目的，CMM规定了该KPA有“4个目标、1项约定、4项能力、8项活动、1项测量、3项验证”，该KPA的17个关键实践KP，就分布在“执行约定、执行能力、执行活动、测量和分析、验证实施”之中，具体内容简述如下。） 目标（Goals） 目标1：软件质量保证活动是有计划的。 目标2：软件产品和活动遵守适用的标准、规程和需求，能得到客观验证。 目标3：受影响的组和个人接到了软件质量保证活动和结果的通知。 目标4：高级管理者处理在软件项目内部不能解决的不符合问题。 执行约定（Commitment to Perform，CO） 约定1：项目遵守书面的实施软件质量保证(SQA)的组织方针。 该方针一般规定： 1．对全部软件项目，SQA功能到位； 2．SQA有一个向高级管理者报告质量问题的独立渠道，它独立于： ——项目经理 ——项目软件工程组 ——其他软件有关组 其他软件有关组的例子有： ──软件配置管理组 ──文档支持组 组织必须确定一种组织机构，它在组织的战略经营目标和经营环境中，支持那些引发独立性要求的活动，例如SQA。 独立性应该表现在： ──给担当SQA角色的个人提供组织上的自由度，使它们成为高级管理者在软件项目中的“耳目”。 ──使担当SQA角色的个人，免受管理者对他们正在评审的软件项目的所做的性能评价的影响。 ──使高级管理者相信，正在报告的有关项目过程和产品的信息是客观的。 3．高级管理者定期评审SQA活动和结果。 执行能力（Ability to Perform，AB） 能力1：存在负责协调和实施项目的SQA组（即SQA组）。 一个组是负责一组作业或活动的部门、经理和个人的集合。组的规模可以变化，可以包括一个受指派的非全日制的单个个人，也可以包括几个从不同部门指派来的非全日制的个人或几个全日制的个人。建立一个组时，应考察的因素包括指派的作业和活动、项目的规模、组织机构和组织文化。某些组，例如，软件质量保证组，集中注意力于项目活动；而其他组，例如，软件工程过程组，则集中关注全组织的活动。 能力2：为进行SQA活动提供足够的资源和投资。 1．指派一个经理，专门负责项目的SQA活动。 2．指派一个在SQA方面博学的、并有权采取监督行动的高级经理，接受和处理软件不符合问题。 ——在SQA中，处在向高级经理报告链上的全部经理，均是在SQA的任务、责任和权利方面富有独到见解、富于智慧和决策能力的管理者。 3．保证支持SQA活动的工具好用。 支持工具的例子有： ──工作站 ──数据库程序 ──电子表格程序 ──审计工具 能力3：SQA组的成员要接受培训，以利于完成他们的SQA活动。 培训的例子有： ──软件工程技巧和实践 ──软件工程组和其他软件有关组的岗位及职责 ──用于软件工程的标准、规程和方法 ──软件项目的应用领域 ──SQA的对象、规程和方法 ──SQA组对软件活动的参与 ──SQA方法和工具的有效使用 ──人员间的交流 能力4：软件项目的成员接受有关SQA组的任务、职责、权利和价值的定向培训。 执行活动（Activities Performed，AC） 活动1：按照已建档的规程为软件项目制定SQA计划。 该规程一般规定： 1．SQA计划的制定是在项目策划的早期阶段，平行于整个项目策划。 2．受影响的组和个人评审该SQA计划。 受影响的组和个人的例子有： ──项目软件经理 ──其他软件经理 ──项目经理 ──顾客的SQA代表 ──SQA组负责解决其报告不符合问题的高级经理 ──软件工程组（包括全部小组，如软件设计小组及软件作业领导） 3．对计划进行管理和控制。 “管理和控制”意味着，在给定时间（过去或现在）内使用的工作产品的版本是已知的（即版本控制），而且以受控的方式引进更改（即更改控制）。 如果希望有比“管理和控制”更高程度的控制，则工作产品可置于配置管理的完备规范之下，正如在“软件配置管理”关键过程域中所描述的。 活动2：按照SQA计划进行SQA组的活动。 该计划包括： 1．SQA组的职责和权利 2．SQA组的资源要求（包括员工、工具和设施） 3．SQA组活动的进度表和投资 4．SQA组参加制定项目的软件开发计划、标准和规程的情况 5．确定将由SQA完成的评价 待评价的产品和活动的例子有： ──运行软件和支持软件 ──可交付的和不可交付的产品 ──软件和非软件产品（例如，文档） ──产品开发和产品验证活动（例如，运行测试用例） ──生成产品时所从事的活动 6．将由SQA组进行的审计和评审。 7．将用做SQA组评审和审计基础的标准和规程。 8．用于对不符合性问题建立文档和进行跟踪直至结束的规程。 这些规程可以作为计划的一部分而纳入计划，也可以通过对包含它们的其他文档进行索引的方式而纳入计划。 9．要求SQA组生成的文档。 10．就SQA活动给软件工程组和其他相关组提供反馈信息的方法和频率。 活动3：SQA组参与准备和评审项目的软件开发计划、标准和规程。 1．SQA就以下几个方面对计划、标准和规程提供咨询和评审： ——对组织方针的符合性 ——对外部强加的标准和要求的符合性（例如，工作陈述所要求的标准） ——适合项目使用的标准 ——在软件开发计划中应阐述的专题 ——项目指定的其他领域 2．SQA组验证计划、标准和规程已到位，并可用于评审与审计软件项目。 活动4：SQA组评审软件工程活动，以验证符合性。 1．用软件开发计划和指定的软件标准及规程，进行评价活动。 参考其他关键过程域中的验证实施共同特性，以便找到包括由SQA组进行特定评审和审计的实践。 2．对偏差进行鉴别和建立文档，并跟踪到结束。 3．验证纠正措施。 活动5：SQA组审计指定的软件工作产品，以验证其符合性。 1．在交付给顾客之前，评价可交付的软件产品。 2．对照指定的软件标准、规程和合同要求，评价软件工作产品。 3．对偏差进行鉴别和建立文档，并跟踪到结束。 4．验证纠正措施。 活动6：SQA组定期向软件工程组报告其活动的结果。 活动7：按照已文档化的规程，对软件活动和软件工作产品中所鉴别出的偏差，建立文档并加以处理。 该规程一般规定： 1．将不符合软件开发计划和指定的项目标准及规程的问题写成文档，并在可能处，与有关的软件作业领导、软件经理或项目经理，一起加以解决。 2．有些不符合软件开发计划和指定标准及规程的问题，不能与软件作业领导、软件经理或项目经理一起加以解决，将这些不符合问题写成文档，并提交给指定的接收不符合问题的高级经理。 3．定期评审提交给高级经理的不符合问题，直至解决它们为止。 4．对不符合问题的文档进行管理和控制。 活动8：SQA组和顾客的SQA人员一起，适时地对软件质量保证的活动和发现进行定期评审。 测量与分析（Measurement and Analysis，ME） 测量1：进行测量，并将测量结果用于确定SQA活动的成本和进度状态。 测量的例子有： ──SQA活动的里程碑完成的情况与计划做比较。 ──在SQA活动中完成的工作、所花费的工作量、所消耗的资金与计划做比较。 ──产品审计和活动评审的次数与计划做比较。 验证实施（Verifying Implementation，VE） 验证1：高级管理者定期参与评审SQA活动。 高级管理者定期评审的主要目的，是在合适的抽象层次上，及时地了解和洞察软件过程活动。评审间隔应满足组织的需求，只要已有报告例外情况的合适机制许可，间隔可以长些。 参考“软件项目跟踪和监督”关键过程域的验证1，以便找到包括高级管理者监督评审典型内容的实践。 验证2：项目经理定期地、按事件驱动方式参与评审SQA活动。 参考“软件项目跟踪和监督”关键过程域的验证2，以便找到包括项目管理者监督评审典型内容的实践。 验证3：独立于SQA组的专家，定期评审SQA组的活动和软件工作产品。 15《CMM软件质量保证过程文件》《CMM软件质量保证过程文件》编写参考指南 1．引言(Introduction) 1.1 目的(Purpose) 本文档是软件质量保证过程的定义，它规定了角色、进入准则、输入、活动、输出、结束准则等。 1.2 范围(Scope) 本文档只适应于软件质量保证过程。 1.3 术语定义(Terms Glossary) [1] 软件相关组：指软件配置管理组、文档支持组、测试组。 [2] 软件质量保证组：指计划和实施软件质量保证活动的人员的集合。 1.4 参考资料(References) [1] Mark C. Paulk等人，《The Capability Maturity Model Guidelines forimproving the software process》，Carnegie Mellon University Software Engineering Institute [2] Mark C. Paulk，《Key practices of the Capability Maturity Model》，Version 1.1，1993 1.5 相关文档(Related Documents) [1] 《软件质量保证程序文件》 1.6 版本更新记录(Version Updated Record) 版本更新记录，如表12-8所示。 表12-8 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2002/03/03 — — — V1.0.1 — — 王小林 2002/03/16 进入准则维护 2．软件质量保证过程(SQA Process) ──参与角色(Roles) R1：软件质量保证组。 R2：项目经理。 R3：软件工程组代表。 R4：软件相关组代表。 R5：高级经理。 ──进入准则(Entry Criteria) E1：软件项目立项报告或下达任务书。 E2：组织的责任人到位，且经过软件质量保证过程的培训。 ──输入(Inputs) I1：《立项建议书》或《项目合同》。 I2：《软件开发计划》。 ──活动(Activities) A1：SQA组成员与项目经理共同选定开发过程中的标准和规范，并参与《软件开发计划》的评审。 A2：SQA成员按软件质量保证程序文件编制《SQA计划》，并经过相关组及个人的评审。 A3：SQA成员按《SQA计划》/《软件开发计划》，参与软件项目的定期或事件驱动的评审与审计活动。 A4：SQA组对审计出的不符合项，按程序文件进行跟踪处理。 A5：SQA组按程序文件，及时向相关组及个人报告其活动结果。 A6：负责软件质量保证的高级经理，处理软件项目内部不能解决的不符合项。 ──输出(Outputs) O1：软件质量保证计划。 O2：软件工程活动评审报告。 O3：软件工作产品审计报告。 O4：不符合项跟踪报告。 ──结束准则(Finish Criteria) F1：软件项目终止。 ──评审与审计(Reviews andAudits) RA1：SQA主管定期参与评审SQA活动。 RA2：项目经理定期或并事件驱动地参与评审SQA活动。 ──测量(Measurements) M1：SQA组成员按程序文件记录SQA活动实际投入的资源、工作量、进度等数据。 ──培训(Training) T1：对SQA组成员进行SQA知识定向培训。 T2：对非SQA组成员，进行软件工程知识定向培训。 ──工具(Tools) T1：MS Word。 T2：MS Project。 16《CMM软件质量保证程序文件》《CMM软件质量保证程序文件》编写参考指南 1．引言(Introduction) 1.1 目的(Purpose) 本文档是《软件质量保证过程文件》的补充文件，它规定了《软件质量保证过程文件》中的工作产品定义和执行步骤。 1.2 范围(Scope) 本文档规定了软件质量保证活动的工作产品及其执行步骤。 1.3 术语定义(Terms Glossary) [1] 工作产品，是指软件生存周期各个阶段所产生的文档化的阶段成果，它包括开发文档、管理文档及软件产品。如软件开发计划、概要设计说明书、源程序等。 1.4 参考资料(References) [1] Mark C. Paulk等人，《The Capability Maturity Model Guidelines forimproving the software process》，Carnegie Mellon University Software Engineering Institute [2] Mark C. Paulk，《Key practices of the Capability Maturity Model》，Version 1.1，1993 1.5 相关文档(Related Documents) [1] 《软件质量保证过程文件》 1.6 版本更新记录(Version Updated Record) 版本更新记录，如表12-9所示。 表12-9 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2002/03/09 — — — V1.0.1 — — 王小林 2002/03/26 术语定义维护 2．软件质量保证过程(SQA Process) 2.1 软件质量保证策划程序(SQA Planning) ──工作产品(Work Product) W1：SQA计划。 W2：SQA计划评审报告。 ──执行步骤(Execute Step) E1：SQA组为软件项目指派SQA成员，并确定其岗位职责。 E2：SQA成员在项目早期，参与制定该软件项目的SQA计划。 E3：SQA成员与项目经理协商识别出该项目的质量保证对象，即该项目的工作产品。 E4：参照《软件质量保证计划制定指南》，制定出该项目的《SQA计划》。 E5：SQA成员估算每个质量保证活动的工作量和所需资源。 E6：项目经理、SQA组、软件相关组评审《SQA计划》。 E7：项目软件开发计划更改时，SQA成员适时调整《SQA计划》。 2.2 定期或事件驱动的评审与审计(Periodic Review and Audit or Review and Audit Drivenby Event) ──工作产品(Work Product) W1：评审报告。 W2：不符合项跟踪表。 ──执行步骤(Execute Step) E1：按照SQA计划，项目组提交工作产品给SQA成员。 E2：SQA成员对提交的工作产品进行评审或审计。 E3：SQA成员填写《评审报告》及《不符合项跟踪表》。 2.3 跟踪处理不符合项(Tracking and Resolution of Noncompliance Items) ──工作产品(Work Product) W1：不符合项跟踪表。 ──执行步骤(Execute Step) E1：SQA成员对每次质量保证活动后产生的不符合项，编制《不符合项跟踪表》。 E2：SQA成员将《不符合项跟踪表》通知项目经理，项目组解决后反馈给SQA成员。 E3：SQA成员对解决的内容进行验证。 E4：SQA成员将项目经理解决不了、或不能由项目经理解决的问题，提交给高层经理解决。 E5：SQA成员对高层经理解决的情况，进行跟踪记录。 2.4 报告活动结果(Report of Activity Results) ──工作产品(Work Product) W1：SQA工作报告。 ──执行步骤(Execute Step) E1：SQA成员编制《SQA工作报告》。 E2：SQA成员将《SQA工作报告》提交给相关经理、相关组及个人。 2.5 软件质量保证管理评审(Assurance Review of Software Quality) ──工作产品(Work Product) W1：SQA管理过程评审报告。 ──执行步骤(Execute Step) E1：SQA组长定期或以事件驱动方式组织召开SQA管理过程评审会。 E2：参加评审会的成员为高级经理、项目经理、独立于SQA组的外部专家。 E3：SQA组长整理《SQA管理过程评审报告》，并改进SQA组的工作。 2.6 记录测量数据(Record of Measurement Data) ──工作产品(Work Product) W1：软件质量保证活动度量表。 ──执行步骤(Execute Step) E1：项目组的SQA成员，每周记录软件质量保证活动，填写到《软件质量保证活动度量表》； E2：SQA成员定期或项目完成后，将度量记录汇总，通报给高级经理和项目经理。 17《软件质量保证计划》《软件质量保证计划》编写参考指南 1．引言(Introduction) 1.1 目的(Purpose) 软件质量保证计划建立的目的，是为了使软件质量保证组及项目组双方能以此软件质量保证计划为依据，执行一系列的SQA活动，从而对软件过程和软件产品的质量提供可视性管理。 1.2 范围(Scope) 本文档适应于软件项目的质量保证全过程。 1.3 术语定义(Terms Glossary) [1] 软件质量：指软件产品满足用户明确和隐含需求的能力特性的总和。 [2] 软件质量保证组：指计划和实施软件质量保证活动的人员集合。 1.4 参考资料(References) [1] 列出有关的参考资料1。 [2] 列出有关的参考资料2。 1.5 相关文档(Related Documents) [1] 列出有关的软件合同。 [2] 列出有关的软件任务书。 1.6 版本更新记录(Version Updated Record) 版本更新记录格式，如表14-3所示。 表14-3 版本更新记录 版本号 创建者 创建日期 维护者 维护日期 维护纪要 V1.0 王大林 2001/04/03 — — — V1.0.1 — — 王小林 2001/04/18 管理机构维护 2．管理机构(Management Organization) 2.1 机构(Organization) 质量保证活动组织关系图见图14-1，它给出了软件组织内部与软件质量保证活动有关的各个小组及个人之间的关系。 图14-1 质量保证活动组织关系图 2.2 职责(Responsibility) 说明与软件质量保证活动有关的各个小组及个人的责任，如表14-4所示。 表14-4 与软件质量保证活动有关的各个小组及个人的责任 小组及个人名称 责 任 高级经理 负责小组之间、部门之间、组织内外的沟通协调 项目经理 负责整个软件项目的业务、技术、资源、活动 软件质量保证组长 保证软件项目的标准、规程、约定得到遵守 软件质量保证成员 制定软件质量保证计划，组织软件质量保证活动，书写软件质量保证报告。重点是对软件工作产品进行评审与审计 续表表 小组及个人名称 责 任 测试组 制定测试计划、用例，组织测试活动，书写测试报告 软件工程组 软件工程项目的分析、设计、编程、测试、培训、实施 配置管理组 软件基线、配置项的认定，配置活动审定，配置资源保证 同行专家 同行专家（外部专家）评审 3．质量保证活动(SQA Activities) 表14-5是《软件质量保证计划任务进度表》(Schedule for SQA)（又称软件质量保证活动表），该表是根据《软件质量保证程序文件》的内容制定的，建议读者将两者结合起来阅读。 表14-5 软件质量保证计划任务进度表 序 号 工作产品名称 组 织 者 参 加 者 计划日期 实际日期 计划工作量 实际工作量 计划资金 实际资金 计划评审次数 实际评审次数 1 《SQA计划》 SQA成员 项目经理、软件相关组 2 《SQA计划》评审报告 SQA成员 项目经理、软件相关组及个人 3 《用户需求报告》评审报告 项目经理 用户、SQA成员、软件相关组、外部专家 4 《用户需求报告》不符合项跟踪表 SQA成员 项目经理、软件相关组 5 《软件需求规格说明书》评审报告 SQA成员 项目经理、软件相关组 6 《软件需求规格说明书》不符合项跟踪表 SQA成员 项目经理、软件相关组 7 《概要设计说明书》评审报告 SQA成员 项目经理、软件相关组 8 《概要设计说明书》不符合项跟踪表 SQA成员 项目经理、软件相关组 续表表 序 号 工作产品名称 组 织 者 参 加 者 计划日期 实际日期 计划工作量 实际工作量 计划资金 实际资金 计划评审次数 实际评审次数 9 《详细设计说明书》评审报告 SQA成员 项目经理、软件相关组 10 《详细设计说明书》不符合项跟踪表 SQA成员 项目经理、软件相关组 11 《Alpha测试报告》评审报告 SQA成员 项目经理、测试组 12 《Beta测试报告》评审报告 项目经理 用户、SQA成员、测试组 13 《用户使用手册》评审报告 SQA成员 项目经理、SCM组、软件相关组 14 《用户安装手册》评审报告 SQA成员 项目经理、SCM组、软件相关组 15 《系统管理手册》评审报告 SQA成员 项目经理、SCM组、软件相关组 16 《SQA工作报告》评审报告 SQA组长 高级经理、项目经理、软件相关组 17 《SQA管理过程》评审报告 SQA组长 高级经理、项目经理、外部专家 18 软件质量保证活动度量表 SQA成员 高级经理、项目经理 其中，用户需求报告评审和Beta测试报告评审的组织者均为项目经理，这是因为这两次评审均需用户参与，并且要用户确认。 4．工具、技术和方法(Tools，Technique and Methods) 根据需要，指明SQA计划中用到的工具、技术和方法。 5．对供货商的控制(Controls to the Suppliers) 供货商包括软件外包商和软件产品销售商，对外包商承包开发软件的过程管理，要按照CMM2的关键过程域“软件子合同管理”(SoftwareSubcontract Management)进行管理。对销售软件产品的销售商，要按照软件组织事先定义好的标准进行控制。 6．活动记录的收集和整理(Collecting，Maintaining and Keep Records) 对SQA计划实施中的活动记录要整理入库，长期保存，由它可生成《软件质量保证活动度量表》，送给高级经理、项目经理阅读。]]></content>
      <categories>
        <category>Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[医院信息管理信息系统]]></title>
    <url>%2Fblog%2F8499.html</url>
    <content type="text"><![CDATA[本手册以系统中的各功能模块为线索，以医院服务主要流程为导向，简单描述了医院信息管理系统中各主要模块的功能及操作方法，主要面向广大的软东医院信息管理系统的用户，目的在于协助其尽快掌握软件的基础使用与操作，同时也可以作为集中培训的基础教材。 前言因本手册其旨在于给医院各岗位工作人员提供快速操作指导，内容不足之处，敬请原谅，若有疑难问题请致电公司客服中心，我们将竭诚为您服务！ 系统简介“软东医院信息管理信息系统”是一套集成门诊挂号收费、住院收费、 药品管理等工作站的医院网络管理系统，本系统适应于二级医院，它操作简单方便，性能稳定；支持按大类收费和明细收费；大类项目和明细项目都能自定义；支持多种发票格式和收据格式，并且每种发票格式都可以自由修改；药品管理部分参考了国外一些优秀医院网络系统的先进经验，具有完善的药品进销存管理包括药品调价报损退库等强到管理功能，处方从门诊收费到药房完全通过网络传输，完全实现无纸化，数据一次性发生，摆药发药全部自动完成，99% 以上的操作实现了零输入。本系统采用先进的服务器客户端结构，客户端运行的只是和用户交互的界面，安装方便，对硬件的要求也极低，只要能运行winXP 以上操作系统的计算机都能正常运行。 系统配置 服 务 器 硬件最低配置 2.0G CPU/2G内存/250G双硬盘 硬件推荐配置 2.8G CPU/4G内存/500G双硬盘 支持Raid-1 操作系统 Windows 2003 server 数据库平台 MS SQLserver2008 工 作 站 操作系统Windows 2003/XP 系统登录点击RdClientManage.exe进入系统后，会有登录界面出现。 输入用户名的助记码，按回车键，如果用户存在，系统将自动显示该用户所对应的科室，输入口令，单击登录或者按回车键。如果口令正确，将根据系统管理员设置给该操作员的权限来登录系统。若口令不正确，系统将提示错误信息。如果不想进入系统点击取消即可。 门诊部分1.1挂号管理1.1.1门急诊挂号 在左边导航栏中出现“挂号管理”的子系统图标，右边会列出挂号管理子系统的主要模块。如下! 找到门急诊挂号模块图标点击进入。如下! 根据要求填写相关信息，输入病人姓名等信息，可以使用回车键进行下一栏的输入（诊疗号不需要手动输入，系统会自动生成），填写完之后单击‘保存’，保存的病人信息会在挂号信息处显示。(保存完成后，系统会自动产生诊疗号和门诊号)如图： 如果要查看是否有预约患者的话，可以单击预约患者信息来查看。 如图： 如果未领票或票已用完系统也会给出提示信息. 如果在保存之前不对该病人进行信息输入，可以单击‘取消’。保存之前，但是信息已经输入完整，可以对该病人信息进行‘删除’。操作完成后，单击‘退出’以退出该界面。 1.1.2 挂号退号 在挂号管理窗口中选择挂号退号，如图： 输入该病人所对应的发票号或门诊号，单击‘查询’，选中该病人信息，单击‘确定’即可对该病人进行退号。发票号或门诊号输入错误时，单击‘取消’，重新输入。 1.1.3 门诊病人信息修改 在挂号管理窗口中选择门诊病人信息修改，进入如下界面： 输入病人挂号时的门诊号或诊疗号，单击‘查询’，就可以对查出来的病人的信息进行修改，修改完成后单击‘确定’，否则单击‘取消’，操作完成后单击‘退出’。 1.1.5 操作员挂号报账单 在挂号管理窗口中选择专家挂号，进入如下界面： 选择起始时间和结束时间以及需要的统计类型和打印方式、所要报账的操作员，单击确定。 1.2.1门诊管理 在左边导航栏中找到门诊医生站子系统图标点击进入门诊管理子系统，右边会列出门诊管理子系统的主要模块。找到门诊医生工作站模块图标点击进入。 门诊医生工作站窗口打开： 如果病人是按专家挂号或者选择了相关医师，那么就选择左边的‘个人’按钮，如果病人按科室挂号，那么就选择左边的‘科室’按钮。 如果挂过号的病人信息没有出现，那么就单击‘刷新列表’。 若病人信息为白色，可以按鼠标右键，弹出菜单，点击‘呼叫病人’就可以将病人转化为待诊状态。 也可以将处于待诊状态的病人通过按鼠标右键的方法将其转为续诊。 若病人信息为橘黄色，则表明该病人处于待诊状态，可以就诊，双击病人信息，就会将病人的详细信息输出，如图所示： .医生可以根据病人的情况填写相关内容（门诊病历、检查治疗、药品处方）。在填写过程中，输入栏中出现图标时，表示可以进行选择，也可以手动输入。如图： 使用从待选项移到已选项，也可以手动输入进行筛选，然后单击‘确定’。 在输入‘检查治疗’‘药品处方’‘中草药处方’时，单击‘新增’就可以输入相关内容，选择处方内容时，可以输入药品名称汉语拼音的第一个字母按‘回车键’就可以出现相关信息，如图： 完成后单击‘保存’， 1.2.2诊断证明在右边列出的门诊管理子系统的主要模块中找到诊断证明模块图标点击进入。 1.2.3个人处方维护在右边列出的门诊管理子系统的主要模块中找到个人处方模块图标点击进入： 个人处方维护所列出的组合名称只能为常用药品、常用检查、常用检验，在此维护的信息将在门诊医生工作站处调用。 1.2.4门诊医生接诊患者信息查询在右边列出的门诊管理子系统的主要模块中找到门诊医生急诊患者信息查询模块图标点击进入。 输入要查询的条件，单击‘查询’即可找到要查询的科室、医师所对应的所有病人信息。 1.3 门诊收费站1.3.1门诊划价收费在左边导航栏中找到门诊管理子系统，右边会列出门诊收费站子系统的主要模块。找到门诊划价收费模块图标点击进入。输入就诊号或挂号号如图： 单击‘确定’，屏幕中会列出该病人所有要划价的费用，如图： 单击‘保存’，如图： 最后单击确定即可。如果以上信息输入不正确，可以单击‘取消’，重新输入。 1.3.2 病人信息维护在右边的主要模块中找到病人信息维护模块图标点击进入，如图： 根据需要输入相关信息（所有部门、检索条件、是否在院都是可选的），单击回车键或‘查询‘按钮，如图： 选中要修改的病人，单击‘编辑’按钮，如图： 修改完成后单击‘确定’即可。 1.3.3 门诊发票重打在右边的主要模块中找到门诊发票重打模块图标点击进入，如图： 单击要重新打印的发票或输入要打印的发票号，单击‘确定‘，如图; 需要重打的话单击‘确定‘，不需要的话单击‘取消’。 1.3.4 门诊退费在右边的主要模块中找到门诊退费模块图标点击进入，输入诊疗号或发票号，如图： 双击该发票号对应的信息，如图： 选择要退的费用，单击‘保存’ 如图： 单击‘确定’即可退费，否则不退费。 1.3.5 门诊日结账（在启用日结配置的情况下才能使用）在右边的主要模块中找到门诊操作员结账模块图标点击进入，如图： 根据具体需要进行选择。 1.3.6 结账信息取消（该功能慎用）在右边的主要模块中找到结账信息取消模块图标点击进入，如图： 输入要撤销结账的操作员代码，如图： 如果要撤销记账的话，选中要撤销的账目，如果需要的话选中删除结账信息单选框，直接单击‘撤销结账数据’，如图： 住院部分根据系统管理员设置给该操作员的权限来登录系统。若口令不正确，系统将提示错误信息。如果不想进入系统点击取消即可。点击左边的住院管理系统，右边会出现相关模块 2.1入院2.1.1 入院登记双击右边的入院登记模块进入如图界面： 单击‘新增’按钮，输入要住院的病人信息（从‘姓名栏’开始可以用‘回车键’依次输入其他信息），单击保存，如图： 然后单击‘确定’，出现如下对话框： 如果要打印病历首页的话，单击‘确定’，否则单击‘取消’。 2.1.2 新生儿入院登记双击右边的新生儿入院登记模块进入如图界面： 单击‘新增’，输入相关信息（输入母亲的住院号，按‘回车键’进行其他项的选择），完成后单击 ‘保存’，出现如下对话框： 再次输入母亲住院号，单击回车键，会出现对应孩子的信息，如图： 双击该婴儿的信息，就可以对婴儿信息进行编辑。 2.1.3 入院登记许可项配置双击右边的入院登记许可项配置模块进入如图界面： 对需要的项打上勾，然后单击提交。 2.2住院医生站2.2.1 导航管理双击右边的导航管理模块进入如图界面： 选中某一病人，单击鼠标右键，会出现长期医嘱、临时医嘱、账目查询、电子病历、床头卡等选项，根据需要进行选择。 例：建立长期医嘱：如图： 单击‘新增’，输入要增加的长期医嘱，如图： 输入完成后，单击保存，如图：，保存完成后，要进行‘确认’，如图： 之后再单击‘保存’，如图 如果确定该遗嘱的话，单击确定即可，否则单击取消，对该医嘱进行‘追加’、‘修改’、‘作废’等操作。对该病人进行长期医嘱时，也可填写临时医嘱。 2.2.2 住院电子病历双击右边的住院电子病历模块进入如图界面： 用鼠标选中左边的病人信息，右击鼠标，会出现收治患者、病案首页、书写病历、病历套打、会诊管理等选项，根据要求进行选择。 例： ‘病案首页’：（如果登录医生不是该病人的主治医生，那么如果要为该病人书写病案首页时，就要先收治该病人） 填写病人的基本情况、诊断情况、治疗情况，完成后单击‘保存’即可。 2.3住院收费2.3.1 住院划价记账双击右边的住院划价记账模块进入如图界面： 可以在对应的科室下面选择病人，也可以输入病人的住院号，按回车键调出病人的相关信息，输入执行科室和收费项目（收费项目可以输入项目的汉语拼音的第一个字母按回车键进行选择），然后单击保存。如果该病人余额不足，如果有“欠费权限的话”可以在‘允许欠费’栏输入金额或者在有担保人的情况下可以填写相关的担保金额。 2.3.2 允许欠费金额设置双击右边的允许欠费金额设置模块进入如图界面： 输入相关的检索条件，单击‘查询’，就可以调出该病人的信息（用以核对），如图： 然后在设定允许欠费金额文本框中输入允许欠费金额，单击‘设定’，如图： 表示设定成功。 2.3.8 增加担保人双击右边的增加担保人模块进入如图界面： 在左边的菜单栏根据科室选择病人或输入病人的住院号，按‘回车键’调出病人的相关信息，然后填写担保人、担保金额等内容。输入完成后，单击‘保存’即可。 2.3.3 预交款管理双击右边的预交款管理模块进入如图界面： 在左边的菜单栏根据科室选择病人或输入住院号，按回车键，调出病人的相关信息，然后输入缴款金额，单击‘收费’按钮即可，如图： 该页面的下面还会出现该病人的明细账信息，如果要该病人要退费的话，可以选择相关的要退的费用，单击‘退费’按钮即可，如图： 2.3.4 预交款发票重打双击右边的预交款发票重打模块进入如图界面： 在左边的菜单中根据科室选择病人或输入住院号，按回车键，页面中会出现该病人所有的预交款信息，如图： 选择要重打的发票，单击‘重打’按钮进行重打，如图： 单击‘确定’即可重打，否则‘取消’。 2.3.5 住院收入按科室统计双击右边的住院收入按科室统计模块进入如图界面： 选择要统计的起止时间、科室等信息，单击‘确定’即可。 2.3.6 住院收入按医师统计 选择要统计的起止时间、医师等信息，单击‘确定’即可。 2.3.7 病人费用类别修改双击右边的病人费用类别修改模块进入如图界面： 输入住院号，按回车键调出病人基本信息，然后输入要修改的病人费用类别信息，单击‘转换’即可。 2.3.9 住院退费双击右边的住院退费模块进入如图界面： 在左边的菜单中根据科室选择病人或输入住院号，按回车键调出病人的相关信息和相关费用，如图： 选中需要退的费用，然后单击‘保存’，如图： 需要退的话，单击‘确定’，否则单击‘取消’。 退费成功后，可以单击‘显示退费’，即可以看到该病人的退费情况。如图： 2.3.10 滚动退费双击右边的滚动退费模块进入如图界面： 在左边的菜单中根据科室选择病人或输入住院号，按回车键调出病人信息和相关的滚动费用，如图： 选择要退的滚动费用，单击保存即可，如图： 2.3.11 病人账目查询双击右边的病人账目查询模块进入如图界面： 输入病人的住院号，按回车键，调出病人的相关信息。如图： 可以通过按‘总账信息’，‘明细账信息’，‘未发药品信息’，‘未记账医嘱’按钮得出相关信息。 2.3.12 病人账目结算双击右边的病人账目结算模块进入如图界面： 输入病人的住院号，按回车键调出病人信息，（如果该病人有未发药品，系统会出现如下对话框： 发药动作完成后，就可以正常结算，单击‘确定’，会出现“确定现在办理患者结算手续吗”的对话框，单击‘确定’即可办理结算手续，如图： 。 2.3.13 结算召回 双击右边的结算召回模块进入如图界面： 在左边的菜单中根据科室选择结算的病人信息或输入要召回的病人的住院号，单击‘查询’，如果确定要召回该病人的话就单击‘确定’，如图： 2.3.14 住院结账双击右边的住院结账模块进入如图界面： 2.3.15 催拖欠款 双击右边的催拖欠款模块进入如图界面： 以上即为所有欠款病人的信息。 2.3.16出院发票重打双击右边的出发票重打模块进入如图界面： 左边的菜单会列出相关的出院病人信息，选择出院病人或输入住院号，按回车键调出出院的病人信息，如图： 单击‘确定’即可完成发票重打。 2.3.17 出院收入按医师统计 双击右边的出院收入按医师统计模块进入如图界面： 输入要统计的信息，按‘确定’即可。 2.3.18出院收入按科室统计 输入要统计的信息，按‘确定’即可。 2.3.19出院病人账目查询双击右边的出院病人账目查询模块进入如图界面： 输入要查询的病人的住院号，按‘回车键’调出病人的相关信息，通过按‘总账信息’，‘明细账信息’查出对应的账目信息。 2.4护士站2.4.1 导航管理 双击右边的导航管理模块进入如图界面： 选择要执行医嘱的病人信息，按鼠标左键，会出现长期医嘱、临时医嘱、床位调整、账目查询、出院结算等选项卡。以长期医嘱为例，如图： 如果该护士对该病人执行了以上操作，就可以单击‘查对’，如果病人余额不足，就可以选择部分查对，如图： 2.4.2 长期医嘱单双击右边的长期医嘱单模块进入如图界面： 输入已经执行的长期医嘱的病人的住院号，如图： 单击确定，就可以看到该病人的长期医嘱单。 2.4.3 临时医嘱单临时医嘱单的操作同长期医嘱单。 2.4.4 转床管理双击右边的转床管理模块进入如图界面； 输入要转床的病人的住院号按回车键就会调出病人的原床位号，然后输入病人要转入的现床位号，单击保存即可。 2.4.5 包床设置双击右边的包床设置模块进入如图界面： 输入住院号，调出相关信息，按‘包床’键即可 2.4.6 临时加床双击临时加床模块进入如图界面： 选择科室名，对该科室按照提示进行临时加床。 2.4.7 临时撤床双击右边的临时撤床模块进入如图界面： 选择科室名，对该科室按照提示进行临时撤床。 2.4.8 转科管理双击右边的转科管理模块进入如图界面： 2.4.9 在院病人一日清单双击右边的在院病人一日清单模块进入如图界面： 选择要统计的方式（按住院号还是按科室），修改要统计的起止时间，按‘确定’键即可。 2.5.10 出院病人一日清单双击右边的出院病人一日清单模块进入如图界面： 出院病人一日清单操作同在院病人一日清单 2.5.11 请领药单（汇总）双击右边的请领药单（汇总）模块进入如图界面： 如果是住院药房的话选择住院药房，起始时间为上次打印或预览的时间，终止时间为当前时间，根据需要进行选择（重打（注：要输入申请号）、预览、打印），单击‘确定’即可。 2.5.12 请领药单（明细）双击右边的请领药单（明细）模块进入如图界面： 选择医嘱类型和药品类别，其他操作同请领药单（汇总） 2.5.13 静滴单（输液卡）双击右边的静滴单（输液卡）模块进入如图界面： 输入住院号，选择要打印或预览的静滴单的起止时间，单击确定即可，如果要按科室查询的话，就选择‘是否按科室查询’单选框，单击确定即可。 2.5.14 请领药单（口服和非口服）双击右边的请领药单（口服和非口服）模块进入如图界面： 操作同请领药单（汇总）。 2.5.15 口服药单双击右边的口服药单模块进入如图界面： 基本操作同静滴单 2.5.16 注射单双击右边的注射单模块进入如图界面： 操作同口服药单。 2.5.17 处置单（医技）双击右边的处置单模块进入如图界面： 操作同上。 2.5.18 治疗处方单双击右边的治疗处方单模块进入如图界面： 2.5.19 皮试结果查询双击右边的皮试结果查询模块进入如图界面： 输入住院号就会出现做过皮试的病人的皮试结果信息查询。 2.5.20 护理记录单双击右边的护理记录单模块进入如图界面： 记录护士在护理过程中病人的基本信息。 2.5出院2.5.1 出院 双击右边的出院模块进入如图界面： 左边菜单会出现相关的可以出院的病人或输入住院号，按回车键，单击‘确定’如图： 要办理出院的话，直接单击‘确定’即可。否则单击‘取消’。 2.5.2 出院病人召回管理双击右边的出院病人召回管理模块进入如图界面：** 输入要召回的病人的住院号，按‘回车键’调出病人的信息，单击‘确定’即可。 药库药房部分3.1 药库管理 3.1.1. 药品初始录入双击右边的药品初始录入模块进入如图界面： 选择药房名称、库房名称等信息（输入药品名称的时可以输入药品名称的汉语拼音的首字母，按回车键，选择相关药品）。输入完成后，单击‘保存’即可。 3.1.2药品入库双击右边的药品入库模块进入如图界面： 点击‘新增’，输入入库的药品信息，如图： 单击‘保存’即可。 3.1.3 药品库存调整双击右边的药品库存调整模块进入如图界面： 输入调整部门，点击‘显示’，屏幕中会列出该药房的所有药品信息，如图： 也可以在按拼音码检索中输入药品的汉语拼音的首字母，如图： 选中要调整的药品，，输入实际库存和调整原因，单击‘确定’，如图： 点击‘调整’即可，如图： 3.1.4 药品调拨管理双击右边的药品调拨管理模块进入如图界面： 单击‘新增’，输入要调拨的库房名称和药品，如图： 单击‘保存’即可，如图： 也可以对已经调拨的药品进行编辑，单击‘编辑’，如图： 选择要编辑的药品，进行‘编辑’即可。 保存完成后，要对药品信息要进行审核，单击‘审核’，如图： 选中要审核的药品信息，双击即可。 3.1.5 药品盘点双击右边的药品盘点模块进入如图界面： 单击‘新增盘点表’，如图： 如果要显示这些药品对应的库存，可以单击‘导入库存’，盘点完成后，单击‘保存’，数据无误后，单击‘审核’、‘保存’，药品盘点任务完成。 3.1.6药品库存上下限维护双击右边的药品库存上下限维护模块进入如图界面： 输入库存下限和库存上限，单击‘保存’即可，如图： 3.1.7药品调价双击右边的药品调价模块进入如图界面： 单击‘新增’，输入相关信息（文件号、调价原因必写），输入药品的新购入价如图： 单击保存即可，如图： 保存之后，要对修改过的信息进行审核，点击‘审核’，如图： 选择部门，单击‘查询’，选择要审核的调价号，单击‘确定’，如图： 选中要审核的药品信息，单击‘确定’即可。 3.1.8药品报损管理双击右边的药品报损管理模块进入如图界面： 单击‘新增’，选择损益类别，输入报损的药品数量，如图： 单击‘保存’即可，如图： 保存完成后，要对输入的信息进行审核，单击‘审核’，如图： 双击要审核报损信息或者选择该审核报损信息单击‘确定’，再次单击‘保存’即可审计成功，如图： 单击‘确定’； 3.1.9药品购物计划双击右边的药品购物计划模块进入如图界面： 单击‘新增’，输入相关信息，即可出现该库房的药品记录信息，如图： 如果只想显示小于库存下限的药品信息，可以在药品信息（仅显示小于库存下限的药品）前面方框点击即可。也可以利用辅助查找（输入药品汉语拼音的第一个字母）来查找有关药品信息。 选中某一药品，右击，会出现‘定位查找’，‘添加到购物计划明细’对话框。 定位查找，如图：点击‘ok’进行查找。 也可以利用单价进行查找。 添加到购物计划明细，输入采购数量和购入价等相关信息，单击‘保存’，如图： 确定信息无误后，单击‘审核’，如图： 选中要审核的药品，单击‘保存’即可，如图： 完成购物计划后，点击‘保存’即可。会出现相关的审核单； 3.1.10药品退货管理双击右边的药品退货管理模块进入如图界面： 单击‘新增’，输入相关信息和要退的药品信息，如图： 单击‘保存’即可。保存完成后，也要对该信息进行审核。 3.1.11 药库药品出入库汇总双击右边的药库药品出入库汇总模块进入如图界面： 选择要统计的药库名称、历史数据、汇总数据的时间，单击‘汇总’即可。 3.1.12 药房药品出入库汇总双击右边的药房药品出入库汇总模块进入如图界面： 选择要统计的药库名称、历史数据、汇总数据的时间，单击‘汇总’即可。 3.2药房药房操作员根据自己的代码进入药房管理系统，如图： 3.2.1药房发药双击右边的药房发药模块，如图所示： 确定是门诊发药还是住院发药，选择药方名称，系统会调出相关的未发药的病人信息，如果病人过多的话，也可以通过输入诊疗号按回车键调出该病人的未发药的信息。如图： 发完药后，点击‘确定’即可，如图： 点击‘确定’之后，会打印相应的发药单； 3.2.2药房退药双击右边的药房发药模块，如图所示： 选择退药的部门，单击‘查询’，如图： 选择要退药的病人信息，单击‘确定’，然后双击该病人信息，如图： 选择要退的药品，单击‘确定’，如图： 单击是，即可完成退药，否则单击‘否’。 3.2.3 药品有效期管理双击右边的药品有效期管理模块，如图所示： 根据提示，输入要查询的药品的有效期，单击‘查询’即可。 3.2. 4药房药品维护双击右边的药房药品维护模块，如图所示： 输入库存上下限，单击‘保存’即可。 3.2.5药品医保类型维护双击右边的药品医保类型维护模块，如图所示： 输入要将修改的药品的汉语拼音的首字母或药品编号、药品名称等相关信息，调出该药品的信息，选择‘修改’按钮，如图： 选择该药品的医保类型，最后‘保存’即可。 3.2. 6药品划价双击右边的药品划价模块，如图所示： 左边列出了已挂号未划价的病人信息，对该病人信息进行双击，如图： 输入处方的药品名称，如图： 单击保存即可：]]></content>
      <categories>
        <category>case</category>
      </categories>
      <tags>
        <tag>case</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术变化那么快，如何做到不被淘汰]]></title>
    <url>%2Fblog%2F63607.html</url>
    <content type="text"><![CDATA[在浩大的软件世界里，作为一名普通程序员，显得十分渺小，甚至会感到迷茫。我们内心崇拜技术，却也对日新月异的技术抱有深深的恐惧。有时候我会思考难道在技术领域内不断紧跟新潮，不断提升技能就是我的价值所在？那么我是技术的主人还是技术的奴隶？ 人之所以迷茫往往是找不到工作生活的重心，感受不到工作或生活的价值。那么什么是价值呢？说的大一点就是我改变了世界，说的小一点就是我的所作所为改善了某些问题。如果不清楚自己的行为、目标、价值三者的关系，那么又何来重心？又如何能分得清重要性与优先级呢？ 程序员的迷茫不仅仅是面对技术繁杂的无力感，更重要的是因为长期埋没于软件世界的浩大的分工体系中，无法看清从业务到软件架构的价值链条，无法清楚定位自己在分工体系的位置，处理不好自身与技术、业务的关系所致。 很多程序员打心底不喜欢业务，这一点我曾经也经历过，我更宁愿从事框架工具、技术组件研究的相关事情。我有个朋友经常吐槽我说：”你们天天加班加点写了那么多代码，然后呢？有改变什么吗？还不是写出了一堆垃圾。”仔细想想很多时候业务在我们脑海中存留的只是逻辑和流程，我们丢失的是对业务场景的感受，对用户痛点的体会，对业务发展的思考。这些都是与价值紧密相关的部分。我们很自然的用战术的勤快掩盖战略的懒惰！那么这样的后果就是我们把自己限死在流水线的工位上，阉割了自己能够发现业务价值的能力，而过多关注新技术对职场竞争力的价值。这也就是我们面对繁杂技术，而产生技术学习焦虑症的根本原因。 业务、技术与软件系统的价值链那么什么是业务呢？就是指某种有目的的工作或工作项目，业务的目的就是解决人类社会与吃喝住行息息相关的领域问题，包括物质的需求和精神的需求，使开展业务活动的主体和受众都能得到利益。通俗的讲业务就是用户的痛点，是业务提供方（比如公司）的盈利点。而技术则是解决问题的工具和手段。比如为了解决用户随时随地购物的业务问题时，程序员利用web技术构建电子商务App，而当需求升级为帮助用户快速选购商品时，程序员会利用数据算法等技术手段构建推荐引擎。技术如果脱离了业务，那么技术应用就无法很好的落地，技术的研究也将失去场景和方向。而业务脱离了技术，那么业务的开展就变得极其昂贵和低效。 所以回过头来我们想想自己没日没夜写了那么多的代码从而构建起来的软件系统，它的价值何在呢？说白了就是为了解决业务问题，所以当你所从事的工作内容并不能为解决业务问题带来多大帮助的时候，你应该要及时做出调整。那么软件系统又是如何体现它自身的价值呢？在我看来有如下几个方面的体现： 业务领域与功能：比如支付宝立足支付领域而推出的转账、收款功能等，比如人工智能自动驾驶系统等。 服务能力：这就好比火车站购票窗口，评判它的服务能力的标准就是它能够同时处理多少用户的购票业务，能不能在指定时间内完成购票业务，能不能7*8小时持续工作。对应到软件系统领域，则表现为以下三个方面： 系统正确性(程序能够正确表述业务流程，没有Bug) 可用性（可以7＊24小时＊365不间歇工作） 大规模（高并发，高吞吐量） 互联网公司正是借助大规模的软件系统承载着繁多的业务功能，使其拥有巨大的服务能力并借助互联网技术突破了空间限制，高效低廉解决了业务问题，创造了丰厚的利润，这是人肉所不可比拟的。 理解了这一层面的概念，你就可以清楚这个价值链条：公司依靠软件系统提供业务服务而创造价值，程序员则是通过构建并持续演进软件系统服务能力以及业务功能以支撑公司业务发展从而创造价值。 有了这个价值链条，我们就可以反思自己的工作学习对软件系统的服务能力提升起到了多大的推动作用？可以反思自己的工作学习是否切实在解决领域的业务问题，还是只是做一些意义不大的重复性工作。 前两天面试了一个候选人，他的工作是从事票务系统开发，他说自己在研究linux内核与汇编语言，我就问他linux内核和汇编语言的学习对你的工作产生了哪些帮助？能否举一个例子？他哑口无言，我内心就觉得这样一个热爱学习的好苗子正迷茫找不到重心，正在做一件浪费精力的事情。正确的学习方式应该是将学习与具体业务场景结合起来，和公司通过软件系统开展业务服务而创造价值，程序员通过提升软件系统服务能力创造价值这一链条串接起来，从对这些价值产生帮助的程度去思考优先级。学习本身没有错，错的往往就是那颗初心。 现在你再来看高并发分布式相关的知识，你会发现并不是因为这些知识比较高深、比较时髦，很多公司有需求才值得学习，而是他们对价值链条有着实实在在的贡献。 价值驱动的架构一谈到软件系统，人们免不了想起架构这件事来。之所以此处去谈及架构是因为每一个程序员本质都是软件架构体系中的一分子，我们可能深埋于体系流水线之中，感受不到位置和价值。但如果站在架构这一高度去看这些问题则将会非常透彻。那么架构究竟是什么？和上述的价值链又有什么关系呢？ 什么是架构？在我看来软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。可能比较抽象，我想我们可以从架构师的一些具体工作任务来理解这句话含义： 组织业务：架构师通过探索和研究业务领域的知识，构建自身看待业务的”世界观”。他会基于这种认识拆分业务生命周期，确立业务边界，构建出了一套解决特定业务问题的领域模型，并且确认模型之间、领域之间的关系与协作方式，完成了对业务领域内的要素的组织工作。 组织技术：为了能在计算机世界中运作人类社会的业务模型，架构师需要选用计算机世界中合适的框架、中间件、编程语言、网络协议等技术工具依据之前设计方案组织起来形成一套软件系统方案，在我看来软件系统就像是一种技术组织，即技术组件、技术手段依据某种逻辑被组织起来了，这些技术工具被确定了职责，有了明确分工，并以实现业务功能为目标集合在了一起。比如RPC框架或消息队列被用于内部系统之间的通信服务就如同信使一般，而数据库则负责记录结果，它更像是一名书记员。 组织人员：为了能够实现利用软件系统解决业务问题的目标，架构师还需要关注软件系统的构建过程，他以实现软件系统为号召，从公司组织中聚集一批软件工程师，并将这些人员按不同工种、不同职责、不同系统进行组织，确定这些人员之间的协作方式，并关注这个组织系统是否运作良好比如沟通是否顺畅、产出是否达到要求、能否按时间完成等。 组织全局，对外输出：架构师的首要目标是解决业务问题，推动业务增长。所以他非常关心软件的运行状况。因为只有在软件系统运行起来后，才能对外提供服务，才能在用户访问的过程中，解决业务问题。架构师需要关注运行过程中产生的数据比如业务成功率，系统运行资源占用数据、用户反馈信息、业务增长情况等，这些信息将会帮助架构师制定下一步架构目标和方向。 所以软件架构不仅仅只是选用什么框架、选用什么技术组件这么简单。它贯穿了对人的组织、对技术的组织、对业务的组织，并将这三种组织以解决业务问题这一目标有机的结合在了一起。 很多面试的候选人在被问及他所开发的系统采用什么架构的问题时，只会罗列出一些技术组件、技术框架等技术要素，这样看来其根本没有理清架构的深层含义。也有一些架构师只专注对底层技术的研究，以为打造一个卓越的系统是非常牛逼的事情，可是他忽略了软件系统的价值是以解决业务问题的能力、支撑业务增长的能力为衡量标准，所以最后生产出了很多对组织，对业务没有帮助的系统。 成本与收益正如之前所说软件系统只有在运行的时候才能创造价值，也就是说软件系统能否7*24小时＊365天稳定的工作关系到公司的收益水平。所以开发团队对生产环境的发布总是小心翼翼，对解决生产环境的问题总是加班加点。而软件系统的成本则体现在软件构建过程，这时候我们就能理解那些工程技术如项目管理、敏捷开发、单元测试、持续集成、持续构建，版本管理等的价值了，他们有的是保证软件系统正确性，有的是为了降低沟通成本，有的是为了提升开发效率等但总的来说就是为了降低软件的构建成本。所以在提升系统服务能力，创造更多业务收益的同时，降低构建成本也是一种提升收益的有效手段。 作为一名软件工程师而言，我们往往处在软件构建过程体系中的某个环节，我们可以基于成本与收益的关系去思考自己每一项技能的价值，学习新的有价值的技能，甚至在工作中基于成本与收益的考量选择合适的技术。比如在逻辑不大发生变化的地方，没有必要去做过多的设计，应用各种花俏的设计模式等浪费时间。这样我们才能成为技术的主人。 架构目标需要适应业务的发展架构的目标就是为了支撑业务增长，就是提升软件系统的服务能力。可是话虽说如此，但真实却要做很多取舍。比如对初创团队而言，其产品是否解决业务问题这一设想还没得到确认，就立即去构造一个高性能、高可用的分布式系统，这样的架构目标远超出业务发展的需求，最后的结果就是浪费大量人力物力，却得不到任何起色。架构师需要审时度势，仔细衡量正确性、大规模、可用性三者的关系，比如今年业务蓬勃发展日均订单300万，基于对未来的可能预测，明年可能有3000万的订单，那么架构师应该要着重考虑大规模和可用性。而且每一点提升的程度，也需要架构师衡量把握，比如可用性要达到2个9还是3个9。 回顾自己以往的工作很多时候就是因为没有确立架构目标导致浪费了组织很多资源，比如在之前的创业团队中，由于本人有一定的代码洁癖，经常会花费很多时间和同事计较代码质量，这样本可以更快上线的功能却需要被延迟，当时过度追求正确性的行为是与创业团队快速验证想法的业务需求不匹配的。 另外一点比较深刻的案例则是在本人担任一个技术团队负责人的时候，在一次述职报告的时候，leader问我对接下来团队工作有什么计划？我当时说了一堆什么改进代码质量，每天晨会，任务透明化，建立迭代机制等等，然后就被各种批驳一通。当时团队基本以外包人员为主，人员水平较差，开发出来的金融系统也是千疮百孔而这条业务线最重要的业务价值则是按计划实现潜在投资方的需求，争取拉到投资。所以不久leader就召集测试架构的相关人员与我这边一同梳理对核心功能的测试工作，将研发、测试、上线的流程自动化。 当时并不理解这样做核心价值是什么。但回过头来看这样的工作方式恰好符合了业务发展的需求，即确保系统是符合设计需求的，保证系统达到可接受的正确性，为后续能过快速前进打下基础，最重要的是为企业降低了构建成本。所以程序员想要工作出业绩，必须认清楚系统背后的业务价值，按价值去梳理工作优先级，而不是像我一般过度纠结细节，追求技术理想化。 成也分工，败也分工正如在程序员的迷茫那一章节提到的：程序员的迷茫因为长期埋没于软件世界的浩大的分工体系中，无法看清从业务到软件架构的价值链条，无法清楚定位自己在分工体系的位置，处理不好自身与技术、业务的关系所致，所以在这里我想谈谈分工。架构师为了使软件系统更好的服务业务，必然将软件系统生命周期进行拆分，比如分出开发生命周期、测试生命周期、用户访问生命周期、软件运维生命周期，并根据不同的生命周期划分出不同的职责与角色。 比如开发人员负责开发周期负责完成软件研发，测试人员负责对开发人员交付的成果进行测试等，于是就形成了分工。一旦分工形成，每一个分工组织都会有自己的价值追求，架构师关注的顶层的价值即软件系统能否支撑业务增长被分工的形式打碎到各个组织中。分工是有其价值的，他使得复杂昂贵的任务可以被简单、并行、可替换的流水线方式解决。但久而久之，价值碎片化的问题就出现了，比如测试人员只关注找出更多问题，开发人员只关注快速开发更多的系统，运维人员只关注保障系统稳定。 三者之间常常都只站在自己的立场去要求对方怎么做，没有人再关注整体价值，产生诸多矛盾增加软件实施成本。而身处流水线中的一员，又因为困扰于重复性工作，迷茫于工作的意义，甚至感觉自己做为了人的创意与灵感都被扼杀了。所以我的朋友吐槽我说你写了那么多代码然后并没有怎么样是非常有道理的，那是因为我只关注着做为流水工人的价值要求，看不到生态链最顶端的价值。 我们仔细想想那些团队领导，精英领袖哪一个不是为着更广大的价值所负责，比如项目经理只需要关心自身项目的商业价值，而公司CEO则关心公司范畴内所有业务的总体商业价值。所以关注的价值越大且职位也就越高。这些高层领导者们把控着整体的价值链条，及时纠正底层分工组织的价值目标与整体价值目标出现偏差的问题。 从价值出发－找寻学习与工作的新思路迷茫能引发思考，架构则塑造了视野，而价值则是我们之所以存活，之所以工作的逻辑起点。基于这样一种价值思维，对我们的学习和工作又可以有哪些改启示呢？ 明确自身的业务相关主体：找出你工作的协作关系网内的业务方和客户方，这样你就可以从客户方中找到离你最近的业务价值点，从你的业务方中挖掘更多的资源。甚至你可以按这个思路顺着网络向上或向下挖掘价值链条，整合更多的上下游资源以实现更大的价值。 向前一步，为更大的价值负责：不要因为自己是开发人员就不去关注软件运维，不要因为只是测试就不关注软件开发，因为你关注的越多你越能看清全局的价值目标。如果只关注一亩三分地，那么注定这辈子只能困守在这一亩三分地里，成为一名流水线上焦虑至死的码农。试着转变思维，从架构师的角度思考价值问题，看看能否将技术贯穿到业务、到用户、到最终的价值去。之前我的朋友说过要把产品经理踢到运营位置去，把程序员踢到产品经理位置去，这样才是正确做事方式。这句话也是类似的意思，向前一步才能懂得怎么做的更好。 像架构师一样思考，用价值找寻重心：人的迷茫是因为找不到重心，而价值的意义在于引导我们思考做哪些事情才能实现价值，先做哪些事情会比后做哪些事情更能创造收益。像架构师那样全局性思考，把遇到问题进行拆分，把学习到的事物串联起来，努力构成完整的价值链条。 学会连接，构建体系：前几天看到一篇文章对今日头条的产品形态极尽批判之词，指责它的智能算法将人类封死在自己的喜好之中，将人类社会进一步碎片化。这似乎很有道理，有趣的是互联网将我们连接至广袤的世界，却也把我们封闭在独属于自己的小世界里。依旧是我的那位朋友，他说他的最大价值在于连接，将不同的人连接在一起，有趣的事情可能就会即将发生。 或许算法的天性就是顺从与迎合，但人最终想理解这个世界还是需要依靠自身的行动与不同人之间建立联系，这也是一种摆脱流水线限制的有效方式。另外，我们自身也是某种事物连接的产物，比如架构师，他是业务、技术、管理连接在一起的一种产物。所以我们应当树立自身的知识体系以吸收融合新知识，将孤立的概念连接起来，形成自身的价值链条。比如这篇文章将我从事技术开发经验、与对架构的理解以及自身过往经历结合起来，这也是一种内在的体系梳理。 作者简介：空融，网名“D调的暖冬”。现就职蚂蚁金服，从事支付宝身份认证相关领域的技术开发。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradle入门笔记]]></title>
    <url>%2Fblog%2F12275.html</url>
    <content type="text"><![CDATA[gradle在语法上是基于Groovy语言的（Groovy 是一种基于JVM的敏捷开发语言，可以简单的理解为强类型语言java的弱类型版本），在项目管理上是基于Ant和Maven概念的项目自动化建构工具。 基础知识准备 Java基础，命令行使用基础 官方文档：https://docs.gradle.org/current/dsl/ Gradle使用指南： https://gradle.org/docs/current/userguide/userguide Android插件文档：https://github.com/google/android-gradle… AndroidGradle使用文档：http://tools.android.com/tech-docs/new-build-system/user-guide Groovy基础： http://attis-wong-163-com.iteye.com/blog/1239819 Groovy闭包的Delegate机制：http://www.cnblogs.com/davenkin/p/gradle-learning-3.html 搭建Gradle运行环境 Gradle 运行依赖JVM，也就是java运行的环境。所以要安装jdk和jre，好像目前的Gradle的运行环境要求jdk的版本在1.6以上，应该的，现在jdk都到1.8了。 然后到Gradle官网现在Gradle的压缩包。地址，这个页面里面又两种方式，一种手动安装，一种通过脚本安装。我一般喜欢自己动手，这样将来清理起来比较方便。 下载压缩包后，解压，然后配置环境变量，手动安装过jdk的人应该都配置环境变量很熟了吧。每个平台下配置环境变量的方式不一样 MacOS 下配置。在~/.bash_profile中添加如下代码 1234#gradle 注意gradle-2.14.1是自己解压的路径export GRADLE_HOME=$&#123;HOME&#125;/gradle-2.14.1PATH=$&#123;PATH&#125;:$&#123;GRADLE_HOME&#125;/binexport PATH 保存后在终端输入source ~/.bash_profile回车执行让刚刚的配置生效。然后命令行输入gradle -v查看是否安装成功。 12345678910111213$ gradle -v------------------------------------------------------------Gradle 2.14.1------------------------------------------------------------Build time: 2016-07-18 06:38:37 UTCRevision: d9e2113d9fb05a5caabba61798bdb8dfdca83719Groovy: 2.4.4Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015JVM: 1.8.0_111 (Oracle Corporation 25.111-b14)OS: Mac OS X 10.12.2 x86_64 有用的信息 您可以每两个月通过Gradle核心工程师免费注册现场培训 我们的指南和参考文件制作了很好的阅读材料 您可以使用构建扫描来可视化和调试您的构建 该摇篮通讯是跟上最新与制作月度问题的好方法 命令行完成脚本可用于bash和zsh Gradle在所有主要操作系统上运行，只需要安装Java JDK或JRE版本7或更高版本。检查，运行java -version： 12$ java -versionjava version &quot;1.8.0_121&quot; 安装gradle与包管理器一起安装安装SDKMAN安装SDKMAN！在类UNIX平台上一样简单。SDKMAN！在Mac OSX，Linux，Cygwin，Solaris和FreeBSD上顺利安装。我们也支持Bash和ZSH shell。只需打开一个新的终端并输入： 1$ curl -s &quot;https://get.sdkman.io&quot; | bash 按照屏幕上的说明完成安装。接下来，打开一个新的终端或输入： 1$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot; 最后，运行以下代码片段以确保安装成功： 1$ sdk version 如果一切顺利的话，应该显示版本。就像是： 1sdkman 5.0.0+51 卸载SDKMAN在不太可能发生的情况下，您想要卸载SDKMAN！，我们还没有自动执行此操作的方法。如果你确实想把它从你的系统中删除，那么这样做很容易。下面将指导你完成备份，然后从系统中删除整个安装。 12tar zcvf ~/sdkman-backup_$(date +%F-%kh%M).tar.gz -C ~/ .sdkman$ rm -rf ~/.sdkman 最后一个步骤涉及编辑和您删除初始化片段 1.bashrc ， 1.bash_profile 和/或 1.profile 文件。如果您使用ZSH，请将其从 1.zshrc 文件中删除。要删除的代码片段如下所示： 12#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!![[ -s &quot;/home/dudette/.sdkman/bin/sdkman-init.sh&quot; ]] &amp;&amp; source &quot;/home/dudette/.sdkman/bin/sdkman-init.sh&quot; 一旦删除，您已经成功卸载SDKMAN！从你的机器。 安装SDKMAN到自定义位置可以安装SDKMAN！到一个自定义的位置以外 1$HOME/.sdkman 。这可以通过 1SDKMAN_DIR 在安装之前导出您的自定义位置来实现。 只需打开一个新的终端并输入： 1$ export SDKMAN_DIR=&quot;/usr/local/sdkman&quot; &amp;&amp; curl -s &quot;https://get.sdkman.io&quot; | bash 为了这个工作，至关重要的是你的用户有这个文件夹的完全访问权限。它也是重要的，该文件夹不存在作为SDKMAN！将尝试创建它。 自动安装gradle1$ sdk install gradle 4.5 Homebrew是“macOS缺少的包管理器”。 1$ brew install gradle Scoop是受Homebrew启发的Windows命令行安装程序。 1$ scoop install gradle chocolatey是“Windows的包管理器”。 1$ choco install gradle MacPorts是一个在macOS上管理工具的系统： 1$ sudo port install gradle 手动安装gradle下载最新的Gradle发行版目前的Gradle版本是在2018年1月24日发布的版本4.5。分发zip文件有两种版本： 仅限二进制 （sha256） 完整的文档和来源（sha256） 如果有疑问，请选择仅二进制版本，并在线浏览文档和来源。 解压分发Linux和MacOS用户解压缩您选择的目录中的分发zip文件，例如： 1234$ mkdir /opt/gradle$ unzip -d /opt/gradle gradle-4.5-bin.zip$ ls /opt/gradle/gradle-4.5LICENSE NOTICE bin getting-started.html init.d lib media Microsoft Windows用户C:\Gradle用文件资源管理器创建一个新目录。 打开第二个文件资源管理器窗口，并转到下载Gradle分配的目录。双击ZIP存档以显示内容。将内容文件夹gradle-4.5拖到新创建的C:\Gradle文件夹中。 或者，您可以C:\Gradle使用您选择的归档工具将Gradle发行版ZIP解压缩。 配置您的系统环境Linux和MacOS用户配置您的PATH环境变量以包含bin解压缩分发的目录，例如： 1$ export PATH=$PATH:/opt/gradle/gradle-4.5/bin Microsoft Windows用户在文件资源管理器中，右键单击This PC（或Computer）图标，然后单击Properties- &gt; Advanced System Settings- &gt; Environmental Variables。 在System Variables选择下Path，然后单击Edit。添加一个条目C:\Gradle\gradle-4.5\bin。点击确定保存。 验证您的安装打开控制台（或Windows命令提示符）并运行gradle -v以运行gradle并显示版本，例如： 12345$ gradle -v------------------------------------------------------------Gradle 4.5------------------------------------------------------------ 用Gradle包装器升级如果您现有的基于Gradle的版本使用Gradle Wrapper，那么可以通过运行wrapper指定所需的Gradle版本的任务轻松升级： 1$ ./gradlew wrapper --gradle-version=4.5 --distribution-type=bin 请注意，没有必要安装Gradle来使用Gradle包装器。下一次调用gradlew或gradlew.bat将下载并缓存指定版本的Gradle。 123$ ./gradlew tasksDownloading https://services.gradle.org/distributions/gradle-4.5-bin.zip... 弄一个HelloWorld看看创建一个test_gralde文件夹。然后在文件夹里面创建一个build.gradle文件。注意文件名不要乱起。在build.gradle中添加如下代码： 123456789task helloworld&#123; doLast&#123; println'Hello World!' &#125;&#125;#后者等同于下面的代码,task helloworld2 &lt;&lt;&#123; println "Hello World!"&#125; 然后来运行一下： 123456789liuqiangs-MacBook-Pro:test_gralde liuqiang$ gradle helloworld:helloworldHello World!BUILD SUCCESSFULTotal time: 1.52 secsThis build could be faster, please consider using the Gradle Daemon: https://docs.gradle.org/2.14.1/userguide/gradle_daemon.html 我们分析一下执行步骤。build.gradle是Gradle默认的构建脚本文件，执行Gradle命令的时候，会默认加载当前目录下的build.gradle脚本文件，当然你也可以通过 -b 参数指定想要加载执行的文件。这只是个最简单的task例子，后面详细介绍task的常见定义。 这个构建脚本定义一个任务（Task），任务名字叫helloworld，并且给任务helloworld添加了一个动作，官方名字是Action，阅读Gradle源代码你会到处见到它，其实他就是一段Groovy语言实现的闭包，doLast就意味着在Task执行完毕之后要回调doLast的这部分闭包的代码实现。第二个方法中的“&lt;&lt;”表示向helloworld中加入执行代码。至于语法部分，基本是Groovy语法（包括一些语法糖，也就是写简写方式，如果写个JavaScript或者Python会好理解一些，但是还是建议去读一下groovy的基本语法），加上一些DSL（domain specific language）的约定。 执行流程和基本术语和Maven一样，Gradle只是提供了构建项目的一个框架，真正起作用的是Plugin。Gradle在默认情况下为我们提供了许多常用的Plugin，其中包括有构建Java项目的Plugin，还有Android等。与Maven不同的是，Gradle不提供内建的项目生命周期管理，只是java Plugin向Project中添加了许多Task，这些Task依次执行，为我们营造了一种如同Maven般项目构建周期。 Gradle是一种声明式的构建工具。在执行时，Gradle并不会一开始便顺序执行build.gradle文件中的内容，而是分为两个阶段，第一个阶段是配置阶段，然后才是实际的执行阶段。配置阶段，Gradle将读取所有build.gradle文件的所有内容来配置Project和Task等，比如设置Project和Task的Property，处理Task之间的依赖关系等。 看一个基本结构的Android多Moudule（也就是gradle中的多Project Multi-Projects Build）的基本项目结构。 12345678910111213141516171819202122232425├── app #Android App目录│ ├── app.iml│ ├── build #构建输出目录│ ├── build.gradle #构建脚本│ ├── libs #so相关库│ ├── proguard-rules.pro #proguard混淆配置│ └── src #源代码，资源等├── module #Android 另外一个module目录│ ├── module.iml│ ├── build #构建输出目录│ ├── build.gradle #构建脚本│ ├── libs #so相关库│ ├── proguard-rules.pro #proguard混淆配置│ └── src #源代码，资源等├── build│ └── intermediates├── build.gradle #工程构建文件├── gradle│ └── wrapper├── gradle.properties #gradle的配置├── gradlew #gradle wrapper linux shell脚本├── gradlew.bat├── LibSqlite.iml├── local.properties #配置Androod SDK位置文件└── settings.gradle #工程配置 上面的是完整的AndroidStudio中的项目结构，我们抽象成Gradle多个Project的样子 1234567891011├── app │ ├── build.gradle #构建脚本├── module │ ├── build.gradle #构建脚本├── build.gradle #工程构建文件├── gradle│ └── wrapper #先不去管它├── gradle.properties #gradle的配置├── gradlew #gradle wrapper linux shell脚本├── gradlew.bat└── settings.gradle #工程配置 Gradle为每个build.gradle都会创建一个相应的Project领域对象，在编写Gradle脚本时，我们实际上是在操作诸如Project这样的Gradle领域对象。在多Project的项目中，我们会操作多个Project领域对象。Gradle提供了强大的多Project构建支持。 要创建多Project的Gradle项目，我们首先需要在根（Root）Project中加入名为settings.gradle的配置文件，该文件应该包含各个子Project的名称。Gradle中的Project可以简单的映射为AndroidStudio中的Module。 在最外层的build.gradle。一般干得活是：配置其他子Project的。比如为子Project添加一些属性。 在项目根目录下有个一个名为settings.gradle。这个文件很重要，名字必须是settings.gradle。它里边用来告诉Gradle，这个multiprojects包含多少个子Project（可以理解为AndroidStudio中Module）。 读懂Gradle配置语法Gradle向我们提供了一整套DSL，所以在很多时候我们写的代码似乎已经脱离了groovy，但是在底层依然是执行的groovy所以很多语法还是Groovy的语法规则。看一个AndroidStudio中app下的build.gradle的配置 12345678910111213141516171819202122232425apply plugin: 'com.android.application'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.0" defaultConfig &#123; applicationId "me.febsky.demo" minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:25.1.0'&#125; 分析第一行apply plugin: &#39;com.android.application&#39;这句其实是Groovy语法糖，像Ruby和Js都有这种语法糖，apply实际上是个方法，补上括号后的脚本：apply (plugin: &#39;com.android.application&#39;),看起来还是有点别扭是不？还有个语法糖，如果方法参数是个map类型，那么方括号可以省略，进一步还原apply([ plugin: &#39;com.android.application&#39;]),不理解的可以去看下Groovy的map的写法，和js一样。所以这行的意思是：apply其实是个方法，接收一个Map类型的参数。 总结两点：1. 方法调用，圆括号可以省略 2. 如果方法参数是个Map，方括号可以省略。 Groovy语言的闭包语法看上面的dependencies 这其实是个方法调用。调用了Project的dependencies方法。只不过参数是个闭包，闭包的用法在文章开始给出了链接。我们对其进行还原一下： 12345#方法调用省略了（）我们加上dependencies (&#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:25.1.0&apos;&#125;) 提示一点：如果闭包是方法的最后一个参数，那么闭包可以放在圆括号外面 12345#所以代码还能写成这样dependencies ()&#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:25.1.0&apos;&#125; Getter和SetterGroovy语言中的两个概念，一个是Groovy中的Bean概念，一个是Groovy闭包的Delegate机制。Java程序员对JavaBeans和Getter/Setter方法肯定不陌生，被设计用来获取/设置类的属性。但在Groovy中就不用那些没用的方法了。即Groovy动态的为每一个字段都会自动生成getter和setter，并且我们可以通过像访问字段本身一样调用getter和setter。比如Gradle的Project对象有个version属性（Property）下面这两行代码执行结果是一样的: 12println project.version // Groovy println(project.getVersion()) // Java Project，Task ，ActionGradle的Project之间的依赖关系是基于Task的，而不是整个Project的。 Project:是Gradle最重要的一个领域对象，我们写的build.gradle脚本的全部作用，其实就是配置一个Project实例。在build.gradle脚本里，我们可以隐式的操纵Project实例，比如，apply插件、声明依赖、定义Task等，如上面build.gradle所示。apply、dependencies、task等实际上是Project的方法，参数是一个代码块。如果需要，也可以显示的操纵Project实例，比如：project.ext.myProp = &#39;myValue&#39; Task:被组织成了一个有向无环图（DAG）。Gradle中的Task要么是由不同的Plugin引入的，要么是我们自己在build.gradle文件中直接创建的。Gradle保证Task按照依赖顺序执行，并且每个Task最多只被执行一次。 Gradle在默认情况下为我们提供了几个常用的Task，比如查看Project的Properties、显示当前Project中定义的所有Task等。可以通过一下命令行查看Project中所有的Task：$ gradle tasks （具体log不再贴出来）。可以看到，Gradle默认为我们提供了dependencies、projects和properties等Task。dependencies用于显示Project的依赖信息，projects用于显示所有Project，包括根Project和子Project，而properties则用于显示一个Project所包含的所有Property。 Tips: 查看Project中所有的Task：$ gradle tasks查看Project中所有的properties：$ gradle properties 在上面的build.gradle中加入如下代码： 12345678task myTask &#123; doFirst &#123; println &apos;hello&apos; &#125; doLast &#123; println &apos;world&apos; &#125; &#125; 这段代码的含义：给Project添加一个名为“myTask”的任务用一个闭包来配置这个任务,Task提供了doFirst和doLast方法来给自己添加Action。 其实build.gradle脚本的真正作用，就是配置一个Project实例。在执行build脚本之前，Gradle会为我们准备好一个Project实例，执行完脚本之后，Gradle会按照DAG依次执行任务。 自定义Task的写法看下面代码文件路径~/Test/build.gradle： 123456789#1task helloWorld &lt;&lt; &#123; println &quot;Hello World&quot;&#125;#2 Test文件夹下建一个src目录，建一个dst目录，src目录下建立一个文件，命名为test.txttask copyFile(type: Copy)&#123; from &quot;src&quot; into &quot;dst&quot;&#125; 第一个这里的helloWorld是一个DefaultTask类型的对象，这也是定义一个Task时的默认类型，当然我们也可以显式地声明Task的类型，甚至可以自定义一个Task类型。第二个代码中（type：Copy）就是“显式地声明Task的类型”，执行gradle copyFile test.txt也跑到dst中去了。 如果task声明在根Project的build.gradle中的allprojects()方法中，那么这个Task会应用于所有的Project。 task的依赖关系Gradle不提供内建的项目生命周期管理，只是java Plugin向Project中添加了许多Task，这些Task依次执行，为我们营造了一种如同Maven般项目构建周期。那么这些task是如何依次执行的这就用到声明的依赖关系taskA.dependsOn taskB看下面代码： 123456789task taskA &lt;&lt; &#123; println &apos;this is taskA from project 1&apos;&#125;task taskB &lt;&lt; &#123; println &apos;this is taskB from project 1&apos;&#125;taskA.dependsOn taskB 然后我们在命令行运行：$ gradle taskA运行结果会先执行taskB的打印，然后执行taskA的打印 如果是Muliti-Project的模式，依赖关系要带着所属的Project，如taskA.dependsOn &#39;:other-project:taskC&#39; 其中taskC位于和taskA不同的Project中，相对于AndroidStudio来说，就是位于不同的Module下的build.gradle中，而other-project为Module名字。 Task 的type可以自定义（没有深入研究）自定义Plugin的写法没有深入研究，给出一个网上的例子： 12345678910111213141516171819202122232425262728293031apply plugin: DateAndTimePlugindateAndTime &#123; timeFormat = &apos;HH:mm:ss.SSS&apos; dateFormat = &apos;MM/dd/yyyy&apos;&#125;class DateAndTimePlugin implements Plugin&lt;Project&gt; &#123; //该接口定义了一个apply()方法，在该方法中，我们可以操作Project， //比如向其中加入Task，定义额外的Property等。 void apply(Project project) &#123; project.extensions.create(&quot;dateAndTime&quot;, DateAndTimePluginExtension) project.task(&apos;showTime&apos;) &lt;&lt; &#123; println &quot;Current time is &quot; + new Date().format(project.dateAndTime.timeFormat) &#125; project.tasks.create(&apos;showDate&apos;) &lt;&lt; &#123; println &quot;Current date is &quot; + new Date().format(project.dateAndTime.dateFormat) &#125; &#125;&#125;//每个Gradle的Project都维护了一个ExtenionContainer，//我们可以通过project.extentions进行访问//比如读取额外的Property和定义额外的Property等。//向Project中定义了一个名为dateAndTime的extension//并向其中加入了2个Property，分别为timeFormat和dateFormatclass DateAndTimePluginExtension &#123; String timeFormat = &quot;MM/dd/yyyyHH:mm:ss.SSS&quot; String dateFormat = &quot;yyyy-MM-dd&quot;&#125; 每一个自定义的Plugin都需要实现Plugin接口，除了给Project编写Plugin之外，我们还可以为其他Gradle类编写Plugin。该接口定义了一个apply()方法，在该方法中，我们可以操作Project，比如向其中加入Task，定义额外的Property等。 原文地址 Gradle WrapperWrapper，顾名思义，其实就是对Gradle的一层包装，便于在团队开发过程中统一Gradle构建的版本，然后提交到git上，然后别人可以下载下来，这样大家都可以使用统一的Gradle版本进行构建，避免因为Gradle版本不统一带来的不必要的问题。（所以要明白这个东西可以没有，有了只是为了统一管理，更加方便） 生成wrappergradle 内置了生成wrapper的task，我们可以命令行下执行：$ gradle wrapper 生成后的目录结构如下(用过AndroidStudio的很熟悉了)： 123456├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat gradlew和gradlew.bat分别是Linux和Window下的可执行脚本，他们的用法和gradle原生命令是一样的，gradle怎么用，他们也就可以怎么用。在MacOS下运行$ ./gradlew myTask gradle-wrapper.jar是具体业务逻辑实现的jar包，gradlew最终还是使用java执行的这个jar包来执行相关gradle操作。 gradle-wrapper.properties是配置文件，用于配置使用哪个版本的gradle等 详细的看下gradle-wrapper.properties内容123456#Sat Jan 21 14:02:40 CST 2017distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-bin.zip 从上面内容和文件的名称都可以看出，这就是个java的配置文件,上面看到的是自动生成的，我们也可以手动修改。然后看下各个字段的含义： distributionBase 下载的gradle压缩包解压后存储的主目录 distributionPath 相对于distributionBase的解压后的gradle压缩包的路径 zipStoreBase 同distributionBase，只不过是存放zip压缩包的 zipStorePath 同distributionPath，只不过是存放zip压缩包的 distributionUrl gradle发行版压缩包的下载地址，也就是你现在这个项目将要依赖的gradle的版本。 生成wrapper可以指定参数 生成wrapper可以通过指定参数的方式来指定gradle-wrapper.properties内容。 使用方法如gradle wrapper –gradle-version 2.14这样，这样就意味着我们配置wrapper使用2.14版本的gradle，它会影响gradle-wrapper.properties中的distributionUrl的值，该值的规则是http://services.gradle.org/distributions/gradle-${gradleVersion}-bin.zip 如果我们在调用gradle wrapper的时候不添加任何参数呢，那么就会使用你当前Gradle的版本作为生成的wrapper的gradle version。例如你当前安装的gradle是2.10版本的，那么生成的wrapper也是2.10版本的。注：当前版本指的是环境变量中配置的那个版本。]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[晋升研究员，阿里十年他都经历了什么]]></title>
    <url>%2Fblog%2F1042.html</url>
    <content type="text"><![CDATA[在上海工作8年后，身为部门经理的钱磊，管理着一家ERP公司的百十来号员工，“再往上爬就是老板和他儿子了……从这个领域的技术角度来讲算是做到了顶。”05年，钱磊就开始关注一家名字奇怪，做事也奇怪的公司。 要不要折腾一下？2008年5月的一天钱磊对新婚的妻子说，想去杭州发展，那里有个公司叫阿里巴巴…… 阿里技术人钱磊 #侧面像马总，正面比马总帅# ——他的内网标签之一 01 不扒层皮，你怎么知道自己是谁？告别上海的家和妻子，钱磊拖着行李箱独自来了杭州。 豪情万丈地入职，不料压根没有“蜜月期”……“刚来的那两周，时时刻刻觉得自己是不是要背着包回上海了……”钱磊并不回避刚入职时的囧境。 “不舒服，压力大。在原来的公司里，我就是拍板的人，来了以后发现其它人都挺厉害的。端着架子放不下，总想着自己好歹也是在业内干了八九年的人，在这里被刚毕业一两年的工程师挑战……” 像他这样外地来杭的人，一般入职后就开始着手找房子，钱磊则是在宾馆里住了整整两周。 “那段经历对我来说还是蛮宝贵的，不是有句阿里土话嘛，当你觉得不舒服的时候，就是成长的时候。一个人四平八稳时，很难获得成长。” 02 主管搭了半条命，我学到了两个字“担当”“硬”着陆半个月后，扒了层“皮”的钱磊又被主管砸了块“石头”。 他们要用技术的手段彻底解决业务问题——为阿里巴巴最早的“产品后台”B2B的CRM做系统重构。这就好比开着汽车换引擎，百年老宅动地基…… “最重要的一个责任落在了我身上，研发框架。当时业务给我们的时间只有两个月。我用了两周时间搭框架、做论证。对于一个入职不久的新人来讲，挑战非常大。” 这种打仗的感觉，让钱磊渐渐忘记了自己是谁，业务在奔跑，系统延迟一天上线，影响就越大。每天几百人依靠这个系统工作。 “……我的主管被业务方总经理请去喝了两个小时的茶，他是把半条命都搭上了。做不好，没有退路。为了系统上线，当时还停了两天业务，对公司来说每一分钟都是损失。” 系统上线后虽然又经历了多次调试，但这是一次技术对业务的引领，而不是以往那样跟在后面打配合。因为框架的通用性还不错。直到现在，这套CRM还在使用。 把业务风险和技术风险搭在一起，并不是一个最好的选择，但却是当时唯一的选择。“我从主管身上学到了两个字‘担当’，这是一个管理者的气质。” 阿里管理者气质：担当 03 离开场景和业务的修炼都是伪命题接手用户权限中心的技术团队后，钱磊开始实打实地接触客户。在这几年里，他从偏技术的架构，转为偏业务的架构。“离业务太远，做出来的东西不是场景驱动，后续会有较多的问题。架构师别把自己修炼成仙了，给公司留下的却是与业务无关的垃圾。” 当时B2B的ICBU遇到了用户权益打包的问题，底层需要一个产品化的解决方案，“原来每年销售做完规划以后，技术同学都要算，会花掉多少人力去做一个新的产品配置。每次都靠研发同学冲到代码里面写一大堆。我们做了权益包功能后，只花几个小时就能配置好了。权益的产品化解决了ICBU的一个大问题。这又是一次技术引领业务的实例。” 阿里土话：业绩永远都是附属品 04 越想证明自己 死得越快两年前，钱磊调到共享平台，做会员和安全。他们团队从技术和产品端入手，解决了移动端与PC端会员整体链路兼容的问题。降低了一半与帐户相关的客服电话量。“现在帐户相关的客服量在7%左右，我们的目标是三年后降到0。” 从中间件到信息平台，再到共享平台，钱磊接的摊子越来越大，2015年，入职的第7年，他获得了一次提名晋升P10（研究员）的机会。 “面试的时候，自我感觉还不错，毕竟这几年也做了几件拿得出手的东西……”一个月后，钱磊却得知了自己晋升失败的消息。 “心里肯定有波动啊。”提起两年前的那次晋升面试，钱磊坦白：“我当时还请了两天假，出去放空了一下。想明白了几件事，第一，这几年我在阿里巴巴学到的东西是不是已经远远超出过去？第二，公司给予的平台和空间是不是足够我成长？第三，我为业务创造最大化的价值了吗？当我连续问了自己几个问题后，一下子就看透了。证明自己没什么大意思，给业务和用户创造价值才是最踏实的。越想证明自己的人，死得越快。” 阿里土话：总是想要证明自己时，就没有了投入工作的心态 05 善于总结才能获得加速度钱磊觉得自己这九年来做得最正确的事，就是坚持总结和反思。“我几乎每个月都会给自己留出做总结的时候，这个月自己和团队做了什么事，还有哪些提升空间。一定要趁热打铁记录下来，反思能让我保持头脑的清晰。 我觉得一个不善于总结的人，就是在吃老本，吃惯性，吃你的智商和知识。反思就是获得加速度的那个点。这是工作多年来，让我最受益的一个习惯。” 06 技术人千万别陷在技术的圈子里钱磊在自己的内网签名里写着“知行合一”四个字。身为技术男，在业务相关的书之外，他独爱王阳明和南怀瑾，“王阳明的知行合一，是我的座右铭，倾听内心的声音，力量强大。南怀瑾的《庄子》我读了好几遍，佩服他为人的格局。我觉得技术同学特别需要打开思路，千万不要局限在技术这个圈子里。要有自己丰富的阅历，去看很多东西，触类旁通，在某些时候形成链接，对你的技术思考、业务思考都有帮助。” 阿里土话：成长是自己的事 07 好奇心与三个Why带了七八年团队，最多的时候钱磊一年要参加50多场面试，有招聘新人的，也有晋升的。他选人用人会特别看重对方的心态： “我觉得心态非常重要，我们面试人的时候，一定要去看他的进取心和好奇心。我觉得这两者是面向未来的能力。 我会问三个Why：为什么这样做？这样做背后有什么问题和思考？你的业务价值支撑点是什么？我对技术同学的要求是：至少你自己做的事儿，如果到‘P7’这个级别，一定是问不倒的，一定经得起我问三个‘为什么’。如果你经不起问的话，我认为你做这个事要么是需求驱动，要么你就是一个吃瓜群众。我非常在意一个人的独立思考能力。” 终极三问，why,how,who 08 一个计较KPI的主管肯定会带出一个计较KPI的团队 钱磊说自己的管理之道就是四个字“言传身教”，“首先，要做好自己，不要对别人要求很高，对自己要求很低。再有，你是业务驱动、客户价值驱动，还是KPI驱动？一个天天计较自己KPI的人，肯定带不出一个不计较KPI的团队。 我们团队的KPI很简单，就是回归到业务场景。我的KPI已经连续几年都是以客服量为衡量点。你这个产品怎么样，上了多少功能，都不是最主要的因素，关键是你最终解决了客户的什么问题。客户用脚来投票。我会带着团队的D（业务负责人）一起review团队的KPI。 阿里土话：刚工作的几年比谁更踏实，再过几年比谁更激情 09 人生没有白走的路2017年7月，钱磊通过“绿色通道”（免试）晋升为P10（研究员），既在意料之中，又在意料之外。尽管不做要求，他还是准备了一个简单的PPT，那是写给自己的9年总结。 钱磊的办公桌面一如典型的技术男那样简单。桌上摆着他5岁女儿的照片。问起他印象最深刻的一个瞬间，他不加思索地回答：“2015年双11，连续熬了两个通宵后，11月13日的凌晨，我走到园区一号楼取车，眼前的夜空很美，身后是灯火通明的楼宇。就是一种很幸福的感觉。我，在这里，和大家在一起。我们和这家公司，挺伟大的……” 这就是一个阿里技术男的成长史。哪有那么多成长快乐，每一步都不是白走的路。你怎样选择和对待人生，人生就怎么样待你。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hybrid app技术开发APP应用]]></title>
    <url>%2Fblog%2F3405.html</url>
    <content type="text"><![CDATA[hybrid app技术开发APP应用。而现在主流的Hybrid app框架是phonegap。在使用phonegap做混合式开发之前需要下载很多软件及插件。如：JavaJDK、node.js、cordova、ionic、Android studio、AndroidSDK等软件及相应的插件。（请不要下载phonegap应用程序，不要混淆）下面就来简单介绍一下，如何安装cordova和ionic及常用的命令总结。 第一部分 安装时总结win系统下nodejs安装及环境配置第一步：下载nodejs官网：http://nodejs.org/download/ 第二步：安装nodejs 下载完成之后，双击”node-v0.10.28-x86.msi”，开始安装nodejs，自定义安装在D:\dev\nodejs下面。 在cmd控制台输入：node -v，控制台将打印出：v0.10.28，出现版本提示表示安装成功。 该引导步骤会将node.exe文件安装到D:\dev\nodejs\目录下，并将该目录添加进PATH环境变量。 第三步：npm安装由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以使用cmd命令行输入”npm -v”来测试是否成功安装。出现版本提示表示安装成功。 第四步：安装相关环境npm install -g express-generator npm install jade -g npm install mysql -g 默认情况下上述组件都是安装在D:\dev\nodejs\node_modules文件夹下，这也是nodejs相关组件的自动查找路径。 第五步：安装CoffeeScript1npm install coffee-script -g 确认安装的命令：coffee -v，出现版本号表示成功安装。 补充说明：所有命令都是-g进行全局安装的，这样安装的安装包都在当前用户下，在磁盘的所有其他地方都可以访问到，比较方面。否则安装在当前目录下，只能在当前目录下使用。 安装express问题安装nodejs安装包后，通过npm安装express后，运行express提示” express”不是内部或外部命令，原因是版本问题，当前版本是4.0.0，改成3.5.0即可运行。 1npm install -g express@3.5.0 注意：express 测试版本用大写V npm命令集合： npm install moduleNames：安装Node模块 npm install express默认会安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本，如npm install express@3.0.6 npm install -g将包安装到全局环境中 但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的，就好像全局安装了vmarket后，就可以在命令行中直接运行vm命令 npm install –save安装的同时，将信息写入package.json中项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了。 全局安装命令为npm install -g moduleName。 npm view moduleNames：查看node模块的package.json文件夹 npm list：查看当前目录下已安装的node包 npm help：查看帮助命令 npm view moudleName dependencies：查看包的依赖关系 npm view moduleName repository.url：查看包的源文件地址 npm view moduleName engines：查看包所依赖的Node的版本 npm help folders：查看npm使用的所有文件夹 npm rebuild moduleName：用于更改包内容后进行重建 npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新 npm update moduleName：更新node模块 npm uninstall moudleName：卸载node模块 一个npm包是包含了package.json的文件夹，package.json描述了这个文件夹的结构。访问npm的json文件夹的方法如下： $ npm help json 此命令会以默认的方式打开一个网页，如果更改了默认打开程序则可能不会以网页的形式打开。 发布一个npm包的时候，需要检验某个包名是否已存在 $ npm search packageName npm init：会引导你创建一个package.json文件，包括名称. 版本. 作者这些信息等 npm root：查看当前包的安装路径 npm root -g：查看全局的包的安装路径 npm -v：查看npm安装的版本 npm install –save moduleName 安装模块到本目录 更多命令请参看npm官方文档：https://www.npmjs.org/doc/ npm install -g cnpm –registry=https://registry.npm.taobao.org（npm镜像源指向淘宝） cnpm install -g cordova ionic（安装cordova ionic） cnpm update -g cordova ionic（更新cordova ionic） ionic -help（查看帮助） ionic -v（查看版本） ionic start myApp blank（空项目） ionic start myApp tabs（带导航条） ionic start myApp sidemenu（带侧滑菜单） ionic platform add android（添加android平台） ionic platform remove android（移除android平台） ionic build android（编译项目apk） ionic emulate android（运行项目apk 手机连接在手机运行 模拟器连接在模拟器运行） ionic run android （相当于build + emulate） ionic serve （开启服务调试） ionic build ios（编译项目ipk） ionic emulate ios（运行项目ipk） 第六步：创建项目express /tmp/foo &amp;&amp; cd /tmp/foo npm install //下载依赖包 npm start //启动项目 目录介绍: node_moduls 存放所有的项目依赖库 package.json 项目依赖配置及开发者信息 app.js 程序启动文件 public 静态文件（css js img） routes 路由文件（MVC中的C，controller） Viesws 页面文件（Ejs模板） 第七步 创建cordova项目（注意：当第一次创建或编译项目的时候，可能系统会自动下载一些东西，需要一些时间。） 在某个目录下创建cordova项目，打开命令行 输入： 1cordova create test com.cordova.test test （创建cordova工程 &lt;文件夹名&gt; &lt;包名&gt; &lt;app名&gt;） 文件夹目录 hooks：存放自定义cordova命令的脚本文件。每个project命令都可以定义before和after的Hook，比如：before_build、after_build。没用过，不展开了。 platforms：平台目录，各自的平台代码就放在这里，可以放一下平台专属的代码，现在这个目录应该是空的，后面会介绍如何创建平台。 plugins：插件目录，安装的插件会放在这里。后面会有专门的文章介绍开发插件。 www：最重要的目录，存放项目主题的HTML5和JS代码的目录。app一开始打开的就是这个目录中index.html文件。 config.xml：主要是cordova的一些配置，比如：项目使用了哪些插件、应用图标icon和启动页面SplashScreen，修改app的版本，名字等信息，还有平台的配置。 添加平台支持 用命令行打开对应的文件夹， 添加平台 输入： 1cordova platforms add android 移除平台 输入： 1cordova platforms rm android （移除android平台支持） 也可以通过@版本号，来添加不同版本的android平台，如： 1cordova platforms rm android @4.1.1 现在就可以在www文件夹内写自己的js和html代码了。 添加插件 输入: 1cordova plugin add cordova-plugin-file (cordova plugin add &lt;插件官方名称&gt;) 插件搜索地址：http://cordova.apache.org/plugins/ 也可以通过github查找一些第三方插件 输入： 1cordova plugin add https://github.com/phonegap/phonegap-plugin-barcodescanner.git //这个是扫描二维码插件 (github项目地址) github地址：https://github.com/ 删除插件 输入： 1cordova plugin rm cordova-plugin-file （使用rm和remove都可以） 插件列表 输入： 1cordova plugin list （查看当前安装了哪些插件） 编译调试程序 不是每一句代码都需要运行，根据自己的需求进行选择。 cordova install android //将编译好的应用程序安装到模拟器上。 cordova emulate android //在模拟器上运行（前提是创建好AVD） cordova serve android //在浏览器运行 cordova build android //打包cordova项目到android平台。 cordova run android //通过USB直接安装到真机（该语句已经包括了build命令） 例如：我现在是手边直接连着测试手机，所以我就会直接用cordova run android 中间省略… 出现LAUNCH SUCCESS则编译成功，已经安装到手机上了。 第八步 安装Android SDK 下载Android SDK，点击安装，直接默认路径即可！ 下载地址：http://developer.android.com/sdk/index.html 默认路径安装后，安装完成，开始配置环境变量。 打开计算机属性——高级系统设置——环境变量（如上文） 新建一个环境变量，变量名：ANDROID_HOME，变量值：C:\Program Files (x86)\Android\android-sdk（以你安装目录为准,确认里面有tools和add-ons等多个文件夹），点击确认。 在变量PATH后面加上变量值%ANDROID_HOME%\tools;点击确认即可。 如果没有这个变量，新建一个即可！新建方法见上文！ Android SDK配置完成，接下来验证配置是否成功。 点击运行——输入cmd——回车——输入android -h——回车 ionic Android 环境搭建过程遇到的问题 http://bbs.ionic-china.com/read.php?tid=7&amp;fid=4 第九步 安装Ionic 执行npm install -g ionic 创建一个Ionic APP 执行ionic start myapp[template]Template 有如下三种 默认是tabs project:tabs（默认）. sidemenu. blank 安装模板 ionic install –save 模板 cordova 是页面与设备桥接 npm install –save bower 第十步 安装gulp相关代码合并. 混淆工具npm install gulp npm install gulp-concat:合并文件 npm install gulp-rename:重命名文件 npm install gulp-sass:支持sass npm install gulp-minify-css:压缩css npm install gulp-connect 配置一个web服务器 第十一步 编译测试 android版本 cd myapp ionic platform add android ionic build android ionic run android 如果要在虚拟机中测试，可以改用 ionic emulate android ios版本 $ ionic start myapp tabs $ cd myapp $ ionic platform add ios $ ionic build ios $ ionic emulate ios 浏览器同时修改端口号 cd myapp ionic serve -p 8105 连接数据线直接测试 ionic run android 重点集合ionic安装失败或者cordova安装失败解决方法镜像使用方法（三种办法任意一种都能解决问题，建议使用##### 第三种，将配置写死，下次用的时候配置还在）: 通过config命令 npm config set registry https://registry.npm.taobao.org npm info underscore （如果上面配置正确这个命令会有字符串response） 命令行指定 npm –registry https://registry.npm.taobao.org info underscore 编辑 ~/.npmrc 加入下面内容 registry = https://registry.npm.taobao.org 搜索镜像: https://npm.taobao.org 建立或使用镜像,参考: https://github.com/cnpm/cnpmjs.org 使用cnpm(强烈建议) 安装cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org 以后所有的npm可用cnpm代替，如:cnpm install ionic 如果还是一直失败，将ionic文件下载解压后放到C:\Users\Auser\AppData\Roaming\npm\node_modules中 配置环境变量 node的npm命令Path : C:\Documents and Settings\Administrator\Application Data\npm 补齐npm文件夹下有关于ionic的文件 http://download.csdn.net/detail/superjunjin/8417723 补齐ionic项目下node_modules等文件 http://download.csdn.net/detail/superjunjin/8417731（具体文件见最后的压缩包） 12ionic start myApp sidemenu //创建带有左侧带有menu栏的示例项目ionic start myApp blank //创建空白项目 第二部分 开发过程总结Angular 提供3种方法创建并注册服务 Provider Factory Service Providers 是唯一一种你可以传进 .config() 函数的 service。当你想要在 service对象启用之前，先进行模块范围的配置，那就应该用 provider。 bower安装restangular失败（报错：Bower : ENOGIT git is not installed or not in the PATH） 添加git路径到环境变量PATH中（命令：set PATH=%PATH%;D:\Program Files\Git\bin） 运行bower install restangular 即可安装成功 http://www.ng-newsletter.com/posts/restangular.html restangular文档：https://github.com/mgonto/restangular#element-methods 安装bower install underscore restangular需要用到的js(js少引入报错：Uncaught ReferenceError: _ is not defined from restangular) 12&lt;script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.jsdelivr.net/restangular/latest/restangular.min.js"&gt;&lt;/script&gt; 跨域错误解决办法（XMLHttpRequest cannot load ‘’. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘ ‘ is therefore not allowed access. ） Java代码中返回结果集前增加 1response.setHeader("Access-Control-Allow-Origin", "*"); 国际化 http://yijiebuyi.com/blog/3b55056c87b73ba606c19e9338dca679.html 安装bower install angular-translate 安装bower install angular-translate-loader-static-files angular国际化不存在乱码，如果出现乱码可能是中文json文件编码非UTF-8格式 国际化使用（移动端有问题 无法使用）： 需要引入JS 123&lt;script src="lib/angular/angular.js"&gt;&lt;/script&gt;&lt;script src="lib/angular-translate/angular-translate.js"&gt;&lt;/script&gt;&lt;script src="lib/angular-translate-loader-static-files/angular-translate-loader-static-files.js"&gt;&lt;/script&gt; 建立文件夹i18n存放cn.json /en.json 12en.json：&#123;&quot;100001&quot;:&quot;Login&quot;,&quot;100002&quot;:&quot;Register&quot;&#125;cn.json：&#123;&quot;100001&quot;:&quot;登录&quot;,&quot;100002&quot;:&quot;注册&quot;&#125; 在app.js中config里配置如下 123456//国际化配置$translateProvider.preferredLanguage('cn');$translateProvider.useStaticFilesLoader(&#123; prefix: '/i18n/', suffix: '.json'&#125;); html页面使用 1234567&#123;&#123;'100001' | translate &#125;&#125;5.按钮切换语种.controller('LanguageSwitchingCtrl', ['$scope', '$translate', function (scope, $translate) &#123;scope.switching = function (lang) &#123; $translate.use(lang); &#125;;&#125;]); AngularJS iframe跨域打开内容时报错误的解决办法1&lt;iframe id="myFrame" ng-src="&#123;&#123;url&#125;&#125;" width="100%" height="100%" seamless frameborder="0" &gt;&lt;/iframe&gt; 打开不同域的内容时报下面的错误Blocked loading resource from url not allowed by $sceDelegate policy 解决方案： 1234567app.config(function($sceDelegateProvider) &#123; $sceDelegateProvider.resourceUrlWhitelist([ // Allow same origin resource loads. 'self', // Allow loading from our assets domain. Notice the difference between * and **. 'http://media.w3.org/**']);&#125;);]]></content>
      <categories>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的Bind，Call和Apply]]></title>
    <url>%2Fblog%2F55294.html</url>
    <content type="text"><![CDATA[js 中的 上下文 Context，可以说是一个，你即使不知道，没听过，也不影响你继续写 js 代码的一个概念。但是，它又确确实实是无所不在的一个东西，是的，无所不在。 上下文解释所谓上下文，它是用来存储系统的一些初始化信息，例如在jboss中通过配置文件指定了数据源，那么在jboss启动的时候就把这个文件的相关信息上下文中，于是在我们使用这个数据源的时候，就需要先获得系统的上下文，然后再通过一定的方式将数据源取出来。至于在系统启动时，是如何将这些初始化信息加载到上下文中，而上下文在程序中具体又是以什么形式体现的，应该随着系统的不同而不同。 上下文即ServletContext,是一个全局的储存信息的空间，服务器启动，其就存在，服务器关闭，其才释放。所有用户共用一个ServletContext。所以，为了节省空间，提高效率，ServletContext中，要放必须的、重要的、所有用户需要共享的线程又是安全的一些信息。如，做一个购物类的网站，要从数据库中提取物品信息，如果用session保存这些物品信息，每个用户都访问一便数据库，效率就太低了；所以要用来Servlet上下文来保存，在服务器开始时，就访问数据库，将物品信息存入Servlet上下文中，这样，每个用户只用从上下文中读入物品信息就行了。 获取ServletContext的方法： 12HttpSession session = request.getSession(); session.getServletContext(); 从我自己的经验来看，对上下文的认识，算是分成了三个阶段，每一个阶段，都让我从外在的表现中，理解了一些更本质上的东西。 1. 第一阶段，不知我最开始接触 js 的时候，看到了它的 new ，看到了它的 this ，很自然地会把 js 和其它的一些 OOP 语言等同起来看待，并且，好像，也是这么回事。比如： 12345678910var Class = function(a)&#123; this.a = a; this.add = function()&#123; this.a++; &#125;&#125;var ins = new Class(1);ins.add();console.log(ins.a); //2 上面的代码，可以按预期的那样，最后得到 2 的输出。 但是，如果仅仅是 类，实例 这种层面的认识，我无法解释下面的问题： 1234var ins = new Class(1);var func = ins.add;func();console.log(ins.a); //1 甚至解释不清楚下面的代码： 12345678var obj = &#123; a: 1, add: function()&#123; this.a++; &#125;&#125;obj.add();console.log(obj.a); //2 这里可没有 类 ，也没有 实例 。 我上面的最开始对 js 的认识当中，局限就在于，把 this 理解成了 实例 。也许在其它语言中（比如 Python 常用的实例方法第一个参数 self），是这样。但是在 js 中， this 跟 实例 完全没有关系。 2. 第二阶段，this当我明白问题出在 this 上，或者说，当我终于理解了 this 这个东西之后，上面的代码，再也不会困扰我了。 我知道了， js 中有一个东西叫 上下文 ，可惜的是，这时，我对上下文的概念，仅仅停留在 this上。 这时我的理解是： this 表示的是，函数调用时的 上下文 。 说得详细一点，就是 this 不是表示的 实例 ，而是函数调用时的 上下文 。 上下文 这个东西，默认是 window ，即 全局 。但是，你可以明确地为函数指定一个 上下文 。回到 this 上，就是在定义时你根本不知道 this 是什么，因为在调用时，它可以是任何东西（因为 上下文 是可以人为指定的）。 回到刚开始的代码： 12345678910var Class = function(a)&#123; this.a = a; this.add = function()&#123; this.a++; &#125;&#125;var ins = new Class(1);ins.add();console.log(ins.a); //2 这段代码的结构之所以是 2 ，不是因为 实例 ，而是因为 上下文 。 首先说一下 new 。 new 在 js 中，不考虑原型链它的作用，相当于是先创建了一个空的对象，然后把这个空的对象，作为 构造函数 的 上下文 ，再去执行 构造函数 ，最后再返回这个当初的空对象。即： 12345678910111213141516var what_new = function(func, a)&#123; var context = &#123;&#125;; func.apply(context, [a]); return context;&#125;var Class = function(a)&#123; this.a = a; this.add = function()&#123; this.a++; &#125;&#125;var ins = what_new(Class, 1);ins.add();console.log(ins.a); 当然， new 除了上面的 func.apply 的作用之外， 它还会处理原型链 ，这里就不介绍了。上面的代码仅是为了说明 new 对于所谓的构造函数做了什么事。 有了上下文，就不难解释 ins 这个东西了。所谓的构造函数，只是在指定了 this 到底是哪一个对象之后，作了相应的赋值操作而已，最后得到这个对象的返回，经过了一些赋值操作，对象中就有了新的东西了。 同样，对于一个在定义时包含了 this 的函数，比如前面的例子： 123456var obj = &#123; a: 1, add: function()&#123; this.a++; &#125;&#125; 如果来一句： 123var func = obj.add;func(); //undefinedfunc.apply(&#123;a: 0&#125;) //1 这些都很容易明白了。 js 中的函数，都是一些很单纯的函数，所有的函数跟它在哪里定义完全没有关系（考虑闭包的情况除外）。所以上面的代码，虽然 add 函数是写在 obj 中的，但是，它跟你在 window 中写一个函数是 完全一样 的： 12345var add = function()&#123;this.a++&#125;var obj = &#123; a: 1, add: add&#125; 既然 add 函数中有 this ，那么这个函数执行时的行为，就要小心一点了。所以上面明确地指定了一个上下文给它 func.apply({a: 0}) 。 还是回到开始的代码： 123456var obj = &#123; a: 1, add: function()&#123; this.a++; &#125;&#125; 对于上面的代码，我知道了： 1obj.add(); 和： 12var func = obj.add();func(); 会得到不一样的结果。并且知道，这个不一样的结果是上下文引起的，还知道，后者 func() 执行时，上下文是全局的 window 了。 我虽然知道是这样的一个情况，但是，为什么？执行同一个函数结果怎么就不一样了呢？ 我在很长时间里，都没有去细细考虑过这个问题。不过，因为知道了“上下文是一个在定义时无意义，其具体值完全由执行时决定”这点之后，我都尽量避免去使用 this ，实在要用，在调用时，我都会通过 apply 或 call 明确指定上下文，这样，至少不会踩坑里。 3. 第三阶段，一切都是上下文某天，我在网上看到了这样一段代码（原始出处不知道）： 1var bind = Function.prototype.call.bind(Function.prototype.bind) 这个新定义的 bind 函数具体做什么事先不管它，我好奇的是 call.bind() 这个调用。因为 call 这个函数，之前一直以为它是 Function 对象的一个方法（它本身也是一个函数），但是，如果按“对象的方法”这个角度去想的话，那对它绑定一个上下文（ bind() 的调用 ）不就完全没有意义了么？（因为对象的方法应该是跟上下文无关的） 不久之前，我在一条tweet上看到了这样一段js代码： 1var bind = Function.prototype.call.bind(Function.prototype.bind); 第一眼看上去，我能猜出它究竟是用来做什么的。它把x.y(z)转化成了y(x,z)。我欣喜万分的给我的同事看这段代码。他们问我这是什么意思。而我当我正要开口向他们解释时却发现不知道怎么说才好。我徘徊了一会然后郁闷的走开了。 编写良好的代码会向人们传达它的作用。在读完Functional Javascript和 JavaScript Allongé （两本都是相当好的书）这两本书之后，再加上我在Javascript函数式编程方面有些经验，弄懂上面这段代码的意思毫无压力。但是应该怎么向没有函数式编程经验的人解释呢（正如大多数人关心的那样）？ 我决定亲自来完成这个任务，通过简单地例子和注释。我的结果如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 //设立一个简单地对象作为“上下文”var context = &#123; foo: "bar" &#125;;//一个在this上下文中指向foo变量的函数function returnFoo () &#123; return this.foo;&#125;// 变量在作用域中不存在，因此显示undefinedreturnFoo(); // =&gt; undefined// 如果我们把它绑定在context上下文中var bound = returnFoo.bind(context);// 现在的作用域中有这个变量了bound(); // =&gt; "bar"//// 这就是Function.prototype.bind的作用. //由于returnFoo也是函数，因此它继承了function的原型//// 如果你觉得享受，接着往下读，下面更精彩//// 有许多方法将函数绑定在一个上下文中// Call和Apply让你能在上下文中调用函数returnFoo.call(context); // =&gt; barreturnFoo.apply(context); // =&gt; bar// 将函数添加到对象中context.returnFoo = returnFoo;context.returnFoo(); // =&gt; bar//// 现在我们来玩一点诡异的东西//// Array.prototype 中有一个叫做slice的方法// 对一个数组调用slice，可以返回一个从start index到end index的数组[1,2,3].slice(0,1); // =&gt; [1]// 因此我们把Array.slice赋值给一个本地变量slicevar slice = Array.prototype.slice;//现在的slice是"自由的"，由于Array.prototype中的slice一般指定了上下文//或者默认为this,此时slice将不起作用slice(0, 1); // =&gt; TypeError: can't convert undefined to objectslice([1,2,3], 0, 1); // =&gt; TypeError: ...// 但是如果我们使用call或者apply，slice又将在一个上下文中执行slice.call([1,2,3], 0, 1); // =&gt; [1]// Apply和Call差不多，知识参数要放在一个数组中slice.apply([1,2,3], [0,1]); // =&gt; [1]// 使用call没错了，那么能不呢使用bind呢？// 没错，我们来把"call"绑定在slice上slice = Function.prototype.call.bind(Array.prototype.slice);// 现在slice可以把第一个参数作为上下文了slice([1,2,3], 0, 1); // =&gt; [1]//// 很酷，对吧。现在再来完成一件事//// 现在我们对bind本身做一件刚才对silce做的事var bind = Function.prototype.call.bind(Function.prototype.bind);// 在这里总结一下，好好想想// 发生了什么事? 我们改变了call，// 返回一个接收一个函数和一个上下文作为ic桉树的函数//并且返回了一个完全绑定的函数// 回到最初的例子var context = &#123; foo: "bar" &#125;;function returnFoo () &#123; return this.foo;&#125;// 现在来使用神奇的"bind"函数var amazing = bind(returnFoo, context);amazing(); // =&gt; bar 其中以 slice 函数举的例子让我恍然大悟： 上下文控制不仅仅是 apply / call，所有的点 . ，都是在指定上下文。 js 中的函数比我想像的还要纯，根本没有“对象中的方法”这个东西，即使是“原生对象”中。（它仅仅起一个名字空间的作用） 所有的函数调用，都有两层意义，比如 c.f()： f 这个函数，它在 c 中。（名字空间的问题） 把 c 作为 f 的上下文，去调用 f 。（前提是 f 没有绑定过上下文） 如果 c 没有，则默认是 window 。 所有的，js 中所有的函数调用，都是如此。即使是 f.call(context, x) ，我之前只看到了第一层意义（ f 中有一个 call 方法可以使用），则忽略了第二层意义 —— 把 f 作为 call 的上下文。 简单来说，我们可以相像 call 这个函数，它的代码大概是这样的（可变参数的问题先不管）： 1234var call = function(context, a)&#123; var new_func = this.bind(context); retur new_func(a);&#125; 它的作用，就是把 指定的上下文（context） 作为 自己的上下文（this） 的 上下文 ，然后再调用 自己的上下文（绑定上下文之后的 this） 。 上面一句话有些纠结哈，主要搞明白多种上下文的关系， f.call(context, x) 当中， 自己的上下文上面是 f 。 指定的上下文 上面是 context 。 再看 f.call(context, x) 这个代码，结合“函数是单纯”这点，我想到，即使是原生对象的那些方法， 也不过是把一些单纯的函数放到了 prototype 中而已 ，比如把 call 函数放到了 Function.prototype 当中。 至此，再看 c.f() ， a.b.c() 这些，不要去想是调用 c 对象中的 f 方法（这么说没错，但是名字空间的问题是显而易见的嘛），而是想成，调用时把 c 作为 f 的上下文。 好了，回到开始的那行例子： 1var new_bind = Function.prototype.call.bind(Function.prototype.bind) 这个就非常好理解了（为了描述方便，我改成 new_bind 了），把 bind 作为上下文绑定到 call中。 这里注意一下，绑定了上下文的 call 函数，还是 call 函数，但是 “此 call 已经非彼 call” 了。 所以： 1new_bind != Function.prototype.call 虽然调用形式上， new_bind 和 call 完全一样，但是他们的上下文行为不一样： call 是未绑定状态，所以 f.call() 会在执行时把 f 作为上下文绑定到 call 函数中。 new_bind 是已绑定状态，所以 f.new_bind() 对 new_bind() 的执行完全没影响。 我们可以以这样的流程来帮助我们理解： 1new_bind =&gt; call =&gt; bind.call =&gt; bind.call(f, context) =&gt; f.bind(context) 一步一步解释： new_bind =&gt; call new_bind 在形式上就是 call 。 call =&gt; bind.call 只是这个 call ，是指定了 bind 作为它的上下文的。既然是 bind 作为它的上下文，那我们可以写成是 bind.call 的样式。 bind.call(f, context) =&gt; f.bind(context) new_bind 的调用 new_bind(f, context) 就相当于是 bind.call(f, context) 。考虑 call 函数之前的行为： f.call(context, a) 是把 context 作为 f 的上下文，也就是 context.f(a) ，那么 bind.call(f, context) 对应的就是 f.bind(context) 。 f.bind(context) 不用多说了吧，把 context 绑定到 f 上，返回一个绑定了上下文的新函数。 完全是最基本的代数推导嘛，形式上，上下文前置总是没有问题的。 4. 结语我一直认同，要理解 js 的东西，从函数式语言入手，非常合适。硬要往面向对象的那套东西上套，太纠结了（我不管概念上到底什么样才叫面向对象，原生没有类定义，没有继承，没有实例化，就别扯这些就完了。对了，我认为原型追溯那不叫继承哈）。 当然，我不知道弄明白了最后那个“代数推导”到底有什么好处，也许没有，因为就算不明白这些也不影响我写了很多可以正常工作的 js 代码嘛。只是，我以后再写，思路上的可能会有一些不同了。比如代码组织的形式上，可以尝试把很多的小函数做到不同的“名字空间”中，然后再在业务层面，通过 Mixin 来拼出不同的业务对象。这些函数中可能到处充斥着 this ，我能控制好它们了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs技术]]></title>
    <url>%2Fblog%2F39022.html</url>
    <content type="text"><![CDATA[前端技术的发展是如此之快，各种优秀技术、优秀框架的出现简直让人目不暇接，紧跟时代潮流，学习掌握新知识自然是不敢怠慢。 AngularJS这是一个AngularJS Guide的中文分支版本，提供关于AngularJS的视频、入门、使用与论坛等中文互联网内容，这里的分类并没有完全参照英文版，也并不固定，如果你有发现新的内容需要添加新类别，直接加吧。 视频 Angular教学视频youku转载 入门指南 使用AngularJS构建大型Web应用 AngularJS入门教程 AngularJS学习笔记 使用经验 AngularJS开发一些经验总结 再谈AngularJS DI(Dependency Injection) Angularjs的IOC Inject分析 细说Angular ng-class AngularJS Controller 间通信机制 AngularJS表达式-Expression AngularJS关于依赖和模块与amd/cmd的区别，分享下结合使用示例 搞懂 AngularJS 預設模組 select 標籤的 ngOptions 參數用法 如何讓 Visual Studio 2012 支援 AngularJS 的 Intellisense 如何组织大型JavaScript应用中的代码？ 论坛 AngularJS中文社区 angulargirl 繁体中文翻译 学习AngularJS译者: 这是jmcunningham/AngularJS-Learning的简体中文翻译 我会尽量依照原文翻译 某些专有名词就不另外翻译 如果翻译错误也请提出建议指教 希望大家可以帮忙提供更多更好的AngularJS学习资源 谢谢 这里提供一些学习AngularJS的部落格链接, 文章, 和影片. 这个列表还在持续成长中. 如果你有想提供的链接与资源, 欢迎提出pull request. 我也会尽量确认以下的资源是有用的(不是只有两段文字的灌水文). 如果你有更好的方法来分类这些资源, 请让我知道. 在一般主题分类中的类似文章, 我之后也会把他们另外分类出来. 注意：**开头的链接是讨论ANGULAR 1.2版的新功能. 许多人希望快速了解Angular 1.2版的新功能, 所以我也会在之后开出新的分类标题. 等内容整理差不多或者1.2版分类变得太大我再来编辑, 不过现在的话Angular 1.2链接可以在两处同时看到. Angular 1.2 的新功能 **AngularJS 1.2 &amp; Beyond **Error Message Minification with MinErr **AngularJS路由的变化 **AngularJS缺失的指令: Focus &amp; Blur **Remastered Animation in AngularJS 1.2 **Preparing for Animations in Angular 1.2.0 **AngularJS 1.2中的5个超酷新特性 **在AngularJS 1.2.0中使用ngAnimate替代jQuery.slideDown() **为AngularJS 1.2做好准备 书籍 Books AngularJS 立刻快速开发 AngularJS AngularJS 菜单 AngularJS 在行动 AngularJS For .Net 开发员 AngularJS 浏览器应用程序开发 发现自己的 AngularJS 优势 AngularJS Directives ng-book 打造你的AngularJS AngularJS依赖注入 通过Bootstrap和AngularJS学习Web开发 AngularJS 设计模式 AngularJS 网路应用开发蓝图 实用 AngularJS 影片 Videos Egghead.io — 44 videos of about 4 minutes each — source code 视频教程: 60分钟教你 AngularJS 基础入门 — 1:10:50 AngularJS YouTube 主页 — several videos, mostly presentations of 1h or more Angular JS 入门 — 50:05 Angular JS 端对端测试 — 52:59 Angular JS 安全性 — 29:45 Grunt 和 Angular JS 前端开发流程 — 1:02:37 AngularJS 教程 — 12:19 AngularJS 秀 (Tekpub) — 8 videos (paid) 用 AngularJS 快速开发 Javascript 应用程序(Tuts+) — 22 videos of about 5 minutes each, in 8 sections (paid) AngularJS 基础入门 (Pluralsight) - 6 hours 15 minutes total (paid) **AngularJS 1.2 和未来 AngularJS 实例 - Growing list of 5 minute or less videos 用 AngularJS 和 Firebase 开发实时程序 MongoDB 和 AngularJS， MEAN 堆 AngularJS, EmberJS 和 KnockoutJS 双向绑定的比较 Angular最佳实践 - 64 videos(paid) Neosavvy的 Angular &amp; Jasmine 视频系列 - 16 videos of about 2-3 minutes each AngularJS 视频集合 — Collection of Videos from Various websites. ng-conf YouTube 页面 — YouTube channel with all the presentations given at the Angular Conference in January 2014. 通过50个例子学习 Angular.js (第1部分) 在线课程 Courses Thinkster.io - 学习 AngularJS 更好的方法 - 免費的線上 AngularJS 課程 AngularJS互动教程 和Dan Wahlin一起学习AngularJS Tuts+: 开始使用 Angular Code School Shaping Up with Angular.js Lynda Up and Running with AngularJS Codecademy AngularJs 帮助 Help StackOverflow AngularJS 邮件列表（谷歌小组） Chatroom （基于浏览器的在线聊天系统） AngularJS Google+的社区 reddit 一般主题 General Topics AngularJS 速查表 AngularJS 乐趣 AngularJS Philly ETE 幻灯 随机技巧使用 AngularJS AngularJS 难倒我的是什么 5个理由在企业应用程序世界中使用 AngularJS 在 AngularJS 中实现延迟加载 用更多 AngularJS 魔力来大力增压你的浏览器应用程序 HashKeyCopier - 一个 AngularJS 合并缓存和实时数据的实用工具类 在 AngularJS 中探索 Directive 指令，$scope，DOM 渲染和时序 在 AngularJS 资源上应用缓存的响应 Angularytics: 在 SPA 中用 AngularJS 来跟踪页面访问量和事件的解决方案 在 AngularJS 上共享数据，状态和模型： 方案选择，比较和我的解决方案 Angular.js 和 IE8 缓存 AngularJS 和 SEO 模板，路由和共享数据视图之间的一个 AngularJS 的应用 用 AngularJS 改善最终用户体验 AngularJS 控制器教程与实例 HTML5 本地存储与 Angular JS 动态路由和 AngularJS 以及 Silex 在你的 AngularJS 应用中建模数据和状态 AngularJS 代码重用 在 AngularJS 和 RequireJS 中动态加载控制器和视图 用AngularJS的orderby筛选器对多个字段用不同顺序排序 $http 响应拦截器 AngularJS: 先进的设计模式和最佳实践 AngularJS 的自动 JSON 数据解析 AngularJS 抽象：模块 在 AngularJS 中用 ngSwitch 和 ngSwitchWhen 来混合静态内容 AngularJS 构建大型应用程序 **错误信息与微小MinErr 如何让你的AngularJS 应用程序在IE8工作 AngularJS 性能优化的长列表 AngularJS 响应网站 在 AngularJS 减少初始化时间 用 Yeoman, Grunt 和 Bower快速开发 Angular 程序 **AngularJS 1.2 准备 10个理由网页开发人员应该了解AngularJS AngularJS partials 的懒惰预取 让你加快速度 AngularJS 开发的资源 使用装饰提升 AngularJS $log 使用 AngularJS 和 Stacktrace.js 记录客户端错误 AngularJS表单自动完成，并记住密码 优化AngularJS: 从1200ms到35ms 为AngularJS应用创建一个RequireJS服务 在你的应用开始后加载AngularJS组件 根据需求加载AngularJS模块 用Grunt来配置AngularJS环境 服务器在单页应用(SPAs)中的作用? 通过Websockets将Angular.js实时化 丰富的对象模型和Angular.js 丰富的对象模型和Angular: 一致性映射 AngularJS中的障碍和实用例子 通过故事理解AngularJS路径 重构AngularJS Angular模型和javascript的类 angularjs控制器的状态 怎么使用AngularJS的ngMessages 深度挖掘Angular的控制器 AngularJS自定义过滤器 理解Angular的$scope和$rootScope事件系统中的$emit,$broadcast和$on AngularJS无阻碍数据预载 介绍/开始学习 AngularJS AngularJS 入门 你需要开始了解的 AngularJS 的一切 要成为 AngularJS 专家必备的知识 5个很棒的 AngularJS 功能 AngularJS for jQuery 开发者 AngularJS 入门指南 用 AngularJS 从头开始写应用程序 AngularJS: 概述 AngularJS教程 - 建立一个应用程序使用的指令和数据绑定 在30分钟内教会你 AngularJS 用 Yeoman, Grunt 和 Bower 快速开发 10个你需要开始用 AngularJS 的理由 AngularJS 筛选器 一天学会 AngularJS 7 种成功学习Angular的方法 用Node and Angular创建单页应用 通过 5 个实例学习Angular 考虑的AngularJS的效率 Environment Specific Configuration in AngularJS Using Grunt 用装饰来提升Angular日志 Picking Up Angular, build a twitter-like application AngularJS网页应用的异常处理 AngularJS 101: 从0开始学 Angular 使用及学习心得 Lessons Learned 经验教训：一年一个大AngularJS项目 一些AngularJS陷阱 我希望我事先被告知关于 Angular.js 的事实 我希望我当时就知道我现在知道的东西 — 我和AngularJS 如何建立一个大型Angular.js应用 对新手和全能好奇的开发人员的 AngularJS 提示和技巧 分段式文章 Multipart Articles 开始使用elasticsearch和AngularJS: Part1 - 搜索, Part 2: Faceting, Part 3: Visualization 用AngularJS开发可维护网络应用: Part 1, Part 2 Google,Twitter和AngularJS: 1: Google, Twitter, and AngularJS, 2: Let’s Make a Feed Reader, 3: 生成源, 4: 管理源, 5: 测试, 6: 增加依赖, 7: 表格验证, 8: 迭代程序 &amp; 过滤器, 9: 安装 用AnuglarJS打造 SignalR Stock Ticker: Part 1, Part 2 AngularJS 最佳实践: 我之前都做错了!: Part 1, Part 2, Part 3 AngularJS简介 Part 1, Part 2 深入AngularJS : Part 1, Part 2: 过滤器 The 7 成为Angularjs大师, Part 2: Scopes, Part 3: 双向绑定, Part 4 and 5: Expressions and directives, Part 6: 服务 AngularJS 概况: 1:开始 AngularJS编程, 2:创造 一个 AngularJS 控制器, 3: AngularJS $scope 不是MVC 模型, 4:在 AngularJS中重复使用元素, 5: 在一个 AngularJS ngRepeat 元素中过滤数据, 6:用 #AngularJS 表格控制器来控制表格提交, 7:创造 #AngularJS Directive, 8:在一个 AngularJS 应用中使用DOM 打造一个基于MongoDB, ExpressJS, AngularJS, 和 Node.js的Google日历订阅App Part 1 创造组建: Part 1: 30秒将jQuery转成AngularJS, Part 2: AngularJS Directive 控制器 范例应用程序 Sample Apps 建有AngularJS购物车应用程序 用谷歌feed API 和 AngularJS建立一个 feed 阅读器 Scopes &amp; Compile AngularJS 和 scope.$apply AngularJS 什么是范围原型/原型继承的细微之处？ angularjs.org watch, on pub sub, 和你. AngularJS 中使用 Ng-bind In AngularJS 中解除绑定 $watch() Listeners 使用AngularJS 对DOMZ中的 $scope 进行访问 指令链路, $observe, 和 $watch 功能在AngularJS语境执行的内部 Hailing All Frequencies – 在 AngularJS 用 Pub / Sub 设计模式进行内部沟通 AngularJS 嵌套作用域 AngularJS: 6个常见的使用作用域的陷阱 Scoping AngularJS Directives: Part 1, Part 2 $watch $apply 是怎么运行 $digest 的 AngularJS: $watch, $digest 和 $apply 删除不需要的 Watches Angular - $compile: 它是如何工作，如何使用它。 通过实例来了解 Angular.js $scope 在AngularJS控制器之间共享状态 依賴注入 Dependency Injection AngularJS依赖注入背后的魔法 AngularJS: 更多关于依赖注入 Angularjs 依赖注入 在 AngularJS 中配置依赖注入 在AngularJS依赖注入框架中定义实例化的类 指令 Directives AngularJS指令和JavaScript的计算机科学 AngularJS指令 - 特定于域的扩展为HTML AngularJS指令教程 Commentable： AngularJS 的多态嵌套注释指令 AngularJS的ngForm指令 执行指令后，DOM完成渲染 使用AngularJS指令的案例 我的方法来构建绑定到JavaScript的事件的 AngularJS指令 AngularJS 委派嵌套指令行为转到父指令 AngularJS 探索指令控制器，编译，链接和优先级 AngularJS 在指令中使用控制器 Angular.js 使用JSON参数的指令 指令的漫游指南 创建一个简单的AngularJS指令 扩展的HTML AngularJS指令 Angular 嵌套递归指令 AngularJS一个全功能于一身的指令控制器 平了 AngularJS 的战场: 构建可重用点击编辑指令 AngularJS 覆盖标准的HTML标签的指令 AngularJS 移动滑块指令 在AngularJS中使用命名空间一次性指令 AngularJS 和 $compile 深度了解指令 AngularJS: 引用父作用域的指令 提示：具有相同的名称的指令 将数据移入一个AngularJS指令 构建自定义 AngularJS 指令的独特价值 从现有的插件/脚本之一创建 AngularJS 指令 Angular.js指令 - 控制器和链路之间的区别 AngularJS指令教程 AngularJS指令设计一点通 重构 AngularJS 指令 服务/供应商 Services/Providers Angular service 还是 factory? 如何在4种不同的方式创建 （Singleton） AngularJS服务 Angular JS 中移动AJAX调用到定制服务 消费服务 了解服务的类型 理解 angular $http 拦截器 在 AngularJS 中 provider 供应商之间的差异 Angular 的模块：工厂服务，服务，价值，噢，我的天啊 路由 Routing 如何在AngularJS Web应用程序中推迟路由定义 AngularJS UI路由器状态管理 AngularJS 嵌套视图，路由和深层链接 Angular UI 路由器 AngularJS 使用UI路由器基础 **AngularJS 路由变化 承诺/递延 Promises/Deferred 加强 Angular 承诺: 从当初的诺言的结果中返回字段或方法的新的承诺 AngularJS 承诺，或在AngularJS处理异步请求 在 AngularJS 中利用 Futures 在 AngularJS 视图中使用承诺 使用 AngularJS 承诺 只有在所有的承诺都解决了再显示路由 表单 Forms AngularJS 表单验证 AngularJS指令来测试密码强度 AngularJS 指令来检查密码是否匹配 在 AngularJS 选择菜单中混合静态和动态数据 Angular.js: ng-select 和 ng-options Angular.js: 用 $watch和 blur自动完成和启用表单 创建AngularJS指令在表格中来删除重复的代码 In AngularJS 在指令中强制重绘会导致意外滚动 在 AngularJS 中使用 ngOptions 用 Angular JS 验证表单显示大量验证消息 在AngularJS应用程序管理文件上传的指令 AngularJS 单选按钮 AngularJS Referece 当前的 FormController 在AngularJS 中监听变化的验证 A Select $watch() 教我关于 ngModel 和 AngularJS 最前沿的：高级AngularJS表单验证 Twitter Bootstrap control-group directive for AngularJS 在AngularJS 中防止重复的请求 AngularJS 缺少的指令：原表单复位 **AngularJS 缺少的指令：焦点和模糊 Angular JS: 重复验证表单元素 Angular JS: 通过指令自定义验证 Angular JS: 表单验证 深入学习表单验证 Ng-model 和自定义表单验证 Angular JS Ajax 下拉菜单，日期选择器和保存数据 AngularJS 表单的概念 认证 Authentication AngularJS Web 应用程序处理用户身份验证 Angular.js 单页应用程序验证 AngularJS – 快速的基于角色的认证 单页应用验证 Collections (&amp; ngRepeat Stuff) 使用 AngularJS 继承来的Collection 在 AngularJS 中 添加 ngRepeat 列表分隔符 在 AngularJS 中分组嵌套 ngRepeat 列表 在 AngularJS 中使用 ngController 和 ngRepeat 在 AngularJS 中通过 ngRepeat 渲染DOM元素 原始码组织架构 Code Organization 用 AngularJS 开发超大的应用程序 大 AngularJS 和 JavaScript 的应用的代码组织 Angular 应用程序的网页结构构想 如何组织一个普通 Web 应用程序： 编码 AngularJS 的正确方法。基本示例 AngularJS 模块 ngDefine: AngularJS &amp; RequireJS 模块化AngularJS应用设计 在 AngularJS DI 中使用 RequireJS 测试 Testing 用 AngularJS 和 Testacular 进行全频谱测试 在单元测试中 Mocking 承诺 如何测试AngularJS指令 用 Jasmine 单元测试 AngularJS 控制器 使用 QUnit 和 Sinon 单元测试 AngularJS 控制器 测试 AngularJS Directive： 处理外部模板 如何进行 Angular 应用程序的单元测试 单元测试 - 指令 Directives 单元测试 - 服务 单元测试 - 控制器 在JavaScript 和 AngularJS 中 mock 服务器依赖性 AngularJS 先进的测试和调试的 AngularJS 单元测试的最佳实践 在 AngularJS 中装饰你的测试 RESTful Stuff 在 AngularJS 资源中使用 REST 风格的控制器 Restangular: 新AngularJS框架来适当地，轻松地处理 REST API REST 风格的资源 Restangular 新功能: 针对 Angular的终极 REST API 客户端 使用 AngularJS 厂服务与 RESTful 服务实现互动 在 AngularJS web应用程序中实现一个 REST 风格的 Web 服务身份验证 本地化 Localization Localizing Your AngularJS Apps Internazionalization (i18n) with AngularJS AngularJS And i18n 界面 UI Stuff Angular UI 套件（包括一些子项目） AngularJS 动画 在AngularJS增强的动画功能 可重复使用的 AngularJS 弹出的对话框中服务 在 AngularJS 中创建自定义显示/隐藏 Directive 在 Angular.js 中实现 Bootstrap Tabs 使用拦截器的响应显示和隐藏一个装载小工具 用 AngularJS 建立一个 Typeahead Directive AngularJS Modal 服务 AngularJS 中实现交叉衰落图像 AngularJS 和 SVG AngularJS: 滚动动画 AngularJS 动画 用 AngularJS 实现拖放文件上传 **在 AngularJS 1.2 中重新掌握动画 Angular JS - 通过ID滚动到某个元素 构建 AngularJS 对话服务 **在 Angular 1.2.0 中准备使用动画 **在 AngularJS 1.2.0 中用 ngAnimate 替换 jQuery.slideDown() AngularJS: 模糊图像 directive 使用AngularJS，Ajax和 Bootstrap 3 来建立一个“加载更多”小工具 整合其他语言/框架 Integration With Other Languages/Frameworks AngularJS 和 TypeScript 用 AngularJS 和 D3 来建立一个 WordCloud Directive 在 AngularJS 中用 jQuery Event Delegation Hooking up ASP.NET SignalR with Angular JS 在你的 AngularJS 应用程序进行 Facebook 的身份验证 用 Yeoman, Grunt &amp; Bower 来全面自动化你的 Angular 开发过程 用 Bower 编写可重用的 AngularJS 组件 用 ngularJS 开发谷歌地图的组件 无需服务器来通过 PouchDB 来同步多个 AngularJS 应用程序 用 AngularJS 和 PouchDB构建离线应用 如何AngularJS和Rails集成4 后端代管 Hosted Backends Parse.com boilerplate 建设大型，复杂 AngularJS 应用 用 Firebase用于 Angular 应用程序的实时数据库 用 Backlift开发针对 Angular 的 CRUD 后端 用 AngularJS 和 PouchDB 构建离线应用 用 DreamFactory 开发 针对 Angular 的 CRUD 后端 Firebase 和 Angular 三个双向数据绑定 移动装置 Mobile PhoneGap+AngularJS 快速入门指南 用 AngularJS 开发 PhoneGap 引用程序 PhoneGap 和 AngularJS: In App Browser PhoneGap 和 AngularJS: Notification Service 用 Phonegap, AngularJS 和 ExpressJS 开发移动程序第一部分 编译器 Text editor bundles/IDE Stuff Sublime text 2 包 VIM UltiSnip &amp; Snipmate AngularJS 代码片段 在 WebStorm 7 中运行 Javscript 测试 Visual Studio 开发工具 AngularJS Batarang Chrome 浏览器扩展 从JSON或者 restful API生成 JavaScript 和 HTML，使用 AngularJS 和 JQuery]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码（HTTP Status Code）]]></title>
    <url>%2Fblog%2F17073.html</url>
    <content type="text"><![CDATA[HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。 100客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 200请求已成功，请求所希望的响应头或数据体将随此响应返回。 201请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 207由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 300被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 302请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306在最新版的规范中，306状态码已经不再被使用。 307请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 4001、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 401当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402该状态码是为了将来可能的需求而预留的。 403服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 408请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426客户端应当切换到TLS/1.0。（RFC 2817） 449由微软扩展，代表请求应当在执行完适当的操作后进行重试。 500服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 504作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 509服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510获取资源所需要的策略并没有没满足。（RFC 2774）]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gson和Jackson的使用]]></title>
    <url>%2Fblog%2F13911.html</url>
    <content type="text"><![CDATA[现在json的第三方解析工作很多，如json-lib，gson，jackson，fastjson等，先学习下面两种。 JackSON使用：Jackson主要使用ObjectMapper对象来进行序列化以及反序列化操作。 使用Jackson可以毫无压力的将复杂对象进行完全序列化，也可以将各种类型的对象反序列化 以下代码均省略异常处理 普通对象 序列化Order order对象：1234ObjectMapper mapper = new ObjectMapper();Writer strWriter = new StringWriter();mapper.writeValue(strWriter, order);String json = strWriter.toString(); 反序列化：1Order order = mapper.readValue(json, Order.class); 链表、Map等 序列化List orderList：1234ObjectMapper mapper = new ObjectMapper();Writer strWriter = new StringWriter();mapper.writeValue(strWriter, orderList);String json = strWriter.toString(); 反序列化：需要用到TypeReference 123List&lt;Order&gt; orderList = mapper.readValue(json, new TypeReference&lt;List&lt;Order&gt;&gt;() &#123; &#125;); 反序列化List&lt;LinkedHashMap&lt;String,String&gt;&gt;1List orderList = mapper.readValue(json, List.class); 解析某个字段12JsonNode node = mapper.readTree(json);String name= node.get("name"); Jackson的JSON操作方法准备工作首先去官网下载Jackson工具包，下载地址http://wiki.fasterxml.com/JacksonDownload。Jackson有1.x系列和2.x系列，截止目前2.x系列的最新版本是2.2.3，2.x系列有3个jar包需要下载： jackson-core-2.2.3.jar（核心jar包，下载地址） jackson-annotations-2.2.3.jar（该包提供Json注解支持，下载地址） jackson-databind-2.2.3.jar（下载地址） 12345678910111213141516171819202122232425262728293031323334353637//JSON序列化和反序列化使用的User类import java.util.Date;public class User &#123; private String name; private Integer age; private Date birthday; private String email; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; JAVA对象转JSON[JSON序列化]12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.text.ParseException;import java.text.SimpleDateFormat;import com.fasterxml.jackson.databind.ObjectMapper;public class JacksonDemo &#123; public static void main(String[] args) throws ParseException, IOException &#123; User user = new User(); user.setName("小民"); user.setEmail("xiaomin@sina.com"); user.setAge(20); SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateformat.parse("1996-10-01")); /** * ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。 * ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。 * writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。 * writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。 * writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。 * writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。 */ ObjectMapper mapper = new ObjectMapper(); //User类转JSON //输出结果：&#123;"name":"小民","age":20,"birthday":844099200000,"email":"xiaomin@sina.com"&#125; String json = mapper.writeValueAsString(user); System.out.println(json); //Java集合转JSON //输出结果：[&#123;"name":"小民","age":20,"birthday":844099200000,"email":"xiaomin@sina.com"&#125;] List&lt;User&gt; users = new ArrayList&lt;User&gt;(); users.add(user); String jsonlist = mapper.writeValueAsString(users); System.out.println(jsonlist); &#125;&#125; JSON转Java类[JSON反序列化]12345678910111213141516import java.io.IOException;import java.text.ParseException;import com.fasterxml.jackson.databind.ObjectMapper;public class JacksonDemo &#123; public static void main(String[] args) throws ParseException, IOException &#123; String json = "&#123;\"name\":\"小民\",\"age\":20,\"birthday\":844099200000,\"email\":\"xiaomin@sina.com\"&#125;"; /** * ObjectMapper支持从byte[]、File、InputStream、字符串等数据的JSON反序列化。 */ ObjectMapper mapper = new ObjectMapper(); User user = mapper.readValue(json, User.class); System.out.println(user); &#125;&#125; JSON注解Jackson提供了一系列注解，方便对JSON序列化和反序列化进行控制，下面介绍一些常用的注解。 @JsonIgnore 此注解用于属性上，作用是进行JSON操作时忽略该属性。 @JsonFormat 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”)。 @JsonProperty 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，@JsonProperty(“name”)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Date;import com.fasterxml.jackson.annotation.*;public class User &#123; private String name; //不JSON序列化年龄属性 @JsonIgnore private Integer age; //格式化日期属性 @JsonFormat(pattern = "yyyy年MM月dd日") private Date birthday; //序列化email属性为mail @JsonProperty("mail") private String email; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; 1234567891011121314151617181920212223import java.io.IOException;import java.text.ParseException;import java.text.SimpleDateFormat;import com.fasterxml.jackson.databind.ObjectMapper;public class JacksonDemo &#123; public static void main(String[] args) throws ParseException, IOException &#123; User user = new User(); user.setName("小民"); user.setEmail("xiaomin@sina.com"); user.setAge(20); SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateformat.parse("1996-10-01")); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(user); System.out.println(json); //输出结果：&#123;"name":"小民","birthday":"1996年09月30日","mail":"xiaomin@sina.com"&#125; &#125;&#125; GSON的使用：Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为串行化Java对象为JSON字符串，或反串行化JSON字符串成Java对象。GSON核心jar包不到1M，非常精简，但提供的功能无疑是非常强大的，如果使用JDK自带的JSON解析API，使用起来相对比较繁琐一点，而且代码量较多。 GSON目前的发展状况初始版本 2008年5月22日最新版本(稳定版本) 2.2.4/2013年5月13日；2个月前编程语言 Java操作平台 各种平台许可协议 Apache License 2.0官方网站 http://code.google.com/p/google-gson/下载地址 http://code.google.com/p/google-gson/downloads/listGSON帮助文档 http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/index.html 使用GSON转换时报的一个异常。1234567891011Exception in thread "main" com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was BEGIN_ARRAY at line 1 column 2 at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:176) at com.google.gson.Gson.fromJson(Gson.java:803) at com.google.gson.Gson.fromJson(Gson.java:768) at com.google.gson.Gson.fromJson(Gson.java:717) at com.google.gson.Gson.fromJson(Gson.java:689) at com.demoone.UseGson.testOneBeanFromJSON(UseGson.java:54) at com.demoone.UseGson.main(UseGson.java:89) Caused by: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was BEGIN_ARRAY at line 1 column 2 //注意这句话跟数组集合有关 at com.google.gson.stream.JsonReader.beginObject(JsonReader.java:374) at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:165) ... 6 more 下面贴出，笔者的测试源码，注意上述异常，在代码的注释中已经指出问题原因 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.demoone; import java.util.ArrayList; import java.util.List; import com.entity.Person; import com.google.gson.Gson; import com.google.gson.reflect.*; /*** * 使用gson * 进行序列化,反序列化的操作 * json * **/ public class UseGson &#123; static Gson g=new Gson(); /** * 由集合类型的实体类 * 转换成Json类型 * **/ public static void testToJSON()&#123; List&lt;Person&gt; list=new ArrayList&lt;&gt;(); for(int i=0;i&lt;2;i++)&#123; Person p=new Person(i, "散仙"+i, "北京市"+i, "54152541@qq.com", 500.0); list.add(p); &#125; String json=g.toJson(list); System.out.println(json); &#125; /** * 由json转换为实体类 * */ public static void testOneBeanFromJSON()&#123; /** * 转换一个Java Bean的时候 * 记住不能使用[],只有在使用集合的时候才可以使用 * 如上图贴的那个异常就是由此原因造成的，另外 * 格式要规范，中间不能出现空格字符 * * **/ String jsonBean="[&#123;\"id\":0,\"name\":\"散仙0\",\"address\":\"北京市0\",\"email\":\"54152541@qq.com\",\"money\":500.0&#125;]"; Person p=g.fromJson(jsonBean, Person.class); System.out.println(p); &#125; /** * 由json转换为实体类集合 * * */ public static void testListBeanFromJSON()&#123; /** * 转换一个集合 的实体Bean * 注意前面加上[]方括号，代表一个数组 * **/ String jsonBeanList="[&#123;\"id\":0,\"name\":\"散仙0\",\"address\":\"北京市0\",\"email\":\"54152541@qq.com\",\"money\":500.0&#125;,&#123;\"id\":1,\"name\":\"散仙1\",\"address\":\"北京市1\",\"email\":\"54152541@qq.com\",\"money\":500.0&#125;]"; List&lt;Person&gt; lists=g.fromJson(jsonBeanList,new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType()); System.out.println("反序列之后"); for(Person pp:lists)&#123; System.out.println(pp); &#125; &#125; public static void main(String[] args) &#123; testListBeanFromJSON();//测试集合反序列化 testOneBeanFromJSON();//测试单个实体类反序列化 //testToJSON();//测试序列化 &#125; &#125; 运行结果: 123456testListBeanFromJSON() 方法: 反序列之后 编号：0 名字:散仙0 地址:北京市0 E-mail:54152541@qq.com 钱:500.0 编号：1 名字:散仙1 地址:北京市1 E-mail:54152541@qq.com 钱:500.0 testOneBeanFromJSON() 方法: 编号：0 名字:散仙0 地址:北京市0 E-mail:54152541@qq.com 钱:500.0 实体类Person: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.entity; /** * 实体类 * **/ public class Person &#123; private int id; private String name; private String address; private String email; private double money; @Override public String toString() &#123; // TODO Auto-generated method stub return "编号："+id+" 名字:"+name+" 地址:"+address+" E-mail:"+email+" 钱:"+money; &#125; public Person() &#123; // TODO Auto-generated constructor stub &#125; public Person(int id, String name, String address, String email, double money) &#123; super(); this.id = id; this.name = name; this.address = address; this.email = email; this.money = money; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; &#125;]]></content>
      <categories>
        <category>Json</category>
      </categories>
      <tags>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS是什么]]></title>
    <url>%2Fblog%2F16024.html</url>
    <content type="text"><![CDATA[SASS 是 CSS 的一个预处理工具，简单来说，它通过自己的一套语法规则来写源码，然后通过编译器，得到 CSS 代码。 1. SASS是什么为什么需要这东西呢？因为如果每天都要写很多的 CSS ，那么里面重复的内容会很多，同时，CSS 本身并没有相应的逻辑抽像工具，这就造成在项目中要对样式做有效的管理，似乎没有什么好办法了。 SASS 本身是来源于 Ruby 的一个项目，它目前的标准，应该是一个叫 libSass 的 C 语言库，有了这个 C 语言的实现之后，各种语言就可以很方便地 bind 过去了，从官网上的信息看，目前 C, Go, Java, Javascript, Lua, .NET, Node, Perl, PHP, Python, Ruby, Scala 这些语言上都有实现。 SASS 支持两种格式的源码写法，一种叫 SASS ，另一种叫 SCSS ，区别只是前者使用缩进，后者使用大括号。（我就不明白了，为什么有人喜欢大括号，你写了大括号不也要缩进么） 2. 安装这里，使用 Node 上的实现，叫 node-sass ： 1sudo npm install -g node-sass 安装之后，除了相应的 node 模块，还会有一个命令行可执行程序，叫 node-sass ： 1node-sass a.sass 通过 --output-style 参数可以控制输出的 CSS 的格式，我喜欢用： 1node-sass --output-style compact a.sass 这样输出的 CSS ，是一行一条。（以前喜欢这种形式，是因为一行一条的格式，可以方便地在编辑器中使用列编辑作批量修改） 3. 变量, 赋值, 数据类型SASS 中使用 $ 开头来标识一个变量名，使用 : 完成赋值的操作： 1$a: 123 数据类型有以下几种： 数字 123 , 1.2 , 12px , 12%, 这些是数字类型。比较特殊的一点，可能在于， SASS 把带有 CSS 单位的标识也作为数字处理，在后面的运算符行为时，单位部分也会一并处理。 字符串 abc 或 &quot;abc&quot; 或 &#39;abc&#39; 。简单来说，单引号，双引号都可以，不要引号也可以。但是，因为 CSS 中大部分的描述都是不要引号的形式，比如 color: red ，而不是 color: &#39;red&#39; ，所以，在引号的处理上，要小心。 颜色 red , #abcd , rgb(123,255,67) , rgba(123, 255, 67, 0.5) , CSS 中表示颜色的形式，在 SASS 中作为颜色类型处理。这里注意，第一个 red ，跟字符串的形式一样的。（我猜这类标识具有混合属性吧） 列表 10px 2px 0 0 或 Helvtica, Arial, sans-serif ，以空格，或者以逗号分割的数据形式，为列表。主要对应于 CSS 中的对应形式，比如 margin: 10px 2px 0 0 ， font-family: Helvtica, Arial, sans-serif 。 同时，列表这种类型，在处理函数的参数时也有用。 映射 (k1: v1, k2: v2) ，映射其实就是一个嵌套的列表，形如 (k1 v1), (k2 v2) ，主要用于迭代的一些控制结构中。 4. 变量符号化这里的“符号化”说法，意思就是“行内求值”。简单来说，就是把变量的值，在任何地方，转换为语法结构的一部分（因为按语法规则，“这里”是不能使用变量的）。举一个例子： 1234$a cls.$a: color: red 这肯定是错误的。因为 “规则” / “选择器” 部分，是不允许使用变量的。但是你可以： 1234$a cls.#&#123;$a&#125; color: red 这样，就是正确的了，编译出来是： 1.cls &#123; color: red; &#125; 同时，还有： 1234$a: &apos;red&apos;.cls color: $a 这样写，虽然编译没有问题，但是结果： 1.cls &#123; color: &apos;red&apos;; &#125; 这是不对的。换成： 1234$a: &apos;red&apos;.cls color: #&#123;$a&#125; 就可以正确得到： 1.cls &#123; color: red; &#125; 所以， #{} 的功能，算是非常有用且强大。 5. 嵌套规则与引用CSS 简单来说，只有两部分内容，一是规则，或者说选择器。二是属性描述。DOM 本身是一个层级结构，所以我们在书写规则时，也是层级下降的方式，这样，如果直接写 CSS ，就不可避免地要写很多重复的前置规则，比如： 12.project &gt; .header &gt; .title &#123; color: red; &#125;.project &gt; .header &gt; .content &#123; color: blue; &#125; SASS 最直观的一个功能，就是可以以一种嵌套的层级形式，来处理规则的书写： 123456.project &gt; .header &gt; .title color: red &gt; .content color: blue 这样不光可以少写很多代码，而且最重要的，是容易维护。 这种嵌套的层级结构，有一个特别的功能，就是使用 &amp; 可以作为当前选择的引用，这个功能，一般用于伪类： 12345678910.project &gt; .header &gt; .title color: red &gt; a color: yellow &amp;:hover text-decoration: none 编译得到： 123.project &gt; .header &gt; .title &#123; color: red; &#125;.project &gt; .header &gt; .title &gt; a &#123; color: yellow; &#125;.project &gt; .header &gt; .title &gt; a:hover &#123; text-decoration: none; &#125; 6. 运算符, 逻辑判断, 控制结构SASS 虽然不是完整的一门编程语言，但是，运算符和控制结构的概念还是有的。 这里先说一下， SASS 中可以使用 @debug 作标准输出。 123456789$a: 1px + 1px$b: 1px * 20$c: 10px - 2px$d: 10px / 2$e: 10 + 2 - 3 + 0px$e2: 10 + 2 - 3 + 0%$e3: (10 + 2) * 3 / 100 * 100%@debug $a, $b, $c, $d, $e, $e2, $e3 四则运算时，单位需要匹配，或者，你也可以在最后再处理单位。 控制结构方面，目前有 @for, @each, @while, @if 。 @for 单纯的数字范围的迭代：@for $i from 1 through 10 @debug $i @each 对列表的迭代：@each $i in 1,2,3,4 @debug $i支持多值匹配：@each $a, $b, $c in (a, b, c), (red, 1, blue) @debug $a, $b, $c @while $i: 0@while $i &lt; 10 @debug $i $i: $i + 1 @if 这里随便把逻辑判断一起用了：$i: 0@while $i &lt; 10 @if $i == 0 @debug zero @if $i &gt; 2 @debug gtwo @else @debug ltwo @if $i != 0 @debug other $i: $i + 1 7. 函数定义先说清楚这里的函数定义，传入参数，返回值，返回值。 1234@function add($a, $b) @return $a + $b@debug add(1, 2) 函数的参数，跟 Python 一样，可以有默认值，可以有关键词参数： 默认值： 1234@function add($a, $b:3) @return $a + $b@debug add(1) 关键词参数： 1234@function add($a:2, $b:3) @return $a + $b@debug add($b:1) 8. @mixin, 宏Mixin 是官方的叫的名字， 宏 是我自己叫的，因为，这东西的行为就像“宏”一样，可以生成代码片段。 Mixin 是 SASS 中地位很重要，还特别给它了一种简写形式。 12345@mixin em color: red.header.em @include em 简写形式： 12345=em color: red.header.em +em 生成： 1.header.em &#123; color: red; &#125; Mixin 也可以带参数： 12345678=em-back($color:yellow, $font-size: 14px) color: red background-color: $color font-size: $font-size.header.true +em-back($font-size: 20px) 生成： 1.header.true &#123; color: red; background-color: yellow; font-size: 20px; &#125; 还可以直接传入代码块： 12345678=em color: red @content.header.true +em font-size: 14px 生成： 1.header.true &#123; color: red; font-size: 14px; &#125; 注意， Mixin 的结果是代码块，所以，它不光可以返回属性块，还可以连带规则块一起处理： 123456=em span color: red.header.true +em 生成： 1.header.true span &#123; color: red; &#125; 引用 &amp; 也可以照常使用： 123456789=hover &amp;:hover @content.header.true color: white +hover color: red 生成： 12.header.true &#123; color: white; &#125;.header.true:hover &#123; color: red; &#125; 配合 @at-root 和 &amp; ： 12345678910=hover @at-root &amp; @content.header.true color: white +hover color: red 生成： 12.header.true &#123; color: white; &#125;.header.true &#123; color: red; &#125; Mixin 本身是可以嵌套的： 12345678910=em color: red=hover +em @content.header.true +hover background-color: aqua 生成： 1.header.true &#123; color: red; background-color: aqua; &#125; 9. @extend 续写前面说的 @mixin 是处理抽象的可复用代码，现在说的 @extend 是处理具体的已存在的可复用代码。其实两者的机制都是 Mixin ，这里说的 “续写” 是我自己叫的一个名字，因为我实在不想叫“继承”。 9.1. 最简单情况@extend 的作用，是通过指定标识符，在当前块中引用对应的属性定义。 123456.a color: red.b @extend .a background-color: blue 生成： 12.a, .b &#123; color: red; &#125;.b &#123; background-color: blue; &#125; 这里，你也可以看成是生成了： 123.a &#123; color: red; &#125;.b &#123; color: red; &#125;.b &#123; background-color: blue; &#125; 或者： 12.a &#123; color: red; &#125;.b &#123; color: red; background-color: blue; &#125; 这里的行为，可以注意一点，用 @extend 的块自己本身一定还有一条定义 ，这里的就是最前面的 .b 有自己单独的一条。如果 .b 中没有 background-color ，也可以看成是 .b 会有两条相同的，仅有 color 的属性定义。 9.2. 复合规则当然，这是最简单的情况，复杂一点的： 123456.g.a color: red.b @extend .a background-color: blue 生成的是： 12.g.a, .g.b &#123; color: red; &#125;.b &#123; background-color: blue; &#125; 这里的行为，可以总结为， @extend 部分，不会更改原有的规则限制。这里就是 .a 有 .g 这个限制，那么引用 .a 的 .b ，在引用部分，也有 .g 的限制。 把 .a 换成 .g 的话： 123456.g.a color: red.b @extend .g background-color: blue 那么生成的就是： 12.g.a, .a.b &#123; color: red; &#125;.b &#123; background-color: blue; &#125; 上面的例子，把 .g.a 换成 .g .a 结果相同。 这里的： 1.g.a, .a.b &#123; color: red; &#125; 也可以看成是： 1.g.a, .b.a &#123; color: red; &#125; 9.3. 伪类伪类本身是一个限定，所以，如果碰到伪类的情况，就把它看成是一个普通类限定， @extend 就只是指定了一个复合条件而已。 先看复合条件的情况： 12345.g .x.y.z color: red.m @extend .x.y 生成： 1.g .x.y.z, .g .z.m &#123; color: red; &#125; 即： 1.g .x.y.z, .g .m.z &#123; color: red; &#125; 伪类同样： 12345.g img.user:hover color: red.b @extend img:hover 把 :hover 看成 .hover 就好了： 12345.g img.user:hover, .g .user.b &#123; color: red; &#125;-&gt;.g img.user:hover, .g .b.user &#123; color: red; &#125; 不过伪类一般会这么用吧： 123456.g img.user:hover color: red.b &amp;:hover @extend img:hover 生成： 12345.g img.user:hover, .g .user.b:hover &#123; color: red; &#125;-&gt;.g img.user:hover, .g .b.user:hover &#123; color: red; &#125; 9.4. 序列规则下的使用前面的例子， @extend 所在的规则，本身都比较简单。最复杂的情况，就是 @extend 所在的规则是多重限定，并且 @extend 指定的条件是多重限定，同时，目标定义时，又有多重限定，最后，目标可能还有多个。 四个点， @extend 所在的块， @extend 本身， @extend 可能碰到的目标， @extend 可能碰到的多个目标。 当然，现实情况不会这样，太复杂了 SASS 自己也搞不定。所以， SASS 中， @extend 本身的规则，是不允许有“序列条件”的。 12345.x a color: red.header &gt; a @extend .x a 这种情况，不被允许。 @extend 本身简单了一点，但是情况还是有些伤脑筋： 12345678.x &gt; .side .m.a color: red.y .m.a background-color: yellow.header .title a @extend .m.a 当 @extend 的目标有多个时，我们一个一个来看就好了，先看 .x &gt; .side .m.a 。 前面说过， @extend 不会改变原来的限定，所以， .x &gt; .side 这个条件是不会变的。但是，这里的情况有些不一样，因为， @extend 所在的块，本身还有一个 .header .title 的前置限定条件。 那么现在的问题就是，对于 .header .title a 中的这个 a ，它有两组前置限定条件了。 这里的两组条件，其实跟前面是一回事。最开始的一条，就说了，别忘了在 @extend 所在的块本身，还会有一条定义生成。不同的是，这里 @extend 所在的块本身，会被附加限定条件。 所以，单看： 12345.x &gt; .side .m.a color: red.header .title a @extend .m.a 第一步： 目标照写， .x &gt; .side .m.a { color: red } 。 第二步： 自己照写， .header .title .x &gt; .side a { color: red } 。 第三步： 目标 -&gt; @extend， .x &gt; .side .header .title a { color: red } 。 换作最简单情况的话： 12345.em color: red.side .content @extend .em 第一步： 目标照写， .em { color: red } 。 第二步： 自己照写， .side .content { color: red } 。 第三步： 目标 -&gt; @extend， .side .content { color: red } 。 9.5. 总结总结起来，对于： 12345[PRE_A] TARGET_A color: red[PRE_B] TARGET_B @extend TARGET_A 结果就是： [PRE_A] TARGET_A { color: red } ... TARGET_B { color: red } 1... TARGET_B &#123; color: red &#125; ​ 然后放 1[PRE_A] [PRE_B] 和 1[PRE_B] [PRE_A] 两种情况，得到： ​ [PRE_A] TARGET_A { color: red } [PRE_A] [PRE_B] TARGET_B { color: red } [PRE_B] [PRE_A] TARGET_B { color: red } 看之前的第二个目标实例： 12345.y .m.a background-color: yellow.header .title a @extend .m.a 自然就是生成： 123.y .m.a &#123; background-color: yellow &#125;... a &#123; background-color: yellow &#125;... a &#123; background-color: yellow &#125; 补充上： 123.y .m.a &#123; background-color: yellow &#125;.header .title .y a &#123; background-color: yellow &#125;.y .header .title a &#123; background-color: yellow &#125; 9.6. 抽象块SASS 还真是把 @extend 搞得复杂哦。 SASS 中还有一种“抽象块”的概述，相对于“抽象类”去理解吧。就是，定义的规则块，只是用来被 @extend 的，它自己不会出现在最终的 CSS 中，这种块，使用 %name 结尾来标识： 12345.x .y a%only color: red.title div .link @extend %only 结果就是： 123.x .y a &#123; color: red; &#125;... a.link &#123; color: red; &#125;... a.link &#123; color: red; &#125; 补充： 123.x .y a &#123; color: red; &#125;.x .y .title div a.link &#123; color: red; &#125;.title div .x .y a.link &#123; color: red; &#125; 最后去掉不要的： 12.x .y .title div a.link &#123; color: red; &#125;.title div .x .y a.link &#123; color: red; &#125; 抽象块最后 a.link 的处理，跟普通 @extend 行为不一样，普通的 @extend 不会保留 a ，只有 .link 。 10. @import 引入其它文件@import ，首先有原本的功能，即可以引入一段其它的 CSS 。 同时， SASS 中的 @import 也可以引入自己的 SASS 文件，比如： 1234@import &quot;reset.sass&quot;.ok @extend .em reset.sass 中有定义 .em { color: red; } ，最后编译就可以得到： 1.em, .ok &#123; color: red; &#125; @import 的其它使用形式还有： @import &quot;a&quot;, &quot;b&quot; 引入多个文件 @import &quot;a&quot; screen 使用媒体查询 @import url(&quot;http://fonts.googleapis.com/css?family=#{$family}&quot;) 使用变量 @import 可以在规则中使用，它的行为类似单纯的宏替换，比如： 12.a1 @import &quot;a.sass&quot; 11. @media 媒体查询@media 的写法与其在 CSS 中是一样的，SASS 中， @media 的额外能力，就是你可以把它写在规则下面，编译的时候，会自动整理代码，把 @media 部分抽到最外面去： 1234.a color: red @media print color: black 会生成： 12.a &#123; color: red; &#125;@media print &#123; .a &#123; color: black; &#125; &#125;]]></content>
      <categories>
        <category>SASS</category>
      </categories>
      <tags>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志组件slf4j介绍及配置详解]]></title>
    <url>%2Fblog%2F30235.html</url>
    <content type="text"><![CDATA[每一个Java程序员都知道日志对于任何一个Java应用程序尤其是服务端程序是至关重要的，而很多程序员也已经熟悉各种不同的日志库，如java.util.logging、Apache log4j、logback。但如果你还不知道SLF4J（Simple logging facade for Java）的话，那么是时候在你的项目中学习使用SLF4J了。 基本介绍SLF4J不同于其他日志类库，与其它日志类库有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。如果是在编写供内外部都可以使用的API或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。 如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无需忍受加载和维护一个新的日志框架的痛苦。 总的来说，SLF4J使你的代码独立于任意一个特定的日志API，这是对于API开发者的很好的思想。虽然抽象日志类库的思想已经不是新鲜的事物，而且Apache commons logging也已经在使用这种思想了，但SLF4J正迅速成为Java世界的日志标准。让我们再看几个使用SLF4J而不是log4j、logback或者java.util.logging的理由。 SLF4J对比Log4J，logback和java.util.Logging的优势正如我之前说的，在你的代码中使用SLF4J写日志语句的主要出发点是使得你的程序独立于任何特定的日志类库，依赖于特定类库可能需要使用不同于你已有的配置，并且导致更多维护的麻烦。除此之外，还有一个SLF4J API的特性是使得我坚持使用SLF4J而抛弃我长期间钟爱的Log4j的理由，是被称为占位符(place holder)，在代码中表示为“{}”的特性。占位符是一个非常类似于在String的format()方法中的%s，因为它会在运行时被某个提供的实际字符串所替换。这不仅降低了你代码中字符串连接次数，而且还节省了新建的String对象。通过使用SLF4J，你可以在运行时延迟字符串的建立，这意味着只有需要的String对象才被建立。而如果你已经使用log4j，那么你已经对于在if条件中使用debug语句这种变通方案十分熟悉了，但SLF4J的占位符就比这个好用得多。 这是你在Log4j中使用的方案，但这并不有趣，而且降低了代码可读性，因为它增加了不必要的繁琐重复代码(boiler-plate code)： 123if (logger.isDebugEnabled()) &#123; logger.debug("Processing trade with id: " + id + " symbol: " + symbol);&#125; 另一方面，如果你使用SLF4J的话，你可以得到更简洁格式的结果，就像以下展示的一样： 1logger.debug("Processing trade with id: &#123;&#125; and symbol : &#123;&#125; ", id, symbol); 在SLF4J，我们不需要字符串连接而且不会导致暂时不需要的字符串消耗。取而代之，我们在一个以占位符和参数传递实际值构成的模板格式下写日志信息。你可能会在想万一我有很多个参数怎么办？嗯，那么你可以选择使用变量参数版本的日志方法或者以Object数组传递。这是一个相当方便和高效方法的打日志方法。记住，在生产最终日志信息字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了CPU去处理字符串连接命令的时间。这里是使用SLF4J日志方法的代码，来自于slf4j-log4j12-1.6.1.jar中的Log4j的适配器类Log4jLoggerAdapter。 123456public void debug(String format, Object arg1, Object arg2) &#123; if (logger.isDebugEnabled()) &#123; FormattingTuple ft = MessageFormatter.format(format, arg1, arg2); logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable()); &#125;&#125; 同时，我们应该知道打日志是对应用程序性能有着很大影响，在生产环节上我们建议只进行必要的日志记录。 使用配置maven依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt; 日志系统配置假设现有如下程序： 1234567891011121314import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Main &#123; private static final Logger logger = LoggerFactory.getLogger(Main.class); public static void main(String[] args) &#123; int status = 0; if (status == 0) &#123; logger.info("status:&#123;&#125;", status); &#125; else &#123; logger.info("status:&#123;&#125;", status); &#125; logger.info("end!"); &#125;&#125; 可以使用以下两种方式对日志系统的输出格式、记录级别、输出方式等进行配置。 properties文件方式log4j.properties: 12345678910log4j.rootLogger=info, ServerDailyRollingFile, stdoutlog4j.appender.ServerDailyRollingFile=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.ServerDailyRollingFile.DatePattern=&apos;.&apos;yyyy-MM-ddlog4j.appender.ServerDailyRollingFile.File=logs/notify-subscription.loglog4j.appender.ServerDailyRollingFile.layout=org.apache.log4j.PatternLayoutlog4j.appender.ServerDailyRollingFile.layout.ConversionPattern=%d - %m%nlog4j.appender.ServerDailyRollingFile.Append=truelog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; %p [%c] %m%n 输出结果为： 122016-05-12 16:08:21 INFO [club.chuxing.learn.Main] status:0 2016-05-12 16:08:21 INFO [club.chuxing.learn.Main] end! xml文件方式首先pom中添加如下依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt;&lt;/dependency&gt; logback.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="true"&gt; &lt;!-- 应用名称 --&gt; &lt;property name="APP_NAME" value="logtest" /&gt; &lt;!--日志文件的保存路径,首先查找系统属性-Dlog.dir,如果存在就使用其；否则，在当前目录下创建名为logs目录做日志存放的目录 --&gt; &lt;property name="LOG_HOME" value="$&#123;log.dir:-logs&#125;/$&#123;APP_NAME&#125;" /&gt; &lt;!-- 日志输出格式 --&gt; &lt;property name="ENCODER_PATTERN" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;80&#125; - %msg%n" /&gt; &lt;contextName&gt;$&#123;APP_NAME&#125;&lt;/contextName&gt; &lt;!-- 控制台日志：输出全部日志到控制台 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;Pattern&gt;$&#123;ENCODER_PATTERN&#125;&lt;/Pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件日志：输出全部日志到文件 --&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/output.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;7&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;ENCODER_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 错误日志：用于将错误日志输出到独立文件 --&gt; &lt;appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;7&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;ENCODER_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 独立输出的同步日志 --&gt; &lt;appender name="SYNC_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/sync.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;7&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;ENCODER_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name="log.sync" level="DEBUG" addtivity="true"&gt; &lt;appender-ref ref="SYNC_FILE" /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value="DEBUG" /&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;appender-ref ref="FILE" /&gt; &lt;appender-ref ref="ERROR_FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; 输出结果为： 122016-05-12 17:08:32.105 [main] INFO club.chuxing.learn.Main - status:0 2016-05-12 17:08:32.114 [main] INFO club.chuxing.learn.Main - end! 日志系统配置说明输出级别的种类 ERROR 为严重错误 主要是程序的错误 WARN 为一般警告，比如session丢失 INFO 为一般要显示的信息，比如登录登出 DEBUG 为程序的调试信息 配置日志信息输出目的地 log4j.appender.appenderName=?? org.apache.log4j.ConsoleAppender（控制台）org.apache.log4j.FileAppender（文件）org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 配置日志信息的格式 log4j.appender.appenderName.layout = ?? org.apache.log4j.HTMLLayout（以HTML表格形式布局）org.apache.log4j.PatternLayout（可以灵活地指定布局模式）org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） ConsoleAppender选项 Threshold=DEBUG:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。Target=System.err:默认情况下是System.out,指定输出控制台 FileAppender 选项 Threshold=DEBUG:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。File=mylog.txt:指定消息输出到mylog.txt文件。Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。 RollingFileAppender 选项 Threshold=DEBUG:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。File=mylog.txt:指定消息输出到mylog.txt文件。Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。MaxBackupIndex=2:指定可以产生的滚动文件的最大数。 日志信息格式中几个符号所代表的含义 -X号: X信息输出时左对齐；%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921%r: 输出自应用启动到输出该log信息耗费的毫秒数%c: 输出日志信息所属的类目，通常就是所在类的全名%t: 输出产生该日志事件的线程名%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main (TestLog4.java:10)%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。%%: 输出一个”%”字符%F: 输出日志消息产生时所在的文件名称%L: 输出代码中的行号%m: 输出代码中指定的消息,产生的日志具体信息%n: 输出一个回车换行符，Windows平台为”\r\n”，Unix平台为”\n”输出日志信息换行 一个示例配置文件 1234567891011121314log4j.debug=true log4j.rootLogger=DEBUG,D,Elog4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File = logs/logs.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = DEBUGlog4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%nlog4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = logs/error.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = ERRORlog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n 过滤器过滤器，执行一个过滤器会有返回个枚举值，即DENY，NEUTRAL，ACCEPT其中之一。返回DENY，日志将立即被抛弃不再经过其他过滤器；返回NEUTRAL，有序列表里的下个过滤器过接着处理日志；返回ACCEPT，日志会被立即处理，不再经过剩余过滤器。过滤器被添加到 中，为 添加一个或多个过滤器后，可以用任意条件对日志进行过滤。 有多个过滤器时，按照配置顺序执行。 常用的过滤器： LevelFilter： 级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。有以下子节点： :设置过滤级别 :用于配置符合过滤条件的操作 :用于配置不符合过滤条件的操作 ThresholdFilter： 临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回NEUTRAL；当日志级别低于临界值时，日志会被拒绝。 例如：过滤掉所有低于INFO级别的日志。 EvaluatorFilter： 求值过滤器，评估、鉴别日志是否符合指定条件。有一下子节点： :鉴别器，常用的鉴别器是JaninoEventEvaluato，也是默认的鉴别器，它以任意的Java布尔值表达式作为求值条件，求值条件在配置文件解释过成功被动态编译，布尔值表达式返回true就表示符合过滤条件。evaluator有个子标签，用于配置求值条件。 求值表达式作用于当前日志，logback向求值表达式暴露日志的各种字段：Name Type Descriptionevent LoggingEvent 与记录请求相关联的原始记录事件，下面所有变量都来自event 例如，event.getMessage()返回下面”message”相同的字符串 message String 日志的原始消息 例如，设有logger mylogger，”name”的值是”AUB”，对于 mylogger.info(“Hello {}”,name); “Hello {}”就是原始消息。formatedMessage String 日志被各式话的消息， 例如，设有logger mylogger，”name”的值是”AUB”，对于 mylogger.info(“Hello {}”,name); “Hello Aub”就是格式化后的消息。logger String logger 名。 loggerContext LoggerContextVO 日志所属的logger上下文。 level int 级别对应的整数值，所以 level &gt; INFO 是正确的表达式。 timeStamp long 创建日志的时间戳。 marker Marker 与日志请求相关联的Marker对象，注意“Marker”有可能为null，所以你要确保它不能是null。 mdc Map 包含创建日志期间的MDC所有值得map。访问方法是：mdc.get(“myKey”) 。 mdc.get()返回的是Object不是String，要想调用String的方法就要强转 例如，((String) mdc.get(“k”)).contains(“val”) .MDC可能为null，调用时注意。 throwable java.lang.Throwable 如果没有异常与日志关联”throwable” 变量为 null. 不幸的是， “throwable” 不能被序列化。在远程系统上永远为null，对于与位置无关的表达式请使用下面的变量throwableProxy throwableProxy IThrowableProxy 与日志事件关联的异常代理。如果没有异常与日志事件关联，则变量”throwableProxy” 为 null. 当异常被关联到日志事件时，”throwableProxy” 在远程系统上不会为null :用于配置符合过滤条件的操作 :用于配置不符合过滤条件的操作 例如：过滤掉所有日志消息中不包含“billing”字符串的日志。 参考来源： http://www.importnew.com/7450.html#comment-204549 http://www.tuicool.com/articles/6VRnui http://blog.csdn.net/linwei_1029/article/details/8844939 http://blog.csdn.net/xuanjiewu/article/details/7587586 http://blog.csdn.net/haidage/article/details/6794540]]></content>
      <categories>
        <category>SLF4J</category>
      </categories>
      <tags>
        <tag>SLF4J</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web站点如何防范XSS、CSRF、SQL注入攻击]]></title>
    <url>%2Fblog%2F52946.html</url>
    <content type="text"><![CDATA[对Web服务器的攻击也可以说是形形色色、种类繁多，常见的有挂马、SQL注入、缓冲区溢出、嗅探、利用IIS等针对Webserver漏洞进行攻击。本文结合WEB TOP10漏洞中常见的SQL注入，跨站脚本攻击(XSS)，跨站请求伪造（CSRF）攻击的产生原理，介绍相应的防范方法。 XSS跨站脚本攻击**XSS跨站脚本攻击指攻击者在网页中嵌入客户端脚本(例如JavaScript)，当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的，比如获取用户的Cookie，导航到恶意网站，携带木马等。 如何防止XSS跨站脚本攻击：原则：不相信用户输入的数据 将重要的cookie标记为http only，这样的话Javascript 中的document.cookie语句就不能获取到cookie了 只允许用户输入我们期望的数据。例如：年龄的textbox中，只允许用户输入数字，而数字之外的字符都过滤掉 对数据进行Html Encode 处理。&lt; 转化为 &amp;lt;、&gt; 转化为 &amp;gt;、&amp; 转化为 &amp;amp;、&#39; 转化为 &amp;#039;、&quot; 转化为 &amp;quot;、空格 转化为 &amp;nbsp; 过滤或移除特殊的Html标签。例如：&lt;script&gt;、&lt;iframe&gt;、&amp;lt; for &lt;、&amp;gt; for &gt;、&amp;quot for 过滤JavaScript 事件的标签。例如 “onclick=”、”onfocus” 等等很多浏览器都加入了安全机制来过滤XSS 注意：攻击代码不一定在中 CSRF跨站请求伪造CSRF（XSRF）尽管听起来很想XSS跨站脚本攻击，但是它于XSS完全不同。XSS是利用站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的站点。与XSS相比，CSRF攻击不大流行和难以防范，所以比XSS更具危险性。 如何防止CSRF跨站请求伪造： 对于web站点，将持久化的授权方法（例如cookie或者HTTP授权）切换为瞬时的授权方法（在每个form中提供隐藏field）。 “双提交”cookie。此方法只工作于Ajax请求，但它能够作为无需改变大量form的全局修正方法。如果某个授权的cookie在form post之前正被JavaScript代码读取，那么限制跨域规则将被应用。什么叫限制跨域规则呢？限制跨域规则就是：如果服务器需要在Post请求体或者URL中包含授权cookie的请求，那么这个请求必须来自于受信任的域，因为其它域是不能从信任域读取cookie的。上面那个例子的受信任域就是银行网站的某个域，而Mallory发给Bob的链接不是受信任的域。 使用Post代替Get。Post方式不会在web服务器和代理服务器日志中留下数据尾巴，然而Get方式却会留下数据尾巴。 以上三点都是正对web站点的防御手段，第4点是从用户的角度的防御手段。通过在浏览其它站点前登出站点或者在浏览器会话结束后清理浏览器的cookie来防止CSRF攻击。 SQL注入所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 如何防止SQL注入： 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL请求到Action的映射规则]]></title>
    <url>%2Fblog%2F61440.html</url>
    <content type="text"><![CDATA[URL请求到Action的映射规则 1.URL路径映射1.1.对一个action配置多个URL映射：我们把上一篇中的HelloWorldController的index() action方法的@RequestMapping更改为@RequestMapping(value={“/index”, “/hello”}, method = {RequestMethod.GET})，这表示对该action配置了/index和/hello两个映射。运行测试，可以看到/helloworld/hello请求也成功匹配。 1.2.URL请求参数映射：这在查询的时候经常用到，比如我们根据id或编号来获取某一条记录。 在HelloWorldController添加一个getDetail的action，代码如下： 12345678@RequestMapping(value="/detail/&#123;id&#125;", method = &#123;RequestMethod.GET&#125;)public ModelAndView getDetail(@PathVariable(value="id") Integer id)&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("id", id); modelAndView.setViewName("detail"); return modelAndView;&#125; 其中value=”/detail/{id}”,中的{id}为占位符表示可以映射请求为/detail/xxxx 的URL如：/detail/123等。 方法的参数@PathVariable(value=”id”) Integer id 用于将URL中占位符所对应变量映射到参数id上，@PathVariable(value=”id”) 中value的值要和占位符/{id}大括号中的值一致。 在views中添加detail.jsp视图，用于将获取到的id值展示出来。视图内容如下： 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;id&#125;&lt;/body&gt;&lt;/html&gt; 运行试，请求URL地址 http://localhost:8080/SpringMVCLesson/helloworld/detail/123 ，结果可以看到已经正确的显示了我们请求的id。 1.3.URL通配符映射：我们还可以通过通配符对URL映射进行配置，通配符有“？”和“”两个字符。其中“？”表示1个字符，“”表示匹配多个字符，“**”表示匹配0个或多个路径。 例如：12345678910“/helloworld/index?”可以匹配“/helloworld/indexA”、“/helloworld/indexB”但不能匹配“/helloworld/index”也不能匹配“/helloworld/indexAA”； “/helloworld/index*”可以匹配“/helloworld/index”、“/helloworld/indexA”、“/helloworld/indexAA” 但不能匹配“/helloworld/index/A”； “/helloworld/index/*”可以匹配“/helloworld/index/”、“/helloworld/index/A”、“/helloworld/index/AA”、“/helloworld/index/AB” 但不能匹配 “/helloworld/index”、“/helloworld/index/A/B”; “/helloworld/index/**”可以匹配“/helloworld/index/”下的多有子路径，比如：“/helloworld/index/A/B/C/D”; 如果现在有“/helloworld/index”和“/helloworld/*”，如果请求地址为“/helloworld/index”那么将如何匹配？Spring MVC会按照最长匹配优先原则（即和映射配置中哪个匹配的最多）来匹配，所以会匹配“/helloworld/index”，下面来做测试： 在HelloWorldController添加一个urlTest的action，内容如下： 1234567@RequestMapping(value="/*", method = &#123;RequestMethod.GET&#125;)public ModelAndView urlTest()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("urltest"); return modelAndView;&#125; 在views文件夹中新加一个视图urltest.jsp，为了和index.jsp做区别urltest.jsp的内容如下： 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; urlTest!&lt;/body&gt;&lt;/html&gt; 请求http://localhost:8080/SpringMVCLesson/helloworld/index查看结果： 可以看出映射的是index对应的action。 请求http://localhost:8080/SpringMVCLesson/helloworld/AAA查看结果： 可以看出映射的是urlTest对应的action。 1.4.URL正则表达式映射：Spring MVC还支持正则表达式方式的映射配置，我们通过一个测试来展示： 在HelloWorldController添加一个regUrlTest的action，内容如下： 123456789@RequestMapping(value="/reg/&#123;name:\\w+&#125;-&#123;age:\\d+&#125;", method = &#123;RequestMethod.GET&#125;)public ModelAndView regUrlTest(@PathVariable(value="name") String name, @PathVariable(value="age") Integer age)&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("name", name); modelAndView.addObject("age", age); modelAndView.setViewName("regurltest"); return modelAndView;&#125; 在views文件夹中新加一个视图regurltest.jsp内容如下： 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;name&#125;-$&#123;age&#125;&lt;/body&gt;&lt;/html&gt; 请求http://localhost:8080/SpringMVCLesson/helloworld/reg/Hanmeimei-18查看结果： 请求http://localhost:8080/SpringMVCLesson/helloworld/reg/Hanmeimei-Lilei查看结果（会发现找不到对应的action返回404）： 2.限制action所接受的请求方式（get或post）：之前我们在HelloWorldController的index() action方法上配置的为@RequestMapping(value=”/“, method = {RequestMethod.GET})我们把它改为@RequestMapping(value=”/“, method = {RequestMethod.POST})再次请求http://localhost:8080/SpringMVCLesson/helloworld/index试一下： 这里可以看到结果映射到了urlTest这个action，这是因为我们在urlTest上配置的为@RequestMapping(value=”/*”, method = {RequestMethod.GET})，当index这个action映射不在符合时便映射到了urlTest。 我们也可以这样配置@RequestMapping(value=”/*”, method = {RequestMethod.GET, RequestMethod.POST})表示该action可以接受get或post请求，不过更简单的是不对method做配置则默认支持所有请求方式。 3.限制action所接受请求的参数：我们可以为某个action指定映射的请求中必须包含某参数，或必须不包含某参数，或者某参数必须等于某个值，或者某参数必须不等于某个值这些限制。 3.1.指定映射请求必须包含某参数：在HelloWorldController添加一个paramsTest的action，内容如下： 123456@RequestMapping(value="/paramstest", params="example", method = &#123;RequestMethod.GET&#125;)public ModelAndView paramsTest()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("paramstest"); return modelAndView;&#125; 在view文件夹中新加一个视图paramstest.jsp内容如下： 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; paramstest!&lt;/body&gt;&lt;/html&gt; 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest查看结果： 这里可以看到没有找到paramsTest这个action结果还是映射到了urlTest这个action。 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example查看结果： 这次可以看到请求映射到了paramsTest这个action。 3.2.指定映射请求必须不包含某参数：把刚才添加的paramsTest的@RequestMapping(value=”/paramstest”, params=”example”, method = {RequestMethod.GET}) 改为@RequestMapping(value=”/paramstest”, params=”!example”, method = {RequestMethod.GET}) 重新请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example查看结果： 可以看到又没有找到paramsTest这个action而映射到了urlTest这个action。 3.3.指定映射请求中或者某参数必须等于某个值：把刚才添加的paramsTest的@RequestMapping(value=”/paramstest”, params=”example”, method = {RequestMethod.GET}) 改为@RequestMapping(value=”/paramstest”, params=”example=AAA”, method = {RequestMethod.GET}) 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example=BBB查看结果： 可以看到没有找到paramsTest这个action而映射到了urlTest这个action。 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example=AAA查看结果： 这次可以看到请求映射到了paramsTest这个action。 3.4.指定映射请求中或者某参数必须不等于某个值：把刚才添加的paramsTest的@RequestMapping(value=”/paramstest”, params=”example”, method = {RequestMethod.GET}) 改为@RequestMapping(value=”/paramstest”, params=”example!=AAA”, method = {RequestMethod.GET}) 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example=BBB查看结果： 可以看到请求映射到了paramsTest这个action。 请求http://localhost:8080/SpringMVCLesson/helloworld/paramstest?example=AAA查看结果： 可以看到没有找到paramsTest这个action而映射到了urlTest这个action。 注：当我们为params指定多个参数时如：params={“example1”, “example2”}，表示的是and关系，即两个参数限制必须同时满足。 4.限制action所接受请求头参数：同限制action所接受的请求参数一样，我们也可以为某个action指定映射的请求头中必须包含某参数，或必须不包含某参数，或者某参数必须等于某个值，或者某参数必须不等于某个值这些限制。 4.1.指定映射请求头必须包含某参数：@RequestMapping(value=”/headerTest”, headers = “example”)。与限制请求参数是一样的，可以参考上面的例子进行测试。 4.2.指定映射请求头必须不包含某参数：@RequestMapping(value=”/headerTest”, headers = “!example”)。与限制请求参数是一样的，可以参考上面的例子进行测试。 4.3.指定映射请求头中或者某参数必须等于某个值：@RequestMapping(value=”/headerTest”, headers = “Accept=text/html”)。与限制请求参数是一样的，可以参考上面的例子进行测试。 4.4.指定映射请求头中或者某参数必须不等于某个值：@RequestMapping(value=”/headerTest”, headers = “Accept!=text/html”)。与限制请求参数是一样的，可以参考上面的例子进行测试。 注：当我们为headers指定多个参数时如：headers={“example1”, “example2”}，表示的是and关系，即两个参数限制必须同时满足。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的职业方向]]></title>
    <url>%2Fblog%2F47386.html</url>
    <content type="text"><![CDATA[我们可能会有这样的疑问：将来就业干啥好呢？ 如果你是学计算机的，将来想进入软件和互联网行业， 恭喜， 这是个好行业， 薪水很高， 也不需靠关系， 一切靠实力说话， 不需要有个好爸爸。 坏处是， 这个行业需要极为繁重的脑力和体力劳动 , 加班也是司空见惯的事情。 接下来的问题是： 现在软件和互联网大概有哪些方向？ 看看下文的解释： 1. 首先是需求从哪里来?1.1 客户的项目如果做的是客户的项目， 需求当然是从客户那里来的，当然客户绝对是软件开发的小白（其实也不能这么绝对啦， 我也见过极少客户中很优秀的软件人才），他们很难清楚的描述自己真正的业务要求， 这时候就需要有个人隆重出场了： 业务分析师 ， 对于大公司， 业务分析师是专职的， 对于小公司，项目经理或者开发骨干也就硬着头皮上了。 业务分析师需要把需求理理清楚， 交给后面的架构人员做设计。 业务分析师如果在某个行业干久了， 就会变成业务专家， 例如你把国内各大银行的核心系统项目都做了个遍， 那你对银行业务的熟悉程度甚至可能超过银行的特定人员， 这时候你就超级值钱了， 不仅仅能分析业务， 更能够帮助银行优化业务， 你说牛不牛？ 问： 业务分析师需要懂技术吗？ 答： 最好是懂一点，你分析出来的东西是要码农们实现的， 如果不考虑现有的技术，一味地迎合用户， 肯定会被码农们骂死。 如果你是由程序员成长起来的业务专家， 技术精湛， 那就坐着数钱玩吧。 1.2 公司的产品如果你做的是产品， 例如微信， QQ, 淘宝 ， 魔兽世界，征途， 大话西游， 那需求其实是自己公司的人来定义的。 定义这个需求的现在有个时髦的职业： 产品经理。 像张小龙就是微信的超级产品经理， 史玉柱就是征途的骨灰级产品经理。 产品经理主要根据用户的心理和体验来设计产品， 让大家用的爽，好的产品经理现在非常吃香， 也属于紧缺人才。 问： 产品经理需要懂技术吗？ 答： 需要， 最好是从程序员成长起来的， 知道一个产品设计实现的难度， 要不然只顾自己爽 ， 也会被码农骂死。 2. 设计和开发2.1 架构师听起来很高大上的一个职位， 但是需要强悍的技术实力和深厚的技术积累 架构师的成长需要历练， 需要技术的广度， 和适当的深度。 设计优雅，灵活，可扩展的架构是架构师的主要工作 不能追求最新，最热的技术， 还要考虑现有团队的能力，技术的成熟度。 人员需求：★ 难度指数：★★★★★ 2.2 web后端码农后端码农主要实现业务逻辑， 提供接口给前端使用。 Java 当然是用的最多的， 但是也有别的相对小众的像Python, ruby on rails 等， 还有就是PHP，简单粗暴 中小网站常用，无论哪一个，学习起来都不是很难 这一块的人员需求是比较大的。 人员需求：★★★★★ 难度指数：★★★ 2.3 web前端码农主要是Javascript , CSS， JQuery 等， 最近几年大家重视浏览器端用户体验， 浏览器端做的越来越炫， 所以也很火 人员需求：★★★★★ 难度指数：★★★ 2.4手机端码农主要是Android, iOS , 由于移动互联网的发展， 现在很火爆， 需求量很大， 相对而言iOS的门槛高一些，程序员也少一点，不过工资高一点。 人员需求：★★★★ 难度指数：★★★★ 2.5 系统编程码农有些需求很简单， 有些需求很复杂， 需要支持海量的用户 ，海量的并发， 像淘宝的双11， 像微信的春节抢红包 需要做云计算，虚拟化，分布式处理， 支持系统水平扩展。 对于海量的数据，还需要做大数据分析，从中提取有价值的信息， 例如Hadoop。 由于需要对操作系统，数据库，服务器端系统做定制开发， 甚至自己搞一套， 小公司一般没有这样的技术能力， 主要是BAT这样的公司在搞。 人员需求不是很大， 对码农来讲， 需要在一个领域钻研的非常深， 技术稳定度比较好。 人员需求：★★ 难度指数：★★★★★ 2.6 安全互联网时代， 你的信息一不留神就有可能被偷走， 安全变的越来越重要。 所以单单实现了功能， 满足了性能还不够， 很多公司，尤其是BAT对安全非常重视。 这个方向也需要对技术钻研的很深才可以 人员需求：★★ 难度指数：★★★★★ 3. 测试这个对技术要求不太高，但也需要测试相关的知识， 能够设计测试用例， 准备测试数据， 执行测试。 现在敏捷开发流行， 对测试也要求懂开发知识， 至少能够开发一些自动化的脚本。 很多女生后来转到了测试岗位， 我想主要是女生比较细心吧。 我在IBM见过一个非常优秀的测试人员： 她不仅仅能出色完成上面说的工作， 还可以参与设计开发的讨论， 经常能从测试角度提出开发人员都没有想到的问题，极大的帮助提升了软件的质量。 4. 数据库管理员几乎所有项目都需要数据库的支持， 对于大型，超大型项目， 会有一个叫做DBA的职位。他对数据库知识极为精通，平时对数据库进行管理， 开发时能帮助开发团队设计数据库，并且找出性能瓶颈， 进行性能调优。 5. 美工/文档美工： 就是对界面进行美化了，一般是由美工先出界面原型， 大家讨论，修改，确定后美工会生成各种界面元素，像图标，按钮等。 现在对美工也有一定的技术要求， 不仅仅是画界面，还要把html模板做出来， 所以美工需要懂得 HTML, CSS, 甚至部分Javascript。 程序员拿到html模板后，往上添加业务代码即可。 文档编写人员：小项目一般是有人兼职做， 大的项目，产品会有人专职写文档， 我2003年的时候参与过上海证券交易所的项目， 看到有个专职的文档编写人员写的Word , 是在是太专业了， 那个精美啊，完全是可以直接出版的水准。 我把它copy下来，自己都想山寨一个， 照葫芦画瓢都做不出来。 6. 项目管理项目已经开始了， 业务分析师， 架构师， 开发，测试等人一群人如饿狼扑食，势必要把项目撕个粉碎。 可以这么多人怎么协作？ 如何管理？ 进度能不能按要求完成? 这就需要项目经理出马了。 项目经理，说白了就是带着大家做项目， 主要和人打交道， 需要协调各个方面的关系， 保证项目的进展顺利。 问： 项目经理需要懂技术吗？ 答： 当然需要， 最好是开发出身， 要不然你就听不懂那帮码农再说什么， 只能在表面漂浮着， 没法深入项目，别人也就不服你 ， 肯定是带不好团队的。 7. 运营如果你是在开发自己的产品， 开发完成以后， 马上就会遇到一个问题， 怎么推广？ 在互联网时代，世界是平的， 竞争异常激烈，一个好的软件，或者App, 或者网站， 缺乏运营， 你的技术再好也不行。 运营其实就是想方设法让你的产品被人知道， 被人用起来，这里边水很深，例如怎么写个软文？ 怎么在社交网络，微信，微博进行营销？ 怎么统计，分析，精准的定位？ 这方面， 2014年以前的小米绝对是典范。 雷军的7字诀：专注，极致，口碑， 快， 黎万强的《参与感》 都是经典。 好的互联网运营人才奇缺， 当然非常的吃香。 对编程不感兴趣的同学，不妨看看这个方向。说了这么多职业方向， 你会发现， 绝大多数都要求懂一定的技术， 所以我其实想想说的是：刚参加工作， 不妨先从程序员开始， 慢慢的再寻找自己感兴趣的方向。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery中的DOM操作]]></title>
    <url>%2Fblog%2F64922.html</url>
    <content type="text"><![CDATA[JQuery中的DOM操作主要对包括：建【新建】、增【添加】、删【删除】、改【修改】、查【查找】【像数据库操作】。下面的DOM操作将围绕上面的DOM树进行学习JQueryDOM操作。 一、查–查找DOM节点查找节点非常容易，使用选择器就能轻松完成各种查找工作。 例：查找元素节点p返回p内的文本内容 1$("p").text(); 例：查找元素节点p的属性返回属性名称对应的属性值 1$("p").attr("title")//返回p的属性title的值。 1、jQuery选择器：$(‘#text’)最基本的选择器，简化了js的getElementById\byClassNames，querySelectorAll()等方法。允许使用css选择器来对DOM元素进行选择。 2、子元素1$(“.parent”).children();//所有子元素的集合1 3、parent()、parents()、closest()parent()用于查找一级父元素，parents()查找所有父元素的集合，closest()查找最近的父元素例如： 123456789&lt;div&gt; &lt;ul&gt; &lt;li id=“a”&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;var test = $(“#a”);test.parent();//ultest.parents();//ul,div..一直到htmltest.closest(“div”)//div12345678910 4、find()同js的[某元素].getElementById()，在某元素里面找元素 5、nextAll()、prevAll()Ps:javaScript的对应方法 1firstChild(),lastChild,parent()…. 二、建–新建DOM节点1、创建元素节点创建元素节点并且把节点作为元素的子节点添加到DOM节点树上。先创建元素点，创建元素节点使用Jquery的工厂函数$()来完成，格式如下：$(html),该方法会根据传入的html字符串返回一个DOM对象，并将DOM对象包装成一个JQuery对象后返回。创建一个元素节点JQuery代码如下： 1$li1=$("&lt;li&gt;&lt;/li&gt;") 代码返回$li1就是一个由DOM对象包装成的JQuery对象。把新建节点添加到DOM树中JQuery代码如下： 1$("ul").append($li1); 添加后页面中只能看到元素默认的”·”,由于没有为节点添加文本所以只显示默认符号，下面创建文本节点。PS:append()方法是添加DOM节点方法详见增–添加DOM节点。 2、创建文本节点使用JQuery的工厂函数$()同样能够创建文本节点，创建文本节点的JQuery代码如下： 1$li2=$("&lt;li&gt;苹果&lt;/li&gt;"); 代码返回$li2就是一个由DOM对象包装成JQuery对象，把新建的文本节点添加到DOM树中JQuery代码如下： 1$("ul").append($li2); 添加后页面中能看到”·苹果”，右键查看页面源码发现新加的文本节点没有title属性。下面方法创建带属性的节点。 3、创建属性节点创建属性节点同元素节点、文本节点一样使用JQuery的工厂函数完成。创建属性节点的JQuery代码如下： 1$li3=$("&lt;li title='榴莲'&gt;榴莲&lt;/li&gt;"); 代码返回$li3也是一个由DOM对象包装成JQuery对象，把新建的属性节点添加到DOM树中JQuery代码如下： 1$("ul").append($li3); 添加后页面中能看到”·榴莲”，右键查看页面源码发现新加的属性节点有title=’榴莲’属性。 三、增–添加DOM节点动态新建元素不添加到文档中没有实际意义，将新建的节点插入到文档中有多个方法，如下：append()、appendTo()、prepend()、prependTo()、after()、insertAfter()、before()、insertBefore()。 1、append()方法append()方法向匹配的元素内部追加内容，方法如下： 1$("target").append(element); 例： 1$("ul").append("&lt;li title='香蕉'&gt;香蕉&lt;/li&gt;"); 该方法查找ul元素，然后向ul中添加新建的li元素。 2、appendTo()方法appendTo()方法将所有匹配的元素追加到指定的元素中，该方法是append()方法的颠倒[操作主题的颠倒并非操作结果]操作。方法如下： 1$(element).appendTo(target); 例： 1$("&lt;li title='荔枝'&gt;荔枝&lt;li&gt;").appendTo("ul"); 该方法新建元素li，然后把li添加到查找到的ul元素中。 3、prepend()方法prepend()方法将每匹配的元素内部前置要添加的元素，方法如下：$(target).prepend(element);例： 1$("ul").prepend("&lt;li title='芒果'&gt;芒果&lt;/li&gt;") 该方法将查找元素ul然后将新建的li元素作为ul子节点，且作为ul的第一个子节点插入到ul中。 4、prependTo()方法 prependTo()方法将元素添加到每一个匹配的元素内部前置，方法如下：$(element).prependTo();例： 1$("&lt;li title='西瓜’&gt;西瓜&lt;/li&gt;").prependTo("ul"); 该方法将新建的元素li插入到查找到的ul元素中作为ul的第一个子节元素。 5、after()方法after()方法向匹配的元素后面添加元素，新添加的元素做为目标元素后的紧邻的兄弟元素。方法如下： 1$(target).after(element); 例: 1$("p").after("&lt;span&gt;新加段新加段新加段新加段新加段&lt;/span&gt;"); 方法将查找节点p，然后把新建的元素添加到span节点后面做为p的兄弟节点。 6、insertAfter()方法insertAfter()方法将新建的元素插入到查找到的目标元素后，做为目标元素的兄弟节点。方法如下： 1$(element).insertAfter(target); 例: 1$("&lt;p&gt;insertAfter操作&lt;/p&gt;").insertAfter("span"); 方法将新建的p元素添加到查找到目标元素span后面，做为目标元素后面的第一个兄弟节点。 7、before()方法before()方法在每一个匹配的元素之前插入，做为匹配元素的前一个兄弟节点。方法如下: 1$(target).before(element); 例： 1$("p").before("&lt;span&gt;下面是个段落&lt;/span&gt;"); before方法查找每个元素p，将新建的span元素插入到元素p之前做为p的前一个兄弟节点。 8、insertBefore()方法insertBefore()方法将新建元素添加到目标元素前，做为目标元素的前一个兄弟节点，方法如下: 1$(element).insertBefore(target); 例: 1$("&lt;a href='#'&gt;锚&lt;/a&gt;").insertBefore("ul"); insertBefore()新建a元素，将新建的a元素添加到元素ul前，做为ul的前一个兄弟节点。 增加元素的方法前四个是添加到元素内部，后四个是添加到元素外部的操作，有这些方法可以完成任何形式的元素添加。 四、删–删除DOM节点操作如果想要删除文档中的某个元素JQuery提供了两种删除节点的方法：remove()和empty(); 1、remove()方法remove()方法删除所有匹配的元素，传入的参数用于筛选元素，该方法能删除元素中的所有子节点，当匹配的节点及后代被删除后，该方法返回值是指向被删除节点的引用，因此可以使用该引用，再使用这些被删除的元素。方法如下： 1$(element).remove(); 例: 12span=("span").remove();$span.insertAfter("ul"); 该示例中先删除所有的span元素，把删除后的元素使用$span接收，把删除后的元素添加到ul后面做为ul的兄弟节点。该操作相当于将所有的span元素以及后代元素移到ul后面。 2、empty()方法。empty()方法严格来讲并不是删除元素，该方法只是清空节点，它能清空元素中的所有子节点。方法如下: 1$(element).empty(); 例： 1$("ul li:eq(0)").empty(); 该示例使用empty方法清空ul中第一个li的文本值。只能下li标签默认符号”·“。 五、改–修改DOM节点操作 修改文档中的元素节点可以使用多种方法:复制节点、替换节点、包裹节点。 1、复制节点$(element).clone() 复制节点方法能够复制节点元素，并且能够根据参数决定是否复制节点元素的行为。方法如下: 1$(element).clone(true); 例： 1$("ul li:eq(0)").clone(true); 该方法复制ul的第一个li元素，true参数决定复制元素时也复制元素行为，当不复制行为时没有参数。 2、替换节点$(element).repalcewith()、$(element).repalceAll() 替换节点方法能够替换某个节点，有两种形式形式实现：replaceWith()和replaceAll().使用replaceWith方法使用后面的元素替换前面的元素，replaceAll方法使用前面的元素替换后面的元素，方法如下：$(oldelement).replaceWith(newelement);$(newelement).repalceAll(oldelement);例： $(“p”).replaceWith(“我要留下“);该方法使用strong元素替换p元素。 $(“替换strong“).repalceAll(“strong”);该例使用h3元素替换所有的strong元素。 3、包裹节点$(element).wrap()、$(element).wrapAll()、$(element).wrapInner() 包裹节点方法使用其他标记包裹目标元素从而改变元素的显示形式等，并且该操作不会破坏原始文档的词义。包裹节点有三种实现形式：wrap();wrapAll();wrapInner(); wrap()方法如下： 1$(dstelement).wrap(tag); 例： 1 $("p").wrap("&lt;b&gt;&lt;/b&gt;");//该示例方法使用b标签包裹所有的p元素每个元素都使用b标签包裹。 wrapAll()方法如下： 1$(dstelement).wrapAll(tag); 例： 1 $("p").wrapAll("&lt;b&gt;&lt;/b&gt;");//访示例方法使用b标签包裹所有的p元素，所有的p元素标签用一个b标签包裹。 wrapInner()方法如下： 1$(dstelement).wrapInner(tag); 例： 1 $("strong").wrapInner("&lt;b&gt;&lt;/b&gt;");//该示例使用b标签包裹每个一strong元素的子元素。 Dom元素的其他操作:属性操作、样式操作、设置和获取HTML,文本和值、遍历节点操作、Css-Dom操作。 1、属性操作attr()和removeAttr()attr()方法能够获取元素属性，也能能够设置元素属性。方法如下，当attr(para1)方法有个参数时候用于获得当前元素的para1的属性值，当attr(para1,attrValue)有两个参数时候设置当前元素的属性名为para1的属性值为attrValue;例： 12$("p").attr("title");//该示例用于获得p元素的title属性值。$("p").attr("title","//你最喜欢的水果");该示例设置p元素的title属性值为"你最喜欢的水果"; 如果一次设置多个属性值可以使用“名/值”对形式，例： 1$("p").attr(&#123;"title":"你最喜欢的水果","name":"水果"&#125;)//。该示例一次设置两个属性值。 removeAttr()方法用于删除特定的属性，方法是在参数中指定属性名。例： 1$("p").removeAttr("name");//该方法就是移除p元素的name属性。 2、样式操作addClass()、removeClass()、toggleClass()和hasClass()添加样式addClass()方法，使用该方法对目标元素添加相应的样式，方法如下： 1$(element).addClass(); 例： 1$("p").addClass("ul");//该示例设置元素p的样式为ul。 移除样式removeClass()方法，使用该方法移除目标元素的指定样式，方法如下： 1$(element).removeClass(); 例： 1$("p").removeClass("ul");//该救命去除掉p元素的ul类样式。 切换样式toggleClass()方法，使用该方法切换目标元素的样式，方法如下： 1$(element).toggleClass(); 例： 1$("p").toggleClass("ul");//该方法来回切换【添加删除实现切换】元素p的样式ul. 判断元素是否使用了样式 $(element).hasClass(),方法如下：$(element).hasClass(class);例： 1alert($("p").hasClass("ul"));//打印出p元素是否有ul样式。 PS:addClass()和attr()方法设置样式的不同，attr方法把元素的属性名对应的属性值设为方法中的参数值，addClass()则把属性值 添加到属性名对应的属性值中。例：已有元素元素样式,使用attr()和addClass()分别添加新样式。 3、设置和获取HTML【html()】,文本【text()】和值【val()】html()方法获得或设置某个元素的html元素。方法如下:$(selector).html();例: 1234567891011121314151617181920 $("p").html();该示例获得元素p的html内容。$("p").html("&lt;strong&gt;添加html内容&lt;/strong&gt;");该示例设置p的html内容为”&lt;strong&gt;添加html内容&lt;/strong&gt;“;PS：该方法可以用于XHTML文档，不能用于XML文档。text()方法获得或设置某个元素的文本值。方法如下:$(selecotr).text();例：$("p").text();该示例获得元素p的text文本内容。$("p").text("重新设置的文本内容");该示例设置元素p的text文本为"重新设置的文本内容";PS:该方法对html和XML文档都适用。val()方法获得或设置某个元素的值，如果元素值是多选则以数组形式返回，方法如下：$(selector).val();例:文本元素 &lt;input type="text" id="userName" value="请输入用户名" /&gt;$("#userName").val();获得input元素的值。$("#userName").val('响马');设置input元素的值为'响马'。val()方法的不仅能操作input，最重要的一个用途用于select【下拉列表框】、checkbox【多选框】、radio【单选框】。例：在下拉框下的多选赋值应用&lt;select id="fruits" multiple="multiple"&gt;&lt;option&gt;苹果&lt;/option&gt;&lt;option&gt;香蕉&lt;/option&gt;&lt;option&gt;西瓜&lt;/option&gt;&lt;/select&gt;$("#fruits").val(['苹果','香蕉']);该示例使select中苹果和香蕉两项被选中。 4、遍历节点操作children()、next()、prev()、siblings()和closest()children()方法用于取得匹配元素的子元素集合，只匹配子元素不考虑任何后代元素。方法如下：$(selector).children();例： 1 ("("body").children().length;//该示例获得body元素的子元素个数； next()方法用于匹配元素的下一个兄弟节点，方法如下:$(selector).next();例： 1 $("p").next().html();//该示例获得p元素的下一个兄弟节点的html内容。 prev()方法用于匹配元素的上一个兄弟节点，方法如下：$(selector).prev();例： 1 $("ul").prev().text();//该示例获得ul元素的上一个兄弟节点的文本内容。 siblings方法()用于匹配目标元素的所有兄弟元素，方法如下：$(selector).siblings();例： 1$("p").slibings();//示例获得p元素的所有兄弟节点元素。 closest()方法()用来取得最近的匹配元素，首先检查当前元素是否匹配如果匹配则直接返回，否则继续向上查找父元素中符合条件的元素返回，如果没有匹配的元素则返回空JQuery对象。 5、CSS-Dom操作css()、offset()、position()、scrollTop()和scrollLeft()css()方法用于获取、设置元素的一个或多个属性。方法如下：$(selector).css();例： 123$("p").css("color","red");//该示例用于设置元素的颜色属性为红色; $("p").css("color")//该示例用于获得元素的color样式值; $("p").css(&#123;"font-size":"30px","backgroundColor","#888888"&#125;);//该示例用于设置元素的多个样式。 offset()方法用于获取元素相对当前窗体的偏移量，其返回对象包括两个属性：top和left。方法如下：$(selector).offset() 1 var offset= $("p").offset(); var left=offset.left;var top=offset.top;//该示例用于获得元素p的偏移量。 PS:offset()只对可见元素有效。 position()方法用于获取元素于最近的个position样式属性设置为relative或者absolute的祖交节点的相对偏移量。方法如下：$(selector).position();例： 1 var postion = $("p").positon();var left=positon.left;var top=positon.top;//该示例用于获得元素p的位置。 scrollTop()和scrollLeft()方法用于获取元素的滚动条距顶端的距离和距左侧的距离。方法如下:(selector).scrollTop();(selector).scrollLeft();例： 1var scrollTop=("p").scrollTop();var scrollLeft=("p").scrollLeft();//该示例用于获得元素的滚动条的位置。 也可以添加参数将元素滚动到指定的位置。例： 1 ("textarea").scrollTop(300);("textarea").scrollLeft(300);]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端程序员该做什么]]></title>
    <url>%2Fblog%2F1360.html</url>
    <content type="text"><![CDATA[以前做Web开发的时候，根本没有前端，后端之说。 原因很简单，那个时候服务器端的代码就是一切：接受浏览器的请求，实现业务逻辑，访问数据库，用JSP生成HTML，然后发送给浏览器。 即使后来Javascript在浏览器中添加了一些AJAX的效果，那也是锦上添花，绝对不敢造次。因为页面的HTML主要还是用所谓“套模板”的方式生成：美工生成HTML模板，程序员用JSP,Veloctiy,FreeMaker等技术把动态的内容添加上去，仅此而已。 在最初的J2EE体系中，这个表示层可不仅仅是浏览器中运行的页面，还包括Java写的桌面端，只是Java在桌面端太不争气， 没有发展起来。 每个程序员都是所谓“全栈”工程师，不仅要搞定HTML, JavaScript, CSS，还要实现业务逻辑，编写访问数据库的代码。等到部署的时候，就把所有的代码打成一个WAR包，往Tomcat指定的目录一扔，测试一下没问题，收工回家！ 不差钱的公司会把程序部署到Weblogic，Websphere这样的应用服务器中，还会用上高大上的EJB。 虽然看起来生活“简单”又“惬意”，但实际上也需要实现那些多变的、不讲逻辑的业务需求，苦逼的本质并没有改变。 前后端的分离随着大家对浏览器页面的视觉和交互要求越来越高，“套模板”的方式渐渐无法满足要求，这个所谓的表示层慢慢地迁移到浏览器当中去了，一大批像Angular, ReactJS之类的框架崛起，前后端分离了！ 后端的工程师只负责提供接口和数据，专注于业务逻辑的实现，前端取到数据后在浏览器中展示，各司其职。 像Java这样的语言很适合去实现复杂的业务逻辑，尤其是一些MIS系统，行业软件如税务、电力、烟草、金融，通信等等。 所以剥离表示层，只做后端挺合适的。 但是如果仅仅是实现业务逻辑，那后端也不会需要这么多技术了，搞定SSH/SSM就行了。 后端技术互联网，尤其是移动互联网开始兴起以后，海量的用户呼啸而来，一个单机部署的小小War包肯定是撑不住了，必须得做分布式。 原来的单个Tomcat得变成Tomcat的集群，前边弄个Web服务器做请求的负载均衡，不仅如此，还得考虑状态问题，session的一致性。 业务越来越复杂，我们不得不把某些业务放到一个机器（或集群）上，把另外一部分业务放到另外一个机器（或集群）上，虽然系统的计算能力，处理能力大大增强，但是这些系统之间的通信就变成了头疼的问题，消息队列（MQ)，RPC框架（如Dubbo）应运而生，为了提高通信效率，各种序列化的工具(如Protobuf)也争先空后地问世。 单个数据库也撑不住了，那就做数据库的读写分离，如果还不行，就做分库和分表，把原有的数据库垂直地切一切，或者水平地切一切， 但不管怎么切，都会让应用程序的访问非常麻烦，因为数据要跨库做Join/排序，还需要事务，为了解决这个问题，又有各种各样“数据访问中间件”的工具和产品诞生。 为了最大程度地提高性能，缓存肯定少不了，可以在本机做缓存(如Ehcache)，也可以做分布式缓存(如Redis)，如何搞数据分片，数据迁移，失效转移，这又是一个超级大的主题了。 互联网用户喜欢上传图片和文件，还得搞一个分布式的文件系统（如FastDFS），要求高可用，高可靠。 数据量大了，搜索的需求就自然而然地浮出水面，你得弄一个支持全文索引的搜索引擎(如Elasticsearch ,Solr)出来。 林子大了，什么鸟都有，必须得考虑安全，数据的加密/解密，签名、证书，防止SQL注入，XSS/CSRF等各种攻击。 “大后端”前面提到了这么多的系统，还都是分布式的，每次上线，运维的同学说：把这么多系统协调好，把老子都累死了。 得把持续集成做好，能自动化地部署，自动化测试（其实前端也是如此），后来出现了一个革命化的技术docker， 能够让开发、测试、生成环境保持一致，系统原来只是在环境（如Ngnix, JVM,Tomcat,MySQL等）上部署代码，现在把代码和环境一并打包， 运维的工作一下子就简化了。 公司自己购买服务器比较贵，维护也很麻烦，又难于弹性地增长，那就搞点虚拟的服务器吧，硬盘、内存都可以动态扩展（反正是虚拟的）， 访问量大的时候多用点，没啥访问量了就释放一点，按需分配，很方便，这就是云计算的一个场景。 随着时间的推移，各个公司和系统收集的数据越来越多，都堆成一座大山了，难道就放在那里白白地浪费硬盘空间吗？ 有人就惊奇地发现，咦，我们利用这些数据搞点事情啊， 比如把数据好好分析一下，预测一下这个用户的购买/阅读/浏览习惯，给他推荐一点东西嘛。 可是这么多数据，用传统的方式计算好几天甚至好几个月才能出个结果，到时候黄花菜都凉了，所以也得利用分布式的技术，想办法把计算分到各个计算机去，然后再把计算结果收回来， 时势造英雄，Hadoop及其生态系统就应运而生了。 之前听说过一个大前端的概念，把移动端和网页端都归结为“前端”，我这里造个词“大后端”，把那些用户直接接触不到的、发生在服务器端的都归结进来。 怎么学？现在无论是前端还是后端，技术领域多如牛毛，都严重地细分了，所以我认为真正的全栈工程师根本不存在，因为一个人精力有限，不可能搞定这么多技术领域，太难了。 培训机构所说的“全栈”，我认为就是前后端还在拉拉扯扯，藕断丝连，没有彻底分离的时候的“全栈”工程师。 那么问题来了， 后端这么多东西，我该怎么学？ 往深度挖掘，可以成为某个技术领域的专家，如搜索方面的专家、安全方面的专家，分布式文件的专家等等，不管是哪个领域，重点都不是学会使用某个工具和框架， 而是保证你可以自己的知识和技术去搞定这个领域的顶尖问题。 往广度发展，各个技术领域都要了解，对于某种需求，能够选取合适的软件和技术架构来实现它，把需求转化成合适的技术组件，让这些组件以合适的方式连接、部署、运行，这也需要持续地学习和不断的经验积累。 很多人入行以后，都是靠一门语言，几个框架谋生，在这个行业摸爬滚打几年以后，会产生一些疑惑： 作为热爱技术的码农，以后的路该怎么走？ 我觉得有两个方向可供大家参考： 一个是“上天”，一个是“入地”。 上天“上天”的意思就是慢慢往上升了， 刚开始的时候就是在一些框架中做一个填空人员， 在别人的指导下实现小块的业务需求， 比如用Spring, Hibernate/MyBatis 去写税务软件的某一个模块。 后来职责扩大，自己开始负责一个或几个模块，带着别人做开发，看到的领域也越来越大， 开始向外扩展， 去学习系统的缓存是怎么设计的，数据库读写分离，主从复制是怎么做的， session是怎么管理的，搜索是怎么实现的 ，消息队列是怎么用的，怎么做到高可用性、高并发等等。 由点及面， 着眼系统整体和业务的全局，慢慢具备了设计系统架构的能力： 把需求转化成合适的技术组件，让这些组件以合适的方式连接、部署、运行。 经过长时间的实践、历练和经验的积累，把很多东西都研究透了，知道了各种技术的优缺点，终于迎来了质变的一天：突然发现自己具备了技术选型的能力，对于某种需求，能够选取合适的软件和技术架构来实现它。 这时候即使软件业发生了一些变化，出现了很多新技术，例如DevOps, 容器， 微服务，前后端分离，Angular, React ，CQRS 等等， 你发现稍加研究就能参透这些技术的本质， 他们要解决什么问题，有哪些最佳实践， 能否在自己的项目/产品中采用。 恭喜， 你已经成功上天了！ 注意，我说的并不是架构师，技术总监， CTO这样的title ， 而是一种能力。 那些“上天”的人知识面讲究广度，对深度并没有极致要求， 你可能并不了解一个软件的内部细节实现， 但是一定知道这个软件的特点、能力、性能和适用范围。 入地对于“入地”的人，恰恰相反，要求深度而不求广度， 要求是领域专家， 一个形象的比喻是要求一个一厘米宽的口子得有两公里深。 “入地”的人专注于某一类技术，比如说有人特别喜欢安全领域，把各种攻击、防御方法研究透彻 ， 成为了一个安全专家。 或者有人就是喜欢搜索，把搜索引擎的原理搞了个明明白白， 成了搜索专家。 很明显，“入地”要求一个人真的要对这个领域超级感兴趣，要不然就经不起诱惑，耐不住寂寞，别人都在热议云计算，大数据，人工智能，你还能静下心来研究动态字节码生成吗？ 你还能研究Tomcat的原理吗？ “入地”的领域非常多，例如安全、搜索、应用程序框架、缓存、JVM、分布式、RPC框架等等。 或者更加底层的数据库开发，Web服务器开发， 编译器开发等。 这些领域对软件的正确性、可靠性、安全性、性能要求极高，所以从事这些软件开发的人，肯定得真正地精通操作系统、网络、算法等基础知识， 这些人是真正的专家，受到大家的尊敬。 哪个更好？上天和入地哪个更好，更高级？ 其实没有贵贱之分，就看一个人的爱好了，每一条路都不容易，都需要努力的奋斗才行。 最怕的是高不成低不就，工作多年还是呆在中间，那就容易被IT的大浪拍死在沙滩上了！]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http Server, 一个差生的逆袭]]></title>
    <url>%2Fblog%2F16421.html</url>
    <content type="text"><![CDATA[我刚毕业那会儿，国家还是包分配工作的， 我的死党小明被分配到了一个叫数据库的大城市，天天都可以坐在高端大气上档次的机房里， 在那里专门执行SQL查询优化 ， 工作稳定又舒适； 隔壁宿舍的小白被送到了编译器镇，在那里专门把C源文件编译成EXE程序， 虽然累，但是技术含量非常高， 工资高，假期多。 我成绩不太好，典型的差生，四级补考了两次才过， 被发配到了一个不知道什么名字的村庄，据说要处理什么HTTP请求， 这个村庄其实就是一个破旧的电脑， 令我欣慰的是可以上网，时不时能和死党们通个信什么的。 不过辅导员说了， 我们都有光明的前途。 Http Server 1.0HTTP是个新鲜的事物， 能够激起我一点点工作的兴趣， 不至于沉沦下去。 一上班，操作系统老大扔给我一大堆文档： “这是HTTP协议， 两天看完！” 我这样的英文水平， 这几十页的英文HTTP协议我不吃不喝不睡两天也看不完， 死猪不怕开水烫，慢慢磨吧。 两个星期以后， 我终于大概明白了这HTTP是怎么回事： 无非是有些电脑上的浏览器向我这个破电脑发送一个预先定义好的文本（Http request）, 然后我这边处理一下（通常是从硬盘上取一个后缀名是html的文件）， 然后再把这个文件通过文本方式发回去（http response）， 就这么简单。 唯一麻烦的实现， 我得请操作系统给我建立Http层下面的TCP连接通道， 因为所有的文本数据都得通过这些TCP通道接收和发送， 这个通道是用socket建立的。 弄明白了原理，我很快就搞出了第一版程序， 这个程序长这个样子： 看看， 这些socket, bind, listen , accept… 都是操作系统老大提供的接口， 我能做的也就是把他们组装起来： 先在80端口监听， 然后进入无限循环，如果有连接请求来了，就接受(accept)，创建新的socket, 最后才可以通过这个socket来接收，发送http数据。 老大给我的程序起了个名称， Http Server, 版本1.0 。 这个名字听起来挺高端的， 我喜欢。 我兴冲冲的拿来实验， 程序启动了， 在80端口“蹲守”， 过了一会儿就有连接请求了， 赶紧Accept ,建立新的socket, 成功 ！ 接下来就需要从socket 中读取Http Request了。 可是这个receive 调用好慢， 我足足等了100毫秒还没有响应 ！ 我被阻塞(block)住了！ 操作系统老大说： “别急啊， 我也在等着从网卡那里读数据，读完以后就会复制给你。 ” 我乐的清闲， 可以休息一下。 可是操作系统老大说：“别介啊， 后边还有很多浏览器要发起连接， 你不能在这儿歇着啊。” 我说不歇着怎么办？ receive调用在你这里阻塞着， 我除了加入阻塞队列， 让出CPU让别人用还能干什么？ 老大说： “唉， 大学里没听说过多进程吗？ 你现在很明显是单进程， 一旦阻塞就完蛋了， 想办法用下多进程， 每个进程处理一个请求！ ” 老大教训的是， 我忘了多进程并发编程了。 Http 2.0 ：多进程多进程的思路非常简单，当accept连接以后，对于这个新的socket ， 不在主进程里处理， 而是新创建子进程来接管。 这样主进程就不会阻塞在receive 上， 可以继续接受新的连接了。 我改写了代码， 把Http server 升级为V2.0， 这次运行顺畅了很多， 能并发的处理很多连接了。 这个时候Web 刚刚兴起， 我这个Http Server 访问的人还不多， 每分钟也就那么几十个连接发过来，我轻松应对。 由于是新鲜事物， 我还有资本给搞数据库的小明和做编译的小白吹吹牛， 告诉他们我可是网络高手。 没过几年, Web迅速发展， 我所在的破旧机器也不行了， 换成了一个性能强悍的服务器， 也搬到了四季如春的机房里。 现在每秒中都有上百个连接请求了， 有些连接持续的时间还相当的长，所以我经常得创建成百上千的进程来处理他们，每个进程都得耗费大量的系统资源， 很明显操作系统老大已经不堪重负了。 他说： “咱们不能这么干了， 这么多进程，光是做进程切换就把我累死了。” “要不对每个Socket连接我不用进程了， 使用线程？ ” “可能好一点， 但我还是得切换线程啊， 你想想办法限制一下数量吧。” 我怎么限制？ 我只能说同一时刻，我只能支持x个连接， 其他的连接只能排队等待了。 这肯定不是一个好的办法。 Http Server 3.0 : Select模型老大说： “我们仔细合计合计， 对我来说，一个Socket连接就是一个所谓的文件描述符（File Descriptor ,简称 fd , 是个整数） , 这个fd 背后是一个简单的数据结构， 但是我们用了一个非常重量级的东西– 进程 –来表示对它的读写操作， 有点浪费啊。” 我说： “要不咱们还切换回单进程模型？ 但是又会回到老路上去， 一个receive 的阻塞就什么事都干不了了” “单进程也不是不可以， 但是我们要改变一下工作方式。” “改成什么？” 我想不透老大在卖什么关子。 “你想想你阻塞的本质原因， 还不是因为人家浏览器还没有把数据发过来， 我自然也没法给你， 而你又迫不及待的想去读， 我只好把你阻塞。 在单进程情况下， 一阻塞，别的事儿都干不了。“ “对，就是这样” “所以你接受了客户端连接以后， 不能那么着急的去读， 咱们这么办， 你的每个socket fd 都有编号， 你把这些编号告诉我， 就可以阻塞休息了 ” 我问道：“这不和以前一样吗？ 原来是调用receive 时阻塞， 现在还是阻塞” “听我说完， 我会在后台检查这些编号的socket, 如果发现这些socket 可以读写， 我会把对应的socket 做个标记， 把你唤醒去处理这些socket 的数据， 你处理完了，再把你的那些socket fd 告诉我， 再次进入阻塞，如此循环往复。” 我有点明白了： “ 这是我们俩的一种通信方式， 我告诉你我要等待什么东西， 然后阻塞， 如果事件发生了， 你就把我唤醒， 让我做事情。” “对， 关键点是你等我的通知， 我把你从阻塞状态唤醒后， 你一定要去遍历一遍所有的socket fd，看看谁有标记， 有标记的做相应处理。 我把这种方式叫做 select ” 我用select的方式改写了Http server， 抛弃了一个socket请求对于一个进程的模式， 现在我用一个进程就可以处理所有的socket了。 Http Server4.0 : epoll这种称为select的方式运行了一段时间， 效果还不错， 我只管把socket fd 告诉老大， 然后等着他通知我就行了。 有一次我无意中问老大：“我每次最多可以告诉你多少个socket fd？” “1024个” “那就是说我一个进程最多只能监控1024个socket了？ ” “是的， 你可以考虑多用几个进程啊” 这倒是一个办法， 不过”select”的方式用的多了， 我就发现了弊端， 最大的问题就是我从阻塞中恢复以后，需要遍历这1000多个socket fd， 看看有没有标志位需要处理。 实际的情况是， 很多socket 并不活跃， 在一段时间内浏览器并没有数据发过来， 这1000多个socket 可能只有那么几十个需要真正的处理， 但是我不得不查看所有的socket fd， 这挺烦人的。 难道老大不能把那些发生了变化的socket 告诉我吗？ 我把这个想法给老大说了下， 他说：“嗯， 现在访问量越来越大， select 方式已经不满足要求， 我们需要与时俱进了， 我想了一个新的方式，叫做epoll” “看到没有， 使用epoll和select 其实类似“ 老大接着说 ： ” 不同的地方是第3步和第4步， 我只会告诉你那些可以读写的socket , 你呢只需要处理这些’ready’ 的socket 就可以了“ “看来老大想的很周全， 这种方式对我来说就简单的多了。 ” 我用epoll 把Http Server 再次升级， 由于不需要遍历全部集合， 只需要处理哪些有变化的， 活跃的socket 文件描述符， 系统的处理能力有了飞跃的提升。 我的Http Server 受到了广泛的欢迎， 全世界有无数人在使用， 最后死党数据库小明也知道了， 他问我：“ 大家都说你能轻松的支持好几万的并发连接， 真是这样吗？ ” 我谦虚的说： “过奖， 其实还得做系统的优化啦。” 他说：“厉害啊，你小子走了狗屎运了啊。” 我回答： “毕业那会儿辅导员不是说过吗， 每个人都有光明的前途。” （完）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入网址到浏览器呈现发生了什么]]></title>
    <url>%2Fblog%2F37416.html</url>
    <content type="text"><![CDATA[前言这篇文章是应网友之邀所写，主要描述一下我们访问网站时， 从输入网址到最后浏览器呈现内容，中间发生了什么。 今天的文章主要专注于应用层，我拿了一个很简单的网络结构来讲。假定本机已经获取了IP地址，各种网络基础设施已经准备好了。 由于知识点太多，我肯定会漏掉部分内容，欢迎在留言中补充， 以后我会根据大家建议再写文章扩展。 准备当你在浏览器中输入网址（例如www.coder.com）并且敲了回车以后， 浏览器首先要做的事情就是获得coder.com的IP地址，具体的做法就是发送一个UDP的包给DNS服务器，DNS服务器会返回coder.com的IP, 这时候浏览器通常会把IP地址给缓存起来，这样下次访问就会加快。 比如Chrome， 你可以通过chrome://net-internals/#dns来查看。 有了服务器的IP， 浏览器就要可以发起HTTP请求了，但是HTTP Request/Response必须在TCP这个“虚拟的连接”上来发送和接收。 想要建立“虚拟的”TCP连接，TCP邮差需要知道4个东西：（本机IP, 本机端口，服务器IP, 服务器端口），现在只知道了本机IP,服务器IP， 两个端口怎么办？ 本机端口很简单，操作系统可以给浏览器随机分配一个， 服务器端口更简单，用的是一个“众所周知”的端口，HTTP服务就是80， 我们直接告诉TCP邮差就行。 经过三次握手以后，客户端和服务器端的TCP连接就建立起来了！ 终于可以发送HTTP请求了。 之所以把TCP连接画成虚线，是因为这个连接是虚拟的。 Web服务器一个HTTP GET请求经过千山万水，历经多个路由器的转发，终于到达服务器端（HTTP数据包可能被下层进行分片传输，略去不表）。 Web服务器需要着手处理了，它有三种方式来处理： 可以用一个线程来处理所有请求，同一时刻只能处理一个，这种结构易于实现，但是这样会造成严重的性能问题。 可以为每个请求分配一个进程/线程，但是当连接太多的时候，服务器端的进程/线程会耗费大量内存资源，进程/线程的切换也会让CPU不堪重负。 复用I/O的方式，很多Web服务器都采用了复用结构，例如通过epoll的方式监视所有的连接，当连接的状态发生变化（如有数据可读）， 才用一个进程/线程对那个连接进行处理，处理完以后继续监视，等待下次状态变化。 用这种方式可以用少量的进程/线程应对成千上万的连接请求。 我们使用Nginx这个非常流行的Web服务器来继续下面的故事。 对于HTTP GET请求，Nginx利用epoll的方式给读取了出来， Nginx接下来要判断，这是个静态的请求还是个动态的请求啊？ 如果是静态的请求（HTML文件，JavaScript文件，CSS文件，图片等），也许自己就能搞定了（当然依赖于Nginx配置，可能转发到别的缓存服务器去），读取本机硬盘上的相关文件，直接返回。 如果是动态的请求，需要后端服务器（如Tomcat)处理以后才能返回，那就需要向Tomcat转发，如果后端的Tomcat还不止一个，那就需要按照某种策略选取一个。 例如Ngnix支持这么几种： 轮询：按照次序挨个向后端服务器转发 权重：给每个后端服务器指定一个权重，相当于向后端服务器转发的几率。 ip_hash： 根据ip做一个hash操作，然后找个服务器转发，这样的话同一个客户端ip总是会转发到同一个后端服务器。 fair：根据后端服务器的响应时间来分配请求，响应时间段的优先分配。 不管用哪种算法，某个后端服务器最终被选中，然后Nginx需要把HTTP Request转发给后端的Tomcat，并且把Tomcat输出的HttpResponse再转发给浏览器。 由此可见，Nginx在这种场景下，是一个代理人的角色。 应用服务器Http Request终于来到了Tomcat，这是一个由Java写的、可以处理Servlet/JSP的容器，我们的代码就运行在这个容器之中。 如同Web服务器一样， Tomcat也可能为每个请求分配一个线程去处理，即通常所说的BIO模式（Blocking I/O 模式）。 也可能使用I/O多路复用技术，仅仅使用若干线程来处理所有请求，即NIO模式。 不管用哪种方式，Http Request 都会被交给某个Servlet处理，这个Servlet又会把Http Request做转换，变成框架所使用的参数格式，然后分发给某个Controller(如果你是在用Spring)或者Action(如果你是在Struts)。 剩下的故事就比较简单了（不，对码农来说，其实是最复杂的部分），就是执行码农经常写的增删改查逻辑，在这个过程中很有可能和缓存、数据库等后端组件打交道，最终返回HTTP Response，由于细节依赖业务逻辑，略去不表。 根据我们的例子，这个HTTP Response应该是一个HTML页面。 归途Tomcat很高兴地把Http Response发给了Ngnix 。 Ngnix也很高兴地把Http Response 发给了浏览器。 发完以后TCP连接能关闭吗？ 如果使用的是HTTP1.1， 这个连接默认是keep-alive，也就是说不能关闭； 如果是HTTP1.0，要看看之前的HTTP Request Header中有没有Connetion:keep-alive，如果有，那也不能关闭。 浏览器再次工作浏览器收到了Http Response，从其中读取了HTML页面，开始准备显示这个页面。 但是这个HTML页面中可能引用了大量其他资源，例如js文件，CSS文件，图片等，这些资源也位于服务器端，并且可能位于另外一个域名下面，例如static.coder.com。 浏览器没有办法，只好一个个地下载，从使用DNS获取IP开始，之前做过的事情还要再来一遍。不同之处在于不会再有应用服务器如Tomcat的介入了。 如果需要下载的外部资源太多，浏览器会创建多个TCP连接，并行地去下载。 但是同一时间对同一域名下的请求数量也不能太多，要不然服务器访问量太大，受不了。所以浏览器要限制一下， 例如Chrome在Http1.1下只能并行地下载6个资源。 当服务器给浏览器发送JS,CSS这些文件时，会告诉浏览器这些文件什么时候过期（使用Cache-Control或者Expire），浏览器可以把文件缓存到本地，当第二次请求同样的文件时，如果不过期，直接从本地取就可以了。 如果过期了，浏览器就可以询问服务器端，文件有没有修改过？（依据是上一次服务器发送的Last-Modified和ETag），如果没有修改过（304 Not Modified），还可以使用缓存。否则的话服务器就会被最新的文件发回到浏览器。 当然如果你按了Ctrl+F5，会强制地发出GET请求，完全无视缓存。 注：在Chrome下，可以通过 chrome://view-http-cache/ 命令来查看缓存。 现在浏览器得到了三个重要的东西： HTML ，浏览器把它变成DOM Tree CSS, 浏览器把它变成CSS Rule Tree JavaScript， 它可以修改DOM Tree 浏览器会通过DOM Tree和CSS Rule Tree生成所谓“Render Tree”，计算每个元素的位置/大小，进行布局，然后调用操作系统的API进行绘制，这是一个非常复杂的过程，略去不表。 到目前为止，我们终于在浏览器中看到了www.coder.com的内容。 （完）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS Client集群环境的问题及解决方案]]></title>
    <url>%2Fblog%2F53969.html</url>
    <content type="text"><![CDATA[为了描述方便，假设有如下一个单点登录系统。一套CASServer，两套CAS Client系统。为了描述的方便，省略CAS Server调用用户系统完成登录，以及CASClient从用户系统读取用户详细信息的过程。 1 单点登录的过程为了描述方便，假设有如下一个单点登录系统。一套CASServer，两套CAS Client系统。为了描述的方便，省略CAS Server调用用户系统完成登录，以及CASClient从用户系统读取用户详细信息的过程。 1.1 多应用情况下Session信息假定有两个CAS Client应用，一个CAS Server。应用的部署，可能在不同的服务器，也可能有不同的访问IP或域名，即使是同一个浏览器，在各个应用中的Session信息也是不相同的。 浏览器中，每个应用有一个独立的JSESSIONIDCookie。某一个应用，不可能读取到浏览器在其他应用中的Cookie信息。 假定用户首先访问CAS Client 01，系统提醒用户进行一次登录；然后用户访问CAS Client2，不会再提示登录而是直接登录成功。 1.2 第一次访问CAS Client 01用户打开浏览器后第一次访问，重定向到单点登录后，会提示用户输入账号密码登录。登录成功之后，再跳转回CAS Client。 1.3 第一次访问CAS Client 02当用户浏览器已经登录系统，切换到另一个CASClient时，跟第一次访问有所不同，因为已经登录成功，就不会再提醒输入账号密码登录了。 1.4 再次访问CAS Clients当用户已经访问过CAS Client后，当用户再次访问，系统不会再跳转到CAS Server做认证。 1.5 CASClient配置为了实现前述的单点登录过程，以Java WEB项目为例，需要在 web.xml 中进行相应的配置。（为了排版，没有填写Filter的完整class名，请自行查阅补充。） 123456789101112131415161718192021222324&lt;filter&gt; &lt;filter-name&gt;CAS AuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;*.AuthenticationFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt;*.Cas10TicketValidationFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest WrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;*.HttpServletRequestWrapperFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS AuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest WrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 仔细看一下配置过滤器可以发现，三个过滤器正好对应流程图中三次访问CAS Client。 Authentication Filter：负责将未登录用户跳转到登录界面 Authentication Filter：负责验证Service Ticket HttpServletRequest WrapperFilter：负责将用户信息封装到request和session中。 2 统一注销的过程2.1 不能实现统一注销会有什么问题当用户访问系统后从系统注销，如何能够从每个应用中都注销？注意前面1.4部分的描述，如果用户注销时，并没有注销CASClient 02中的会话信息，如果用户在浏览器中直接访问这个应用，因为Session存在，并不会提醒用户重新登录。 这会带来两个潜在的隐患： 用户注销user1后换账号user2重新登录，进入CAS Client 02之后，当前身份其实还是user1，并没有如用户预期一样使用user2身份。 用户user1点击注销后离开，没有关闭浏览器。这时候其他用户直接打开CAS Client 02，能够直接盗用user1的身份进行操作。 2.2基本概念：Service、TGT和STCAS已经考虑到统一注销的问题。 这里有三个重要的概念TGT、ST和Service，需要着重介绍一下，因为它们同后续统一注销的方案息息相关。 2.2.1 Service这是用户第一次访问CAS Client的URL。假设一个CAS Client应用部署在域名oa.company.com，使用HTTP协议，应用首页是index.htm。当用户第一次访问这个应用时，对应的URL地址是 http://oa.company.com/index.htm 。这个URL，对CAS Server来说，就是一个service。 当用户第一次跳转到CAS Server的时候，可以看到传了一个参数service，就是这个值。当CASServer生成Ticket重定向到CAS Client的时候，实际就是在这个service 中添加了一个参数 ticket 。 2.2.2 TGT：Ticket Grangting TicketTGT是CAS Server为每一个登录用户创建的登录令牌。在CASServer上拥有了TGT，用户就可以证明自己在CASServer成功登录过。TGT封装了SessionCookie值以及此Cookie值对应的用户信息。当HTTP请求到来时，CAS以此Cookie值为key查询缓存中有无TGT ，如果有的话，则相信用户已登录过。 2.2.3 ST：Service TicketST是CAS Server为用户签发的访问某一service的认证令牌。用户访问service时，service发现用户没有ST，浏览器会跳转到CASServer去获取ST。CAS Server发现用户有TGT，则签发一个ST，返回给用户。用户使用ST作为ticket参数去访问service，service拿ST去CAS Server验证，验证通过后，得到当前登录用户的登录名。 注意TGT和ST，是一对多的关系。一个TGT会维护一个 services 列表，每当为用户创建一个ST并认证通过后，会将这个ST添加到TGT的services列表中。这样，在CASServer端，这个services列表实际维护了一个用户登录过的所有CASClient。这就为实现统一注销打下了基础。 2.3 CAS Client的统一注销配置CAS Client，为了实现统一注销，除了第一张介绍的三个登录过程的过滤器之外，还需要添加一个统一注销过滤器。 1234567891011&lt;filter&gt; &lt;filter-name&gt;CAS Single Sign OutFilter&lt;/filter-name&gt; &lt;filter-class&gt;*.SingleSignOutFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign OutFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;listener&gt; &lt;listener-class&gt;*.SingleSignOutHttpSessionListener&lt;/listener-class&gt;&lt;/listener&gt; 2.4 CAS Server注销过程用户在浏览器中点击“注销”链接，实际浏览器会访问CASServer的注销页面。收到注销请求后，CAS Server会读取到TGT，并检查当前用户登录过的所有service，并依次发送注销请求。 2.5 CAS Client注销过程CAS Client的注销，核心代码是SingleSignOutFilter，它的关键代码 12345678910public voiddoFilter(servletRequest, servletResponse, filterChain)&#123; HttpServletRequest request =(HttpServletRequest)servletRequest; if (handler.isTokenRequest(request)) &#123; handler.recordSession(request); &#125; else if (handler.isLogoutRequest(request)) &#123; handler.destroySession(request); return; &#125; filterChain.doFilter(servletRequest, servletResponse);&#125; 其中handler是SingleSignOutHandler的实例，这个对象完成用户在CASClient端登录信息的维护和注销工作。 至此，CAS完整的登录和注销过程就完成。 2.6 思考：什么情况统一注销会失败统一注销的实现，需要CAS Server通过HttpClient访问CAS Client的service。如果这个访问过程失败，就会导致统一注销失败。列了几种情况，不详述。 开发调试阶段，使用localhost访问CAS Client。 CAS Server部署在外网，CAS Client部署在内网。 网络安全设置，不允许CASServer访问CAS Client。 3 CAS Client集群的影响前面的论述，一直假定所有的CAS Client都是单点部署，没有集群。如果集群，会有什么影响，应该如何来解决？ 3.1 Client集群对登录的影响假设使用nginx做集群前端，后面部署两台CAS Client 01的实例。我们看看对登录过程会有什么影响。 为了描述方便，CAS Client登录过程会有三次请求（对应三个过滤器），我们依次命名为Authentication Request / Validation Request / Wrapper Request。 Nginx缺省的分发规则，并不是sticky模式，同一个浏览器的请求，会按照nginx自身某种规则进行分发。我们曾经测试过，在双点集群环境下，Authentication Request和ValidationRequest会恰好被分发到两台服务器，这就会导致登录过程死循环。 出现登录死循环的原因，主要在于nginx分发时，没有使用sticky策略，也就是同一个浏览器的请求，永远分发给同一台CAS Client实例。缺省nginx的分发策略，可以根据用户IP分发，实现的是同一个IP永远分发到同一台Client，这样就能解决死循环的问题。 3.2 Client集群对注销的影响当nginx实现了sitcky转发，同一个浏览器的访问会分发到同一个Client1实例，该用户的会话信息也一直保存在Client1实例中。 当用户统一注销时，由CAS Server向Client发送注销请求，这时候nginx无法确保按当前用户进行分发，因此可能会被分发到Client2。这时候，实际效果是注销失败。 这个问题，在我们当前的环境中真实存在，还没有合理的解决方法。初步分析，大概有几个修改方向。 3.2.1 修改nginx分发策略问题存在的原因，是因为nginx在分发注销策略时，不能准确分发。如果能在这个环节进行修改，系统代码和环境，基本不用做任何修改。 这里有两种分发方法： CAS Server发送的注销请求，分发给对应的后台服务器。 CAS Server发送的注销请求，广播到所有的后台服务器。 初步结论：同架构组进行了沟通，这两种方案都很难实现，特别是广播的方案，没在网络上找到类似成功的案例。 3.2.2 集群的节点实现Session同步如果能实现集群Session的同步：同步创建、同步注销，主要在一个Client上实现了注销，其他Client也就同步注销。 这个会对Tomcat性能有影响。 3.2.3 集群节点使用redis保存会话信息即使是多个节点，它们的会话信息只有一份。一旦失效，则所有节点都失效。这只是一个设想，没有做技术调研，不知能够实现。 这有两种修改方法： 修改Tomcat的配置文件，使用redis保存Tomcat的会话信息。 修改代码而不是Tomcat，使用redis保存会话信息。 初步结论：架构组不允许修改生产环境的Tomcat，否定了第一种方法。我们只能尝试修改代码并利用redis保存会话。 3.2.4 每次请求验证用户是否注销首先，在CAS Server中实现一个接口，用于判断某一个ST对应的TGT是否还有效。 在SingleSignOutFilter中，每次访问都调用CAS Server的这个新接口，判断用户是否已经注销。如果已经注销，则立刻注销本实例中的会话信息。 这个方法是比较安全的解决办法，但每次请求都会调用CASServer接口，会对性能造成巨大影响。完全不建议用这种方案。 3.2.5 几种策略的初步调研对前面提到的几种方案做了初步调研之后： 技术实现困难，否定了方案1 性能考虑以及架构组的策略，否定方案2 架构组的策略，否定方案3中的第一种做法。 性能考虑，否定方案4。 因此，可能的做法是修改代码，使用redis保存会话信息。 4 使用redis保存会话在目前的生产环境的限制下，我们只能采用修改代码来实现redis保存会话的实现方案。 4.1 Request和Session缺省怎么实现在Tomcat缺省的实现中，Session信息都是保存在JVM中，所以不能跨JVM共享。 要想将所有的session都保存到redis中，一种能想到的简单办法是自己写一个CustomSession，将会话信息保存到这个自定义的Session中，并且利用redis等进行保存。但这样做，会带来很大的代码改动，所有涉及到session读写操作的地方可能都需要修改。 我们希望找到更优雅的解决方案，能够修改更少的代码。 4.2 WEB请求的执行过程Request 和Session什么时候创建？如何传递？ Filter的调用入口函数是doFilter，传入的主要参数是request和response。在此之前，Tomcat已经创建好request。通常情况下，业务代码不需要关心request和session等对象如何创建的问题，只需要使用即可。每个过滤器的实现，当需要继续流程的时候，只需要将得到的request和response传递给下一个filter就行。 但这仅仅是缺省做法，并不表示我们不能修改或重写一个request对象。我们想修改Session的保存位置，如果能在所有的Filter之前插入一个自定义过滤器，定义一个新的Request传递给后面的Filter，并且让后面的Filter和Servlet感受不到变化，就可以实现这个目标。 4.3 如何定制Request4.3.1 增加过滤器在所有的Filter之前，插入一个新的Filter。 HttpServletRequest可以重写吗？ 4.3.2 Tomcat的Request实现4.3.3 改写之后的Request实现在Session重写一个RedisSessionRequest，继承自HttpServletRequestWrapper，并包含原request(RequestFacade)的引用。但需要读取Form参数时，直接调用oriRequest取值。当需要拿到Session对象进行会话信息访问时，调用重载后的函数。 这样就实现了request的封装，在后续的filter和servlet中通过request获取到的session，都是放在redis中的会话数据，不再是缺省保存在JVM中的数据。 4.3.4 集群环境的session读写当nginx将同一个浏览器的请求分发给不同的Tomcat时，都会根据SessionId从redis中读取Session。因为同一个浏览器发送请求的SessionID相同，所以在不同的Tomcat实例中，会读取到同一个Session对象。 4.4 使用Spring Session实现根据前面的分析，在项目中自定义Request，就可以实现需求。Spring Session已经是一个成熟的开源实现，并且后端实现了将会话保存在redis、mongodb、jdbc等多种实现，我们没必要自己发明轮子。 Spring提供的例子代码很简洁，跟我们已经实现的业务系统稍微有点不同。在现有系统中，已经定义了bean jedisConnectionFactory，可以直接使用。 4.4.1 修改pom.xml在pom.xml文件中，添加代码 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4.4.2 修改redis配置文件在项目中已经有redis配置文件spring-redis.xml，在其中添加内容 1&lt;context:annotation-config/&gt;&lt;beans:beanclass="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"/&gt; 4.4.3 修改web.xml在所有的过滤器前面添加一个新的过滤器 12345678910&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 4.5 测试实现效果集成Spring Session后，经过初步测试，能够达到预想效果。（感谢同事瑞钊的实际测试并提供截图） 4.5.1 Session信息已经保存到redis中用户登录后查看redis中的数据，可以看到这些Session信息。 4.5.2 删除redis中会话的影响用户登录后继续访问系统，不会切换到CAS登录页面。 如果手工删掉redis中的session，重新访问，可以看到需要重新做一个CAS认证的过程。 4.5.3 统一用户注销的测试后续需要部署一套生产环境的集群环境，验证统一注销的效果。 5 问题：问题在于，Cas Client中有一个实现类HashMapBackedSessionMappingStorage，这个类的作用，在于存储tiket和sessionId的映射注销的时候，cas服务器会发来一个tiket，退出过滤器需要根据这个ticket找到对应的sessionId来清除session 而HashMapBackedSessionMappingStorage是存储在Map里的，也就是内存里的，而不是session里 如果能保证nginx转发的路径是固定的，也就是一个访问者 固定访问一个tomcat，那固然没问题。所以我觉得 你这个方案测试应该是没问题的。 但是，如果这个tomcat挂掉了呢？ 靠谱的方式应该是把这个映射关系 也存在redis里。也就是自己实现一个RedisBackedSessionMappingStorage 链接：https://yq.aliyun.com/articles/49871casclient源代码下载链接：https://github.com/apereo/java-cas-client cas官网链接：https://www.apereo.org/projects/cas 上面一篇引用别人的分析方案介绍，来描述了下项目中遇到的问题，现在介绍本人怎么解决的 本人项目中用的是改造了tomcat 做的session 共享 所以客户端请求退出，服务端根据TGT查看对应的ST进行请求客户端，通过nginx负载均衡，可能对应到另一台客户端服务器，但是我们的session是存入rediscluster，任意客户端可以根据sessionid取到这个，进行删除，这样session就没了。即在客户端配置的SingleSignOutFilter，需要在HashMapBackedSessionMappingStorage进行删除存入redis的session数据，这样就可以退出了，就是这个原理来处理这个退出登录问题 代码依赖jar包spring-data-redis-1.7.4.RELEASE.jar；jedis-2.9.0.jar；fastjson-1.2.31.jar；注意jar包版本 改造的HashMapBackedSessionMappingStorage类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package org.jasig.cas.client.session;/*- agreements. See the NOTICE file distributed with this work- for additional information regarding copyright ownership.- Jasig licenses this file to you under the Apache License,- Version 2.0 (the "License"); you may not use this file- except in compliance with the License. You may obtain a- copy of the License at the following location: *- http://www.apache.org/licenses/LICENSE-2.0 *- Unless required by applicable law or agreed to in writing,- software distributed under the License is distributed on an- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY- KIND, either express or implied. See the License for the- specific language governing permissions and limitations- under the License. */import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import javax.annotation.Resource;import javax.servlet.http.HttpSession;import org.jasig.cas.client.session.SessionMappingStorage;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.EnableMBeanExport;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;/**- HashMap backed implementation of SessionMappingStorage.- @author Scott Battaglia- @version Revision Date- @since 3.1 */ public final class HashMapBackedSessionMappingStorage implements SessionMappingStorage &#123; protected final transient Logger logger = LoggerFactory.getLogger(getClass()); private final static String CASCLIENT_PREFIX = "CASCLI:SESSIONID:"; private final static String CASCLIENT_MAPID_PREFIX = "CASCLI:MAPID:"; private int casTimeout=86400; private RedisTemplate redisTemplate=new RedisTemplate(); public RedisTemplate getRedisTemplate() &#123; return redisTemplate; &#125; public void setRedisTemplate(RedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; public HashMapBackedSessionMappingStorage()&#123; ApplicationContext ac =new ClassPathXmlApplicationContext("classpath:schemeone/xml/spring-core.xml"); setRedisTemplate((RedisTemplate)ac.getBean("redisTemplate")); &#125; @Override public synchronized void addSessionById(String mappingId, HttpSession session) &#123; logger.debug("Adding ticket &#123;&#125;", session); try &#123; String sessionRedisKey = this.getCasSessionRedisKey(session.getId()); String mappingIdRedisKey = this.getCasMappingIdRedisKey(mappingId); this.redisTemplate.boundValueOps(sessionRedisKey).set(mappingId, casTimeout, TimeUnit.SECONDS); this.redisTemplate.boundValueOps(mappingIdRedisKey).set(session.getId(), casTimeout, TimeUnit.SECONDS); &#125; catch (final Exception e) &#123; logger.error("Failed Adding &#123;&#125;", session, e); &#125; &#125; @Override public synchronized void removeBySessionById(String sessionId) &#123; logger.debug("Attempting to remove Session=[&#123;&#125;]", sessionId); final String key =(String) this.redisTemplate.boundValueOps(this.getCasSessionRedisKey(sessionId)).get(); if (logger.isDebugEnabled()) &#123; if (key != null) &#123; logger.debug("Found mapping for session. Session Removed."); &#125; else &#123; logger.debug("No mapping for session found. Ignoring."); &#125; &#125; this.redisTemplate.delete(this.getCasMappingIdRedisKey(key)); this.redisTemplate.delete(this.getCasSessionRedisKey(sessionId)); &#125; @Override public synchronized HttpSession removeSessionByMappingId(String mappingId) &#123; //先去取sessionid final String sessionId=(String) this.redisTemplate.boundValueOps(this.getCasMappingIdRedisKey(mappingId)).get(); //final HttpSession session = (HttpSession) this.redisTemplate.boundValueOps(sessionId).get(); this.redisTemplate.delete(sessionId);// if (session != null) &#123;// removeBySessionById(session.getId());// &#125;// return session; if (sessionId != null) &#123; removeBySessionById(sessionId); &#125; return null; &#125; private String getCasSessionRedisKey( String sessionId) &#123; return CASCLIENT_PREFIX + sessionId; &#125; private String getCasMappingIdRedisKey(String mappingId) &#123; return CASCLIENT_MAPID_PREFIX + mappingId; &#125;&#125; redistemplteBean配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"xmlns:context="http://www.springframework.org/schema/context"xmlns:util="http://www.springframework.org/schema/util"xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"&gt; &lt;!-- 扫描注解Bean --&gt;&lt;context:component-scan base-package="com.hivescm" /&gt;&lt;aop:config proxy-target-class="true" /&gt;&lt;!-- 开启AOP监听 只对当前配置文件有效 --&gt;&lt;aop:aspectj-autoproxy expose-proxy="true" /&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;!--&lt;value&gt;classpath:schemeone/properties/common/*.properties&lt;/value&gt; --&gt; &lt;value&gt;classpath:schemeone/properties/common/redis.cluster.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt;&lt;!-- 最大空闲数 --&gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt;&lt;!-- 最大建立连接等待时间 --&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt;&lt;!-- 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个 --&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean&gt;&lt;!-- 配置文件加载 --&gt; &lt;bean id="resourcePropertySource" class="org.springframework.core.io.support.ResourcePropertySource"&gt; &lt;constructor-arg name="name" value="redis.cluster.properties"/&gt; &lt;constructor-arg name="resource" value="classpath:schemeone/properties/common/redis.cluster.properties"/&gt; &lt;/bean&gt;&lt;!-- redisCluster配置 --&gt; &lt;bean id="redisClusterConfiguration" class="org.springframework.data.redis.connection.RedisClusterConfiguration"&gt; &lt;constructor-arg name="propertySource" ref="resourcePropertySource"/&gt; &lt;/bean&gt;&lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;constructor-arg name="clusterConfig" ref="redisClusterConfiguration"/&gt; &lt;constructor-arg name="poolConfig" ref="poolConfig"/&gt; &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt;&lt;!-- 如果不配置Serializer，那么存储的时候缺省使用String，如果用User类型存储，那么会提示错误User can't cast to String！！ --&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="hashKeySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;/property&gt; &lt;property name="hashValueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt; &lt;/property&gt; &lt;/bean &gt;&lt;/beans&gt; redis.cluster.properties 1234567891011121314151617181920212223242526272829303132333435363738394041424344#redis\u4E2D\u5FC3#redis\u7684\u670D\u52A1\u5668\u5730\u5740redis.host=192.168.103.158#redis\u7684\u670D\u52A1\u7AEF\u53E3redis.port=6379#\u5BC6\u7801redis.password=#\u6700\u5927\u7A7A\u95F2\u6570redis.maxIdle=100#\u6700\u5927\u8FDE\u63A5\u6570redis.maxActive=300#\u6700\u5927\u5EFA\u7ACB\u8FDE\u63A5\u7B49\u5F85\u65F6\u95F4redis.maxWait=1000#\u5BA2\u6237\u7AEF\u8D85\u65F6\u65F6\u95F4\u5355\u4F4D\u662F\u6BEB\u79D2redis.timeout=100000redis.maxTotal=1000redis.minIdle=8#\u660E\u662F\u5426\u5728\u4ECE\u6C60\u4E2D\u53D6\u51FA\u8FDE\u63A5\u524D\u8FDB\u884C\u68C0\u9A8C,\u5982\u679C\u68C0\u9A8C\u5931\u8D25,\u5219\u4ECE\u6C60\u4E2D\u53BB\u9664\u8FDE\u63A5\u5E76\u5C1D\u8BD5\u53D6\u51FA\u53E6\u4E00\u4E2Aredis.testOnBorrow=true#sentinel#spring.redis.sentinel.node1.host=127.0.0.1#spring.redis.sentinel.node2.host=127.0.0.1#spring.redis.sentinel.node3.host=127.0.0.1#spring.redis.sentinel.node1.port=26379#spring.redis.sentinel.node2.port=26479#spring.redis.sentinel.node3.port=26579#sentinel#jediscluster#cluster1.host.port=127.0.0.1:7000#cluster2.host.port=127.0.0.1:7001#cluster3.host.port=127.0.0.1:7002#cluster4.host.port=127.0.0.1:7003#cluster5.host.port=127.0.0.1:7004#cluster6.host.port=127.0.0.1:7005#cluster7.host.port=127.0.0.1:7006#cluster8.host.port=127.0.0.1:7007#jediscluster#rediscluster#spring.redis.cluster.nodes=192.168.103.158:6379spring.redis.cluster.nodes=192.168.103.174:6379,192.168.103.174:6389,192.168.103.174:6399,192.168.103.173:6379,192.168.103.173:6389,192.168.103.173:6399spring.redis.cluster.max-redirects=3]]></content>
      <categories>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具类总结]]></title>
    <url>%2Fblog%2F36591.html</url>
    <content type="text"><![CDATA[Java FileUtils、StringUtils和DateUtils笔记 FileUtils我项目中用到的文件工具类 读取raw文件、file文件，drawable文件，asset文件，比如本地的json数据，本地文本等；如：String result =FileUtil.getString(context,”raw://first.json”) 读取本地的property文件，并转化为hashMap类型的数据 （simpleProperty2HashMap）； 将raw文件拷贝到指定目录（copyRawFile）； 基本文件读写操作（readFile，writeFile）； 从文件的完整路径名（路径+文件名）中提取 路径（extractFilePath）； 从文件的完整路径名（路径+文件名）中提取文件名(包含扩展名)如：d:\path\file.ext –&gt; file.ext（extractFileName） 检查指定文件的路径是否存在（pathExists） 检查制定文件是否存在（fileExists） 创建目录（makeDir） 移除字符串中的BOM前缀（removeBomHeaderIfExists） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435package com.nsu.edu.library.utils;import android.content.Context;import android.graphics.Bitmap;import android.graphics.drawable.BitmapDrawable;import android.text.TextUtils;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.util.HashMap;import java.util.Iterator;import java.util.Properties;import java.util.Set;/** * Create By Anthony on 2016/1/15 * Class Note:文件工具类 * 包含内容： * 1 读取raw文件、file文件，drawable文件，asset文件，比如本地的json数据，本地文本等； * 如：String result =FileUtil.getString(context,"raw://first.json") * 2 读取本地的property文件，并转化为hashMap类型的数据（simpleProperty2HashMap）； * 3 将raw文件拷贝到指定目录（copyRawFile）； * 4 基本文件读写操作（readFile，writeFile）； * 5 从文件的完整路径名（路径+文件名）中提取 路径（extractFilePath）； * 6 从文件的完整路径名（路径+文件名）中提取文件名(包含扩展名) 如：d:\path\file.ext --&gt; file.ext（extractFileName） *7 检查指定文件的路径是否存在（pathExists） *8 检查制定文件是否存在（fileExists） *9 创建目录（makeDir） *10 移除字符串中的BOM前缀（removeBomHeaderIfExists） */public class FileUtil &#123; public static final String ASSETS_PREFIX = "file://android_assets/"; public static final String ASSETS_PREFIX2 = "file://android_asset/"; public static final String ASSETS_PREFIX3 = "assets://"; public static final String ASSETS_PREFIX4 = "asset://"; public static final String RAW_PREFIX = "file://android_raw/"; public static final String RAW_PREFIX2 = "raw://"; public static final String FILE_PREFIX = "file://"; public static final String DRAWABLE_PREFIX = "drawable://"; public static InputStream getStream(Context context, String url) throws IOException &#123; String lowerUrl = url.toLowerCase(); InputStream is; if (lowerUrl.startsWith(ASSETS_PREFIX)) &#123; String assetPath = url.substring(ASSETS_PREFIX.length()); is = getAssetsStream(context, assetPath); &#125; else if (lowerUrl.startsWith(ASSETS_PREFIX2)) &#123; String assetPath = url.substring(ASSETS_PREFIX2.length()); is = getAssetsStream(context, assetPath); &#125; else if (lowerUrl.startsWith(ASSETS_PREFIX3)) &#123; String assetPath = url.substring(ASSETS_PREFIX3.length()); is = getAssetsStream(context, assetPath); &#125; else if (lowerUrl.startsWith(ASSETS_PREFIX4)) &#123; String assetPath = url.substring(ASSETS_PREFIX4.length()); is = getAssetsStream(context, assetPath); &#125; else if (lowerUrl.startsWith(RAW_PREFIX)) &#123; String rawName = url.substring(RAW_PREFIX.length()); is = getRawStream(context, rawName); &#125; else if (lowerUrl.startsWith(RAW_PREFIX2)) &#123; String rawName = url.substring(RAW_PREFIX2.length()); is = getRawStream(context, rawName); &#125; else if (lowerUrl.startsWith(FILE_PREFIX)) &#123; String filePath = url.substring(FILE_PREFIX.length()); is = getFileStream(filePath); &#125; else if (lowerUrl.startsWith(DRAWABLE_PREFIX)) &#123; String drawableName = url.substring(DRAWABLE_PREFIX.length()); is = getDrawableStream(context, drawableName); &#125; else &#123; throw new IllegalArgumentException(String.format("Unsupported url: %s \n" + "Supported: \n%sxxx\n%sxxx\n%sxxx", url, ASSETS_PREFIX, RAW_PREFIX, FILE_PREFIX)); &#125; return is; &#125; private static InputStream getAssetsStream(Context context, String path) throws IOException &#123; return context.getAssets().open(path); &#125; private static InputStream getFileStream(String path) throws IOException &#123; return new FileInputStream(path); &#125; private static InputStream getRawStream(Context context, String rawName) throws IOException &#123; int id = context.getResources().getIdentifier(rawName, "raw", context.getPackageName()); if (id != 0) &#123; try &#123; return context.getResources().openRawResource(id); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; throw new IOException(String.format("raw of id: %s from %s not found", id, rawName)); &#125; private static InputStream getDrawableStream(Context context, String rawName) throws IOException &#123; int id = context.getResources().getIdentifier(rawName, "drawable", context.getPackageName()); if (id != 0) &#123; BitmapDrawable drawable = (BitmapDrawable) context.getResources().getDrawable(id); Bitmap bitmap = drawable.getBitmap(); ByteArrayOutputStream os = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG, 0, os); return new ByteArrayInputStream(os.toByteArray()); &#125; throw new IOException(String.format("bitmap of id: %s from %s not found", id, rawName)); &#125; public static String getString(Context context, String url) throws IOException &#123; return getString(context, url, "UTF-8"); &#125; public static String getString(Context context, String url, String encoding) throws IOException &#123; String result = readStreamString(getStream(context, url), encoding); if (result.startsWith("\ufeff")) &#123; result = result.substring(1); &#125; return result; &#125; public static String readStreamString(InputStream is, String encoding) throws IOException &#123; return new String(readStream(is), encoding); &#125; public static byte[] readStream(InputStream is) throws IOException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buf = new byte[1024 * 10]; int readlen; while ((readlen = is.read(buf)) &gt;= 0) &#123; baos.write(buf, 0, readlen); &#125; baos.close(); return baos.toByteArray(); &#125; public static Bitmap getDrawableBitmap(Context context, String rawName) &#123; int id = context.getResources().getIdentifier(rawName, "drawable", context.getPackageName()); if (id != 0) &#123; BitmapDrawable drawable = (BitmapDrawable) context.getResources().getDrawable(id); if (drawable != null) &#123; return drawable.getBitmap(); &#125; &#125; return null; &#125; /** * 读取Property文件 */ public static HashMap&lt;String, String&gt; simpleProperty2HashMap(Context context, String path) &#123; try &#123; InputStream is = getStream(context, path); return simpleProperty2HashMap(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new HashMap&lt;String, String&gt;(); &#125; private static HashMap&lt;String, String&gt; simpleProperty2HashMap(InputStream in) throws IOException &#123; HashMap&lt;String, String&gt; hashMap = new HashMap&lt;String, String&gt;(); Properties properties = new Properties(); properties.load(in); in.close(); Set keyValue = properties.keySet(); for (Iterator it = keyValue.iterator(); it.hasNext(); ) &#123; String key = (String) it.next(); hashMap.put(key, (String) properties.get(key)); &#125; return hashMap; &#125; /** * 将raw文件拷贝到指定目录 */ public static void copyRawFile(Context ctx, String rawFileName, String to) &#123; String[] names = rawFileName.split("\\."); String toFile = to + "/" + names[0] + "." + names[1]; File file = new File(toFile); if (file.exists()) &#123; return; &#125; try &#123; InputStream is = getStream(ctx, "raw://" + names[0]); OutputStream os = new FileOutputStream(toFile); int byteCount = 0; byte[] bytes = new byte[1024]; while ((byteCount = is.read(bytes)) != -1) &#123; os.write(bytes, 0, byteCount); &#125; os.close(); is.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 基本文件操作 */ public static String FILE_READING_ENCODING = "UTF-8"; public static String FILE_WRITING_ENCODING = "UTF-8"; public static String readFile(String _sFileName, String _sEncoding) throws Exception &#123; StringBuffer buffContent = null; String sLine; FileInputStream fis = null; BufferedReader buffReader = null; if (_sEncoding == null || "".equals(_sEncoding)) &#123; _sEncoding = FILE_READING_ENCODING; &#125; try &#123; fis = new FileInputStream(_sFileName); buffReader = new BufferedReader(new InputStreamReader(fis, _sEncoding)); boolean zFirstLine = "UTF-8".equalsIgnoreCase(_sEncoding); while ((sLine = buffReader.readLine()) != null) &#123; if (buffContent == null) &#123; buffContent = new StringBuffer(); &#125; else &#123; buffContent.append("\n"); &#125; if (zFirstLine) &#123; sLine = removeBomHeaderIfExists(sLine); zFirstLine = false; &#125; buffContent.append(sLine); &#125;// end while return (buffContent == null ? "" : buffContent.toString()); &#125; catch (FileNotFoundException ex) &#123; throw new Exception("要读取的文件没有找到!", ex); &#125; catch (IOException ex) &#123; throw new Exception("读取文件时错误!", ex); &#125; finally &#123; // 增加异常时资源的释放 try &#123; if (buffReader != null) buffReader.close(); if (fis != null) fis.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; public static File writeFile(InputStream is, String path, boolean isOverride) throws Exception &#123; String sPath = extractFilePath(path); if (!pathExists(sPath)) &#123; makeDir(sPath, true); &#125; if (!isOverride &amp;&amp; fileExists(path)) &#123; if(path.contains(".")) &#123; String suffix = path.substring(path.lastIndexOf(".")); String pre = path.substring(0, path.lastIndexOf(".")); path = pre + "_" + TimeUtils.getNowTime() + suffix; &#125; else &#123; path = path + "_" + TimeUtils.getNowTime(); &#125; &#125; FileOutputStream os = null; File file = null; try &#123; file = new File(path); os = new FileOutputStream(file); int byteCount = 0; byte[] bytes = new byte[1024]; while ((byteCount = is.read(bytes)) != -1) &#123; os.write(bytes, 0, byteCount); &#125; os.flush(); return file; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("写文件错误", e); &#125; finally &#123; try &#123; if (os != null) os.close(); if (is != null) is.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static File writeFile(String path, String content, String encoding, boolean isOverride) throws Exception &#123; if (TextUtils.isEmpty(encoding)) &#123; encoding = FILE_WRITING_ENCODING; &#125; InputStream is = new ByteArrayInputStream(content.getBytes(encoding)); return writeFile(is, path, isOverride); &#125; /** * 从文件的完整路径名（路径+文件名）中提取 路径（包括：Drive+Directroy ) * * @param _sFilePathName * @return */ public static String extractFilePath(String _sFilePathName) &#123; int nPos = _sFilePathName.lastIndexOf('/'); if (nPos &lt; 0) &#123; nPos = _sFilePathName.lastIndexOf('\\'); &#125; return (nPos &gt;= 0 ? _sFilePathName.substring(0, nPos + 1) : ""); &#125; /** * 从文件的完整路径名（路径+文件名）中提取文件名(包含扩展名) &lt;br&gt; * 如：d:\path\file.ext --&gt; file.ext * * @param _sFilePathName * @return */ public static String extractFileName(String _sFilePathName) &#123; return extractFileName(_sFilePathName, File.separator); &#125; /** * 从文件的完整路径名（路径+文件名）中提取文件名(包含扩展名) &lt;br&gt; * 如：d:\path\file.ext --&gt; file.ext * * @param _sFilePathName 全文件路径名 * @param _sFileSeparator 文件分隔符 * @return */ public static String extractFileName(String _sFilePathName, String _sFileSeparator) &#123; int nPos = -1; if (_sFileSeparator == null) &#123; nPos = _sFilePathName.lastIndexOf(File.separatorChar); if (nPos &lt; 0) &#123; nPos = _sFilePathName .lastIndexOf(File.separatorChar == '/' ? '\\' : '/'); &#125; &#125; else &#123; nPos = _sFilePathName.lastIndexOf(_sFileSeparator); &#125; if (nPos &lt; 0) &#123; return _sFilePathName; &#125; return _sFilePathName.substring(nPos + 1); &#125; /** * 检查指定文件的路径是否存在 * * @param _sPathFileName 文件名称(含路径） * @return 若存在，则返回true；否则，返回false */ public static boolean pathExists(String _sPathFileName) &#123; String sPath = extractFilePath(_sPathFileName); return fileExists(sPath); &#125; public static boolean fileExists(String _sPathFileName) &#123; File file = new File(_sPathFileName); return file.exists(); &#125; /** * 创建目录 * * @param _sDir 目录名称 * @param _bCreateParentDir 如果父目录不存在，是否创建父目录 * @return */ public static boolean makeDir(String _sDir, boolean _bCreateParentDir) &#123; boolean zResult = false; File file = new File(_sDir); if (_bCreateParentDir) zResult = file.mkdirs(); // 如果父目录不存在，则创建所有必需的父目录 else zResult = file.mkdir(); // 如果父目录不存在，不做处理 if (!zResult) zResult = file.exists(); return zResult; &#125; /** * 移除字符串中的BOM前缀 * * @param _sLine 需要处理的字符串 * @return 移除BOM后的字符串. */ private static String removeBomHeaderIfExists(String _sLine) &#123; if (_sLine == null) &#123; return null; &#125; String line = _sLine; if (line.length() &gt; 0) &#123; char ch = line.charAt(0); // 使用while是因为用一些工具看到过某些文件前几个字节都是0xfffe. // 0xfeff,0xfffe是字节序的不同处理.JVM中,一般是0xfeff while ((ch == 0xfeff || ch == 0xfffe)) &#123; line = line.substring(1); if (line.length() == 0) &#123; break; &#125; ch = line.charAt(0); &#125; &#125; return line; &#125;&#125; 网上的工具类这个工具类也大同小异。其中也有很多和我上面重复的一些方法，也有上面没有的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575package com.nsu.edu.library.utils;import android.text.TextUtils;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.util.ArrayList;import java.util.List;/** * File Utils * &lt;ul&gt; * Read or write file * &lt;li&gt;&#123;@link #readFile(String, String)&#125; read file&lt;/li&gt; * &lt;li&gt;&#123;@link #readFileToList(String, String)&#125; read file to string list&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, String, boolean)&#125; write file from String&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, String)&#125; write file from String&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, List, boolean)&#125; write file from String List&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, List)&#125; write file from String List&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, InputStream)&#125; write file&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(String, InputStream, boolean)&#125; write file&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(File, InputStream)&#125; write file&lt;/li&gt; * &lt;li&gt;&#123;@link #writeFile(File, InputStream, boolean)&#125; write file&lt;/li&gt; * &lt;/ul&gt; * &lt;ul&gt; * Operate file * &lt;li&gt;&#123;@link #moveFile(File, File)&#125; or &#123;@link #moveFile(String, String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #copyFile(String, String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #getFileExtension(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #getFileName(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #getFileNameWithoutExtension(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #getFileSize(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #deleteFile(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #isFileExist(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #isFolderExist(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #makeFolders(String)&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link #makeDirs(String)&#125;&lt;/li&gt; * &lt;/ul&gt; * * @author &lt;a href="http://www.trinea.cn" target="_blank"&gt;Trinea&lt;/a&gt; 2012-5-12 */public class FileUtils &#123; public final static String FILE_EXTENSION_SEPARATOR = "."; private FileUtils() &#123; throw new AssertionError(); &#125; /** * read file * * @param filePath * @param charsetName The name of a supported &#123;@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;&#125; * @return if file not exist, return null, else return content of file * @throws RuntimeException if an error occurs while operator BufferedReader */ public static StringBuilder readFile(String filePath, String charsetName) &#123; File file = new File(filePath); StringBuilder fileContent = new StringBuilder(""); if (file == null || !file.isFile()) &#123; return null; &#125; BufferedReader reader = null; try &#123; InputStreamReader is = new InputStreamReader(new FileInputStream(file), charsetName); reader = new BufferedReader(is); String line = null; while ((line = reader.readLine()) != null) &#123; if (!fileContent.toString().equals("")) &#123; fileContent.append("\r\n"); &#125; fileContent.append(line); &#125; return fileContent; &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(reader); &#125; &#125; /** * write file * * @param filePath * @param content * @param append is append, if true, write to the end of file, else clear content of file and write into it * @return return false if content is empty, true otherwise * @throws RuntimeException if an error occurs while operator FileWriter */ public static boolean writeFile(String filePath, String content, boolean append) &#123; if (StringUtils.isEmpty(content)) &#123; return false; &#125; FileWriter fileWriter = null; try &#123; makeDirs(filePath); fileWriter = new FileWriter(filePath, append); fileWriter.write(content); return true; &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(fileWriter); &#125; &#125; /** * write file * * @param filePath * @param contentList * @param append is append, if true, write to the end of file, else clear content of file and write into it * @return return false if contentList is empty, true otherwise * @throws RuntimeException if an error occurs while operator FileWriter */ public static boolean writeFile(String filePath, List&lt;String&gt; contentList, boolean append) &#123; if (ListUtils.isEmpty(contentList)) &#123; return false; &#125; FileWriter fileWriter = null; try &#123; makeDirs(filePath); fileWriter = new FileWriter(filePath, append); int i = 0; for (String line : contentList) &#123; if (i++ &gt; 0) &#123; fileWriter.write("\r\n"); &#125; fileWriter.write(line); &#125; return true; &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(fileWriter); &#125; &#125; /** * write file, the string will be written to the begin of the file * * @param filePath * @param content * @return */ public static boolean writeFile(String filePath, String content) &#123; return writeFile(filePath, content, false); &#125; /** * write file, the string list will be written to the begin of the file * * @param filePath * @param contentList * @return */ public static boolean writeFile(String filePath, List&lt;String&gt; contentList) &#123; return writeFile(filePath, contentList, false); &#125; /** * write file, the bytes will be written to the begin of the file * * @param filePath * @param stream * @return * @see &#123;@link #writeFile(String, InputStream, boolean)&#125; */ public static boolean writeFile(String filePath, InputStream stream) &#123; return writeFile(filePath, stream, false); &#125; /** * write file * * @param file the file to be opened for writing. * @param stream the input stream * @param append if &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end of the file rather than the beginning * @return return true * @throws RuntimeException if an error occurs while operator FileOutputStream */ public static boolean writeFile(String filePath, InputStream stream, boolean append) &#123; return writeFile(filePath != null ? new File(filePath) : null, stream, append); &#125; /** * write file, the bytes will be written to the begin of the file * * @param file * @param stream * @return * @see &#123;@link #writeFile(File, InputStream, boolean)&#125; */ public static boolean writeFile(File file, InputStream stream) &#123; return writeFile(file, stream, false); &#125; /** * write file * * @param file the file to be opened for writing. * @param stream the input stream * @param append if &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end of the file rather than the beginning * @return return true * @throws RuntimeException if an error occurs while operator FileOutputStream */ public static boolean writeFile(File file, InputStream stream, boolean append) &#123; OutputStream o = null; try &#123; makeDirs(file.getAbsolutePath()); o = new FileOutputStream(file, append); byte data[] = new byte[1024]; int length = -1; while ((length = stream.read(data)) != -1) &#123; o.write(data, 0, length); &#125; o.flush(); return true; &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException("FileNotFoundException occurred. ", e); &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(o); IOUtils.close(stream); &#125; &#125; /** * move file * * @param sourceFilePath * @param destFilePath */ public static void moveFile(String sourceFilePath, String destFilePath) &#123; if (TextUtils.isEmpty(sourceFilePath) || TextUtils.isEmpty(destFilePath)) &#123; throw new RuntimeException("Both sourceFilePath and destFilePath cannot be null."); &#125; moveFile(new File(sourceFilePath), new File(destFilePath)); &#125; /** * move file * * @param srcFile * @param destFile */ public static void moveFile(File srcFile, File destFile) &#123; boolean rename = srcFile.renameTo(destFile); if (!rename) &#123; copyFile(srcFile.getAbsolutePath(), destFile.getAbsolutePath()); deleteFile(srcFile.getAbsolutePath()); &#125; &#125; /** * copy file * * @param sourceFilePath * @param destFilePath * @return * @throws RuntimeException if an error occurs while operator FileOutputStream */ public static boolean copyFile(String sourceFilePath, String destFilePath) &#123; InputStream inputStream = null; try &#123; inputStream = new FileInputStream(sourceFilePath); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException("FileNotFoundException occurred. ", e); &#125; return writeFile(destFilePath, inputStream); &#125; /** * read file to string list, a element of list is a line * * @param filePath * @param charsetName The name of a supported &#123;@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;&#125; * @return if file not exist, return null, else return content of file * @throws RuntimeException if an error occurs while operator BufferedReader */ public static List&lt;String&gt; readFileToList(String filePath, String charsetName) &#123; File file = new File(filePath); List&lt;String&gt; fileContent = new ArrayList&lt;String&gt;(); if (file == null || !file.isFile()) &#123; return null; &#125; BufferedReader reader = null; try &#123; InputStreamReader is = new InputStreamReader(new FileInputStream(file), charsetName); reader = new BufferedReader(is); String line = null; while ((line = reader.readLine()) != null) &#123; fileContent.add(line); &#125; return fileContent; &#125; catch (IOException e) &#123; throw new RuntimeException("IOException occurred. ", e); &#125; finally &#123; IOUtils.close(reader); &#125; &#125; /** * get file name from path, not include suffix * * &lt;pre&gt; * getFileNameWithoutExtension(null) = null * getFileNameWithoutExtension("") = "" * getFileNameWithoutExtension(" ") = " " * getFileNameWithoutExtension("abc") = "abc" * getFileNameWithoutExtension("a.mp3") = "a" * getFileNameWithoutExtension("a.b.rmvb") = "a.b" * getFileNameWithoutExtension("c:\\") = "" * getFileNameWithoutExtension("c:\\a") = "a" * getFileNameWithoutExtension("c:\\a.b") = "a" * getFileNameWithoutExtension("c:a.txt\\a") = "a" * getFileNameWithoutExtension("/home/admin") = "admin" * getFileNameWithoutExtension("/home/admin/a.txt/b.mp3") = "b" * &lt;/pre&gt; * * @param filePath * @return file name from path, not include suffix * @see */ public static String getFileNameWithoutExtension(String filePath) &#123; if (StringUtils.isEmpty(filePath)) &#123; return filePath; &#125; int extenPosi = filePath.lastIndexOf(FILE_EXTENSION_SEPARATOR); int filePosi = filePath.lastIndexOf(File.separator); if (filePosi == -1) &#123; return (extenPosi == -1 ? filePath : filePath.substring(0, extenPosi)); &#125; if (extenPosi == -1) &#123; return filePath.substring(filePosi + 1); &#125; return (filePosi &lt; extenPosi ? filePath.substring(filePosi + 1, extenPosi) : filePath.substring(filePosi + 1)); &#125; /** * get file name from path, include suffix * * &lt;pre&gt; * getFileName(null) = null * getFileName("") = "" * getFileName(" ") = " " * getFileName("a.mp3") = "a.mp3" * getFileName("a.b.rmvb") = "a.b.rmvb" * getFileName("abc") = "abc" * getFileName("c:\\") = "" * getFileName("c:\\a") = "a" * getFileName("c:\\a.b") = "a.b" * getFileName("c:a.txt\\a") = "a" * getFileName("/home/admin") = "admin" * getFileName("/home/admin/a.txt/b.mp3") = "b.mp3" * &lt;/pre&gt; * * @param filePath * @return file name from path, include suffix */ public static String getFileName(String filePath) &#123; if (StringUtils.isEmpty(filePath)) &#123; return filePath; &#125; int filePosi = filePath.lastIndexOf(File.separator); return (filePosi == -1) ? filePath : filePath.substring(filePosi + 1); &#125; /** * get folder name from path * * &lt;pre&gt; * getFolderName(null) = null * getFolderName("") = "" * getFolderName(" ") = "" * getFolderName("a.mp3") = "" * getFolderName("a.b.rmvb") = "" * getFolderName("abc") = "" * getFolderName("c:\\") = "c:" * getFolderName("c:\\a") = "c:" * getFolderName("c:\\a.b") = "c:" * getFolderName("c:a.txt\\a") = "c:a.txt" * getFolderName("c:a\\b\\c\\d.txt") = "c:a\\b\\c" * getFolderName("/home/admin") = "/home" * getFolderName("/home/admin/a.txt/b.mp3") = "/home/admin/a.txt" * &lt;/pre&gt; * * @param filePath * @return */ public static String getFolderName(String filePath) &#123; if (StringUtils.isEmpty(filePath)) &#123; return filePath; &#125; int filePosi = filePath.lastIndexOf(File.separator); return (filePosi == -1) ? "" : filePath.substring(0, filePosi); &#125; /** * get suffix of file from path * * &lt;pre&gt; * getFileExtension(null) = "" * getFileExtension("") = "" * getFileExtension(" ") = " " * getFileExtension("a.mp3") = "mp3" * getFileExtension("a.b.rmvb") = "rmvb" * getFileExtension("abc") = "" * getFileExtension("c:\\") = "" * getFileExtension("c:\\a") = "" * getFileExtension("c:\\a.b") = "b" * getFileExtension("c:a.txt\\a") = "" * getFileExtension("/home/admin") = "" * getFileExtension("/home/admin/a.txt/b") = "" * getFileExtension("/home/admin/a.txt/b.mp3") = "mp3" * &lt;/pre&gt; * * @param filePath * @return */ public static String getFileExtension(String filePath) &#123; if (StringUtils.isBlank(filePath)) &#123; return filePath; &#125; int extenPosi = filePath.lastIndexOf(FILE_EXTENSION_SEPARATOR); int filePosi = filePath.lastIndexOf(File.separator); if (extenPosi == -1) &#123; return ""; &#125; return (filePosi &gt;= extenPosi) ? "" : filePath.substring(extenPosi + 1); &#125; /** * Creates the directory named by the trailing filename of this file, including the complete directory path required * to create this directory. &lt;br/&gt; * &lt;br/&gt; * &lt;ul&gt; * &lt;strong&gt;Attentions:&lt;/strong&gt; * &lt;li&gt;makeDirs("C:\\Users\\Trinea") can only create users folder&lt;/li&gt; * &lt;li&gt;makeFolder("C:\\Users\\Trinea\\") can create Trinea folder&lt;/li&gt; * &lt;/ul&gt; * * @param filePath * @return true if the necessary directories have been created or the target directory already exists, false one of * the directories can not be created. * &lt;ul&gt; * &lt;li&gt;if &#123;@link FileUtils#getFolderName(String)&#125; return null, return false&lt;/li&gt; * &lt;li&gt;if target directory already exists, return true&lt;/li&gt; * &lt;li&gt;return &#123;@link File#makeFolder&#125;&lt;/li&gt; * &lt;/ul&gt; */ public static boolean makeDirs(String filePath) &#123; String folderName = getFolderName(filePath); if (StringUtils.isEmpty(folderName)) &#123; return false; &#125; File folder = new File(folderName); return (folder.exists() &amp;&amp; folder.isDirectory()) ? true : folder.mkdirs(); &#125; /** * @param filePath * @return * @see #makeDirs(String) */ public static boolean makeFolders(String filePath) &#123; return makeDirs(filePath); &#125; /** * Indicates if this file represents a file on the underlying file system. * * @param filePath * @return */ public static boolean isFileExist(String filePath) &#123; if (StringUtils.isBlank(filePath)) &#123; return false; &#125; File file = new File(filePath); return (file.exists() &amp;&amp; file.isFile()); &#125; /** * Indicates if this file represents a directory on the underlying file system. * * @param directoryPath * @return */ public static boolean isFolderExist(String directoryPath) &#123; if (StringUtils.isBlank(directoryPath)) &#123; return false; &#125; File dire = new File(directoryPath); return (dire.exists() &amp;&amp; dire.isDirectory()); &#125; /** * delete file or directory * &lt;ul&gt; * &lt;li&gt;if path is null or empty, return true&lt;/li&gt; * &lt;li&gt;if path not exist, return true&lt;/li&gt; * &lt;li&gt;if path exist, delete recursion. return true&lt;/li&gt; * &lt;ul&gt; * * @param path * @return */ public static boolean deleteFile(String path) &#123; if (StringUtils.isBlank(path)) &#123; return true; &#125; File file = new File(path); if (!file.exists()) &#123; return true; &#125; if (file.isFile()) &#123; return file.delete(); &#125; if (!file.isDirectory()) &#123; return false; &#125; for (File f : file.listFiles()) &#123; if (f.isFile()) &#123; f.delete(); &#125; else if (f.isDirectory()) &#123; deleteFile(f.getAbsolutePath()); &#125; &#125; return file.delete(); &#125; /** * get file size * &lt;ul&gt; * &lt;li&gt;if path is null or empty, return -1&lt;/li&gt; * &lt;li&gt;if path exist and it is a file, return file size, else return -1&lt;/li&gt; * &lt;ul&gt; * * @param path * @return returns the length of this file in bytes. returns -1 if the file does not exist. */ public static long getFileSize(String path) &#123; if (StringUtils.isBlank(path)) &#123; return -1; &#125; File file = new File(path); return (file.exists() &amp;&amp; file.isFile() ? file.length() : -1); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318public class FileUtil&#123; private static String message; /** * 读取文本文件内容 * @param filePathAndName 带有完整绝对路径的文件名 * @param encoding 文本文件打开的编码方式 * @return 返回文本文件的内容 */ public static String readTxt(String filePathAndName,String encoding) throws IOException&#123; encoding = encoding.trim(); StringBuffer str = new StringBuffer(""); String st = ""; try&#123; FileInputStream fs = new FileInputStream(filePathAndName); InputStreamReader isr; if(encoding.equals(""))&#123; isr = new InputStreamReader(fs); &#125;else&#123; isr = new InputStreamReader(fs,encoding); &#125; BufferedReader br = new BufferedReader(isr); try&#123; String data = ""; while((data = br.readLine())!=null)&#123; str.append(data+" "); &#125; &#125;catch(Exception e)&#123; str.append(e.toString()); &#125; st = str.toString(); &#125;catch(IOException es)&#123; st = ""; &#125; return st; &#125; /** * 新建目录 * @param folderPath 目录 * @return 返回目录创建后的路径 */ public static String createFolder(String folderPath) &#123; String txt = folderPath; try &#123; java.io.File myFilePath = new java.io.File(txt); txt = folderPath; if (!myFilePath.exists()) &#123; myFilePath.mkdir(); &#125; &#125; catch (Exception e) &#123; message = "创建目录操作出错"; &#125; return txt; &#125; /** * 多级目录创建 * @param folderPath 准备要在本级目录下创建新目录的目录路径 例如 c:myf * @param paths 无限级目录参数，各级目录以单数线区分 例如 a|b|c * @return 返回创建文件后的路径 例如 c:myfac */ public static String createFolders(String folderPath, String paths)&#123; String txts = folderPath; try&#123; String txt; txts = folderPath; StringTokenizer st = new StringTokenizer(paths,"|"); for(int i=0; st.hasMoreTokens(); i++)&#123; txt = st.nextToken().trim(); if(txts.lastIndexOf("/")!=-1)&#123; txts = createFolder(txts+txt); &#125;else&#123; txts = createFolder(txts+txt+"/"); &#125; &#125; &#125;catch(Exception e)&#123; message = "创建目录操作出错！"; &#125; return txts; &#125; /** * 新建文件 * @param filePathAndName 文本文件完整绝对路径及文件名 * @param fileContent 文本文件内容 * @return */ public static void createFile(String filePathAndName, String fileContent) &#123; try &#123; String filePath = filePathAndName; filePath = filePath.toString(); File myFilePath = new File(filePath); if (!myFilePath.exists()) &#123; myFilePath.createNewFile(); &#125; FileWriter resultFile = new FileWriter(myFilePath); PrintWriter myFile = new PrintWriter(resultFile); String strContent = fileContent; myFile.println(strContent); myFile.close(); resultFile.close(); &#125; catch (Exception e) &#123; message = "创建文件操作出错"; &#125; &#125; /** * 有编码方式的文件创建 * @param filePathAndName 文本文件完整绝对路径及文件名 * @param fileContent 文本文件内容 * @param encoding 编码方式 例如 GBK 或者 UTF-8 * @return */ public static void createFile(String filePathAndName, String fileContent, String encoding) &#123; try &#123; String filePath = filePathAndName; filePath = filePath.toString(); File myFilePath = new File(filePath); if (!myFilePath.exists()) &#123; myFilePath.createNewFile(); &#125; PrintWriter myFile = new PrintWriter(myFilePath,encoding); String strContent = fileContent; myFile.println(strContent); myFile.close(); &#125; catch (Exception e) &#123; message = "创建文件操作出错"; &#125; &#125; /** * 删除文件 * @param filePathAndName 文本文件完整绝对路径及文件名 * @return Boolean 成功删除返回true遭遇异常返回false */ public static boolean delFile(String filePathAndName) &#123; boolean bea = false; try &#123; String filePath = filePathAndName; File myDelFile = new File(filePath); if(myDelFile.exists())&#123; myDelFile.delete(); bea = true; &#125;else&#123; bea = false; message = (filePathAndName+"删除文件操作出错"); &#125; &#125; catch (Exception e) &#123; message = e.toString(); &#125; return bea; &#125; /** * 删除文件夹 * @param folderPath 文件夹完整绝对路径 * @return */ public static void delFolder(String folderPath) &#123; try &#123; delAllFile(folderPath); //删除完里面所有内容 String filePath = folderPath; filePath = filePath.toString(); java.io.File myFilePath = new java.io.File(filePath); myFilePath.delete(); //删除空文件夹 &#125; catch (Exception e) &#123; message = ("删除文件夹操作出错"); &#125; &#125; /** * 删除指定文件夹下所有文件 * @param path 文件夹完整绝对路径 * @return * @return */ public static boolean delAllFile(String path) &#123; boolean bea = false; File file = new File(path); if (!file.exists()) &#123; return bea; &#125; if (!file.isDirectory()) &#123; return bea; &#125; String[] tempList = file.list(); File temp = null; for (int i = 0; i &lt; tempList.length; i++) &#123; if (path.endsWith(File.separator)) &#123; temp = new File(path + tempList[i]); &#125;else&#123; temp = new File(path + File.separator + tempList[i]); &#125; if (temp.isFile()) &#123; temp.delete(); &#125; if (temp.isDirectory()) &#123; delAllFile(path+"/"+ tempList[i]);//先删除文件夹里面的文件 delFolder(path+"/"+ tempList[i]);//再删除空文件夹 bea = true; &#125; &#125; return bea; &#125; /** * 复制单个文件 * @param oldPathFile 准备复制的文件源 * @param newPathFile 拷贝到新绝对路径带文件名 * @return */ public static void copyFile(String oldPathFile, String newPathFile) &#123; try &#123; int bytesum = 0; int byteread = 0; File oldfile = new File(oldPathFile); if (oldfile.exists()) &#123; //文件存在时 InputStream inStream = new FileInputStream(oldPathFile); //读入原文件 FileOutputStream fs = new FileOutputStream(newPathFile); byte[] buffer = new byte[1444]; while((byteread = inStream.read(buffer)) != -1)&#123; bytesum += byteread; //字节数 文件大小 System.out.println(bytesum); fs.write(buffer, 0, byteread); &#125; inStream.close(); &#125; &#125;catch (Exception e) &#123; message = ("复制单个文件操作出错"); &#125; &#125; /** * 复制整个文件夹的内容 * @param oldPath 准备拷贝的目录 * @param newPath 指定绝对路径的新目录 * @return */ public static void copyFolder(String oldPath, String newPath) &#123; try &#123; new File(newPath).mkdirs(); //如果文件夹不存在 则建立新文件夹 File a=new File(oldPath); String[] file=a.list(); File temp=null; for (int i = 0; i &lt; file.length; i++) &#123; if(oldPath.endsWith(File.separator))&#123; temp=new File(oldPath+file[i]); &#125;else&#123; temp=new File(oldPath+File.separator+file[i]); &#125; if(temp.isFile())&#123; FileInputStream input = new FileInputStream(temp); FileOutputStream output = new FileOutputStream(newPath + "/" + (temp.getName()).toString()); byte[] b = new byte[1024 * 5]; int len; while ((len = input.read(b)) != -1) &#123; output.write(b, 0, len); &#125; output.flush(); output.close(); input.close(); &#125; if(temp.isDirectory())&#123;//如果是子文件夹 copyFolder(oldPath+"/"+file[i],newPath+"/"+file[i]); &#125; &#125; &#125;catch (Exception e) &#123; message = "复制整个文件夹内容操作出错"; &#125; &#125; /** * 移动文件 * @param oldPath * @param newPath * @return */ public static void moveFile(String oldPath, String newPath) &#123; copyFile(oldPath, newPath); delFile(oldPath); &#125; /** * 移动目录 * @param oldPath * @param newPath * @return */ public static void moveFolder(String oldPath, String newPath) &#123; copyFolder(oldPath, newPath); delFolder(oldPath); &#125; /** * 得到错误信息 */ public static String getMessage()&#123; return message; &#125;&#125; StringUtils 字符串达到多长才截取 将指定的对象转换为String类型 转换字符,用于替换提交的数据中存在非法数据:”‘“ 对标题””转换为中文“”采用对应转换 替换HTML标记 标题中含有特殊字符替换 如:●▲@◎※ 主要在标题中使用 替换所有英文字母 替换所有数字 将/n转换成为回车 ,空格转为&nbsp; 清除所有&lt;&gt;标记符号 主要在搜索中显示文字内容 而不显示样式 清楚WOrd垃圾代码 判断传入的字符串如果为null则返回””,否则返回其本身 获取百分比 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676package com.xwtech.uomp.base.util;import java.io.UnsupportedEncodingException;import java.text.NumberFormat;import java.util.HashMap;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.xwtech.uomp.base.action.handler.HandlerResult;import com.xwtech.uomp.base.constants.SystemCodeConstants;public class StringUtil &#123; public static final String arrTest[] = &#123;"[br]", "[/b]", "[/i]", "[/u]", "[/size]", "[/color]", "[/align]", "[/url]", "[/email]", "[/img]"&#125;; public static final String arrParam[] = &#123;"\\[br\\]", "\\[b\\](.+?)\\[/b\\]", "\\[i\\](.+?)\\[/i\\]", "\\[u\\](.+?)\\[/u\\]", "\\[size=(.+?)\\](.+?)\\[/size\\]", "\\[color=(.+?)\\](.+?)\\[/color\\]", "\\[align=(.+?)\\](.+?)\\[/align\\]", "\\[url=(.+?)\\](.+?)\\[/url\\]", "\\[email=(.+?)\\](.+?)\\[/email\\]," + "\\[img=(.+?)\\](.+?)\\[/img\\]"&#125;; public static final String arrCode[] = &#123;"&lt;br&gt;", "&lt;b&gt;$1&lt;/b&gt;", "&lt;i&gt;$1&lt;/i&gt;", "&lt;u&gt;$1&lt;/u&gt;", "&lt;font size=\"$1\"&gt;$2&lt;/font&gt;", "&lt;font color=\"$1\"&gt;$2&lt;/font&gt;", "&lt;div align=\"$1\"&gt;$2&lt;/div&gt;", "&lt;a href=\"$1\" target=\"_blank\"&gt;$2&lt;/a&gt;", "&lt;a href=\"email:$1\"&gt;$2&lt;/a&gt;", "&lt;img src=\"$1\" border=0&gt;$2&lt;/img&gt;"&#125;; public static int getInt(String content) &#123; int intContent; try &#123; intContent = Integer.parseInt(content); &#125; catch (Exception e) &#123; intContent = 0; &#125; return intContent; &#125; public static long getLong(String content) &#123; long lngContent; try &#123; lngContent = Long.parseLong(content); &#125; catch (Exception e) &#123; lngContent = 0L; &#125; return lngContent; &#125; /** 1 * @param str 原字符串 * @param length 字符串达到多长才截取 * @return */ @SuppressWarnings("static-access") public static String subStringToPoint(String str, int length, String more) &#123; String reStr = ""; if (str.length() * 2 - 1 &gt; length) &#123; int reInt = 0; if (str == null) return ""; char[] tempChar = str.toCharArray(); for (int kk = 0; (kk &lt; tempChar.length &amp;&amp; length &gt; reInt); kk++) &#123; String s1 = str.valueOf(tempChar[kk]); byte[] b = s1.getBytes(); reInt += b.length; reStr += tempChar[kk]; &#125; if (length == reInt || (length == reInt - 1)) &#123; if (!reStr.equals(str)) &#123; reStr += more; &#125; &#125; &#125; else &#123; reStr = str; &#125; return reStr; &#125; /** 2 * 将指定的对象转换为String类型 * * @param curObject 传入对象参数 * @return String */ public static String getString(Object curObject) &#123; if (null == curObject) &#123; throw new NullPointerException("The input object is null."); &#125; else &#123; return curObject.toString(); &#125; &#125; /** 3 * 转换字符,用于替换提交的数据中存在非法数据:"'" * * @param Content * @return */ public static String replaceChar(String content) &#123; String newstr = ""; newstr = content.replaceAll("\'", "''"); return newstr; &#125; /**4 * 对标题""转换为中文“”采用对应转换 * * @param Content * @return */ public static String replaceSymbol(String content) &#123; int intPlaceNum = 0; int Num = 0; String strContent = content; while (true) &#123; //判断是否还存在" intPlaceNum = strContent.indexOf("\""); if (intPlaceNum &lt; 0) &#123; break; &#125; else &#123; if (Num % 2 == 0) &#123; strContent = strContent.replaceFirst("\"", "“"); &#125; else &#123; strContent = strContent.replaceFirst("\"", "”"); &#125; Num = Num + 1; &#125; &#125; return strContent; &#125; /**5 * 替换HTML标记 * * @param Content * @return */ public static String replaceCharToHtml(String content) &#123; String strContent = content; strContent = strContent.replaceAll("&lt;", "&lt;"); strContent = strContent.replaceAll("&gt;", "&gt;"); strContent = strContent.replaceAll("\"", """); return strContent; &#125; public static String replaceHtmlToChar(String content) &#123; String strContent = content; strContent = strContent.replaceAll("&lt;", "&lt;"); strContent = strContent.replaceAll("&gt;", "&gt;"); strContent = strContent.replaceAll(""", "\""); return strContent; &#125; //数据库替换 public static String replaceCharToSql(String content) &#123; String strContent = content; strContent = strContent.replaceAll("%", "\\\\%"); return strContent; &#125; public static String toHtmlValue(String value) &#123; if (null == value) &#123; return null; &#125; char a = 0; StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; value.length(); i++) &#123; a = value.charAt(i); switch (a) &#123; // 双引号 case 34: buf.append("""); break; // &amp;号 case 38: buf.append("&amp;"); break; // 单引号 case 39: buf.append("'"); break; // 小于号 case 60: buf.append("&lt;"); break; // 大于号 case 62: buf.append("&gt;"); break; default: buf.append(a); break; &#125; &#125; return buf.toString(); &#125; /**6 * 标题中含有特殊字符替换 如:●▲@◎※ 主要在标题中使用 * * @param Content * @return */ public static String replaceSign(String content) &#123; String strContent = ""; strContent = content.replaceAll("\\*", ""); strContent = strContent.replaceAll("\\$", ""); strContent = strContent.replaceAll("\\+", ""); String arrStr[] = &#123;":", "：", "●", "▲", "■", "@", "＠", "◎", "★", "※", "＃", "〓", "＼", "§", "☆", "○", "◇", "◆", "□", "△", "＆", "＾", "￣", "＿", "♂", "♀", "Ю", "┭", "①", "「", "」", "≮", "§", "￡", "∑", "『", "』", "⊙", "∷", "Θ", "の", "↓", "↑", "Ф", "~", "Ⅱ", "∈", "┣", "┫", "╋", "┇", "┋", "→", "←", "!", "Ж", "#"&#125;; for (int i = 0; i &lt; arrStr.length; i++) &#123; if ((strContent.indexOf(arrStr[i])) &gt;= 0) &#123; strContent = strContent.replaceAll(arrStr[i], ""); &#125; &#125; return strContent; &#125; /**7 * 替换所有英文字母 * * @param Content * @return */ public static String replaceLetter(String content) &#123; String strMark = "[^[A-Za-z]+$]"; String strContent = ""; strContent = content.replaceAll(strMark, ""); return strContent; &#125; /**8 * 替换所有数字 * * @param Content * @return */ public static String replaceNumber(String content) &#123; String strMark = "[^[0-9]+$]"; String strContent = ""; strContent = content.replaceAll(strMark, ""); return strContent; &#125; /**9 * 将/n转换成为回车&lt;br&gt; ,空格转为 * * @param Content * @return */ public static String replaceBr(String content) &#123; if (content == null) &#123; return ""; &#125; String strContent = ""; // String strMark ="[/\n\r\t]"; //strContent = content.replaceAll(strMark,"&lt;br&gt;"); strContent = content.replaceAll("\n\r\t", "&lt;br&gt;"); strContent = strContent.replaceAll("\n\r", "&lt;br&gt;"); strContent = strContent.replaceAll("\r\n", "&lt;br&gt;"); strContent = strContent.replaceAll("\n", "&lt;br&gt;"); strContent = strContent.replaceAll("\r", "&lt;br&gt;"); strContent = strContent.replaceAll(" ", " "); return strContent; &#125; /**10 * 清除所有&lt;&gt;标记符号 主要在搜索中显示文字内容 而不显示样式 * * @param Content * @return */ public static String replaceMark(String content) &#123; String strContent = ""; String strMark = "&lt;\\s*[^&gt;]*&gt;"; strContent = content.trim(); strContent = strContent.replaceAll("\"", ""); strContent = strContent.replaceAll("\'", ""); //删除所有&lt;&gt;标记 strContent = strContent.replaceAll(strMark, ""); strContent = strContent.replaceAll(" ", ""); strContent = strContent.replaceAll(" ", ""); strContent = strContent.replaceAll(" ", ""); strContent = strContent.replaceAll("\r", ""); strContent = strContent.replaceAll("\n", ""); strContent = strContent.replaceAll("\r\n", ""); return strContent; &#125; /**11 * 清楚WOrd垃圾代码 * * @param Content * @return */ public static String clearWord(String content) &#123; String strContent = ""; strContent = content.trim(); strContent = strContent.replaceAll("x:str", ""); //Remove Style attributes strContent = strContent.replaceAll("&lt;(\\w[^&gt;]*) style=\"([^\"]*)\"", "&lt;$1"); //Remove all SPAN tags strContent = strContent.replaceAll("&lt;\\/?SPAN[^&gt;]*&gt;", ""); //Remove Lang attributes strContent = strContent.replaceAll("&lt;(\\w[^&gt;]*) lang=([^ |&gt;]*)([^&gt;]*)", "&lt;$1$3"); //Remove Class attributes strContent = strContent.replaceAll("&lt;(\\w[^&gt;]*) class=([^ |&gt;]*)([^&gt;]*)", "&lt;$1$3"); //Remove XML elements and declarations strContent = strContent.replaceAll("&lt;\\\\?\\?xml[^&gt;]*&gt;", ""); //Remove Tags with XML namespace declarations: &lt;o:p&gt;&lt;/o:p&gt; strContent = strContent.replaceAll("&lt;\\/?\\w+:[^&gt;]*&gt;", ""); return strContent; &#125; /** * 对组ID信息进行处理 转换为标准ID组 并过滤重复的信息 * * @param teamId * @return */ public static String checkTeamId(String teamId) &#123; String strTeamId = ""; String strTempId = ""; String strTemp = ""; String[] arrTeamId = teamId.split(","); for (int num = 0; num &lt; arrTeamId.length; num++) &#123; strTemp = arrTeamId[num].trim(); if ((!strTemp.equals("")) &amp;&amp; (!strTemp.equals("0"))) &#123; if ((strTempId.indexOf("," + strTemp + ",")) &gt;= 0) &#123; //表示已经保存过了 &#125; else &#123; if (strTeamId.equals("")) &#123; strTeamId = strTemp; strTempId = strTempId + "," + strTemp + ","; ; &#125; else &#123; strTeamId = strTeamId + "," + strTemp; strTempId = strTempId + strTemp + ","; &#125; &#125; &#125; &#125; return strTeamId; &#125; public static String replaceUbb(String content) &#123; String strContent = content; try &#123; for (int num = 0; num &lt; arrTest.length; num++) &#123; if ((strContent.indexOf(arrTest[num])) &gt;= 0) &#123; try &#123; strContent = strContent.replaceAll(arrParam[num], arrCode[num]); &#125; catch (Exception ex) &#123; &#125; &#125; &#125; &#125; catch (Exception e) &#123; //System.out.println("UBB CODE 错误"+e); &#125; return strContent; &#125; /**12 * 判断传入的字符串如果为null则返回"",否则返回其本身 * * @param string * @param instant * @return String */ public static String convertNull(String string, String instant) &#123; return isNull(string) ? instant : string; &#125; /** * &#123;@link #convertNull(String, String)&#125; * * @param string * @return String */ public static String convertNull(String string) &#123; return convertNull(string, ""); &#125; /** * 判断对象是否为空 * * @param obj Object * @return boolean 空返回true,非空返回false */ public static boolean isNull(Object obj) &#123; return (null == obj) ? true : false; &#125; /** * Description:判断字段空null &lt;br&gt; * * @param s * @return boolean */ public static boolean isNull(String s) &#123; if (s == null || "".equals(s.trim())) &#123; return true; &#125; return false; &#125; /**13 * 获取百分比 * * @param p1 * @param p2 * @return */ public static String percent(double p1, double p2) &#123; if (p2 == 0) &#123; return "0.00%"; &#125; String str; double p3 = p1 / p2; NumberFormat nf = NumberFormat.getPercentInstance(); nf.setMinimumFractionDigits(2); str = nf.format(p3); return str; &#125; /** * 字符串编码转换的实现方法 * * @param str 待转换编码的字符串 * @param oldCharset 原编码 * @param newCharset 目标编码 * @return * @throws UnsupportedEncodingException */ public static String changeCharset(String str, String oldCharset, String newCharset) &#123; try &#123; if (str != null) &#123; //用旧的字符编码解码字符串。解码可能会出现异常。 byte[] bs = str.getBytes(oldCharset); //用新的字符编码生成字符串 return new String(bs, newCharset); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); return ""; &#125; return ""; &#125; /** * 字符串编码转换的实现方法 * * @param str 待转换编码的字符串 * @param newCharset 目标编码 * @return * @throws UnsupportedEncodingException */ public String changeCharset(String str, String newCharset) &#123; try &#123; if (str != null) &#123; //用默认字符编码解码字符串。 byte[] bs = str.getBytes(); //用新的字符编码生成字符串 return new String(bs, newCharset); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return ""; &#125; /** * 解析html中的参数信息 * * @param elementStr * @return */ public static Map&lt;String, String&gt; getConfigValue(String elementStr) &#123; try &#123; elementStr = java.net.URLDecoder.decode(elementStr, "utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; int start = elementStr.indexOf("configvalue"); Map&lt;String, String&gt; map = null; //参数的键值对 if (start != -1) &#123; map = new HashMap&lt;String, String&gt;(); start = elementStr.indexOf("\"", start); int end = elementStr.lastIndexOf("||"); if (start &lt; 0 || end &lt; 0) &#123; return null; &#125; String configValue = elementStr.substring(start + 1, end); String[] values = configValue.split("\\|\\|"); for (int i = 0; i &lt; values.length; i++) &#123; String value = values[i]; if (value != null &amp;&amp; value.trim().length() &gt; 1) &#123; int de = value.indexOf("="); if (de &gt; 0) &#123; String name = value.substring(0, de); String v = value.substring(de + 1); map.put(name, v); &#125; &#125; &#125; &#125; return map; &#125; /** * 转换空值为0 * * @param str * @return */ public static String conventString(String str) &#123; return null == str || "".equals(str) ? "" + "0" : str; &#125; public static String alert(HandlerResult result, String contextPath) &#123; StringBuffer sf = new StringBuffer(); sf.append("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); sf.append("&lt;html&gt;&lt;head&gt;&lt;title&gt;信息提示&lt;/title&gt;"); sf.append("&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"").append(contextPath).append("/resource/css/frame.css\" /&gt;"); sf.append("&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxWindows/codebase/skins/dhtmlxwindows_dhx_skyblue.css\"/&gt;"); sf.append("&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxWindows/codebase/dhtmlxwindows.css\"/&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxLayout/codebase/dhtmlxcommon.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxLayout/codebase/dhtmlxcontainer.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/Dhtmlx/dhtmlxSuite/dhtmlxWindows/codebase/dhtmlxwindows.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/jquery-1.7.1.min.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/uompDialog.js\"&gt;&lt;/script&gt;"); sf.append("&lt;script type=\"text/javascript\" language=\"javascript\" src=\"").append(contextPath).append("/resource/scripts/main.js\" &gt;&lt;/script&gt;"); sf.append("&lt;/head&gt;&lt;body&gt;"); sf.append("&lt;/body&gt;&lt;/html&gt;"); sf.append("&lt;script type=\"text/javascript\"&gt;"); sf.append("$(document).ready(function()&#123;"); sf.append(" top.UOMPDialog.alert('" + result.getResMsg() + "',0,\"\""); if (SystemCodeConstants.NOT_LOGIN.equals(result.getSysCode())) &#123; sf.append(", &#123;'yes' : function()&#123;"); sf.append(" top.location.href = '").append(contextPath).append("/index.jsp'").append(";"); sf.append("&#125;&#125;"); &#125; sf.append(");"); sf.append(" &#125;);"); sf.append("&lt;/script&gt;"); return sf.toString(); &#125; public static void main(String[] args) &#123; Pattern pattern = Pattern.compile("&lt;span\\s.+?]]&lt;/span&gt;"); String str = "&lt;span configvalue=\"eid=1043||ename=%E9%9D%A2%E5%8C%85%E5%B1%91||folderId=CLBLYM||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 面包屑 ]]&lt;/span&gt;&lt;br /&gt;" + "业务名称：&lt;span configvalue=\"eid=1042||ename=%E4%B8%9A%E5%8A%A1%E5%90%8D%E7%A7%B0||busiNum=CL||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 业务名称 ]]&lt;/span&gt;&lt;br /&gt;" + "业务资费：&lt;span configvalue=\"eid=1041||ename=%E4%B8%9A%E5%8A%A1%E8%B5%84%E8%B4%B9||busiNum=CL||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 业务资费 ]]&lt;/span&gt;&lt;br /&gt;" + "业务介绍：&lt;br /&gt;" + "&lt;span configvalue=\"eid=1040||ename=%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D||busiNum=CL||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 业务介绍 ]]&lt;/span&gt;&lt;br /&gt;" + "&lt;br /&gt;" + "&lt;br /&gt;" + "&lt;br /&gt;&lt;span &gt;]]&lt;/span&gt;" + "&lt;span configvalue=\"eid=1043||ename=%E9%9D%A2%E5%8C%85%E5%B1%91||folderId=CLBLYM||\" contenteditable=\"false\" style=\"background-color: #ffff00; color: #000000\"&gt;[[ 面包屑 ]]&lt;/span&gt;&lt;br /&gt;"; Matcher matcher = pattern.matcher(str); String htmlStr = ""; StringBuffer strbuff = new StringBuffer(); int i = 0; while (matcher.find()) &#123; String bm = matcher.group(); System.out.println(bm); Map map = getConfigValue(bm); if (map != null) &#123; //todo:从缓存中获取数据 if (((String) map.get("eid")).equals("1043")) &#123; String se = "【掌上营业厅】+ 1"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; else if (((String) map.get("eid")).equals("1042")) &#123; String se = "【掌上营业厅】+ 2"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; else if (((String) map.get("eid")).equals("1041")) &#123; String se = "【掌上营业厅】 + 3"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; else if (((String) map.get("eid")).equals("1040")) &#123; String se = "【掌上营业厅】+ 4"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; else if (((String) map.get("eid")).equals("1046")) &#123; String se = "【掌上营业厅】+888888888888"; matcher.appendReplacement(strbuff, Matcher.quoteReplacement(se == null ? "" : se)); &#125; i++; &#125; &#125; matcher.appendTail(strbuff); htmlStr += strbuff.toString(); System.out.println(htmlStr + "=================" + i); &#125; /** * 方法描述：判断传入的字符串是否非空，即：字符串是否等于null、""或" "。 * 创建日期：2013-12-7下午11:39:34 * 修改日期： * 作者：zhanglu * @param: * @return:boolean */ public static boolean isNotEmpty(String str) &#123; if ((null == str) || ("".equals(str.trim()))) &#123; return false; &#125; else &#123; return true; &#125; &#125; /** * 方法描述：将传入的字符串转换成整型数据，如果转换过程中发生异常，则返回默认值：defaultValue。 * 创建日期：2013-12-7下午11:40:20 * 修改日期： * 作者：zhanglu * @param: * @return:int */ public static int convertIntoInt(String str, int defaultValue) &#123; // 定义一个返回值，假如转型过程中发生异常，则返回此默认值 int retData = defaultValue; try &#123; retData = Integer.parseInt(str.trim()); &#125; catch(NumberFormatException e) &#123; &#125; catch(Exception ex) &#123; &#125; return retData; &#125;&#125; org.apache.commons.lang.StringUtils中方法的操作对象是java.lang.String类型的对象，是JDK提供的String类型操作方法的补充，并且是null安全的(即如果输入参数String为null则不会抛出NullPointerException，而是做了相应处理，例如，如果输入为null则返回也是null等，具体可以查看源代码)。 除了构造器，StringUtils中一共有130多个方法，并且都是static的， 所以我们可以这样调用StringUtils.xxx()。 下面分别对一些常用方法做简要介绍： public static boolean isEmpty(String str) 判断某字符串是否为空，为空的标准是str == null 或 str.length() == 0下面是示例： 1234567891011StringUtils.isEmpty(null) = trueStringUtils.isEmpty("") = trueStringUtils.isEmpty(" ") = falseStringUtils.isEmpty(" ") = falseStringUtils.isEmpty("bob") = falseStringUtils.isEmpty(" bob ") = false public static boolean isNotEmpty(String str) 判断某字符串是否非空，等于!isEmpty(String str)下面是示例： 1234567891011StringUtils.isNotEmpty(null) = falseStringUtils.isNotEmpty("") = falseStringUtils.isNotEmpty(" ") = trueStringUtils.isNotEmpty(" ") = trueStringUtils.isNotEmpty("bob") = trueStringUtils.isNotEmpty(" bob ") = true public static boolean isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace)构成下面是示例： 123456789101112131415StringUtils.isBlank(null) = trueStringUtils.isBlank("") = trueStringUtils.isBlank(" ") = trueStringUtils.isBlank(" ") = trueStringUtils.isBlank("\t \n \f \r") = trueStringUtils.isBlank("\b") = falseStringUtils.isBlank("bob") = falseStringUtils.isBlank(" bob ") = false public static boolean isNotBlank(String str) 判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成，等于!isBlank(String str) 下面是示例： 123456789101112131415StringUtils.isNotBlank(null) = falseStringUtils.isNotBlank("") = falseStringUtils.isNotBlank(" ") = falseStringUtils.isNotBlank(" ") = falseStringUtils.isNotBlank("\t \n \f \r") = falseStringUtils.isNotBlank("\b") = trueStringUtils.isNotBlank("bob") = trueStringUtils.isNotBlank(" bob ") = true public static String trim(String str) 去掉字符串两端的控制符(control characters, char &lt;= 32)如果输入为null则返回null 下面是示例： 123456789101112131415StringUtils.trim(null) = nullStringUtils.trim("") = ""StringUtils.trim(" ") = ""StringUtils.trim(" \b \t \n \f \r ") = ""StringUtils.trim(" \n\tss \b") = "ss"StringUtils.trim(" d d dd ") = "d d dd"StringUtils.trim("dd ") = "dd"StringUtils.trim(" dd ") = "dd" public static String trimToNull(String str) 去掉字符串两端的控制符(control characters, char &lt;= 32)如果变为null或””，则返回null 下面是示例： 123456789101112131415StringUtils.trimToNull(null) = nullStringUtils.trimToNull("") = nullStringUtils.trimToNull(" ") = nullStringUtils.trimToNull(" \b \t \n \f \r ") = nullStringUtils.trimToNull(" \n\tss \b") = "ss"StringUtils.trimToNull(" d d dd ") = "d d dd"StringUtils.trimToNull("dd ") = "dd"StringUtils.trimToNull(" dd ") = "dd" public static String trimToEmpty(String str) 去掉字符串两端的控制符(control characters, char &lt;= 32)如果变为null或””，则返回”” 下面是示例： 123456789101112131415StringUtils.trimToEmpty(null) = ""StringUtils.trimToEmpty("") = ""StringUtils.trimToEmpty(" ") = ""StringUtils.trimToEmpty(" \b \t \n \f \r ") = ""StringUtils.trimToEmpty(" \n\tss \b") = "ss"StringUtils.trimToEmpty(" d d dd ") = "d d dd"StringUtils.trimToEmpty("dd ") = "dd"StringUtils.trimToEmpty(" dd ") = "dd" public static String strip(String str) 去掉字符串两端的空白符(whitespace)，如果输入为null则返回null 下面是示例(注意和trim()的区别)： 123456789101112131415StringUtils.strip(null) = nullStringUtils.strip("") = ""StringUtils.strip(" ") = ""StringUtils.strip(" \b \t \n \f \r ") = "\b"StringUtils.strip(" \n\tss \b") = "ss \b"StringUtils.strip(" d d dd ") = "d d dd"StringUtils.strip("dd ") = "dd"StringUtils.strip(" dd ") = "dd" public static String stripToNull(String str) 去掉字符串两端的空白符(whitespace)，如果变为null或””，则返回null 下面是示例(注意和trimToNull()的区别)： 123456789101112131415StringUtils.stripToNull(null) = nullStringUtils.stripToNull("") = nullStringUtils.stripToNull(" ") = nullStringUtils.stripToNull(" \b \t \n \f \r ") = "\b"StringUtils.stripToNull(" \n\tss \b") = "ss \b"StringUtils.stripToNull(" d d dd ") = "d d dd"StringUtils.stripToNull("dd ") = "dd"StringUtils.stripToNull(" dd ") = "dd" public static String stripToEmpty(String str) 去掉字符串两端的空白符(whitespace)，如果变为null或””，则返回”” 下面是示例(注意和trimToEmpty()的区别)： 123456789101112131415StringUtils.stripToNull(null) = ""StringUtils.stripToNull("") = ""StringUtils.stripToNull(" ") = ""StringUtils.stripToNull(" \b \t \n \f \r ") = "\b"StringUtils.stripToNull(" \n\tss \b") = "ss \b"StringUtils.stripToNull(" d d dd ") = "d d dd"StringUtils.stripToNull("dd ") = "dd"StringUtils.stripToNull(" dd ") = "dd" public static String strip(String str, String stripChars) 去掉str两端的在stripChars中的字符。如果str为null或等于””，则返回它本身； 如果stripChars为null或””，则返回strip(String str)。 public static String stripStart(String str, String stripChars) 和11相似，去掉str前端的在stripChars中的字符。 public static String stripEnd(String str, String stripChars) 和11相似，去掉str末端的在stripChars中的字符。 public static String[] stripAll(String[] strs) 对字符串数组中的每个字符串进行strip(String str)，然后返回。如果strs为null或strs长度为0，则返回strs本身 public static String[] stripAll(String[] strs, String stripChars) 对字符串数组中的每个字符串进行strip(String str, String stripChars)，然后返回。如果strs为null或strs长度为0，则返回strs本身 public static boolean equals(String str1, String str2) 比较两个字符串是否相等，如果两个均为空则也认为相等。 public static boolean equalsIgnoreCase(String str1, String str2) 比较两个字符串是否相等，不区分大小写，如果两个均为空则也认为相等。 public static int indexOf(String str, char searchChar) 返回字符searchChar在字符串str中第一次出现的位置。如果searchChar没有在str中出现则返回-1， 如果str为null或””，则也返回-1 public static int indexOf(String str, char searchChar, int startPos) 返回字符searchChar从startPos开始在字符串str中第一次出现的位置。如果从startPos开始searchChar没有在str中出现则返回-1， 如果str为null或””，则也返回-1 public static int indexOf(String str, String searchStr) 返回字符串searchStr在字符串str中第一次出现的位置。如果str为null或searchStr为null则返回-1， 如果searchStr为””,且str为不为null，则返回0， 如果searchStr不在str中，则返回-1 public static int ordinalIndexOf(String str, String searchStr, int ordinal) 返回字符串searchStr在字符串str中第ordinal次出现的位置。如果str=null或searchStr=null或ordinal&lt;=0则返回-1 举例(*代表任意字符串)： 1234567891011121314151617181920212223StringUtils.ordinalIndexOf(null, *, *) = -1StringUtils.ordinalIndexOf(*, null, *) = -1StringUtils.ordinalIndexOf("", "", *) = 0StringUtils.ordinalIndexOf("aabaabaa", "a", 1) = 0StringUtils.ordinalIndexOf("aabaabaa", "a", 2) = 1StringUtils.ordinalIndexOf("aabaabaa", "b", 1) = 2StringUtils.ordinalIndexOf("aabaabaa", "b", 2) = 5StringUtils.ordinalIndexOf("aabaabaa", "ab", 1) = 1StringUtils.ordinalIndexOf("aabaabaa", "ab", 2) = 4StringUtils.ordinalIndexOf("aabaabaa", "bc", 1) = -1StringUtils.ordinalIndexOf("aabaabaa", "", 1) = 0StringUtils.ordinalIndexOf("aabaabaa", "", 2) = 0 public static int indexOf(String str, String searchStr, int startPos) 返回字符串searchStr从startPos开始在字符串str中第一次出现的位置。举例(*代表任意字符串)： 123456789101112131415161718192021StringUtils.indexOf(null, *, *) = -1StringUtils.indexOf(*, null, *) = -1StringUtils.indexOf("", "", 0) = 0StringUtils.indexOf("aabaabaa", "a", 0) = 0StringUtils.indexOf("aabaabaa", "b", 0) = 2StringUtils.indexOf("aabaabaa", "ab", 0) = 1StringUtils.indexOf("aabaabaa", "b", 3) = 5StringUtils.indexOf("aabaabaa", "b", 9) = -1StringUtils.indexOf("aabaabaa", "b", -1) = 2StringUtils.indexOf("aabaabaa", "", 2) = 2StringUtils.indexOf("abc", "", 9) = 3 public static int lastIndexOf(String str, char searchChar) 基本原理同18。 public static int lastIndexOf(String str, char searchChar, int startPos) 基本原理同19。 public static int lastIndexOf(String str, String searchStr) 基本原理同20。 public static int lastIndexOf(String str, String searchStr, int startPos) 基本原理同22。 public static boolean contains(String str, char searchChar) 判断字符串str中是否包含字符searchChar。如果str为null或””，返回false； 如果searchChar不在str中，返回false。 public static boolean contains(String str, String searchStr) 判断字符串str是否包含字符串searchStr。如果str为null或searchStr为null，返回false； 如果str为””，并且searchStr为””，返回true 举例： 1234567StringUtils.contains("", "") = trueStringUtils.contains("dfg", "") = trueStringUtils.contains("dfg", "d") = trueStringUtils.contains("dfg", "gz") = false public static boolean containsIgnoreCase(String str, String searchStr) 判断字符串str是否包含字符串searchStr，不区分大小写。和28类似。 public static int indexOfAny(String str, char[] searchChars) 找出字符数组searchChars中的字符第一次出现在字符串str中的位置。如果字符数组中的字符都不在字符串中，则返回-1 如果字符串为null或””，则返回-1 举例(*表示任意)： 12345678910111213StringUtils.indexOfAny(null, *) = -1StringUtils.indexOfAny("", *) = -1StringUtils.indexOfAny(*, []) = -1StringUtils.indexOfAny("asdf", ['a','f',' ']) = 0StringUtils.indexOfAny("bs df", ['a','f',' ']) = 2StringUtils.indexOfAny("bsdf", ['a','f',' ']) = 3StringUtils.indexOfAny("bbeegg", ['a','f',' ']) = -1 public static int indexOfAny(String str, String searchChars) 找出字符串searchChars中的字符第一次出现在字符串str中的位置。如果字符串searchChars中的字符都不在字符串str中，则返回-1 如果searchChars或str为null或为””，则返回-1 举例(*表示任意)： 123456789101112131415StringUtils.indexOfAny(null, *) = -1StringUtils.indexOfAny("", *) = -1StringUtils.indexOfAny(*, null) = -1StringUtils.indexOfAny(*, "") = -1StringUtils.indexOfAny("asdf", "af ") = 0StringUtils.indexOfAny("bs df", "af ") = 2StringUtils.indexOfAny("bsdf", "af ") = 3StringUtils.indexOfAny("bbeegg", "af ") = -1 public static int indexOfAnyBut(String str, char[] searchChars) 找出字符串str中不在字符数组searchChars中的第一个字符的位置。如果字符串中的所有字符都在字符数组中，则返回-1 如果字符串为null或””，则返回-1 举例(*表示任意)： 12345678910111213StringUtils.indexOfAnyBut(null, *) = -1StringUtils.indexOfAnyBut("", *) = -1StringUtils.indexOfAnyBut(*, []) = -1StringUtils.indexOfAnyBut("asdf", ['a','f',' ']) = 1StringUtils.indexOfAnyBut("bs df", ['a','f',' ']) = 0StringUtils.indexOfAnyBut(" aaf", ['a','f',' ']) = -1StringUtils.indexOfAnyBut("bbeegg", ['a','f',' ']) = 0 public static int indexOfAnyBut(String str, String searchChars) 找出字符串str中不在字符串searchChars中的第一个字符的位置。如果字符串str中的所有字符都在字符串searchChars中，则返回-1 如果字符串str或searchChars为null或””，则返回-1 举例(*表示任意)： 123456789101112131415StringUtils.indexOfAnyBut(null, *) = -1StringUtils.indexOfAnyBut("", *) = -1StringUtils.indexOfAnyBut(*, null) = -1StringUtils.indexOfAnyBut(*, "") = -1StringUtils.indexOfAnyBut("asdf", "af ") = 1StringUtils.indexOfAnyBut("bs df", "af ") = 0StringUtils.indexOfAnyBut(" aaf", "af ") = -1StringUtils.indexOfAnyBut("bbeegg", "af ") = 0 public static boolean containsOnly(String str, char[] valid) 判断是否字符串str仅包含字符数组valid中的字符，即字符串中的字符是否都在字符数组中。如果str为null，则返回false；如果str为””，则返回true 举例(*表示任意)： 12345678910111213StringUtils.containsOnly(null, *)) = falseStringUtils.containsOnly("", *)) = trueStringUtils.containsOnly("afaf", ['a','f',' ']))= trueStringUtils.containsOnly("af a", ['a','f',' ']))= trueStringUtils.containsOnly("a", ['a','f',' '])) = trueStringUtils.containsOnly("afg", ['a','f',' '])) = falseStringUtils.containsOnly("bbeegg", [])) = false public static boolean containsOnly(String str, String validChars) 判断是否字符串str仅包含字符串validChars中的字符，即字符串str中的字符是否都在字符串validChars中。 和34类似，举例(*表示任意)： 123456789101112131415StringUtils.containsOnly(null, *) = falseStringUtils.containsOnly(*, null) = falseStringUtils.containsOnly("", "") = trueStringUtils.containsOnly("", "a") = trueStringUtils.containsOnly("afaf", "af ") = trueStringUtils.containsOnly("af a", "af ") = trueStringUtils.containsOnly("afg", "af ") = falseStringUtils.containsOnly("afg", "") = false public static boolean containsNone(String str, char[] invalidChars) 判断是否字符串str不包含字符数组invalidChars中的字符，如果含有则返回false。举例(*表示任意)： 123456789101112131415StringUtils.containsNone(null, *) = trueStringUtils.containsNone(*, []) = trueStringUtils.containsNone("", *) = trueStringUtils.containsNone("ab", []) = trueStringUtils.containsNone("b", ['a','f',' ']) = trueStringUtils.containsNone("bcd", ['a','f',' ']) = trueStringUtils.containsNone("abc", ['a','f',' ']) = falseStringUtils.containsNone(" ", ['a','f',' ']) = false public static boolean containsNone(String str, String invalidChars) 判断是否字符串str不包含字符串invalidChars中的字符，如果含有则返回false。举例(*表示任意)： 123456789101112131415StringUtils.containsNone(null, *) = trueStringUtils.containsNone(*, null) = trueStringUtils.containsNone("", *) = trueStringUtils.containsNone("ab", "") = trueStringUtils.containsNone("b", "af ") = trueStringUtils.containsNone("bcd", "af ") = trueStringUtils.containsNone("abc", "af ") = falseStringUtils.containsNone(" ", "af ") = false public static int indexOfAny(String str, String[] searchStrs) 找出字符串数组searchStrs中的字符串第一次出现在字符串str中的位置。如果数组中没有字符串在str中，则返回-1 如果数组为null或长度为0，则返回-1 举例(*表示任意)： 123456789101112131415StringUtils.indexOfAny(null, *) = -1StringUtils.indexOfAny(*, null) = -1StringUtils.indexOfAny(*, []) = -1StringUtils.indexOfAny("", [""]) = 0StringUtils.indexOfAny("bbeegg", ["as","df","yy"]) = -1StringUtils.indexOfAny("asdfgh", ["as","df","yy"]) = 0StringUtils.indexOfAny("dfasgh", ["as","df","yy"]) = 0StringUtils.indexOfAny("ghasdf", ["as","df","yy"]) = 2 public static int lastIndexOfAny(String str, String[] searchStrs) 找出字符串数组searchStrs中的字符串最后一次出现在字符串str中的位置。如果数组中没有字符串在str中，则返回-1 如果数组为null或长度为0，则返回-1 举例(*表示任意)： 1234567891011121314151617StringUtils.lastIndexOfAny(null, *) = -1StringUtils.lastIndexOfAny(*, null) = -1StringUtils.lastIndexOfAny(*, []) = -1StringUtils.lastIndexOfAny("", [""]) = 0StringUtils.lastIndexOfAny("bbeegg", ["as","df","yy"]) = -1StringUtils.lastIndexOfAny("asdfgh", ["as","df","yy"]) = 2StringUtils.lastIndexOfAny("dfghjk", ["as","df","yy"]) = 0StringUtils.lastIndexOfAny("ghasdf", ["as","df","yy"]) = 4StringUtils.lastIndexOfAny("ghasdf", ["as","df",""]) = 6 public static String substring(String str, int start) 得到字符串str的子串。如果start小于0，位置是从后往前数的第|start|个 如果str为null或””，则返回它本身 举例(*表示任意)： 1234567891011121314151617StringUtils.substring(null, *) = nullStringUtils.substring("", *) = ""StringUtils.substring("asdf", 0)) = "asdf"StringUtils.substring("asdf", 1)) = "sdf"StringUtils.substring("asdf", 3)) = "f"StringUtils.substring("asdf",) = ""StringUtils.substring("asdf", -1)) = "f"StringUtils.substring("asdf", -3)) = "sdf"StringUtils.substring("asdf", -8)) = "asdf" public static String substring(String str, int start, int end) 得到字符串str的子串。如果start小于0，位置是从后往前数的第|start|个， 如果end小于0，位置是从后往前数的第|end|个， 如果str为null或””，则返回它本身 举例(*表示任意)： 123456789101112131415161718192021StringUtils.substring(null, *, *) = nullStringUtils.substring("", * , *) = "";StringUtils.substring("asdf", 0, 2) = "as"StringUtils.substring("asdf", 0, -1) = "asd"StringUtils.substring("asdf", 2, -1) = "d"StringUtils.substring("asdf", 2, -2) = ""StringUtils.substring("asdf", 3, 2) = ""StringUtils.substring("asdf", 1, = "sdf"StringUtils.substring("asdf", -1, -3) = ""StringUtils.substring("asdf", -3, -1) = "sd"StringUtils.substring("asdf", -8, 5) = "asdf" public static String left(String str, int len) 得到字符串str从左边数len长度的子串。如果str为null或为””，则返回它本身 如果len小于0，则返回”” 举例(*表示任意)： 1234567891011StringUtils.left(null, *) = nullStringUtils.left(*, -ve) = ""StringUtils.left("", *) = ""StringUtils.left("asdf", 0) = ""StringUtils.left("asdf", 2) = "as"StringUtils.left("asdf", = "asdf" public static String right(String str, int len) 得到字符串str从右边数len长度的子串。如果str为null或为””，则返回它本身 如果len小于0，则返回”” 举例(*表示任意)： 1234567891011StringUtils.right(null, *) = nullStringUtils.right(*, -ve) = ""StringUtils.right("", *) = ""StringUtils.right("asdf", 0) = ""StringUtils.right("asdf", 2) = "df"StringUtils.right("asdf", = "asdf" public static String mid(String str, int pos, int len) 得到字符串str从pos开始len长度的子串。如果str为null或为””，则返回它本身 如果len小于0或pos大于srt的长度，则返回”” 如果pos小于0，则pos设为0 举例(*表示任意)： 123456789101112131415StringUtils.mid(null, *, *) = nullStringUtils.mid("", *, *) = ""StringUtils.mid(*, *, -ve) = ""StringUtils.mid("asdf", 0, 4)) = "asdf"StringUtils.mid("asdf", 2, 2)) = "df"StringUtils.mid("asdf", 2, 5)) = "df"StringUtils.mid("asdf", -2, 1)) = "a"StringUtils.mid("asdf", 0, -1)) = "" public static String substringBefore(String str, String separator) 得到字符串str的在字符串separator出现前的字串，且separator不包括在内。如果str为null或为””，则返回它本身 如果separator为null，则返回str本身 举例(*表示任意)： 123456789101112131415161718192021StringUtils.substringBefore(null, *) = nullStringUtils.substringBefore("", *) = ""StringUtils.substringBefore("asdfg", null)) = "asdfg"StringUtils.substringBefore("asdfg", "a")) = ""StringUtils.substringBefore("asdfg", "sd")) = "a"StringUtils.substringBefore("asdfsag", "sa")) = "asdf"StringUtils.substringBefore("asdfg", "h")) = "asdfg"StringUtils.substringBefore("asdfg", "")) = ""StringUtils.substringBefore("asdfg", "dfgh")) = "asdfg"StringUtils.substringBefore("asdfg", "dfg")) = "as"StringUtils.substringBefore("abbbabbba", "bb")) = "a" public static String substringAfter(String str, String separator) 得到字符串str的在字符串separator出现后的字串，且separator不包括在内。如果str为null或为””，则返回它本身 如果separator为null，则返回”” 举例(*表示任意)： 123456789101112131415161718192021StringUtils.substringAfter(null, *) = nullStringUtils.substringAfter("", *) = ""StringUtils.substringAfter(*, null) = ""StringUtils.substringAfter("asdfg", "a")) = "sdfg"StringUtils.substringAfter("asdfg", "sd")) = "fg"StringUtils.substringAfter("asdfsag", "sa")) = "g"StringUtils.substringAfter("asdfg", "h")) = ""StringUtils.substringAfter("asdfg", "")) = "asdfg"StringUtils.substringAfter("asdfg", "dfgh")) = ""StringUtils.substringAfter("asdfg", "dfg")) = ""StringUtils.substringAfter("abbbabbba", "bb"))= "babbba" public static String substringBeforeLast(String str, String separator) 和45类似，得到字符串str的在字符串separator最后一次出现前的字串。这里不再举例。 public static String substringAfterLast(String str, String separator) 和46类似，得到字符串str的在字符串separator最后一次出现后的字串。这里不再举例。 public static String substringBetween(String str, String tag) 得到str中的在两个字符串tag中间的字符串，即str中的tag所夹的串。如果str为null或tag为null，返回null 举例(*表示任意)： 1234567891011121314151617StringUtils.substringBetween(null, *) = nullStringUtils.substringBetween(*, null) = nullStringUtils.substringBetween("", "") = ""StringUtils.substringBetween("", "a")) = nullStringUtils.substringBetween("asdfdf", "df")) = ""StringUtils.substringBetween("asdfas", "as")) = "df"StringUtils.substringBetween("dfasdfasdfas", "df")) = "as"StringUtils.substringBetween("dfasdfasdfas", "as")) = "df"StringUtils.substringBetween("dfasdfasgdf", "df")) = "as" public static String substringBetween(String str, String open, String close) 得到str中的在两个字符串open和close中间的字符串，即open和close所夹的串。如果str为null或open为null或close为null，返回null 举例(*表示任意)： 123456789101112131415161718192021StringUtils.substringBetween(null, *, *) = nullStringUtils.substringBetween(*, null, *) = nullStringUtils.substringBetween(*, *, null) = nullStringUtils.substringBetween("", "", "") = ""StringUtils.substringBetween("", "", "]") = nullStringUtils.substringBetween("", "[", "]") = nullStringUtils.substringBetween("[]", "[","]")) = ""StringUtils.substringBetween("a[sd]f", "[","]")) = "sd"StringUtils.substringBetween("a[sd]f[gh]", "[","]")) = "sd"StringUtils.substringBetween("a[sd]f", "]","[")) = nullStringUtils.substringBetween("a[sd]f", "","")) = "" public static String[] substringsBetween(String str, String open, String close) 得到str中的在两个字符串open和close中间的字符串，即open和close所夹的串，把所有符合的结果放在数组中返回。 和50类似，但是返回了所有的结果(50只返回了第一个匹配的结果)。 这里不再举例。 public static String[] split(String str) 把字符串拆分成一个字符串数组，用空白符(whitespace)作为分隔符。Whitespace是这样定义的 {@link Character#isWhitespace(char)} 如果字符串为null，返回null 如果字符串为””，返回空数组{} 举例(*表示任意)： 12345678910111213141516171819StringUtils.split(null) = nullStringUtils.split("") = &#123;&#125;StringUtils.split("as df yy")) = &#123;"as","df","yy"&#125;StringUtils.split(" as df yy ")) = &#123;"as","df","yy"&#125;StringUtils.split("as\ndf\ryy")) = &#123;"as","df","yy"&#125;StringUtils.split("as\tdf\fyy")) = &#123;"as","df","yy"&#125;StringUtils.split("as df \fyy")) = &#123;"as","df","yy"&#125;StringUtils.split("as\t \r df \f \n yy")) = &#123;"as","df","yy"&#125;StringUtils.split("as")) = &#123;"as"&#125;StringUtils.split(" as ")) = &#123;"as"&#125; public static String[] split(String str, char separatorChar) 把字符串拆分成一个字符串数组，用指定的字符separatorChar作为分隔符。如果字符串为null，返回null 如果字符串为””，返回空数组{} 举例(*表示任意)： 1234567891011121314151617StringUtils.split(null, *) = nullStringUtils.split("", *) = &#123;&#125;StringUtils.split("as df yy",' ')) = &#123;"as","df","yy"&#125; StringUtils.split(" as df yy ",' ')) = &#123;"as","df","yy"&#125; StringUtils.split("asodfoyy",'o')) = &#123;"as","df","yy"&#125; StringUtils.split("as.df.yy",'.')) = &#123;"as","df","yy"&#125; StringUtils.split("as\ndf\nyy",'\n'))= &#123;"as","df","yy"&#125; StringUtils.split("as",' ')) = &#123;"as"&#125; StringUtils.split(" as ",' ')) = &#123;"as"&#125; public static String[] split(String str, String separatorChars) 把字符串拆分成一个字符串数组，用指定的字符串separatorChars作为分隔符。如果字符串str为null，返回null 如果字符串str为””，返回空数组{} 如果separatorChars为null，则默认为空白符 和53类似。 举例(*表示任意)： 12345StringUtils.split("as \rdf \t yy",null)) = &#123;"as","df","yy"&#125;StringUtils.split("as\ndf\fyy",null)) = &#123;"as","df","yy"&#125;StringUtils.split("as","")) = &#123;"as"&#125; public static String[] split(String str, String separatorChars, int max) 把字符串拆分成一个字符串数组，用指定的字符串separatorChars作为分隔符，数组的最大长度为max。 如果字符串str为null，返回null 如果字符串str为””，返回空数组{} 如果separatorChars为null，则默认为空白符 如果max小于等于0，认为是没有限制 举例(*表示任意)： 12345678910111213141516171819StringUtils.split(null, *, *) = nullStringUtils.split("", *, *) = &#123;&#125;StringUtils.split("as df yy",null,0)) = &#123;"as","df","yy"&#125;StringUtils.split("as df yy"," ",0)) = &#123;"as","df","yy"&#125;StringUtils.split("as.df.yy",".",-1)) = &#123;"as","df","yy"&#125;StringUtils.split("as.df.yy",".",4)) = &#123;"as","df","yy"&#125;StringUtils.split("as-!-df-!-yy","-!-",0)) = &#123;"as","df","yy"&#125;StringUtils.split("as.df.yy",".",2)) = &#123;"as","df.yy"&#125;StringUtils.split("as","",0)) = &#123;"as"&#125;StringUtils.split("as","",2)) = &#123;"as"&#125; public static String[] splitByWholeSeparator(String str, String separator) 个人认为和54功能一样。区别有待发掘。 public static String[] splitByWholeSeparator( String str, String separator, int max ) 个人认为和55功能一样。区别有待发掘。 public static String[] splitPreserveAllTokens(String str) 把字符串str拆分成一个数组，用空白符(whitespace)作为分隔符，保留所有的标识，包括相邻分隔符产生的空的标识。它可作为StringTokenizer的一个替代。 Whitespace是这样定义的{@link Character#isWhitespace(char)}。 举例(*表示任意)： 12345678910111213StringUtils.splitPreserveAllTokens(null)) = nullStringUtils.splitPreserveAllTokens("")) = &#123;&#125;StringUtils.splitPreserveAllTokens("as df gh jk")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as\ndf\rgh\fjk")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as\tdf gh jk")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as df gh")) = &#123;"as","","df","gh"&#125;StringUtils.splitPreserveAllTokens(" as df ")) = &#123;"","as","","","df","",""&#125; public static String[] splitPreserveAllTokens(String str, char separatorChar) 和58类似，只是分隔符为字符separatorChar。举例(*表示任意)： 12345678910111213StringUtils.splitPreserveAllTokens(null, *) = nullStringUtils.splitPreserveAllTokens("", *) = &#123;&#125;StringUtils.splitPreserveAllTokens("as df gh jk",' ')) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as.df.gh.jk",'.')) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as..df.gh",'.')) = &#123;"as","","df","gh"&#125;StringUtils.splitPreserveAllTokens(",as,,,df,,",',')) = &#123;"","as","","","df","",""&#125;StringUtils.splitPreserveAllTokens("as.df.gh",',')) = &#123;"as.df.gh"&#125; public static String[] splitPreserveAllTokens(String str, String separatorChars) 和59类似，只是分隔符为字符串separatorChars。举例(*表示任意)： 12345678910111213141516171819StringUtils.splitPreserveAllTokens(null, *) = nullStringUtils.splitPreserveAllTokens("", *) = &#123;&#125;StringUtils.splitPreserveAllTokens("as df gh jk",null)) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as\ndf\rgh\fjk",null))= &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as df gh jk"," ")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as.df.gh.jk",".")) = &#123;"as","df","gh","jk"&#125;StringUtils.splitPreserveAllTokens("as..df.gh",".")) = &#123;"as","","df","gh"&#125;StringUtils.splitPreserveAllTokens(",as,,,df,,",",")) = &#123;"","as","","","df","",""&#125;StringUtils.splitPreserveAllTokens("as.df.gh",",")) = &#123;"as.df.gh"&#125;StringUtils.splitPreserveAllTokens("as.df.gh","")) = &#123;"as.df.gh"&#125; public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) 和上面几个类似，只是指定了数组的最大长度。如果max为0或负数，则认为没有限制。 这里不再举例。 public static String join(Object[] array) 把数组中的元素连接成一个字符串返回。举例(*表示任意)： 123456789StringUtils.join(null) = nullStringUtils.join(&#123;&#125;) = ""StringUtils.join(&#123;"as","df","gh","jk"&#125;)) = "asdfghjk"StringUtils.join(&#123;"as","","df","gh"&#125;)) = "asdfgh"StringUtils.join(&#123;"","as","","","df","",""&#125;)) = "asdf" public static String join(Object[] array, char separator) 把数组中的元素连接成一个字符串返回，把分隔符separator也加上。举例(*表示任意)： 12345678910111213141516171819StringUtils.join(null, *) = nullStringUtils.join(&#123;&#125;, *) = ""StringUtils.join(&#123;null&#125;, *) = ""StringUtils.join(&#123;"as","df","gh","jk"&#125;,' ')) = "as df gh jk"StringUtils.join(&#123;"as","df","gh","jk"&#125;,'.')) = "as.df.gh.jk"StringUtils.join(&#123;"as","","df","gh"&#125;,'.')) = "as..df.gh"StringUtils.join(&#123;"","as","","","df","",""&#125;,','))= ",as,,,df,,"StringUtils.join(&#123;"","as","","","df","",""&#125;,' '))= " as df "StringUtils.join(&#123;"as.df.gh"&#125;,'.')) = "as.df.gh"StringUtils.join(&#123;"as.df.gh"&#125;,' ')) = "as.df.gh" public static String join(Object[] array, char separator, int startIndex, int endIndex) 把数组中的元素连接成一个字符串返回，把分隔符separator也加上。连接的开始位置为startIndex，结束位置为endIndex。 这里不再举例。 public static String join(Object[] array, String separator) 与63类似，这里不再举例。 public static String join(Object[] array, String separator, int startIndex, int endIndex) 与64类似，这里不再举例。 public static String deleteWhitespace(String str) 删除字符串中的所有空白符(whitespace)，空白符是这样定义的{@link Character#isWhitespace(char)}。举例(*表示任意)： 12345678910111213StringUtils.deleteWhitespace(null) = nullStringUtils.deleteWhitespace("") = ""StringUtils.deleteWhitespace("asd")) = "asd",StringUtils.deleteWhitespace("as df")) = "asdf"StringUtils.deleteWhitespace("as\n\r\f\tdf")) = "asdf"StringUtils.deleteWhitespace("as\bdf")) = "as\bdf"StringUtils.deleteWhitespace(" as df ")) = "asdf" public static String removeStart(String str, String remove) 如果字符串str是以字符串remove开始，则去掉这个开始，然后返回，否则返回原来的串。举例(*表示任意)： 12345678910111213StringUtils.removeStart(null, *) = nullStringUtils.removeStart("", *) = ""StringUtils.removeStart(*, null) = *StringUtils.removeStart("asdf","")) = "asdf"StringUtils.removeStart("asdf","as")) = "df"StringUtils.removeStart("asdf","df")) = "asdf"StringUtils.removeStart("asdf","gh")) = "asdf" public static String removeEnd(String str, String remove) 如果字符串str是以字符串remove结尾，则去掉这个结尾，然后返回，否则返回原来的串。这里不再举例。 public static String remove(String str, String remove) 去掉字符串str中所有包含remove的部分，然后返回。这里不再举例。 public static String remove(String str, char remove) 去掉字符串str中所有包含remove的部分，然后返回。 这里不再举例。 public static String replaceOnce(String text, String repl, String with) 在字符串text中用with代替repl，仅一次。这里不再举例。 public static String replace(String text, String repl, String with) 在字符串text中用with代替repl，替换所有。这里不再举例。 public static String replace(String text, String repl, String with, int max) 在字符串text中用with代替repl，max为最大替换次数。如果max小于0，则替换所有。 这里不再举例。 public static String replaceChars(String str, char searchChar, char replaceChar) 在字符串str中用字符replaceChar代替所有字符searchChar，如果字符串为null或””，则返回它本身。 这里不再举例。 public static String replaceChars(String str, String searchChars, String replaceChars) 用replaceChars代替str中的searchChars。replaceChars的长度应该和searchChars的长度相等， 如果replaceChars的长度大于searchChars的长度，超过长度的字符将被忽略， 如果replaceChars的长度小于searchChars的长度，超过长度的字符将被删除。 举例(*表示任意)： 1234567891011121314151617181920212223StringUtils.replaceChars(null, *, *) = nullStringUtils.replaceChars("", *, *) = ""StringUtils.replaceChars("asdf", null, *) = "asdf"StringUtils.replaceChars("asdf", "", *) = "asdf"StringUtils.replaceChars("asdf","s",null)) = "adf"StringUtils.replaceChars("asdf","s","")) = "adf"StringUtils.replaceChars("asdsfsg","s","y")) = "aydyfyg"StringUtils.replaceChars("asdf","sd","yy")) = "ayyf"StringUtils.replaceChars("asdf","sd","yyy")) = "ayyf"StringUtils.replaceChars("asssdf","s","yyy")) = "ayyydf"StringUtils.replaceChars("asdf","sd","y")) = "ayf"StringUtils.replaceChars("assssddddf","sd","y"))= "ayyyyf" public static String overlay(String str, String overlay, int start, int end) 用字符串overlay覆盖字符串str从start到end之间的串。如果str为null，则返回null 如果start或end小于0，则设为0 如果start大于end，则两者交换 如果start或end大于str的长度，则认为等于str的长度 举例(*表示任意)： 123456789101112131415161718192021StringUtils.overlay(null, *, *, *) = nullStringUtils.overlay("","as",0,0)) = "as"StringUtils.overlay("asdfgh","qq",2,5)) = "asqqh"StringUtils.overlay("asdfgh","qq",5,2)) = "asqqh"StringUtils.overlay("asdfgh","qq",-1,3)) = "qqfgh"StringUtils.overlay("asdfgh","qq",-1,-3)) = "qqasdfgh"StringUtils.overlay("asdfgh","qq",7,10)) = "asdfghqq"StringUtils.overlay("asdfgh","qq",0,8)) = "qq"StringUtils.overlay("asdfgh","qq",2,8)) = "asqq"StringUtils.overlay("asdfgh",null,2,5)) = "ash"StringUtils.overlay("asdfgh","",2,5)) = "ash" public static String chop(String str) 去掉字符串str的最后一个字符。如果字符串以”\r\n”结尾，则去掉它们。 这里不再举例。 public static String repeat(String str, int repeat) 重复字符串repeat次，组合成一个新串返回。如果字符串str为null或””，则返回它本身 如果repeat小于0，则返回”” 举例(*表示任意)： 123456789StringUtils.repeat(null, *) = nullStringUtils.repeat("", *) = ""StringUtils.repeat("a", 3) = "aaa"StringUtils.repeat("ab", 2) = "abab"StringUtils.repeat("a", -2) = "" public static String rightPad(String str, int size) 如果str为null，则返回null如果字符串长度小于size，则在右边补空格使其长度等于size，然后返回 如果字符串长度大于等于size，则返回它本身 这里不再举例。 public static String rightPad(String str, int size, char padChar) 和80类似，只是补的字符为padChar。这里不再举例。 public static String rightPad(String str, int size, String padStr) 和80类似，只是补的是字符串padStr。举例(*表示任意)： 123456789101112131415161718192021StringUtils.rightPad(null, *, *) = nullStringUtils.rightPad("",0,"")) = ""StringUtils.rightPad("",3,"")) = " "StringUtils.rightPad("",3,"a")) = "aaa"StringUtils.rightPad("",2,"as")) = "as"StringUtils.rightPad("as",-1,"df")) = "as"StringUtils.rightPad("as",0,"df")) = "as"StringUtils.rightPad("as",3,"df")) = "asd"StringUtils.rightPad("as",8,"df")) = "asdfdfdf"StringUtils.rightPad("as",5,null)) = "as "StringUtils.rightPad("as",5,"")) = "as " public static String leftPad(String str, int size) 和80类似，只是补左边。这里不再举例。 public static String leftPad(String str, int size, char padChar) 和81类似。这里不再举例。 public static String leftPad(String str, int size, String padStr) 和82类似。这里不再举例。 public static String center(String str, int size) 产生一个字符串返回，该字符串长度等于size，str位于新串的中心，其他位置补空格。如果str为null，则返回null 如果size小于str的长度，则返回str本身 举例(*表示任意)： 123456789101112131415StringUtils.center(null, *) = nullStringUtils.center("",1)) = " "StringUtils.center("",2)) = " "StringUtils.center("as",-1)) = "as"StringUtils.center("as",2)) = "as"StringUtils.center("as",3)) = "as "StringUtils.center("as",4)) = " as "StringUtils.center("as",10)) = " as " public static String center(String str, int size, char padChar) 和86类似，只是其他位置补padChar。这里不再举例。 public static String center(String str, int size, String padStr) 和86类似，只是其他位置补padStr。这里不再举例。 public static String swapCase(String str) 把字符串中的字符大写转换为小写，小写转换为大写。举例： 1234567StringUtils.swapCase(null) = nullStringUtils.swapCase("") = ""StringUtils.swapCase("Hello Boys")) = "hELLO bOYS"StringUtils.swapCase("I am 11")) = "i AM 11" public static int countMatches(String str, String sub) 计算字符串sub在字符串str中出现的次数。如果str为null或””，则返回0 举例(*表示任意)： 12345678910111213StringUtils.countMatches(null, *) = 0StringUtils.countMatches("", *) = 0StringUtils.countMatches("asdf","as")) = 1StringUtils.countMatches("asdfas","as")) = 2StringUtils.countMatches("dfgh","as")) = 0StringUtils.countMatches("as","")) = 0StringUtils.countMatches("as",null)) = 0 DateUtilDateUtil类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652package com.util;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;public class DateUtil &#123; /** * 获取SimpleDateFormat * @param parttern 日期格式 * @return SimpleDateFormat对象 * @throws RuntimeException 异常：非法日期格式 */ private static SimpleDateFormat getDateFormat(String parttern) throws RuntimeException &#123; return new SimpleDateFormat(parttern); &#125; /** * 获取日期中的某数值。如获取月份 * @param date 日期 * @param dateType 日期格式 * @return 数值 */ private static int getInteger(Date date, int dateType) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); return calendar.get(dateType); &#125; /** * 增加日期中某类型的某数值。如增加日期 * @param date 日期字符串 * @param dateType 类型 * @param amount 数值 * @return 计算后日期字符串 */ private static String addInteger(String date, int dateType, int amount) &#123; String dateString = null; DateStyle dateStyle = getDateStyle(date); if (dateStyle != null) &#123; Date myDate = StringToDate(date, dateStyle); myDate = addInteger(myDate, dateType, amount); dateString = DateToString(myDate, dateStyle); &#125; return dateString; &#125; /** * 增加日期中某类型的某数值。如增加日期 * @param date 日期 * @param dateType 类型 * @param amount 数值 * @return 计算后日期 */ private static Date addInteger(Date date, int dateType, int amount) &#123; Date myDate = null; if (date != null) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(dateType, amount); myDate = calendar.getTime(); &#125; return myDate; &#125; /** * 获取精确的日期 * @param timestamps 时间long集合 * @return 日期 */ private static Date getAccurateDate(List&lt;Long&gt; timestamps) &#123; Date date = null; long timestamp = 0; Map&lt;Long, long[]&gt; map = new HashMap&lt;Long, long[]&gt;(); List&lt;Long&gt; absoluteValues = new ArrayList&lt;Long&gt;(); if (timestamps != null &amp;&amp; timestamps.size() &gt; 0) &#123; if (timestamps.size() &gt; 1) &#123; for (int i = 0; i &lt; timestamps.size(); i++) &#123; for (int j = i + 1; j &lt; timestamps.size(); j++) &#123; long absoluteValue = Math.abs(timestamps.get(i) - timestamps.get(j)); absoluteValues.add(absoluteValue); long[] timestampTmp = &#123; timestamps.get(i), timestamps.get(j) &#125;; map.put(absoluteValue, timestampTmp); &#125; &#125; // 有可能有相等的情况。如2012-11和2012-11-01。时间戳是相等的 long minAbsoluteValue = -1; if (!absoluteValues.isEmpty()) &#123; // 如果timestamps的size为2，这是差值只有一个，因此要给默认值 minAbsoluteValue = absoluteValues.get(0); &#125; for (int i = 0; i &lt; absoluteValues.size(); i++) &#123; for (int j = i + 1; j &lt; absoluteValues.size(); j++) &#123; if (absoluteValues.get(i) &gt; absoluteValues.get(j)) &#123; minAbsoluteValue = absoluteValues.get(j); &#125; else &#123; minAbsoluteValue = absoluteValues.get(i); &#125; &#125; &#125; if (minAbsoluteValue != -1) &#123; long[] timestampsLastTmp = map.get(minAbsoluteValue); if (absoluteValues.size() &gt; 1) &#123; timestamp = Math.max(timestampsLastTmp[0], timestampsLastTmp[1]); &#125; else if (absoluteValues.size() == 1) &#123; // 当timestamps的size为2，需要与当前时间作为参照 long dateOne = timestampsLastTmp[0]; long dateTwo = timestampsLastTmp[1]; if ((Math.abs(dateOne - dateTwo)) &lt; 100000000000L) &#123; timestamp = Math.max(timestampsLastTmp[0], timestampsLastTmp[1]); &#125; else &#123; long now = new Date().getTime(); if (Math.abs(dateOne - now) &lt;= Math.abs(dateTwo - now)) &#123; timestamp = dateOne; &#125; else &#123; timestamp = dateTwo; &#125; &#125; &#125; &#125; &#125; else &#123; timestamp = timestamps.get(0); &#125; &#125; if (timestamp != 0) &#123; date = new Date(timestamp); &#125; return date; &#125; /** * 判断字符串是否为日期字符串 * @param date 日期字符串 * @return true or false */ public static boolean isDate(String date) &#123; boolean isDate = false; if (date != null) &#123; if (StringToDate(date) != null) &#123; isDate = true; &#125; &#125; return isDate; &#125; /** * 获取日期字符串的日期风格。失敗返回null。 * @param date 日期字符串 * @return 日期风格 */ public static DateStyle getDateStyle(String date) &#123; DateStyle dateStyle = null; Map&lt;Long, DateStyle&gt; map = new HashMap&lt;Long, DateStyle&gt;(); List&lt;Long&gt; timestamps = new ArrayList&lt;Long&gt;(); for (DateStyle style : DateStyle.values()) &#123; Date dateTmp = StringToDate(date, style.getValue()); if (dateTmp != null) &#123; timestamps.add(dateTmp.getTime()); map.put(dateTmp.getTime(), style); &#125; &#125; dateStyle = map.get(getAccurateDate(timestamps).getTime()); return dateStyle; &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @return 日期 */ public static Date StringToDate(String date) &#123; DateStyle dateStyle = null; return StringToDate(date, dateStyle); &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @param parttern 日期格式 * @return 日期 */ public static Date StringToDate(String date, String parttern) &#123; Date myDate = null; if (date != null) &#123; try &#123; myDate = getDateFormat(parttern).parse(date); &#125; catch (Exception e) &#123; &#125; &#125; return myDate; &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @param dateStyle 日期风格 * @return 日期 */ public static Date StringToDate(String date, DateStyle dateStyle) &#123; Date myDate = null; if (dateStyle == null) &#123; List&lt;Long&gt; timestamps = new ArrayList&lt;Long&gt;(); for (DateStyle style : DateStyle.values()) &#123; Date dateTmp = StringToDate(date, style.getValue()); if (dateTmp != null) &#123; timestamps.add(dateTmp.getTime()); &#125; &#125; myDate = getAccurateDate(timestamps); &#125; else &#123; myDate = StringToDate(date, dateStyle.getValue()); &#125; return myDate; &#125; /** * 将日期转化为日期字符串。失败返回null。 * @param date 日期 * @param parttern 日期格式 * @return 日期字符串 */ public static String DateToString(Date date, String parttern) &#123; String dateString = null; if (date != null) &#123; try &#123; dateString = getDateFormat(parttern).format(date); &#125; catch (Exception e) &#123; &#125; &#125; return dateString; &#125; /** * 将日期转化为日期字符串。失败返回null。 * @param date 日期 * @param dateStyle 日期风格 * @return 日期字符串 */ public static String DateToString(Date date, DateStyle dateStyle) &#123; String dateString = null; if (dateStyle != null) &#123; dateString = DateToString(date, dateStyle.getValue()); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param parttern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, String parttern) &#123; return StringToString(date, null, parttern); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param dateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle dateStyle) &#123; return StringToString(date, null, dateStyle); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddParttern 旧日期格式 * @param newParttern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, String olddParttern, String newParttern) &#123; String dateString = null; if (olddParttern == null) &#123; DateStyle style = getDateStyle(date); if (style != null) &#123; Date myDate = StringToDate(date, style.getValue()); dateString = DateToString(myDate, newParttern); &#125; &#125; else &#123; Date myDate = StringToDate(date, olddParttern); dateString = DateToString(myDate, newParttern); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddDteStyle 旧日期风格 * @param newDateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle olddDteStyle, DateStyle newDateStyle) &#123; String dateString = null; if (olddDteStyle == null) &#123; DateStyle style = getDateStyle(date); dateString = StringToString(date, style.getValue(), newDateStyle.getValue()); &#125; else &#123; dateString = StringToString(date, olddDteStyle.getValue(), newDateStyle.getValue()); &#125; return dateString; &#125; /** * 增加日期的年份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加年份后的日期字符串 */ public static String addYear(String date, int yearAmount) &#123; return addInteger(date, Calendar.YEAR, yearAmount); &#125; /** * 增加日期的年份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加年份后的日期 */ public static Date addYear(Date date, int yearAmount) &#123; return addInteger(date, Calendar.YEAR, yearAmount); &#125; /** * 增加日期的月份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加月份后的日期字符串 */ public static String addMonth(String date, int yearAmount) &#123; return addInteger(date, Calendar.MONTH, yearAmount); &#125; /** * 增加日期的月份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加月份后的日期 */ public static Date addMonth(Date date, int yearAmount) &#123; return addInteger(date, Calendar.MONTH, yearAmount); &#125; /** * 增加日期的天数。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加天数后的日期字符串 */ public static String addDay(String date, int dayAmount) &#123; return addInteger(date, Calendar.DATE, dayAmount); &#125; /** * 增加日期的天数。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加天数后的日期 */ public static Date addDay(Date date, int dayAmount) &#123; return addInteger(date, Calendar.DATE, dayAmount); &#125; /** * 增加日期的小时。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加小时后的日期字符串 */ public static String addHour(String date, int hourAmount) &#123; return addInteger(date, Calendar.HOUR_OF_DAY, hourAmount); &#125; /** * 增加日期的小时。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加小时后的日期 */ public static Date addHour(Date date, int hourAmount) &#123; return addInteger(date, Calendar.HOUR_OF_DAY, hourAmount); &#125; /** * 增加日期的分钟。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加分钟后的日期字符串 */ public static String addMinute(String date, int hourAmount) &#123; return addInteger(date, Calendar.MINUTE, hourAmount); &#125; /** * 增加日期的分钟。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加分钟后的日期 */ public static Date addMinute(Date date, int hourAmount) &#123; return addInteger(date, Calendar.MINUTE, hourAmount); &#125; /** * 增加日期的秒钟。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加秒钟后的日期字符串 */ public static String addSecond(String date, int hourAmount) &#123; return addInteger(date, Calendar.SECOND, hourAmount); &#125; /** * 增加日期的秒钟。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加秒钟后的日期 */ public static Date addSecond(Date date, int hourAmount) &#123; return addInteger(date, Calendar.SECOND, hourAmount); &#125; /** * 获取日期的年份。失败返回0。 * @param date 日期字符串 * @return 年份 */ public static int getYear(String date) &#123; return getYear(StringToDate(date)); &#125; /** * 获取日期的年份。失败返回0。 * @param date 日期 * @return 年份 */ public static int getYear(Date date) &#123; return getInteger(date, Calendar.YEAR); &#125; /** * 获取日期的月份。失败返回0。 * @param date 日期字符串 * @return 月份 */ public static int getMonth(String date) &#123; return getMonth(StringToDate(date)); &#125; /** * 获取日期的月份。失败返回0。 * @param date 日期 * @return 月份 */ public static int getMonth(Date date) &#123; return getInteger(date, Calendar.MONTH); &#125; /** * 获取日期的天数。失败返回0。 * @param date 日期字符串 * @return 天 */ public static int getDay(String date) &#123; return getDay(StringToDate(date)); &#125; /** * 获取日期的天数。失败返回0。 * @param date 日期 * @return 天 */ public static int getDay(Date date) &#123; return getInteger(date, Calendar.DATE); &#125; /** * 获取日期的小时。失败返回0。 * @param date 日期字符串 * @return 小时 */ public static int getHour(String date) &#123; return getHour(StringToDate(date)); &#125; /** * 获取日期的小时。失败返回0。 * @param date 日期 * @return 小时 */ public static int getHour(Date date) &#123; return getInteger(date, Calendar.HOUR_OF_DAY); &#125; /** * 获取日期的分钟。失败返回0。 * @param date 日期字符串 * @return 分钟 */ public static int getMinute(String date) &#123; return getMinute(StringToDate(date)); &#125; /** * 获取日期的分钟。失败返回0。 * @param date 日期 * @return 分钟 */ public static int getMinute(Date date) &#123; return getInteger(date, Calendar.MINUTE); &#125; /** * 获取日期的秒钟。失败返回0。 * @param date 日期字符串 * @return 秒钟 */ public static int getSecond(String date) &#123; return getSecond(StringToDate(date)); &#125; /** * 获取日期的秒钟。失败返回0。 * @param date 日期 * @return 秒钟 */ public static int getSecond(Date date) &#123; return getInteger(date, Calendar.SECOND); &#125; /** * 获取日期 。默认yyyy-MM-dd格式。失败返回null。 * @param date 日期字符串 * @return 日期 */ public static String getDate(String date) &#123; return StringToString(date, DateStyle.YYYY_MM_DD); &#125; /** * 获取日期。默认yyyy-MM-dd格式。失败返回null。 * @param date 日期 * @return 日期 */ public static String getDate(Date date) &#123; return DateToString(date, DateStyle.YYYY_MM_DD); &#125; /** * 获取日期的时间。默认HH:mm:ss格式。失败返回null。 * @param date 日期字符串 * @return 时间 */ public static String getTime(String date) &#123; return StringToString(date, DateStyle.HH_MM_SS); &#125; /** * 获取日期的时间。默认HH:mm:ss格式。失败返回null。 * @param date 日期 * @return 时间 */ public static String getTime(Date date) &#123; return DateToString(date, DateStyle.HH_MM_SS); &#125; /** * 获取日期的星期。失败返回null。 * @param date 日期字符串 * @return 星期 */ public static Week getWeek(String date) &#123; Week week = null; DateStyle dateStyle = getDateStyle(date); if (dateStyle != null) &#123; Date myDate = StringToDate(date, dateStyle); week = getWeek(myDate); &#125; return week; &#125; /** * 获取日期的星期。失败返回null。 * @param date 日期 * @return 星期 */ public static Week getWeek(Date date) &#123; Week week = null; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); int weekNumber = calendar.get(Calendar.DAY_OF_WEEK) - 1; switch (weekNumber) &#123; case 0: week = Week.SUNDAY; break; case 1: week = Week.MONDAY; break; case 2: week = Week.TUESDAY; break; case 3: week = Week.WEDNESDAY; break; case 4: week = Week.THURSDAY; break; case 5: week = Week.FRIDAY; break; case 6: week = Week.SATURDAY; break; &#125; return week; &#125; /** * 获取两个日期相差的天数 * @param date 日期字符串 * @param otherDate 另一个日期字符串 * @return 相差天数 */ public static int getIntervalDays(String date, String otherDate) &#123; return getIntervalDays(StringToDate(date), StringToDate(otherDate)); &#125; /** * @param date 日期 * @param otherDate 另一个日期 * @return 相差天数 */ public static int getIntervalDays(Date date, Date otherDate) &#123; date = DateUtil.StringToDate(DateUtil.getDate(date)); long time = Math.abs(date.getTime() - otherDate.getTime()); return (int)time/(24 * 60 * 60 * 1000); &#125;&#125; DateStyle类12345678910111213141516171819202122232425262728293031323334353637383940414243package com.util;public enum DateStyle &#123; MM_DD("MM-dd"), YYYY_MM("yyyy-MM"), YYYY_MM_DD("yyyy-MM-dd"), MM_DD_HH_MM("MM-dd HH:mm"), MM_DD_HH_MM_SS("MM-dd HH:mm:ss"), YYYY_MM_DD_HH_MM("yyyy-MM-dd HH:mm"), YYYY_MM_DD_HH_MM_SS("yyyy-MM-dd HH:mm:ss"), MM_DD_EN("MM/dd"), YYYY_MM_EN("yyyy/MM"), YYYY_MM_DD_EN("yyyy/MM/dd"), MM_DD_HH_MM_EN("MM/dd HH:mm"), MM_DD_HH_MM_SS_EN("MM/dd HH:mm:ss"), YYYY_MM_DD_HH_MM_EN("yyyy/MM/dd HH:mm"), YYYY_MM_DD_HH_MM_SS_EN("yyyy/MM/dd HH:mm:ss"), MM_DD_CN("MM月dd日"), YYYY_MM_CN("yyyy年MM月"), YYYY_MM_DD_CN("yyyy年MM月dd日"), MM_DD_HH_MM_CN("MM月dd日 HH:mm"), MM_DD_HH_MM_SS_CN("MM月dd日 HH:mm:ss"), YYYY_MM_DD_HH_MM_CN("yyyy年MM月dd日 HH:mm"), YYYY_MM_DD_HH_MM_SS_CN("yyyy年MM月dd日 HH:mm:ss"), HH_MM("HH:mm"), HH_MM_SS("HH:mm:ss"); private String value; DateStyle(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; Week类1234567891011121314151617181920212223242526272829303132333435363738394041package com.util;public enum Week &#123; MONDAY("星期一", "Monday", "Mon.", 1), TUESDAY("星期二", "Tuesday", "Tues.", 2), WEDNESDAY("星期三", "Wednesday", "Wed.", 3), THURSDAY("星期四", "Thursday", "Thur.", 4), FRIDAY("星期五", "Friday", "Fri.", 5), SATURDAY("星期六", "Saturday", "Sat.", 6), SUNDAY("星期日", "Sunday", "Sun.", 7); String name_cn; String name_en; String name_enShort; int number; Week(String name_cn, String name_en, String name_enShort, int number) &#123; this.name_cn = name_cn; this.name_en = name_en; this.name_enShort = name_enShort; this.number = number; &#125; public String getChineseName() &#123; return name_cn; &#125; public String getName() &#123; return name_en; &#125; public String getShortName() &#123; return name_enShort; &#125; public int getNumber() &#123; return number; &#125;&#125; DateUtils优化版： 修正当字符串日期风格为MM-dd或yyyy-MM时，若日期太大或太小后，识别日期错误。 修正识别日期算法（getAccurateDate）bug。 修正计算日期天数差（getIntervalDays）bug。 优化DateUtil处理日期的速度。 优化日期风格（DateStyle）识别方式。 DateUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687package com.itkt.mtravel.hotel.util;import java.text.ParsePosition;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;public class DateUtil &#123; private static final ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;(); private static final Object object = new Object(); /** * 获取SimpleDateFormat * @param pattern 日期格式 * @return SimpleDateFormat对象 * @throws RuntimeException 异常：非法日期格式 */ private static SimpleDateFormat getDateFormat(String pattern) throws RuntimeException &#123; SimpleDateFormat dateFormat = threadLocal.get(); if (dateFormat == null) &#123; synchronized (object) &#123; if (dateFormat == null) &#123; dateFormat = new SimpleDateFormat(pattern); dateFormat.setLenient(false); threadLocal.set(dateFormat); &#125; &#125; &#125; dateFormat.applyPattern(pattern); return dateFormat; &#125; /** * 获取日期中的某数值。如获取月份 * @param date 日期 * @param dateType 日期格式 * @return 数值 */ private static int getInteger(Date date, int dateType) &#123; int num = 0; Calendar calendar = Calendar.getInstance(); if (date != null) &#123; calendar.setTime(date); num = calendar.get(dateType); &#125; return num; &#125; /** * 增加日期中某类型的某数值。如增加日期 * @param date 日期字符串 * @param dateType 类型 * @param amount 数值 * @return 计算后日期字符串 */ private static String addInteger(String date, int dateType, int amount) &#123; String dateString = null; DateStyle dateStyle = getDateStyle(date); if (dateStyle != null) &#123; Date myDate = StringToDate(date, dateStyle); myDate = addInteger(myDate, dateType, amount); dateString = DateToString(myDate, dateStyle); &#125; return dateString; &#125; /** * 增加日期中某类型的某数值。如增加日期 * @param date 日期 * @param dateType 类型 * @param amount 数值 * @return 计算后日期 */ private static Date addInteger(Date date, int dateType, int amount) &#123; Date myDate = null; if (date != null) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(dateType, amount); myDate = calendar.getTime(); &#125; return myDate; &#125; /** * 获取精确的日期 * @param timestamps 时间long集合 * @return 日期 */ private static Date getAccurateDate(List&lt;Long&gt; timestamps) &#123; Date date = null; long timestamp = 0; Map&lt;Long, long[]&gt; map = new HashMap&lt;Long, long[]&gt;(); List&lt;Long&gt; absoluteValues = new ArrayList&lt;Long&gt;(); if (timestamps != null &amp;&amp; timestamps.size() &gt; 0) &#123; if (timestamps.size() &gt; 1) &#123; for (int i = 0; i &lt; timestamps.size(); i++) &#123; for (int j = i + 1; j &lt; timestamps.size(); j++) &#123; long absoluteValue = Math.abs(timestamps.get(i) - timestamps.get(j)); absoluteValues.add(absoluteValue); long[] timestampTmp = &#123; timestamps.get(i), timestamps.get(j) &#125;; map.put(absoluteValue, timestampTmp); &#125; &#125; // 有可能有相等的情况。如2012-11和2012-11-01。时间戳是相等的。此时minAbsoluteValue为0 // 因此不能将minAbsoluteValue取默认值0 long minAbsoluteValue = -1; if (!absoluteValues.isEmpty()) &#123; minAbsoluteValue = absoluteValues.get(0); for (int i = 1; i &lt; absoluteValues.size(); i++) &#123; if (minAbsoluteValue &gt; absoluteValues.get(i)) &#123; minAbsoluteValue = absoluteValues.get(i); &#125; &#125; &#125; if (minAbsoluteValue != -1) &#123; long[] timestampsLastTmp = map.get(minAbsoluteValue); long dateOne = timestampsLastTmp[0]; long dateTwo = timestampsLastTmp[1]; if (absoluteValues.size() &gt; 1) &#123; timestamp = Math.abs(dateOne) &gt; Math.abs(dateTwo) ? dateOne : dateTwo; &#125; &#125; &#125; else &#123; timestamp = timestamps.get(0); &#125; &#125; if (timestamp != 0) &#123; date = new Date(timestamp); &#125; return date; &#125; /** * 判断字符串是否为日期字符串 * @param date 日期字符串 * @return true or false */ public static boolean isDate(String date) &#123; boolean isDate = false; if (date != null) &#123; if (getDateStyle(date) != null) &#123; isDate = true; &#125; &#125; return isDate; &#125; /** * 获取日期字符串的日期风格。失敗返回null。 * @param date 日期字符串 * @return 日期风格 */ public static DateStyle getDateStyle(String date) &#123; DateStyle dateStyle = null; Map&lt;Long, DateStyle&gt; map = new HashMap&lt;Long, DateStyle&gt;(); List&lt;Long&gt; timestamps = new ArrayList&lt;Long&gt;(); for (DateStyle style : DateStyle.values()) &#123; if (style.isShowOnly()) &#123; continue; &#125; Date dateTmp = null; if (date != null) &#123; try &#123; ParsePosition pos = new ParsePosition(0); dateTmp = getDateFormat(style.getValue()).parse(date, pos); if (pos.getIndex() != date.length()) &#123; dateTmp = null; &#125; &#125; catch (Exception e) &#123; &#125; &#125; if (dateTmp != null) &#123; timestamps.add(dateTmp.getTime()); map.put(dateTmp.getTime(), style); &#125; &#125; Date accurateDate = getAccurateDate(timestamps); if (accurateDate != null) &#123; dateStyle = map.get(accurateDate.getTime()); &#125; return dateStyle; &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @return 日期 */ public static Date StringToDate(String date) &#123; DateStyle dateStyle = getDateStyle(date); return StringToDate(date, dateStyle); &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @param pattern 日期格式 * @return 日期 */ public static Date StringToDate(String date, String pattern) &#123; Date myDate = null; if (date != null) &#123; try &#123; myDate = getDateFormat(pattern).parse(date); &#125; catch (Exception e) &#123; &#125; &#125; return myDate; &#125; /** * 将日期字符串转化为日期。失败返回null。 * @param date 日期字符串 * @param dateStyle 日期风格 * @return 日期 */ public static Date StringToDate(String date, DateStyle dateStyle) &#123; Date myDate = null; if (dateStyle != null) &#123; myDate = StringToDate(date, dateStyle.getValue()); &#125; return myDate; &#125; /** * 将日期转化为日期字符串。失败返回null。 * @param date 日期 * @param pattern 日期格式 * @return 日期字符串 */ public static String DateToString(Date date, String pattern) &#123; String dateString = null; if (date != null) &#123; try &#123; dateString = getDateFormat(pattern).format(date); &#125; catch (Exception e) &#123; &#125; &#125; return dateString; &#125; /** * 将日期转化为日期字符串。失败返回null。 * @param date 日期 * @param dateStyle 日期风格 * @return 日期字符串 */ public static String DateToString(Date date, DateStyle dateStyle) &#123; String dateString = null; if (dateStyle != null) &#123; dateString = DateToString(date, dateStyle.getValue()); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param newPattern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, String newPattern) &#123; DateStyle oldDateStyle = getDateStyle(date); return StringToString(date, oldDateStyle, newPattern); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param newDateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle newDateStyle) &#123; DateStyle oldDateStyle = getDateStyle(date); return StringToString(date, oldDateStyle, newDateStyle); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddPattern 旧日期格式 * @param newPattern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, String olddPattern, String newPattern) &#123; return DateToString(StringToDate(date, olddPattern), newPattern); &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddDteStyle 旧日期风格 * @param newParttern 新日期格式 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle olddDteStyle, String newParttern) &#123; String dateString = null; if (olddDteStyle != null) &#123; dateString = StringToString(date, olddDteStyle.getValue(), newParttern); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddPattern 旧日期格式 * @param newDateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, String olddPattern, DateStyle newDateStyle) &#123; String dateString = null; if (newDateStyle != null) &#123; dateString = StringToString(date, olddPattern, newDateStyle.getValue()); &#125; return dateString; &#125; /** * 将日期字符串转化为另一日期字符串。失败返回null。 * @param date 旧日期字符串 * @param olddDteStyle 旧日期风格 * @param newDateStyle 新日期风格 * @return 新日期字符串 */ public static String StringToString(String date, DateStyle olddDteStyle, DateStyle newDateStyle) &#123; String dateString = null; if (olddDteStyle != null &amp;&amp; newDateStyle != null) &#123; dateString = StringToString(date, olddDteStyle.getValue(), newDateStyle.getValue()); &#125; return dateString; &#125; /** * 增加日期的年份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加年份后的日期字符串 */ public static String addYear(String date, int yearAmount) &#123; return addInteger(date, Calendar.YEAR, yearAmount); &#125; /** * 增加日期的年份。失败返回null。 * @param date 日期 * @param yearAmount 增加数量。可为负数 * @return 增加年份后的日期 */ public static Date addYear(Date date, int yearAmount) &#123; return addInteger(date, Calendar.YEAR, yearAmount); &#125; /** * 增加日期的月份。失败返回null。 * @param date 日期 * @param monthAmount 增加数量。可为负数 * @return 增加月份后的日期字符串 */ public static String addMonth(String date, int monthAmount) &#123; return addInteger(date, Calendar.MONTH, monthAmount); &#125; /** * 增加日期的月份。失败返回null。 * @param date 日期 * @param monthAmount 增加数量。可为负数 * @return 增加月份后的日期 */ public static Date addMonth(Date date, int monthAmount) &#123; return addInteger(date, Calendar.MONTH, monthAmount); &#125; /** * 增加日期的天数。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加天数后的日期字符串 */ public static String addDay(String date, int dayAmount) &#123; return addInteger(date, Calendar.DATE, dayAmount); &#125; /** * 增加日期的天数。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加天数后的日期 */ public static Date addDay(Date date, int dayAmount) &#123; return addInteger(date, Calendar.DATE, dayAmount); &#125; /** * 增加日期的小时。失败返回null。 * @param date 日期字符串 * @param hourAmount 增加数量。可为负数 * @return 增加小时后的日期字符串 */ public static String addHour(String date, int hourAmount) &#123; return addInteger(date, Calendar.HOUR_OF_DAY, hourAmount); &#125; /** * 增加日期的小时。失败返回null。 * @param date 日期 * @param hourAmount 增加数量。可为负数 * @return 增加小时后的日期 */ public static Date addHour(Date date, int hourAmount) &#123; return addInteger(date, Calendar.HOUR_OF_DAY, hourAmount); &#125; /** * 增加日期的分钟。失败返回null。 * @param date 日期字符串 * @param minuteAmount 增加数量。可为负数 * @return 增加分钟后的日期字符串 */ public static String addMinute(String date, int minuteAmount) &#123; return addInteger(date, Calendar.MINUTE, minuteAmount); &#125; /** * 增加日期的分钟。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加分钟后的日期 */ public static Date addMinute(Date date, int minuteAmount) &#123; return addInteger(date, Calendar.MINUTE, minuteAmount); &#125; /** * 增加日期的秒钟。失败返回null。 * @param date 日期字符串 * @param dayAmount 增加数量。可为负数 * @return 增加秒钟后的日期字符串 */ public static String addSecond(String date, int secondAmount) &#123; return addInteger(date, Calendar.SECOND, secondAmount); &#125; /** * 增加日期的秒钟。失败返回null。 * @param date 日期 * @param dayAmount 增加数量。可为负数 * @return 增加秒钟后的日期 */ public static Date addSecond(Date date, int secondAmount) &#123; return addInteger(date, Calendar.SECOND, secondAmount); &#125; /** * 获取日期的年份。失败返回0。 * @param date 日期字符串 * @return 年份 */ public static int getYear(String date) &#123; return getYear(StringToDate(date)); &#125; /** * 获取日期的年份。失败返回0。 * @param date 日期 * @return 年份 */ public static int getYear(Date date) &#123; return getInteger(date, Calendar.YEAR); &#125; /** * 获取日期的月份。失败返回0。 * @param date 日期字符串 * @return 月份 */ public static int getMonth(String date) &#123; return getMonth(StringToDate(date)); &#125; /** * 获取日期的月份。失败返回0。 * @param date 日期 * @return 月份 */ public static int getMonth(Date date) &#123; return getInteger(date, Calendar.MONTH) + 1; &#125; /** * 获取日期的天数。失败返回0。 * @param date 日期字符串 * @return 天 */ public static int getDay(String date) &#123; return getDay(StringToDate(date)); &#125; /** * 获取日期的天数。失败返回0。 * @param date 日期 * @return 天 */ public static int getDay(Date date) &#123; return getInteger(date, Calendar.DATE); &#125; /** * 获取日期的小时。失败返回0。 * @param date 日期字符串 * @return 小时 */ public static int getHour(String date) &#123; return getHour(StringToDate(date)); &#125; /** * 获取日期的小时。失败返回0。 * @param date 日期 * @return 小时 */ public static int getHour(Date date) &#123; return getInteger(date, Calendar.HOUR_OF_DAY); &#125; /** * 获取日期的分钟。失败返回0。 * @param date 日期字符串 * @return 分钟 */ public static int getMinute(String date) &#123; return getMinute(StringToDate(date)); &#125; /** * 获取日期的分钟。失败返回0。 * @param date 日期 * @return 分钟 */ public static int getMinute(Date date) &#123; return getInteger(date, Calendar.MINUTE); &#125; /** * 获取日期的秒钟。失败返回0。 * @param date 日期字符串 * @return 秒钟 */ public static int getSecond(String date) &#123; return getSecond(StringToDate(date)); &#125; /** * 获取日期的秒钟。失败返回0。 * @param date 日期 * @return 秒钟 */ public static int getSecond(Date date) &#123; return getInteger(date, Calendar.SECOND); &#125; /** * 获取日期 。默认yyyy-MM-dd格式。失败返回null。 * @param date 日期字符串 * @return 日期 */ public static String getDate(String date) &#123; return StringToString(date, DateStyle.YYYY_MM_DD); &#125; /** * 获取日期。默认yyyy-MM-dd格式。失败返回null。 * @param date 日期 * @return 日期 */ public static String getDate(Date date) &#123; return DateToString(date, DateStyle.YYYY_MM_DD); &#125; /** * 获取日期的时间。默认HH:mm:ss格式。失败返回null。 * @param date 日期字符串 * @return 时间 */ public static String getTime(String date) &#123; return StringToString(date, DateStyle.HH_MM_SS); &#125; /** * 获取日期的时间。默认HH:mm:ss格式。失败返回null。 * @param date 日期 * @return 时间 */ public static String getTime(Date date) &#123; return DateToString(date, DateStyle.HH_MM_SS); &#125; /** * 获取日期的星期。失败返回null。 * @param date 日期字符串 * @return 星期 */ public static Week getWeek(String date) &#123; Week week = null; DateStyle dateStyle = getDateStyle(date); if (dateStyle != null) &#123; Date myDate = StringToDate(date, dateStyle); week = getWeek(myDate); &#125; return week; &#125; /** * 获取日期的星期。失败返回null。 * @param date 日期 * @return 星期 */ public static Week getWeek(Date date) &#123; Week week = null; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); int weekNumber = calendar.get(Calendar.DAY_OF_WEEK) - 1; switch (weekNumber) &#123; case 0: week = Week.SUNDAY; break; case 1: week = Week.MONDAY; break; case 2: week = Week.TUESDAY; break; case 3: week = Week.WEDNESDAY; break; case 4: week = Week.THURSDAY; break; case 5: week = Week.FRIDAY; break; case 6: week = Week.SATURDAY; break; &#125; return week; &#125; /** * 获取两个日期相差的天数 * @param date 日期字符串 * @param otherDate 另一个日期字符串 * @return 相差天数。如果失败则返回-1 */ public static int getIntervalDays(String date, String otherDate) &#123; return getIntervalDays(StringToDate(date), StringToDate(otherDate)); &#125; /** * @param date 日期 * @param otherDate 另一个日期 * @return 相差天数。如果失败则返回-1 */ public static int getIntervalDays(Date date, Date otherDate) &#123; int num = -1; Date dateTmp = DateUtil.StringToDate(DateUtil.getDate(date), DateStyle.YYYY_MM_DD); Date otherDateTmp = DateUtil.StringToDate(DateUtil.getDate(otherDate), DateStyle.YYYY_MM_DD); if (dateTmp != null &amp;&amp; otherDateTmp != null) &#123; long time = Math.abs(dateTmp.getTime() - otherDateTmp.getTime()); num = (int) (time / (24 * 60 * 60 * 1000)); &#125; return num; &#125;&#125; DateStyle类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itkt.mtravel.hotel.util;public enum DateStyle &#123; YYYY_MM("yyyy-MM", false), YYYY_MM_DD("yyyy-MM-dd", false), YYYY_MM_DD_HH_MM("yyyy-MM-dd HH:mm", false), YYYY_MM_DD_HH_MM_SS("yyyy-MM-dd HH:mm:ss", false), YYYY_MM_EN("yyyy/MM", false), YYYY_MM_DD_EN("yyyy/MM/dd", false), YYYY_MM_DD_HH_MM_EN("yyyy/MM/dd HH:mm", false), YYYY_MM_DD_HH_MM_SS_EN("yyyy/MM/dd HH:mm:ss", false), YYYY_MM_CN("yyyy年MM月", false), YYYY_MM_DD_CN("yyyy年MM月dd日", false), YYYY_MM_DD_HH_MM_CN("yyyy年MM月dd日 HH:mm", false), YYYY_MM_DD_HH_MM_SS_CN("yyyy年MM月dd日 HH:mm:ss", false), HH_MM("HH:mm", true), HH_MM_SS("HH:mm:ss", true), MM_DD("MM-dd", true), MM_DD_HH_MM("MM-dd HH:mm", true), MM_DD_HH_MM_SS("MM-dd HH:mm:ss", true), MM_DD_EN("MM/dd", true), MM_DD_HH_MM_EN("MM/dd HH:mm", true), MM_DD_HH_MM_SS_EN("MM/dd HH:mm:ss", true), MM_DD_CN("MM月dd日", true), MM_DD_HH_MM_CN("MM月dd日 HH:mm", true), MM_DD_HH_MM_SS_CN("MM月dd日 HH:mm:ss", true); private String value; private boolean isShowOnly; DateStyle(String value, boolean isShowOnly) &#123; this.value = value; this.isShowOnly = isShowOnly; &#125; public String getValue() &#123; return value; &#125; public boolean isShowOnly() &#123; return isShowOnly; &#125;&#125; Week类1234567891011121314151617181920212223242526272829303132333435363738394041package com.util;public enum Week &#123; MONDAY("星期一", "Monday", "Mon.", 1), TUESDAY("星期二", "Tuesday", "Tues.", 2), WEDNESDAY("星期三", "Wednesday", "Wed.", 3), THURSDAY("星期四", "Thursday", "Thur.", 4), FRIDAY("星期五", "Friday", "Fri.", 5), SATURDAY("星期六", "Saturday", "Sat.", 6), SUNDAY("星期日", "Sunday", "Sun.", 7); String name_cn; String name_en; String name_enShort; int number; Week(String name_cn, String name_en, String name_enShort, int number) &#123; this.name_cn = name_cn; this.name_en = name_en; this.name_enShort = name_enShort; this.number = number; &#125; public String getChineseName() &#123; return name_cn; &#125; public String getName() &#123; return name_en; &#125; public String getShortName() &#123; return name_enShort; &#125; public int getNumber() &#123; return number; &#125;&#125; 添加日期风格（DateStyle）时需要注意的事项： 不允许复的日期风格。例如：yyyy-MM-dd和yyyy-M-d，表现出的风格是相同的。只有当两个日期风格含有不同的字符时，才会看成是不相同的日期风格。例如：yyyy-MM-dd和yyyy-M-d EEE。当含有重复的日期风格时，可以通过isShowOnly=true来区分，isShowOnly=true表示该风格只是“格式化Date类型的日期”用，而不用作“自动判断String类型的日期”。 日期必须含有完整年份信息。例如：MM-dd。没有年份的话，判断MM-dd是不准确的，因为无法识别出闰年（2-29）。其实MM-dd等类似的风格，我们日常习惯上，将其看作是“今年的M月d日”，而SimpleDateFormat中的parse方法中默认的年份为1970年。 添加顺序为：由简到繁。目的在于2012-12和2012-12-1是等价的，虽然日期风格不一样，但默认会看成是一样的且以DateStyle匹配到的最后一个为主。因此最好将详细的日期风格写在后面。 优化版本三该版本是一次较大的升级，农历相比公历复杂太多（真佩服古人的智慧），虽然有规律，但涉及到的取舍、近似的感念太多，况且本身的概念就已经很多了，我在网上也是查阅了很多的资料，虽然找到一些计算的方法，但都有些计算缺陷，后来才终于找到“寿天星文历”：一个十分精准的万年历。虽然它的功能十分强大，但相对的涉及到的计算也很多，逻辑和思路都相当的复杂了，维护成本很大，有时候项目中并不一定要用到这么强大的农历，因此该版本目前仅提供了农历的一些基本功能，在下一版本中，我会引入“寿天星文历”，以适合更多的大众需求。 源码： DateUtil类新加入代码： 1234567891011121314151617/** * 获取简单农历对象 * @param date 日期字符串 * @return 简单农历对象 */public static SimpleLunarCalendar getSimpleLunarCalendar(String date) &#123; return new SimpleLunarCalendar(DateUtil.StringToDate(date));&#125;/** * 获取简单农历对象 * @param date 日期 * @return 简单农历对象 */public static SimpleLunarCalendar getSimpleLunarCalendar(Date date) &#123; return new SimpleLunarCalendar(date);&#125; SimpleLunarCalendar类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344package com.util;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;public class SimpleLunarCalendar &#123; /** 最小时间1900-1-31*/ private final static long minTimeInMillis = -2206425952001L; /** 最大时间2099-12-31 */ private final static long maxTimeInMillis = 4102416000000L; /** * 农历年数据表(1900-2099年)&lt;br&gt; * &lt;br&gt; * 每个农历年用16进制来表示，解析时转为2进制&lt;br&gt; * 前12位分别表示12个农历月份的大小月，1是大月，0是小月&lt;br&gt; * 最后4位表示闰月，转为十进制后即为闰月值，例如0110，则为闰6月 */ private final static int[] lunarInfo = &#123; 0x4bd8, 0x4ae0, 0xa570, 0x54d5, 0xd260, 0xd950, 0x5554, 0x56af, 0x9ad0, 0x55d2, 0x4ae0, 0xa5b6, 0xa4d0, 0xd250, 0xd295, 0xb54f, 0xd6a0, 0xada2, 0x95b0, 0x4977, 0x497f, 0xa4b0, 0xb4b5, 0x6a50, 0x6d40, 0xab54, 0x2b6f, 0x9570, 0x52f2, 0x4970, 0x6566, 0xd4a0, 0xea50, 0x6a95, 0x5adf, 0x2b60, 0x86e3, 0x92ef, 0xc8d7, 0xc95f, 0xd4a0, 0xd8a6, 0xb55f, 0x56a0, 0xa5b4, 0x25df, 0x92d0, 0xd2b2, 0xa950, 0xb557, 0x6ca0, 0xb550, 0x5355, 0x4daf, 0xa5b0, 0x4573, 0x52bf, 0xa9a8, 0xe950, 0x6aa0, 0xaea6, 0xab50, 0x4b60, 0xaae4, 0xa570, 0x5260, 0xf263, 0xd950, 0x5b57, 0x56a0, 0x96d0, 0x4dd5, 0x4ad0, 0xa4d0, 0xd4d4, 0xd250, 0xd558, 0xb540, 0xb6a0, 0x95a6, 0x95bf, 0x49b0, 0xa974, 0xa4b0, 0xb27a, 0x6a50, 0x6d40, 0xaf46, 0xab60, 0x9570, 0x4af5, 0x4970, 0x64b0, 0x74a3, 0xea50, 0x6b58, 0x5ac0, 0xab60, 0x96d5, 0x92e0, 0xc960, 0xd954, 0xd4a0, 0xda50, 0x7552, 0x56a0, 0xabb7, 0x25d0, 0x92d0, 0xcab5, 0xa950, 0xb4a0, 0xbaa4, 0xad50, 0x55d9, 0x4ba0, 0xa5b0, 0x5176, 0x52bf, 0xa930, 0x7954, 0x6aa0, 0xad50, 0x5b52, 0x4b60, 0xa6e6, 0xa4e0, 0xd260, 0xea65, 0xd530, 0x5aa0, 0x76a3, 0x96d0, 0x4afb, 0x4ad0, 0xa4d0, 0xd0b6, 0xd25f, 0xd520, 0xdd45, 0xb5a0, 0x56d0, 0x55b2, 0x49b0, 0xa577, 0xa4b0, 0xaa50, 0xb255, 0x6d2f, 0xada0, 0x4b63, 0x937f, 0x49f8, 0x4970, 0x64b0, 0x68a6, 0xea5f, 0x6b20, 0xa6c4, 0xaaef, 0x92e0, 0xd2e3, 0xc960, 0xd557, 0xd4a0, 0xda50, 0x5d55, 0x56a0, 0xa6d0, 0x55d4, 0x52d0, 0xa9b8, 0xa950, 0xb4a0, 0xb6a6, 0xad50, 0x55a0, 0xaba4, 0xa5b0, 0x52b0, 0xb273, 0x6930, 0x7337, 0x6aa0, 0xad50, 0x4b55, 0x4b6f, 0xa570, 0x54e4, 0xd260, 0xe968, 0xd520, 0xdaa0, 0x6aa6, 0x56df, 0x4ae0, 0xa9d4, 0xa4d0, 0xd150, 0xf252, 0xd520 &#125;; /** 十二生肖 */ private final static String[] Animals = &#123; "鼠", "牛", "虎", "兔", "龙", "蛇", "马", "羊", "猴", "鸡", "狗", "猪" &#125;; /** 农历中文字符串一 */ private final static String[] lunarString1 = &#123; "零", "一", "二", "三", "四", "五", "六", "七", "八", "九" &#125;; /** 农历中文字符串二 */ private final static String[] lunarString2 = &#123; "初", "十", "廿", "卅", "正", "腊", "冬", "闰" &#125;; /** 农历年 */ private int lunarYear; /** 农历月 */ private int lunarMonth; /** 农历日 */ private int lunarDay; /** 是否是闰月 */ private boolean isLeap; /** 是否是闰年 */ private boolean isLeapYear; /** 某农历月的最大天数 */ private int maxDayInMonth = 29; /** * 通过 TimeInMillis 构建农历信息 * @param TimeInMillis */ public SimpleLunarCalendar(long TimeInMillis) &#123; this.init(TimeInMillis); &#125; /** * 通过 Date 对象构建农历信息 * @param date 指定日期对象 */ public SimpleLunarCalendar(Date date) &#123; if (date == null) date = new Date(); this.init(date.getTime()); &#125; /** * 农历初始化 * @param timeInMillis 时间毫秒数 */ private void init(long timeInMillis) &#123; if (timeInMillis &gt; minTimeInMillis &amp;&amp; timeInMillis &lt; maxTimeInMillis) &#123; // 以农历为1900年正月一日的1900-1-31作为起始日期 Calendar baseDate = new GregorianCalendar(1900, 0, 31); // 距离起始日期间隔的总天数 long offset = (timeInMillis - baseDate.getTimeInMillis()) / 86400000; // 默认农历年为1900年，且由此开始推算农历年份 this.lunarYear = 1900; int daysInLunarYear = SimpleLunarCalendar.getLunarYearDays(this.lunarYear); // 递减每个农历年的总天数，确定农历年份 while (this.lunarYear &lt; 2100 &amp;&amp; offset &gt;= daysInLunarYear) &#123; offset -= daysInLunarYear; daysInLunarYear = SimpleLunarCalendar.getLunarYearDays(++this.lunarYear); &#125; // 获取该农历年的闰月月份 int leapMonth = SimpleLunarCalendar.getLunarLeapMonth(this.lunarYear); // 没有闰月则不是闰年 this.isLeapYear = leapMonth &gt; 0; // 默认农历月为正月，且由此开始推荐农历月 int lunarMonth = 1; // 是否递减农历月 boolean isDecrease = true; boolean isLeap = false; int daysInLunarMonth = 0; // 递减每个农历月的总天数，确定农历月份 while (lunarMonth &lt; 13 &amp;&amp; offset &gt; 0) &#123; if (isLeap &amp;&amp; !isDecrease) &#123; // 该农历年闰月的总天数 daysInLunarMonth = SimpleLunarCalendar.getLunarLeapDays(this.lunarYear); isDecrease = true; &#125; else &#123; // 该农历年正常农历月份的天数 daysInLunarMonth = SimpleLunarCalendar.getLunarMonthDays(this.lunarYear, lunarMonth); &#125; if (offset &lt; daysInLunarMonth) &#123; break; &#125; offset -= daysInLunarMonth; // 如果农历月是闰月，则不递增农历月份 if (leapMonth == lunarMonth &amp;&amp; isLeap == false) &#123; isDecrease = false; isLeap = true; &#125; else &#123; lunarMonth++; &#125; &#125; // 如果daysInLunarMonth为0则说明默认农历月即为返回的农历月 this.maxDayInMonth = daysInLunarMonth != 0 ? daysInLunarMonth : SimpleLunarCalendar.getLunarMonthDays(this.lunarYear, lunarMonth); this.lunarMonth = lunarMonth; this.isLeap = (lunarMonth == leapMonth &amp;&amp; isLeap); this.lunarDay = (int) offset + 1; &#125; &#125; /** * 获取某农历年的总天数 * @param lunarYear 农历年份 * @return 该农历年的总天数 */ private static int getLunarYearDays(int lunarYear) &#123; // 按小月计算,农历年最少有12 * 29 = 348天 int daysInLunarYear = 348; // 遍历前12位 for (int i = 0x8000; i &gt; 0x8; i &gt;&gt;= 1) &#123; // 每个大月累加一天 daysInLunarYear += ((SimpleLunarCalendar.lunarInfo[lunarYear - 1900] &amp; i) != 0) ? 1 : 0; &#125; // 加上闰月天数 daysInLunarYear += SimpleLunarCalendar.getLunarLeapDays(lunarYear); return daysInLunarYear; &#125; /** * 获取某农历年闰月的总天数 * @param lunarYear 农历年份 * @return 该农历年闰月的总天数，没有闰月返回0 */ private static int getLunarLeapDays(int lunarYear) &#123; // 下一年最后4bit为1111,返回30(大月) // 下一年最后4bit不为1111,返回29(小月) // 若该年没有闰月,返回0 return SimpleLunarCalendar.getLunarLeapMonth(lunarYear) &gt; 0 ? ((SimpleLunarCalendar.lunarInfo[lunarYear - 1899] &amp; 0xf) == 0xf ? 30 : 29) : 0; &#125; /** * 获取某农历年闰月月份 * @param lunarYear 农历年份 * @return 该农历年闰月的月份，没有闰月返回0 */ private static int getLunarLeapMonth(int lunarYear) &#123; // 匹配后4位 int leapMonth = SimpleLunarCalendar.lunarInfo[lunarYear - 1900] &amp; 0xf; // 若最后4位全为1或全为0,表示没闰 leapMonth = (leapMonth == 0xf ? 0 : leapMonth); return leapMonth; &#125; /** * 获取某农历年某农历月份的总天数 * @param lunarYear 农历年份 * @param lunarMonth 农历月份 * @return 该农历年该农历月的总天数 */ private static int getLunarMonthDays(int lunarYear, int lunarMonth) &#123; // 匹配前12位代表的相应农历月份的大小月，大月30天，小月29天 int daysInLunarMonth = ((SimpleLunarCalendar.lunarInfo[lunarYear - 1900] &amp; (0x10000 &gt;&gt; lunarMonth)) != 0) ? 30 : 29; return daysInLunarMonth; &#125; /** * 返回指定数字的农历年份表示字符串 * @param lunarYear 农历年份(数字,0为甲子) * @return 农历年份字符串 */ private static String getLunarYearString(int lunarYear) &#123; String lunarYearString = ""; String year = String.valueOf(lunarYear); for (int i = 0; i &lt; year.length(); i++) &#123; char yearChar = year.charAt(i); int index = Integer.parseInt(String.valueOf(yearChar)); lunarYearString += lunarString1[index]; &#125; return lunarYearString; &#125; /** * 返回指定数字的农历月份表示字符串 * @param lunarMonth 农历月份(数字) * @return 农历月份字符串 (例:正) */ private static String getLunarMonthString(int lunarMonth) &#123; String lunarMonthString = ""; if (lunarMonth == 1) &#123; lunarMonthString = SimpleLunarCalendar.lunarString2[4]; &#125; else &#123; if (lunarMonth &gt; 9) lunarMonthString += SimpleLunarCalendar.lunarString2[1]; if (lunarMonth % 10 &gt; 0) lunarMonthString += SimpleLunarCalendar.lunarString1[lunarMonth % 10]; &#125; return lunarMonthString; &#125; /** * 返回指定数字的农历日表示字符串 * @param lunarDay 农历日(数字) * @return 农历日字符串 (例: 廿一) */ private static String getLunarDayString(int lunarDay) &#123; if (lunarDay &lt; 1 || lunarDay &gt; 30) return ""; int i1 = lunarDay / 10; int i2 = lunarDay % 10; String c1 = SimpleLunarCalendar.lunarString2[i1]; String c2 = SimpleLunarCalendar.lunarString1[i2]; if (lunarDay &lt; 11) c1 = SimpleLunarCalendar.lunarString2[0]; if (i2 == 0) c2 = SimpleLunarCalendar.lunarString2[1]; return c1 + c2; &#125; /** * 取农历年生肖 * @return 农历年生肖(例:龙) */ public String getAnimalString() &#123; if (lunarYear == 0) return null; return SimpleLunarCalendar.Animals[(this.lunarYear - 4) % 12]; &#125; /** * 返回农历日期字符串 * @return 农历日期字符串 */ public String getDayString() &#123; if (lunarDay == 0) return null; return SimpleLunarCalendar.getLunarDayString(this.lunarDay); &#125; /** * 返回农历日期字符串 * @return 农历日期字符串 */ public String getMonthString() &#123; if (lunarMonth == 0) return null; return (this.isLeap() ? "闰" : "") + SimpleLunarCalendar.getLunarMonthString(this.lunarMonth); &#125; /** * 返回农历日期字符串 * @return 农历日期字符串 */ public String getYearString() &#123; if (lunarYear == 0) return null; return SimpleLunarCalendar.getLunarYearString(this.lunarYear); &#125; /** * 返回农历表示字符串 * @return 农历字符串(例:甲子年正月初三) */ public String getDateString() &#123; if (lunarYear == 0) return null; return this.getYearString() + "年" + this.getMonthString() + "月" + this.getDayString() + "日"; &#125; /** * 农历年是否是闰月 * @return 农历年是否是闰月 */ public boolean isLeap() &#123; return isLeap; &#125; /** * 农历年是否是闰年 * @return 农历年是否是闰年 */ public boolean isLeapYear() &#123; return isLeapYear; &#125; /** * 当前农历月是否是大月 * @return 当前农历月是大月 */ public boolean isBigMonth() &#123; return this.getMaxDayInMonth() &gt; 29; &#125; /** * 当前农历月有多少天 * @return 天数 */ public int getMaxDayInMonth() &#123; if (lunarYear == 0) return 0; return this.maxDayInMonth; &#125; /** * 农历日期 * @return 农历日期 */ public int getDay() &#123; return lunarDay; &#125; /** * 农历月份 * @return 农历月份 */ public int getMonth() &#123; return lunarMonth; &#125; /** * 农历年份 * @return 农历年份 */ public int getYear() &#123; return lunarYear; &#125;&#125; 说明：该农历核心算法是从网上寻找而来，但我进行了完善，适用的年份为：1900年——2099年，我去掉了不精准的部分（如天干地支），目前该简单农历只能满足显示阴历信息，适合需要较为简单的用户适用。另外若想支持的年限范围更广，则需要修改lunarInfo（农历年数据表），并做适当的调整（默认农历年）即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate框架技术]]></title>
    <url>%2Fblog%2F37268.html</url>
    <content type="text"><![CDATA[Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。 hibernate框架的搭建Hibernate框架的概述 Hibernate框架的概述 Hibernate称为 Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架 记住：Hibernate是一个持久层的ORM框架！ 什么是ORM（对象关系映射） ORM映射：Object Relational Mapping O：面向对象领域的Object（JavaBean对象） R：关系数据库领域的Relational（表的结构） M：映射Mapping（XML的配置文件） 简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录 Hibernate优点 优点 Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作 Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 技术分析之Hibernate框架的快速入门第一步：下载Hibernate5的运行环境 下载相应的jar包等 http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download 解压后对目录结构有一定的了解 第二步：创建表结构 建表语句如下 123456789101112131415Create database hibernate_day01; Use hibernate_day01; CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_user_id` bigint(32) DEFAULT NULL COMMENT '负责人id', `cust_create_id` bigint(32) DEFAULT NULL COMMENT '创建人id', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_linkman` varchar(64) DEFAULT NULL COMMENT '联系人', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 第三步：搭建Hibernate的开发环境 创建WEB工程，引入Hibernate开发所需要的jar包 MySQL的驱动jar包 Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包） 日志jar包（资料/jar包/log4j/所有jar包） 第四步：编写JavaBean实体类 Customer类的代码如下： 12345678910111213public class Customer &#123; private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; // 省略get和set方法 &#125; 第五步：创建类与表结构的映射 在JavaBean所在的包下创建映射的配置文件 默认的命名规则为：实体类名.hbm.xml 在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束） 123&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; 如果不能上网，编写配置文件是没有提示的，需要自己来配置 先复制http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd –&gt; window –&gt; preferences –&gt; 搜索xml –&gt; 选择xml catalog –&gt; 点击add –&gt; 现在URI –&gt; 粘贴复制的地址 –&gt; 选择location，选择本地的DTD的路径 编写映射的配置文件 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.xujingyang.hibernate.Customer" table="cst_customer"&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="cust_name" column="cust_name"&gt;&lt;/property&gt; &lt;property name="cust_user_id" column="cust_user_id"&gt;&lt;/property&gt; &lt;property name="cust_create_id" column="cust_create_id"&gt;&lt;/property&gt; &lt;property name="cust_source" column="cust_source"&gt;&lt;/property&gt; &lt;property name="cust_industry" column="cust_industry"&gt;&lt;/property&gt; &lt;property name="cust_level" column="cust_level"&gt;&lt;/property&gt; &lt;property name="cust_linkman" column="cust_linkman "&gt;&lt;/property&gt; &lt;property name="cust_phone" column="cust_phone"&gt;&lt;/property&gt; &lt;property name="cust_mobile" column="cust_mobile"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 第六步：编写Hibernate核心的配置文件 在src目录下，创建名称为hibernate.cfg.xml的配置文件 在XML中引入DTD约束 123&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt; 打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） 具体的配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- * 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- * 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- * 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; --&gt; &lt;!-- * 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） * &lt;mapping resource="com/itheima/domain/Customer.hbm.xml"/&gt; --&gt; &lt;mapping resource="com/xujingyang/hibernate/Customer.hbm.xml"/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 回忆：快速入门 下载Hibernate框架的开发包 编写数据库和表结构 创建WEB的项目，导入了开发的jar包 MySQL驱动包、Hibernate开发的必须要有的jar包、日志的jar包 编写JavaBean，以后不使用基本数据类型，使用包装类 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签 编写hibernate的核心的配置文件，里面的内容是固定的 编写代码，使用的类和方法 第七步：编写Hibernate入门代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241import java.util.List ;import org.hibernate.Query ;import org.hibernate.SQLQuery ;import org.hibernate.Session ;import org.hibernate.SessionFactory ;import org.hibernate.Transaction ;import org.hibernate.cfg.Configuration ;import org.junit.Test ;import com.xujingyang.hibernate.Customer ;import com.xujingyang.utils.HibernateUtil ;public class TestHibernate &#123; @Test public void testAddofUtils() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Customer c = new Customer() ; c.setCust_name("hehe") ; session.save(c) ; transaction.commit() ; session.close() ; &#125; /** * 添加数据 */ @Test public void testSave() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 开启事物 Transaction transaction = session.beginTransaction() ; // 编写操作代码 Customer c = new Customer() ; c.setCust_name("小明") ; // 保存用户 session.save(c) ; // 提交事物 transaction.commit() ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** * 根据id查询数据,只能查询一条 */ @Test public void testGet() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 编写操作代码 Customer customer = session.get(Customer.class, 94L) ; System.out.println(customer) ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** * 更新数据 */ @Test public void testUpdate() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 开启事物 Transaction transaction = session.beginTransaction() ; // 编写操作代码 Customer c = session.get(Customer.class, 94L) ; c.setCust_mobile("12324343545") ; session.update(c) ; // 提交事物 transaction.commit() ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** *更新或添加,存在就更新,不存在就添加 */ @Test public void testSaveOrUpdate() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 开启事物 Transaction transaction = session.beginTransaction() ; // 编写操作代码 // Customer c=session.get(Customer.class, 94L); Customer c = new Customer() ; c.setCust_name("小红2") ; c.setCust_mobile("22324343545") ; session.saveOrUpdate(c) ; // 提交事物 transaction.commit() ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** * 删除数据 */ @Test public void testDel() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 开启事物 Transaction transaction = session.beginTransaction() ; // 编写操作代码 Customer c = session.get(Customer.class, 94L) ; session.delete(c) ; // 提交事物 transaction.commit() ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** * 查询多条数据 */ @Test public void testGetList() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 按sql语句查找,并制定类型 SQLQuery sqlQuery = session.createSQLQuery("select * from cst_customer").addEntity( Customer.class) ; List&lt;Customer&gt; list = sqlQuery.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; // 释放资源 session.close() ; sessionFactory.close() ; &#125; /** *所有数据 */ @Test public void testGetAllList() &#123; // 加载配置文件 Configuration config = new Configuration().configure() ; // 创建sessionFactory对象 SessionFactory sessionFactory = config.buildSessionFactory() ; // 创建session对象 Session session = sessionFactory.openSession() ; // 按sql语句查找,并制定类型 Query query = session.createQuery("from Customer") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; // Customer c=session.get(Customer.class, 94L); Customer c = new Customer() ; c.setCust_name("小红2") ; c.setCust_mobile("22324343545") ; session.saveOrUpdate(c) ; // 释放资源 session.close() ; sessionFactory.close() ; &#125; &#125; 第八步：编写Hibernate的SessionFactory工具类1234567891011121314151617package com.xujingyang.utils ;import org.hibernate.Session ;import org.hibernate.SessionFactory ;import org.hibernate.cfg.Configuration ;public class HibernateUtil &#123; private static SessionFactory sessionFactory = null ; static &#123; sessionFactory = new Configuration().configure().buildSessionFactory() ; &#125; public static Session getSession() &#123; return sessionFactory.openSession() ; &#125;&#125; 技术分析之：Hibernate常用的配置文件Hibernate配置文件之映射配置文件 映射文件，即Stu.hbm.xml的配置文件 标签 – 用来将类与数据库表建立映射关系 name – 类的全路径 table – 表名.(类名与表名一致,那么table属性也可以省略) catalog – 数据库的名称，基本上都会省略不写 标签 – 用来将类中的属性与表中的主键建立映射，id标签就是用来配置主键的。 name – 类中属性名 column – 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) length – 字段的程度，如果数据库已经创建好了，那么length可以不写。如果没有创建好，生成表结构时，length最好指定。 – 用来将类中的普通属性与表中的字段建立映射. name – 类中属性名 column – 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) length – 数据长度 type – 数据类型（一般都不需要编写，如果写需要按着规则来编写） Hibernate的数据类型 type=”string” Java的数据类型 type=”java.lang.String” 数据库字段的数据类型 Hibernate配置文件之核心配置文件 核心配置文件的两种方式 第一种方式是属性文件的形式，即properties的配置文件 hibernate.properties hibernate.connection.driver_class=com.mysql.jdbc.Driver 缺点 不能加载映射的配置文件，需要手动编写代码去加载 第二种方式是XML文件的形式，开发基本都会选择这种方式 hibernate.cfg.xml com.mysql.jdbc.Driver 优点 格式比较清晰 编写有提示 可以在该配置文件中加载映射的配置文件（最主要的） 关于hibernate.cfg.xml的配置文件方式 必须有的配置 数据库连接信息: hibernate.connection.driver_class – 连接数据库驱动程序 hibernate.connection.url – 连接数据库URL hibernate.connection.username – 数据库用户名 hibernate.connection.password – 数据库密码 方言: hibernate.dialect – 操作数据库方言 可选的配置 hibernate.show_sql – 显示SQL hibernate.format_sql – 格式化SQL hibernate.hbm2ddl.auto – 通过映射转成DDL语句 create – 每次都会创建一个新的表.—测试的时候 create-drop – 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.—测试的时候 update – 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构. validate – 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错. 加载映射 如果XML方式： 技术分析之Hibernate常用的接口和类Configuration类和作用 Configuration类 Configuration对象用于配置并且启动Hibernate。 Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。 简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。 Configuration类的其他应用（了解） 加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。 如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以假装配置文件 但是需要自己手动加载映射文件 例如：config.addResource(“cn/itcast/domain/Student.hbm.xml”); 如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件 SessionFactory：重要 是工厂类，是生成Session对象的工厂类 SessionFactory类的特点 由Configuration通过加载配置文件创建该对象。 SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。 预定义SQL语句 使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句 常见的SQL语句是增删改查（通过主键来查询） 这样做的目的是效率更高 一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。 SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。 SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。 SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 总结 一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。 Session接口 概述 Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象 Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心 Session是线程不安全的 所有持久化对象必须在 session 的管理下才可以进行持久化操作 Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处 持久化类与 Session 关联起来后就具有了持久化的能力 特点 不是线程安全的。应避免多个线程使用同一个Session实例 Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例 Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存 常用的方法 save(obj) delete(obj) get(Class,id) update(obj) saveOrUpdate(obj) – 保存或者修改（如果没有数据，保存数据。如果有，修改数据） createQuery() – HQL语句的查询的方式 Transaction接口 Transaction是事务的接口 常用的方法 commit() – 提交事务 rollback() – 回滚事务 特点 Hibernate框架默认情况下事务不自动提交.需要手动提交事务 如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务 Hibernate特点 Hibernate持久化对象的状态 Hibernate的一级缓存 Hibernate操作持久化对象的方法 Hibernate的基本查询 Hibernate的持久化类什么是持久化类 持久化类:就是一个Java类（咱们编写的JavaBean），这个Java类与表建立了映射关系就可以成为是持久化类。 持久化类 = JavaBean + xxx.hbm.xml 持久化类的编写规则 提供一个无参数 public访问控制符的构造器 – 底层需要进行反射. 提供一个标识属性，映射数据表主键字段 – 唯一标识OID.数据库中通过主键.Java对象通过地址确定对象.持久化类通过唯一标识OID确定记录 所有属性提供public访问控制符的 set或者get 方法 标识属性应尽量使用基本数据类型的包装类型 区分自然主键和代理主键 创建表的时候 自然主键:对象本身的一个属性.创建一个人员表,每个人都有一个身份证号.(唯一的)使用身份证号作为表的主键.自然主键.（开发中不会使用这种方式） 代理主键:不是对象本身的一个属性.创建一个人员表,为每个人员单独创建一个字段.用这个字段作为主键.代理主键.（开发中推荐使用这种方式） 创建表的时候尽量使用代理主键创建表 主键的生成策略 increment:适用于short,int,long作为主键.不是使用的数据库自动增长机制. Hibernate中提供的一种增长机制. 先进行查询 :select max(id) from user; 再进行插入 :获得最大值+1作为新的记录的主键. 问题:不能在集群环境下或者有并发访问的情况下使用. identity:适用于short,int,long作为主键。但是这个必须使用在有自动增长数据库中.采用的是数据库底层的自动增长机制. 底层使用的是数据库的自动增长(auto_increment).像Oracle数据库没有自动增长. sequence:适用于short,int,long作为主键.底层使用的是序列的增长方式. Oracle数据库底层没有自动增长,想自动增长需要使用序列. uuid:适用于char,varchar类型的作为主键. 使用随机的字符串作为主键. native:本地策略.根据底层的数据库不同,自动选择适用于该种数据库的生成策略.(short,int,long) 如果底层使用的MySQL数据库:相当于identity. 如果底层使用Oracle数据库:相当于sequence. assigned:主键的生成不用Hibernate管理了.必须手动设置主键. Hibernate持久化对象的状态持久化对象的状态 Hibernate的持久化类 持久化类:Java类与数据库的某个表建立了映射关系.这个类就称为是持久化类. 持久化类 = Java类 + hbm的配置文件 Hibernate的持久化类的状态 Hibernate为了管理持久化类：将持久化类分成了三个状态 瞬时态:Transient Object 没有持久化标识OID, 没有被纳入到Session对象的管理. 持久态:Persistent Object 有持久化标识OID,已经被纳入到Session对象的管理. 脱管态:Detached Object 有持久化标识OID,没有被纳入到Session对象的管理.Hibernate持久化对象的状态的转换 瞬时态 – 没有持久化标识OID, 没有被纳入到Session对象的管理 获得瞬时态的对象 User user = new User() 瞬时态对象转换持久态 save()/saveOrUpdate(); 瞬时态对象转换成脱管态 user.setId(1) 持久态 – 有持久化标识OID,已经被纳入到Session对象的管理 获得持久态的对象 get()/load(); 持久态转换成瞬时态对象 delete(); — 比较有争议的，进入特殊的状态(删除态:Hibernate中不建议使用的) 持久态对象转成脱管态对象 session的close()/evict()/clear(); 脱管态 – 有持久化标识OID,没有被纳入到Session对象的管理 获得托管态对象:不建议直接获得脱管态的对象. User user = new User(); user.setId(1); 脱管态对象转换成持久态对象 update();/saveOrUpdate()/lock(); 脱管态对象转换成瞬时态对象 user.setId(null); 注意：持久态对象有自动更新数据库的能力!!! Hibernate的一级缓存Session对象的一级缓存（重点） 什么是缓存？ 其实就是一块内存空间,将数据源（数据库或者文件）中的数据存放到缓存中.再次获取的时候 ,直接从缓存中获取.可以提升程序的性能！ Hibernate框架提供了两种缓存 一级缓存 – 自带的不可卸载的.一级缓存的生命周期与session一致.一级缓存称为session级别的缓存. 二级缓存 – 默认没有开启，需要手动配置才可以使用的.二级缓存可以在多个session中共享数据,二级缓存称为是sessionFactory级别的缓存. Session对象的缓存概述 Session接口中,有一系列的java的集合,这些java集合构成了Session级别的缓存(一级缓存).将对象存入到一级缓存中,session没有结束生命周期,那么对象在session中存放着 内存中包含Session实例 –&gt; Session的缓存（一些集合） –&gt; 集合中包含的是缓存对象！ 证明一级缓存的存在，编写查询的代码即可证明 在同一个Session对象中两次查询，可以证明使用了缓存 Hibernate框架是如何做到数据发生变化时进行同步操作的呢？ 使用get方法查询User对象 然后设置User对象的一个属性，注意：没有做update操作。发现，数据库中的记录也改变了。 利用快照机制来完成的（SnapShot） 控制Session的一级缓存（了解） 学习Session接口中与一级缓存相关的方法 Session.clear() – 清空缓存。 Session.evict(Object entity) – 从一级缓存中清除指定的实体对象。 Session.flush() – 刷出缓存Hibernate中的事务与并发事务相关的概念 什么是事务 事务就是逻辑上的一组操作，组成事务的各个执行单元，操作要么全都成功，要么全都失败. 转账的例子：冠希给美美转钱，扣钱，加钱。两个操作组成了一个事情！ 事务的特性 原子性 – 事务不可分割. 一致性 – 事务执行的前后数据的完整性保持一致. 隔离性 – 一个事务执行的过程中,不应该受到其他的事务的干扰. 持久性 – 事务一旦提交,数据就永久保持到数据库中. 如果不考虑隔离性:引发一些读的问题 脏读 – 一个事务读到了另一个事务未提交的数据. 不可重复读 – 一个事务读到了另一个事务已经提交的update数据,导致多次查询结果不一致. 虚读 – 一个事务读到了另一个事务已经提交的insert数据,导致多次查询结构不一致. 通过设置数据库的隔离级别来解决上述读的问题 未提交读:以上的读的问题都有可能发生. 已提交读:避免脏读,但是不可重复读，虚读都有可能发生. 可重复读:避免脏读，不可重复读.但是虚读是有可能发生. 串行化:以上读的情况都可以避免. 如果想在Hibernate的框架中来设置隔离级别，需要在hibernate.cfg.xml的配置文件中通过标签来配置 通过：hibernate.connection.isolation = 4 来配置 取值 1—Read uncommitted isolation 2—Read committed isolation 4—Repeatable read isolation 8—Serializable isolation丢失更新的问题 如果不考虑隔离性，也会产生写入数据的问题，这一类的问题叫丢失更新的问题。 例如：两个事务同时对某一条记录做修改，就会引发丢失更新的问题。 A事务和B事务同时获取到一条数据，同时再做修改 如果A事务修改完成后，提交了事务 B事务修改完成后，不管是提交还是回滚，如果不做处理，都会对数据产生影响 解决方案有两种 悲观锁 采用的是数据库提供的一种锁机制，如果采用做了这种机制，在SQL语句的后面添加 for update 子句 当A事务在操作该条记录时，会把该条记录锁起来，其他事务是不能操作这条记录的。 只有当A事务提交后，锁释放了，其他事务才能操作该条记录 乐观锁 采用版本号的机制来解决的。会给表结构添加一个字段version=0，默认值是0 当A事务在操作完该条记录，提交事务时，会先检查版本号，如果发生版本号的值相同时，才可以提交事务。同时会更新版本号version=1. 当B事务操作完该条记录时，提交事务时，会先检查版本号，如果发现版本不同时，程序会出现错误。 使用Hibernate框架解决丢失更新的问题 悲观锁 使用session.get(Customer.class, 1,LockMode.UPGRADE); 方法 乐观锁 1.在对应的JavaBean中添加一个属性，名称可以是任意的。例如：private Integer version; 提供get和set方法 2.在映射的配置文件中，提供标签即可。 绑定本地的Session 之前在讲JavaWEB的事务的时候，需要在业务层使用Connection来开启事务， 一种是通过参数的方式传递下去 另一种是把Connection绑定到ThreadLocal对象中 现在的Hibernate框架中，使用session对象开启事务，所以需要来传递session对象，框架提供了ThreadLocal的方式 需要在hibernate.cfg.xml的配置文件中提供配置 1&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; * 重新HibernateUtil的工具类，使用SessionFactory的getCurrentSession()方法，获取当前的Session对象。并且该Session对象不用手动关闭，线程结束了，会自动关闭。 123public static Session getCurrentSession()&#123; return factory.getCurrentSession(); &#125; * 注意：想使用getCurrentSession()方法，必须要先配置才能使用。 Hibernate框架的查询方式Query查询接口 具体的查询代码如下 1234567891011121314151617// 1.查询所有记录 Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list = query.list(); System.out.println(list); // 2.条件查询: Query query = session.createQuery("from Customer where name = ?"); query.setString(0, "李健"); List&lt;Customer&gt; list = query.list(); System.out.println(list); // 3.条件查询: Query query = session.createQuery("from Customer where name = :aaa and age = :bbb"); query.setString("aaa", "李健"); query.setInteger("bbb", 38); List&lt;Customer&gt; list = query.list(); System.out.println(list); Criteria查询接口（做条件查询非常合适） 具体的查询代码如下 1234567891011121314151617// 1.查询所有记录 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); // 2.条件查询 Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq("name", "李健")); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); // 3.条件查询 Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq("name", "李健")); criteria.add(Restrictions.eq("age", 38)); List&lt;Customer&gt; list = criteria.list(); System.out.println(list); 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package com.xujingyang.hibernate ;import java.util.List ;import org.hibernate.Criteria ;import org.hibernate.Query ;import org.hibernate.Session ;import org.hibernate.Transaction ;import org.hibernate.criterion.Criterion ;import org.hibernate.criterion.Restrictions ;import org.junit.Test ;import com.xujingyang.domain.User ;import com.xujingyang.utils.HibernateUtil ;public class Test1 &#123; @Test public void testSave1() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; User user = session.get(User.class, 1) ; user.setName("小明") ; user.setAge(18) ; session.update(user) ; // session.clear();//清除缓存 // session.evict(user);//从一级缓存中删除指定的对象 // session.flush();//输出缓存 transaction.commit() ; &#125; @Test public void testSave2() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; User user = session.get(User.class, 1) ; user.setName("小明") ; user.setAge(11) ; session.update(user) ; transaction.commit() ; &#125; @Test public void testSave3() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; User user = session.get(User.class, 1) ; user.setName("小明") ; user.setMoney(12) ; session.update(user) ; User u = new User() ; u.setName("小红") ; u.setMoney(12) ; session.saveOrUpdate(u) ; transaction.commit() ; &#125; /** * 演示事务 */ @Test public void testSave4() &#123; Session session = null ; Transaction transaction = null ; try &#123; session = HibernateUtil.getThreadLocalSession() ; transaction = session.beginTransaction() ; add1() ; // int i = 1 / 0 ; add2() ; transaction.commit() ; &#125; catch (Exception e) &#123; e.printStackTrace() ; transaction.rollback() ; &#125; &#125; public void add1() &#123; Session session = HibernateUtil.getThreadLocalSession() ; User user = session.get(User.class, 1) ; user.setMoney(0) ; session.update(user) ; &#125; public void add2() &#123; Session session = HibernateUtil.getThreadLocalSession() ; User u = session.get(User.class, 2) ; u.setName("小红") ; u.setMoney(24) ; &#125; /** * HQL按条件查询 */ @Test public void testQuery1() &#123; Session session = HibernateUtil.getSession() ; Query query = session.createQuery("from User where name=?") ; query.setString(0, "小明") ; List list = query.list() ; for (Object object : list) &#123; System.out.println(object) ; &#125; &#125; /** * HQL按条件查询 */ @Test public void testQuery2() &#123; Session session = HibernateUtil.getSession() ; Query query = session.createQuery("from User where name=:name") ; query.setString("name", "小明") ; List list = query.list() ; for (Object object : list) &#123; System.out.println(object) ; &#125; &#125; @Test public void testQuery3() &#123; Session session = HibernateUtil.getSession() ; Criteria criteria = session.createCriteria(User.class) ; List list = criteria.list() ; for (Object object : list) &#123; System.out.println(object) ; &#125; &#125; @Test public void testQuery4() &#123; Session session = HibernateUtil.getSession() ; Criteria criteria = session.createCriteria(User.class) ; criteria.add(Restrictions.gt("money", 0)) ; List list = criteria.list() ; for (Object object : list) &#123; System.out.println(object) ; &#125; &#125;&#125; hibernate之关联关系映射案例：完成CRM的联系人的保存操作需求分析 因为客户和联系人是一对多的关系，在有客户的情况下，完成联系人的添加保存操作技术分析之Hibernate的关联关系映射之一对多映射（重点） 实现过程 JavaWEB中一对多的设计及其建表原则 先导入SQL的建表语句 创建数据库：create database hibernate_03; 编写客户和联系人的JavaBean程序（注意一对多的编写规则） 客户的JavaBean如下 123456789101112131415public class Customer &#123; private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; private Set&lt;Linkman&gt; linkmans = new HashSet&lt;Linkman&gt;(); &#125; * 联系人的JavaBean如下 1234567891011121314public class Linkman &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; private Customer customer; &#125; 编写客户和联系人的映射配置文件（注意一对多的配置编写） 客户的映射配置文件如下 12345678910111213141516171819&lt;class name="com.xujingyang.domain.Customer" table="cst_customer"&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="cust_name" column="cust_name"/&gt; &lt;property name="cust_user_id" column="cust_user_id"/&gt; &lt;property name="cust_create_id" column="cust_create_id"/&gt; &lt;property name="cust_source" column="cust_source"/&gt; &lt;property name="cust_industry" column="cust_industry"/&gt; &lt;property name="cust_level" column="cust_level"/&gt; &lt;property name="cust_linkman" column="cust_linkman"/&gt; &lt;property name="cust_phone" column="cust_phone"/&gt; &lt;property name="cust_mobile" column="cust_mobile"/&gt; &lt;set name="linkmans"&gt; &lt;key column="lkm_cust_id"/&gt; &lt;one-to-many class="com.xujingyang.domain.Linkman"/&gt; &lt;/set&gt; &lt;/class&gt; * 联系人的映射配置文件如下 123456789101112131415&lt;class name="com.xujingyang.domain.Linkman" table="cst_linkman"&gt; &lt;id name="lkm_id" column="lkm_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="lkm_name" column="lkm_name"/&gt; &lt;property name="lkm_gender" column="lkm_gender"/&gt; &lt;property name="lkm_phone" column="lkm_phone"/&gt; &lt;property name="lkm_mobile" column="lkm_mobile"/&gt; &lt;property name="lkm_email" column="lkm_email"/&gt; &lt;property name="lkm_qq" column="lkm_qq"/&gt; &lt;property name="lkm_position" column="lkm_position"/&gt; &lt;property name="lkm_memo" column="lkm_memo"/&gt; &lt;many-to-one name="customer" class="com.xujingyang.domain.Customer" column="lkm_cust_id"/&gt; &lt;/class&gt; 技术分析之保存客户和联系人的数据 进行双向关联进行数据的保存 技术分析之级联保存 测试：如果现在代码只插入其中的一方的数据 如果只保存其中的一方的数据，那么程序会抛出异常。 如果想完成只保存一方的数据，并且把相关联的数据都保存到数据库中，那么需要配置级联！！ 级联保存是方向性 级联保存效果 级联保存：保存一方同时可以把关联的对象也保存到数据库中！！ 使用cascade=”save-update” 技术分析之级联删除 先来给大家在数据库中演示含有外键的删除客户功能，那么SQL语句是会报出错误的 例如：1delete from customers where cid = 1; 如果使用Hibernate框架直接删除客户的时候，测试发现是可以删除的 上述的删除是普通的删除，那么也可以使用级联删除，注意：级联删除也是有方向性的 1* &lt;many-to-one cascade=&quot;delete&quot; /&gt; 技术分析之级联的取值（cascade的取值）和孤儿删除 需要大家掌握的取值如下 none – 不使用级联 save-update – 级联保存或更新 delete – 级联删除 delete-orphan – 孤儿删除.(注意：只能应用在一对多关系) all – 除了delete-orphan的所有情况.（包含save-update delete） all-delete-orphan – 包含了delete-orphan的所有情况.（包含save-update delete delete-orphan） 孤儿删除（孤子删除），只有在一对多的环境下才有孤儿删除 在一对多的关系中,可以将一的一方认为是父方.将多的一方认为是子方.孤儿删除:在解除了父子关系的时候.将子方记录就直接删除。 1* &lt;many-to-one cascade=&quot;delete-orphan&quot; /&gt; 技术分析之让某一方放弃外键的维护，为多对多做准备 先测试双方都维护外键的时候，会产生多余的SQL语句。 想修改客户和联系人的关系，进行双向关联，双方都会维护外键，会产生多余的SQL语句。 产生的原因：session的一级缓存中的快照机制，会让双方都更新数据库，产生了多余的SQL语句。 如果不想产生多余的SQL语句，那么需要一方来放弃外键的维护！ 在标签上配置一个inverse=”true”.true:放弃.false:不放弃.默认值是false 1&lt;inverse=&quot;true&quot;&gt; 技术分析之cascade和inverse的区别 cascade用来级联操作（保存、修改和删除） inverse用来维护外键的 Hibernate的关联关系映射之多对多映射技术分析之多对多的建表原则 JavaWEB的多对多 技术分析之多对多JavaBean的编写 编写用户和角色的JavaBean 用户的JavaBean代码如下 123456789public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); &#125; * 角色的JavaBean代码如下 1234567public class Role &#123; private Long role_id; private String role_name; private String role_memo; private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); &#125; 用户和角色的映射配置文件如下 用户的映射配置文件如下 1234567891011121314&lt;class name="com.xujingyang.domain.User" table="sys_user"&gt; &lt;id name="user_id" column="user_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="user_code" column="user_code"/&gt; &lt;property name="user_name" column="user_name"/&gt; &lt;property name="user_password" column="user_password"/&gt; &lt;property name="user_state" column="user_state"/&gt; &lt;set name="roles" table="sys_user_role"&gt; &lt;key column="user_id"/&gt; &lt;many-to-many class="com.xujingyang.domain.Role" column="role_id"/&gt; &lt;/set&gt; &lt;/class&gt; * 角色的映射配置文件如下 123456789101112&lt;class name="com.xujingyang.domain.Role" table="sys_role"&gt; &lt;id name="role_id" column="role_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="role_name" column="role_name"/&gt; &lt;property name="role_memo" column="role_memo"/&gt; &lt;set name="users" table="sys_user_role"&gt; &lt;key column="role_id"/&gt; &lt;many-to-many class="com.xujingyang.domain.User" column="user_id"/&gt; &lt;/set&gt; &lt;/class&gt; 多对多进行双向关联的时候:必须有一方去放弃外键维护权 技术分析之多对多的级联保存 级联保存 1&lt;set cascade=&quot;save-update&quot;&gt; 级联删除（在多对多中是很少使用的） 级联删除 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.xujingyang.test ;import org.hibernate.Session ;import org.hibernate.Transaction ;import org.junit.Test ;import com.xujingyang.demo.Customer ;import com.xujingyang.demo.LinkMan ;import com.xujingyang.utils.HibernateUtil ;/** * @author oldmonk * @date 2017年4月16日 */public class TestDemo &#123; /** * 双向添加 */ @Test public void Demo1() &#123; Session session = HibernateUtil.getThreadLocalSession() ; Transaction transaction = session.beginTransaction() ; Customer customer = new Customer() ; customer.setCust_name("小明") ; LinkMan lMan1 = new LinkMan() ; lMan1.setLkm_name("小小明1") ; LinkMan lMan2 = new LinkMan() ; lMan2.setLkm_name("小小明2") ; customer.getLinkmans().add(lMan1) ; customer.getLinkmans().add(lMan2) ; lMan1.setCustomer(customer) ; lMan2.setCustomer(customer) ; session.save(customer) ; session.save(lMan1) ; session.save(lMan2) ; transaction.commit() ; &#125; /** * 级联添加, 客户配置中添加cascade="all"此时还维护外建,会执行两次重复的sql语句 , * 添加 inverse="true"时,表明客户表不维护外键,不会重复执行 */ @Test public void Demo2() &#123; Session session = HibernateUtil.getThreadLocalSession() ; Transaction transaction = session.beginTransaction() ; Customer customer = new Customer() ; customer.setCust_name("小明") ; LinkMan lMan1 = new LinkMan() ; lMan1.setLkm_name("小小明1") ; LinkMan lMan2 = new LinkMan() ; lMan2.setLkm_name("小小明2") ; customer.getLinkmans().add(lMan1) ; customer.getLinkmans().add(lMan2) ; session.save(customer) ; transaction.commit() ; &#125; /** * 普通删除,此时会把关联的外建表的列对应的外建置为null * 不添加任何的delete * 删除客户的时候 删除联系人： * 需要在Customer.hbm.xml中set标签上配置cascade="delete" * 删除联系人 同时删除 客户： * 需要在LinkMan.hbm.xml中many-to-one标签上配置cascade="delete" */ @Test public void Demo3() &#123; Session session = HibernateUtil.getThreadLocalSession() ; Transaction transaction = session.beginTransaction() ; Customer customer = session.get(Customer.class, 1L) ; session.delete(customer) ; transaction.commit() ; &#125; /** * 孤儿删除, &lt;set cascade="delete-orphan" /&gt;,跟我解除关系,就把你删了 * 不添加时,只是解除关系,外建置为null */ @Test public void Demo4() &#123; Session session = HibernateUtil.getThreadLocalSession() ; Transaction transaction = session.beginTransaction() ; Customer customer = session.get(Customer.class, 1L) ; LinkMan linkMan = session.get(LinkMan.class, 1L) ; customer.getLinkmans().remove(linkMan) ; transaction.commit() ; &#125;&#125; hibernate之各种查询 Hibernate的查询方式 Hibernate的查询策略 案例：使用Hibernate完成查询所有联系人功能需求分析 完成所有的联系人的查询 技术分析之Hibernate框架的查询方式 唯一标识OID的检索方式 session.get(对象.class,OID) 对象的导航的方式 HQL的检索方式 Hibernate Query Language – Hibernate的查询语言 QBC的检索方式 Query By Criteria – 条件查询 SQL检索方式（了解） 本地的SQL检索 技术分析之HQL的查询方式概述 HQL的介绍 HQL(Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似 在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式 HQL与SQL的关系 HQL 查询语句是面向对象的,Hibernate负责解析HQL查询语句, 然后根据对象-关系映射文件中的映射信息, 把 HQL 查询语句翻译成相应的 SQL 语句. HQL 查询语句中的主体是域模型中的类及类的属性 SQL 查询语句是与关系数据库绑定在一起的. SQL查询语句中的主体是数据库表及表的字段 技术分析之HQL的查询演示 HQL基本的查询格式 支持方法链的编程，即直接调用list()方法 简单的代码如下 1session.createQuery("from Customer").list(); 使用别名的方式 可以使用别名的方式 12session.createQuery("from Customer c").list();session.createQuery("select c from Customer c").list(); 排序查询 排序查询和SQL语句中的排序的语法是一样的 升序 1session.createQuery("from Customer order by cust_id").list(); * 降序 1session.createQuery("from Customer order by cust_id desc").list(); 分页查询 Hibernate框架提供了分页的方法，咱们可以调用方法来完成分页 两个方法如下 setFirstResult(a) – 从哪条记录开始，如果查询是从第一条开启，值是0 setMaxResults(b) – 每页查询的记录条数 演示代码如下 1List&lt;LinkMan&gt; list = session.createQuery("from LinkMan").setFirstResult(0).setMaxResults().list(); 带条件的查询 setParameter(“?号的位置，默认从0开始”,”参数的值”); 不用考虑参数的具体类型 按位置绑定参数的条件查询（指定下标值，默认从0开始） 按名称绑定参数的条件查询（HQL语句中的 ? 号换成 :名称 的方式） 例如代码如下 1234567Query query = session.createQuery("from Linkman where lkm_name like ? order by lkm_id desc"); query.setFirstResult(0).setMaxResults(3); query.setParameter(0, "%熊%"); List&lt;Linkman&gt; list = query.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; HQL的投影查询 投影查询就是想查询某一字段的值或者某几个字段的值 投影查询的案例 如果查询多个字段，例如下面这种方式 1234List&lt;Object[]&gt; list = session.createQuery("select c.cust_name,c.cust_level from Customer c").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; * 如果查询两个字段，也可以把这两个字段封装到对象中 * 先在持久化类中提供对应字段的构造方法 * 使用下面这种HQL语句的方式 1234List&lt;Customer&gt; list = session.createQuery("select new Customer(c.cust_name,c.cust_level) from Customer c").list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; 技术分析之聚合函数查询 获取总的记录数 123456Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery("select count(c) from Customer c").list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 获取某一列数据的和 123456Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery("select sum(c.cust_id) from Customer c").list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 技术分析之QBC检索方式 QBC：Query By Criteria 按条件进行查询 简单查询，使用的是Criteria接口 1234List&lt;Customer&gt; list = session.createCriteria(Customer.class).list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; 排序查询 需要使用addOrder()的方法来设置参数，参数使用org.hibernate.criterion.Order对象 具体代码如下： 12345678910Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc("lkm_id")); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit(); 分页查询 QBC的分页查询也是使用两个方法 setFirstResult(); setMaxResults(); 代码如下; 123456789101112Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc("lkm_id")); criteria.setFirstResult(0); criteria.setMaxResults(3); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit(); 条件查询 （Criterion是查询条件的接口，Restrictions类是Hibernate框架提供的工具类，使用该工具类来设置查询条件） * 条件查询使用Criteria接口的add方法，用来传入条件。 * 使用Restrictions的添加条件的方法，来添加条件，例如： * Restrictions.eq -- 相等 * Restrictions.gt -- 大于号 * Restrictions.ge -- 大于等于 * Restrictions.lt -- 小于 * Restrictions.le -- 小于等于 * Restrictions.between -- 在之间 * Restrictions.like -- 模糊查询 * Restrictions.in -- 范围 * Restrictions.and -- 并且 * Restrictions.or -- 或者 * 测试代码如下 123456789101112Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc("lkm_id")); // 设置查询条件 criteria.add(Restrictions.or(Restrictions.eq("lkm_gender", "男"), Restrictions.gt("lkm_id", 3L))); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit(); 聚合函数查询 （Projection的聚合函数的接口，而Projections是Hibernate提供的工具类，使用该工具类设置聚合函数查询） * 使用QBC的聚合函数查询，需要使用criteria.setProjection()方法 * 具体的代码如下 12345678Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); criteria.setProjection(Projections.rowCount()); List&lt;Number&gt; list = criteria.list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 技术分析之离线条件查询 离线条件查询使用的是DetachedCriteria接口进行查询，离线条件查询对象在创建的时候，不需要使用Session对象，只是在查询的时候使用Session对象即可。 创建离线条件查询对象 1DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); 具体的代码如下 123456789101112Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); // 设置查询条件 criteria.add(Restrictions.eq("lkm_gender", "男")); // 查询数据 List&lt;Linkman&gt; list = criteria.getExecutableCriteria(session).list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit(); 技术分析之SQL查询方式（了解） 基本语法 123456789Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); SQLQuery sqlQuery = session.createSQLQuery("select * from cst_linkman where lkm_gender = ?"); sqlQuery.setParameter(0,"男"); sqlQuery.addEntity(Linkman.class); List&lt;Linkman&gt; list = sqlQuery.list(); System.out.println(list); tr.commit(); 技术分析之HQL多表查询 多表的查询进来使用HQL语句进行查询，HQL语句和SQL语句的查询语法比较类似。 * 内连接查询 * 显示内连接 1select * from customers c inner join orders o on c.cid = o.cno; * 隐式内连接 1select * from customers c,orders o where c.cid = o.cno; * 外连接查询 * 左外连接 1select * from customers c left join orders o on c.cid = o.cno; * 右外连接 1select * from customers c right join orders o on c.cid = o.cno; HQL的多表查询 迫切和非迫切： 非迫切返回结果是Object[] 迫切连接返回的结果是对象，把客户的信息封装到客户的对象中，把订单的信息封装到客户的Set集合中。 内连接查询 内连接使用 inner join ，默认返回的是Object数组 1234567Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Object[]&gt; list = session.createQuery("from Customer c inner join c.linkmans").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tr.commit(); * 迫切内连接:inner join fetch ，返回的是实体对象 12345678Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery("from Customer c inner join fetch c.linkmans").list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) &#123; System.out.println(customer); &#125; tr.commit(); 左外连接查询 左外连接: 封装成List&lt;Object[]&gt; 迫切左外连接 12345678Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery("from Customer c left join fetch c.linkmans").list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) &#123; System.out.println(customer); &#125; tr.commit(); 案例一代码实现 案例二：对查询功能优化需求分析 对Hibernate框架的查询进行优化 技术分析之延迟加载 延迟加载先获取到代理对象，当真正使用到该对象中的属性的时候，才会发送SQL语句，是Hibernate框架提升性能的方式 类级别的延迟加载 Session对象的load方法默认就是延迟加载 1Customer c = session.load(Customer.class, 1L); 没有发送SQL语句，当使用该对象的属性时，才发送SQL语句 * 使类级别的延迟加载失效 * 在&lt;class&gt;标签上配置lazy=”false” 1Hibernate.initialize(Object proxy); 关联级别的延迟加载（查询某个客户，当查看该客户下的所有联系人是是否是延迟加载） 默认是延迟加载 123456Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Customer c = session.get(Customer.class, 1L); System.out.println("============="); System.out.println(c.getLinkmans().size()); tr.commit(); 技术分析之Hibernate框架的查询策略 查询策略： 使用Hibernate查询一个对象的时候，查询其关联对象.应该如何查询.是Hibernate的一种优化手段!!! Hibernate框架的检索策略解决的问题 查询的时机 12Customer c1 = (Customer) session.get(Customer.class, 1); System.out.println(c1.getLinkmans().size()); * lazy属性解决查询的时机的问题，需要配置是否采用延迟加载！！ * 查询的语句形式 1234List&lt;Customer&gt; list = session.createQuery("from Customer").list(); for(Customer c : list)&#123; System.out.println(c.getLinkmans()); &#125; * fetch属性就可以解决查询语句的形式的问题！！ 技术分析之在set标签上配置策略 在标签上使用fetch和lazy属性 fetch的取值 – 控制SQL语句生成的格式 select – 默认值.发送查询语句 join – 连接查询.发送的是一条迫切左外连接!!!配置了join.lazy就失效了 subselect – 子查询.发送一条子查询查询其关联对象.(需要使用list()方法进行测试) lazy的取值 – 查找关联对象的时候是否采用延迟! true – 默认.延迟 false – 不延迟 extra – 及其懒惰 set标签上的默认值是fetch=”select”和lazy=”true” 总结：Hibernate框架都采用了默认值，开发中基本上使用的都是默认值。特殊的情况。 技术分析之在man-to-one标签上配置策略 在标签上使用fetch和lazy属性 fetch的取值 – 控制SQL的格式. select – 默认。发送基本select语句查询 join – 发送迫切左外连接查询 lazy的取值 – 控制加载关联对象是否采用延迟. false – 不采用延迟加载. proxy – 默认值.代理.现在是否采用延迟. 由另一端的上的lazy确定.如果这端的class上的lazy=”true”.proxy的值就是true(延迟加载). 如果class上lazy=”false”.proxy的值就是false(不采用延迟.) 在标签上的默认值是fetch=”select”和proxy 代码实现 TestHQLDemo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package com.xujingyang.test ;import java.util.List ;import org.hibernate.Query ;import org.hibernate.Session ;import org.hibernate.Transaction ;import org.junit.Test ;import com.xujingyang.utils.HibernateUtil ;/** * @author oldmonk * @date 2017年4月19日 */public class TestHQLDemo &#123; /** * 排序查询 */ @Test public void demo1() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer order by cust_id desc") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 检索查询 */ @Test public void demo2() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; // Query query = session.createQuery("from Customer where cust_id=?") ; // query.setLong(0, 2L); Query query = session.createQuery("from Customer where cust_id=2") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 分页查询 */ @Test public void demo3() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer") ; query.setFirstResult(0) ;// 从第几条记录开始 query.setMaxResults(2) ;// 每页显示几条数据 List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 统计查询 */ @Test public void demo4() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("select count(1) from Customer") ; List list = query.list() ; System.out.println(list.get(0)) ; transaction.commit() ; &#125; /** * 投影查询 */ @Test public void demo5() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("select cust_id from Customer") ; List list = query.list() ; for (Object object : list) &#123; System.err.println(object) ; &#125; transaction.commit() ; &#125; /** * 连接查询 */ @Test public void demo6() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer c inner join fetch c.linkmans ") ; List&lt;Object []&gt; list = query.list() ; for (Object [] objects : list) &#123; for (Object object : objects) &#123; System.out.println(object) ; &#125; &#125; transaction.commit() ; &#125; /** * 迫切内连接 */ @Test public void demo7() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer c inner join fetch c.linkmans ") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 外连接 */ @Test public void demo8() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Query query = session.createQuery("from Customer c left join fetch c.linkmans ") ; List&lt;Customer&gt; list = query.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; &#125; TestQBCDemo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.xujingyang.test ;import java.util.List ;import org.hibernate.Criteria ;import org.hibernate.Session ;import org.hibernate.Transaction ;import org.hibernate.criterion.DetachedCriteria ;import org.hibernate.criterion.Order ;import org.hibernate.criterion.Projection ;import org.hibernate.criterion.Projections ;import org.hibernate.criterion.Restrictions ;import org.junit.Test ;import com.xujingyang.utils.HibernateUtil ;/** * @author oldmonk * @date 2017年4月19日 */public class TestQBCDemo &#123; /** * 基本查询 */ @Test public void demo1() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; List&lt;Customer&gt; list = criteria.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 条件查询 */ @Test public void demo2() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; // criteria.add(Restrictions.gt("cust_id", 3L)); criteria.add(Restrictions.between("cust_id", 3L, 4L)) ; List&lt;Customer&gt; list = criteria.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 分页查询 */ @Test public void demo3() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; criteria.setFirstResult(0) ; criteria.setMaxResults(2) ; List&lt;Customer&gt; list = criteria.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 排序查询 */ @Test public void demo4() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; criteria.addOrder(Order.desc("cust_id")) ; List&lt;Customer&gt; list = criteria.list() ; for (Customer customer : list) &#123; System.out.println(customer) ; &#125; transaction.commit() ; &#125; /** * 统计查询 */ @Test public void demo5() &#123; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; Criteria criteria = session.createCriteria(Customer.class) ; // criteria.setProjection(Projections.id()); criteria.setProjection(Projections.sum("cust_id")) ; List list = criteria.list() ; for (Object obj : list) &#123; System.out.println(obj) ; &#125; transaction.commit() ; &#125; /** * 离线条件查询:DetachedCriteria(SSH整合经常使用.). * * 可以脱离session设置参数. */ @Test public void demo6() &#123; DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class) ; detachedCriteria.add(Restrictions.gt("cust_id", 3L)) ; Session session = HibernateUtil.getSession() ; Transaction transaction = session.beginTransaction() ; List list = detachedCriteria.getExecutableCriteria(session).list() ; for (Object obj : list) &#123; System.out.println(obj) ; &#125; transaction.commit() ; &#125; &#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java技术重点回顾]]></title>
    <url>%2Fblog%2F44393.html</url>
    <content type="text"><![CDATA[Java技术重点回顾 JavaI/O Java中和I/O操作相关的内容，I/O也是编程语言的一个基础特性，Java中的I/O分为两种类型，一种是顺序读取，一种是随机读取。 我们先来看顺序读取，有两种方式可以进行顺序读取，一种是InputStream/OutputStream，它是针对字节进行操作的输入输出流；另外一种是Reader/Writer，它是针对字符进行操作的输入输出流。 InputStream的结构 FileInputStream：操作文件，经常和BufferedInputStream一起使用 PipedInputStream：可用于线程间通信 ObjectInputStream：可用于对象序列化 ByteArrayInputStream：用于处理字节数组的输入 LineNumberInputStream：可输出当前行数，并且可以在程序中进行修改 OutputStream的结构PrintStream：提供了类似print和println的接口去输出数据 下面我们来看如何使用Stream的方式来操作输入输出 使用InputStream读取文件1234567891011121314151617181920212223242526使用FileInputStream读取文件信息public static byte[] readFileByFileInputStream(File file) throws IOException&#123; ByteArrayOutputStream output = new ByteArrayOutputStream(); FileInputStream fis = null; try &#123; fis = new FileInputStream(file); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = fis.read(buffer, 0, buffer.length)) != -1) &#123; output.write(buffer, 0, bytesRead); &#125; &#125; catch(Exception ex) &#123; System.out.println("Error occurs during reading " + file.getAbsoluteFile()); &#125; finally &#123; if (fis !=null) fis.close(); if (output !=null) output.close(); &#125; return output.toByteArray();&#125; 使用BufferedInputStream读取文件12345678910111213141516171819202122232425262728public static byte[] readFileByBufferedInputStream(File file) throws Exception&#123; FileInputStream fis = null; BufferedInputStream bis = null; ByteArrayOutputStream output = new ByteArrayOutputStream(); try &#123; fis = new FileInputStream(file); bis = new BufferedInputStream(fis); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = bis.read(buffer, 0, buffer.length)) != -1) &#123; output.write(buffer, 0, bytesRead); &#125; &#125; catch(Exception ex) &#123; System.out.println("Error occurs during reading " + file.getAbsoluteFile()); &#125; finally &#123; if (fis != null) fis.close(); if (bis != null) bis.close(); if (output != null) output.close(); &#125; return output.toByteArray();&#125; 使用OutputStream复制文件1234567891011121314151617181920212223242526public static void copyFileByFileOutputStream(File file) throws IOException&#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(file); fos = new FileOutputStream(file.getName() + ".bak"); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = fis.read(buffer,0,buffer.length)) != -1) &#123; fos.write(buffer, 0, bytesRead); &#125; fos.flush(); &#125; catch(Exception ex) &#123; System.out.println("Error occurs during copying " + file.getAbsoluteFile()); &#125; finally &#123; if (fis != null) fis.close(); if (fos != null) fos.close(); &#125;&#125; 使用BufferedOutputStream复制文件123456789101112131415161718192021222324252627282930313233public static void copyFilebyBufferedOutputStream(File file)throws IOException&#123; FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; try &#123; fis = new FileInputStream(file); bis = new BufferedInputStream(fis); fos = new FileOutputStream(file.getName() + ".bak"); bos = new BufferedOutputStream(fos); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = bis.read(buffer, 0, buffer.length)) != -1) &#123; bos.write(buffer, 0, bytesRead); &#125; bos.flush(); &#125; catch(Exception ex) &#123; System.out.println("Error occurs during copying " + file.getAbsoluteFile()); &#125; finally &#123; if (fis != null) fis.close(); if (bis != null) bis.close(); if (fos != null) fos.close(); if (bos != null) bos.close(); &#125;&#125; 这里的代码对异常的处理非常不完整，稍后我们会给出完整严谨的代码。 Reader的结构这里的Reader基本上和InputStream能够对应上。 Writer的结构下面我们来看一些使用Reader或者Writer的例子 使用Reader读取文件内容 123456789101112131415161718192021222324public static String readFile(String file)throws IOException&#123; BufferedReader br = null; StringBuffer sb = new StringBuffer(); try &#123; br = new BufferedReader(new FileReader(file)); String line = null; while((line = br.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch(Exception ex) &#123; System.out.println("Error occurs during reading " + file); &#125; finally &#123; if (br != null) br.close(); &#125; return sb.toString();&#125; 使用Writer复制文件123456789101112131415161718192021222324public static void copyFile(String file) throws IOException&#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; br = new BufferedReader(new FileReader(file)); bw = new BufferedWriter(new FileWriter(file + ".bak")); String line = null; while((line = br.readLine())!= null) &#123; bw.write(line); &#125; &#125; catch(Exception ex) &#123; System.out.println("Error occurs during copying " + file); &#125; finally &#123; if (br != null) br.close(); if (bw != null) bw.close(); &#125;&#125; 下面我们来看如何对文件进行随机访问，Java中主要使用RandomAccessFile来对文件进行随机操作。 创建一个大小固定的文件1234567public static void createFile(String file, int size) throws IOException&#123; File temp = new File(file); RandomAccessFile raf = new RandomAccessFile(temp, "rw"); raf.setLength(size); raf.close();&#125; 向文件中随机写入数据1234567public static void writeFile(String file, byte[] content, int startPos, int contentLength) throws IOException&#123; RandomAccessFile raf = new RandomAccessFile(new File(file), "rw"); raf.seek(startPos); raf.write(content, 0, contentLength); raf.close();&#125; 接下里，我们来看一些其他的常用操作 移动文件12345678public static boolean moveFile(String sourceFile, String destFile)&#123; File source = new File(sourceFile); if (!source.exists()) throw new RuntimeException("source file does not exist."); File dest = new File(destFile); if (!(new File(dest.getPath()).exists())) new File(dest.getParent()).mkdirs(); return source.renameTo(dest);&#125; 复制文件123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void copyFile(String sourceFile, String destFile) throws IOException&#123; File source = new File(sourceFile); if (!source.exists()) throw new RuntimeException("File does not exist."); if (!source.isFile()) throw new RuntimeException("It is not file."); if (!source.canRead()) throw new RuntimeException("File cound not be read."); File dest = new File(destFile); if (dest.exists()) &#123; if (dest.isDirectory()) throw new RuntimeException("Destination is a folder."); else &#123; dest.delete(); &#125; &#125; else &#123; File parentFolder = new File(dest.getParent()); if (!parentFolder.exists()) parentFolder.mkdirs(); if (!parentFolder.canWrite()) throw new RuntimeException("Destination can not be written."); &#125; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(source); fos = new FileOutputStream(dest); byte[] buffer = new byte[1024]; int bytesRead = 0; while((bytesRead = fis.read(buffer, 0, buffer.length)) != -1) &#123; fos.write(buffer, 0, bytesRead); &#125; fos.flush(); &#125; catch(IOException ex) &#123; System.out.println("Error occurs during copying " + sourceFile); &#125; finally &#123; if (fis != null) fis.close(); if (fos != null) fos.close(); &#125;&#125; 复制文件夹12345678910111213141516171819202122232425262728public static void copyDir(String sourceDir, String destDir) throws IOException&#123; File source = new File(sourceDir); if (!source.exists()) throw new RuntimeException("Source does not exist."); if (!source.canRead()) throw new RuntimeException("Source could not be read."); File dest = new File(destDir); if (!dest.exists()) dest.mkdirs(); File[] arrFiles = source.listFiles(); for(int i = 0; i &lt; arrFiles.length; i++) &#123; if (arrFiles[i].isFile()) &#123; BufferedReader reader = new BufferedReader(new FileReader(arrFiles[i])); BufferedWriter writer = new BufferedWriter(new FileWriter(destDir + "/" + arrFiles[i].getName())); String line = null; while((line = reader.readLine()) != null) writer.write(line); writer.flush(); reader.close(); writer.close(); &#125; else &#123; copyDir(sourceDir + "/" + arrFiles[i].getName(), destDir + "/" + arrFiles[i].getName()); &#125; &#125;&#125; 删除文件夹123456789101112131415161718192021public static void del(String filePath)&#123; File file = new File(filePath); if (file == null || !file.exists()) return; if (file.isFile()) &#123; file.delete(); &#125; else &#123; File[] arrFiles = file.listFiles(); if (arrFiles.length &gt; 0) &#123; for(int i = 0; i &lt; arrFiles.length; i++) &#123; del(arrFiles[i].getAbsolutePath()); &#125; &#125; file.delete(); &#125;&#125; 获取文件夹大小1234567891011121314151617public static long getFolderSize(String dir)&#123; long size = 0; File file = new File(dir); if (!file.exists()) throw new RuntimeException("dir does not exist."); if (file.isFile()) return file.length(); else &#123; String[] arrFileName = file.list(); for (int i = 0; i &lt; arrFileName.length; i++) &#123; size += getFolderSize(dir + "/" + arrFileName[i]); &#125; &#125; return size;&#125; 将大文件切分成多个小文件123456789101112131415161718192021222324252627282930313233343536public static void splitFile(String filePath, long unit) throws IOException&#123; File file = new File(filePath); if (!file.exists()) throw new RuntimeException("file does not exist."); long size = file.length(); if (unit &gt;= size) return; int count = size % unit == 0 ? (int)(size/unit) : (int)(size/unit) + 1; String newFile = null; FileOutputStream fos = null; FileInputStream fis =null; byte[] buffer = new byte[(int)unit]; fis = new FileInputStream(file); long startPos = 0; String countFile = filePath + "_Count"; PrintWriter writer = new PrintWriter(new FileWriter( new File(countFile))); writer.println(filePath + "\t" + size); for (int i = 1; i &lt;= count; i++) &#123; newFile = filePath + "_" + i; startPos = (i - 1) * unit; System.out.println("Creating " + newFile); fos = new FileOutputStream(new File(newFile)); int bytesRead = fis.read(buffer, 0, buffer.length); if (bytesRead != -1) &#123; fos.write(buffer, 0, bytesRead); writer.println(newFile + "\t" + startPos + "\t" + bytesRead); &#125; fos.flush(); fos.close(); System.out.println("StartPos:" + i*unit + "; EndPos:" + (i*unit + bytesRead)); &#125; writer.flush(); writer.close(); fis.close();&#125; 将多个小文件合并成一个大文件1234567891011121314151617181920212223242526public static void linkFiles(String countFile) throws IOException&#123; File file = new File(countFile); if (!file.exists()) throw new RuntimeException("Count file does not exist."); BufferedReader reader = new BufferedReader(new FileReader(file)); String line = reader.readLine(); String newFile = line.split("\t")[0]; long size = Long.parseLong(line.split("\t")[1]); RandomAccessFile raf = new RandomAccessFile(newFile, "rw"); raf.setLength(size); FileInputStream fis = null; byte[] buffer = null; while((line = reader.readLine()) != null) &#123; String[] arrInfo = line.split("\t"); fis = new FileInputStream(new File(arrInfo[0])); buffer = new byte[Integer.parseInt(arrInfo[2])]; long startPos = Long.parseLong(arrInfo[1]); fis.read(buffer, 0, Integer.parseInt(arrInfo[2])); raf.seek(startPos); raf.write(buffer, 0, Integer.parseInt(arrInfo[2])); fis.close(); &#125; raf.close();&#125; 执行外部命令1234567891011121314151617181920212223public static void execExternalCommand(String command, String argument)&#123; Process process = null; try &#123; process = Runtime.getRuntime().exec(command + " " + argument); InputStream is = process.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line = null; while((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (process != null) process.destroy(); &#125;&#125; Java网络通信Java实现网络通信，包括TCP通信、UDP通信、多播以及NIO。 TCP连接TCP的基础是Socket，在TCP连接中，我们会使用ServerSocket和Socket，当客户端和服务器建立连接以后，剩下的基本就是对I/O的控制了。 我们先来看一个简单的TCP通信，它分为客户端和服务器端。 客户端代码如下： 简单的TCP客户端1234567891011121314151617181920212223242526272829303132333435363738import java.net.*;import java.io.*;public class SimpleTcpClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = null; BufferedReader br = null; PrintWriter pw = null; BufferedReader brTemp = null; try &#123; socket = new Socket(InetAddress.getLocalHost(), 5678); br = new BufferedReader(new InputStreamReader(socket.getInputStream())); pw = new PrintWriter(socket.getOutputStream()); brTemp = new BufferedReader(new InputStreamReader(System.in)); while(true) &#123; String line = brTemp.readLine(); pw.println(line); pw.flush(); if (line.equals("end")) break; System.out.println(br.readLine()); &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (socket != null) socket.close(); if (br != null) br.close(); if (brTemp != null) brTemp.close(); if (pw != null) pw.close(); &#125; &#125;&#125; 服务器端代码如下： 简单版本TCP服务器端12345678910111213141516171819202122232425262728293031323334353637import java.net.*;import java.io.*;public class SimpleTcpServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = null; Socket client = null; BufferedReader br = null; PrintWriter pw = null; try &#123; server = new ServerSocket(5678); client = server.accept(); br = new BufferedReader(new InputStreamReader(client.getInputStream())); pw = new PrintWriter(client.getOutputStream()); while(true) &#123; String line = br.readLine(); pw.println("Response:" + line); pw.flush(); if (line.equals("end")) break; &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (server != null) server.close(); if (client != null) client.close(); if (br != null) br.close(); if (pw != null) pw.close(); &#125; &#125;&#125; 这里的服务器的功能非常简单，它接收客户端发来的消息，然后将消息“原封不动”的返回给客户端。当客户端发送“end”时，通信结束。 上面的代码基本上勾勒了TCP通信过程中，客户端和服务器端的主要框架，我们可以发现，上述的代码中，服务器端在任何时刻，都只能处理来自客户端的一个请求，它是串行处理的，不能并行，这和我们印象里的服务器处理方式不太相同，我们可以为服务器添加多线程，当一个客户端的请求进入后，我们就创建一个线程，来处理对应的请求。 改善后的服务器端代码如下： 多线程版本的TCP服务器端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.net.*;import java.io.*;public class SmartTcpServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(5678); while(true) &#123; Socket client = server.accept(); Thread thread = new ServerThread(client); thread.start(); &#125; &#125;&#125;class ServerThread extends Thread&#123; private Socket socket = null; public ServerThread(Socket socket) &#123; this.socket = socket; &#125; public void run() &#123; BufferedReader br = null; PrintWriter pw = null; try &#123; br = new BufferedReader(new InputStreamReader(socket.getInputStream())); pw = new PrintWriter(socket.getOutputStream()); while(true) &#123; String line = br.readLine(); pw.println("Response:" + line); pw.flush(); if (line.equals("end")) break; &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (socket != null) try &#123; socket.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; if (br != null) try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (pw != null) pw.close(); &#125; &#125;&#125; 修改后的服务器端，就可以同时处理来自客户端的多个请求了。 在编程的过程中，我们会有“资源”的概念，例如数据库连接就是一个典型的资源，为了提升性能，我们通常不会直接销毁数据库连接，而是使用数据库连接池的方式来对多个数据库连接进行管理，已实现重用的目的。对于Socket连接来说，它也是一种资源，当我们的程序需要大量的Socket连接时，如果每个连接都需要重新建立，那么将会是一件非常没有效率的做法。 和数据库连接池类似，我们也可以设计TCP连接池，这里的思路是我们用一个数组来维持多个Socket连接，另外一个状态数组来描述每个Socket连接是否正在使用，当程序需要Socket连接时，我们遍历状态数组，取出第一个没被使用的Socket连接，如果所有连接都在使用，抛出异常。这是一种很直观简单的“调度策略”，在很多开源或者商业的框架中（Apache/Tomcat），都会有类似的“资源池”。 TCP连接池的代码如下： 一个简单的TCP连接池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.net.*;import java.io.*;public class TcpConnectionPool &#123; private InetAddress address = null; private int port; private Socket[] arrSockets = null; private boolean[] arrStatus = null; private int count; public TcpConnectionPool(InetAddress address, int port, int count) &#123; this.address = address; this.port = port; this .count = count; arrSockets = new Socket[count]; arrStatus = new boolean[count]; init(); &#125; private void init() &#123; try &#123; for (int i = 0; i &lt; count; i++) &#123; arrSockets[i] = new Socket(address.getHostAddress(), port); arrStatus[i] = false; &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125; public Socket getConnection() &#123; if (arrSockets == null) init(); int i = 0; for(i = 0; i &lt; count; i++) &#123; if (arrStatus[i] == false) &#123; arrStatus[i] = true; break; &#125; &#125; if (i == count) throw new RuntimeException("have no connection availiable for now."); return arrSockets[i]; &#125; public void releaseConnection(Socket socket) &#123; if (arrSockets == null) init(); for (int i = 0; i &lt; count; i++) &#123; if (arrSockets[i] == socket) &#123; arrStatus[i] = false; break; &#125; &#125; &#125; public void reBuild() &#123; init(); &#125; public void destory() &#123; if (arrSockets == null) return; for(int i = 0; i &lt; count; i++) &#123; try &#123; arrSockets[i].close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); continue; &#125; &#125; &#125;&#125; UDP连接UDP是一种和TCP不同的连接方式，它通常应用在对实时性要求很高，对准确定要求不高的场合，例如在线视频。UDP会有“丢包”的情况发生，在TCP中，如果Server没有启动，Client发消息时，会报出异常，但对UDP来说，不会产生任何异常。 UDP通信使用的两个类时DatagramSocket和DatagramPacket，后者存放了通信的内容。 下面是一个简单的UDP通信例子，同TCP一样，也分为Client和Server两部分，Client端代码如下： UDP通信客户端123456789101112131415161718192021222324252627282930import java.net.*;import java.io.*;public class UdpClient &#123; public static void main(String[] args) &#123; try &#123; InetAddress host = InetAddress.getLocalHost(); int port = 5678; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); while(true) &#123; String line = br.readLine(); byte[] message = line.getBytes(); DatagramPacket packet = new DatagramPacket(message, message.length, host, port); DatagramSocket socket = new DatagramSocket(); socket.send(packet); socket.close(); if (line.equals("end")) break; &#125; br.close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; Server端代码如下： UDP通信服务器端1234567891011121314151617181920212223242526272829import java.net.*;import java.io.*;public class UdpServer &#123; public static void main(String[] args) &#123; try &#123; int port = 5678; DatagramSocket dsSocket = new DatagramSocket(port); byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while(true) &#123; dsSocket.receive(packet); String message = new String(buffer, 0, packet.getLength()); System.out.println(packet.getAddress().getHostName() + ":" + message); if (message.equals("end")) break; packet.setLength(buffer.length); &#125; dsSocket.close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; 这里，我们也假设和TCP一样，当Client发出“end”消息时，认为通信结束，但其实这样的设计不是必要的，Client端可以随时断开，并不需要关心Server端状态。 多播（Multicast）多播采用和UDP类似的方式，它会使用D类IP地址和标准的UDP端口号，D类IP地址是指224.0.0.0到239.255.255.255之间的地址，不包括224.0.0.0。 多播会使用到的类是MulticastSocket，它有两个方法需要关注：joinGroup和leaveGroup。 下面是一个多播的例子，Client端代码如下： 多播通信客户端12345678910111213141516171819202122232425262728import java.net.*;import java.io.*;public class MulticastClient &#123; public static void main(String[] args) &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try &#123; InetAddress address = InetAddress.getByName("230.0.0.1"); int port = 5678; while(true) &#123; String line = br.readLine(); byte[] message = line.getBytes(); DatagramPacket packet = new DatagramPacket(message, message.length, address, port); MulticastSocket multicastSocket = new MulticastSocket(); multicastSocket.send(packet); if (line.equals("end")) break; &#125; br.close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; 服务器端代码如下： 多播通信服务器端123456789101112131415161718192021222324252627282930import java.net.*;import java.io.*;public class MulticastServer &#123; public static void main(String[] args) &#123; int port = 5678; try &#123; MulticastSocket multicastSocket = new MulticastSocket(port); InetAddress address = InetAddress.getByName("230.0.0.1"); multicastSocket.joinGroup(address); byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while(true) &#123; multicastSocket.receive(packet); String message = new String(buffer, packet.getLength()); System.out.println(packet.getAddress().getHostName() + ":" + message); if (message.equals("end")) break; packet.setLength(buffer.length); &#125; multicastSocket.close(); &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; NIO（New IO）NIO是JDK1.4引入的一套新的IO API，它在缓冲区管理、网络通信、文件存取以及字符集操作方面有了新的设计。对于网络通信来说，NIO使用了缓冲区和通道的概念。 下面是一个NIO的例子，和我们上面提到的代码风格有很大的不同。 NIO例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.*;import java.nio.*;import java.nio.channels.*;import java.nio.charset.*;import java.net.*;public class NewIOSample &#123; public static void main(String[] args) &#123; String host="127.0.0.1"; int port = 5678; SocketChannel channel = null; try &#123; InetSocketAddress address = new InetSocketAddress(host,port); Charset charset = Charset.forName("UTF-8"); CharsetDecoder decoder = charset.newDecoder(); CharsetEncoder encoder = charset.newEncoder(); ByteBuffer buffer = ByteBuffer.allocate(1024); CharBuffer charBuffer = CharBuffer.allocate(1024); channel = SocketChannel.open(); channel.connect(address); String request = "GET / \r\n\r\n"; channel.write(encoder.encode(CharBuffer.wrap(request))); while((channel.read(buffer)) != -1) &#123; buffer.flip(); decoder.decode(buffer, charBuffer, false); charBuffer.flip(); System.out.println(charBuffer); buffer.clear(); charBuffer.clear(); &#125; &#125; catch(Exception ex) &#123; System.err.println(ex.getMessage()); &#125; finally &#123; if (channel != null) try &#123; channel.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 上述代码会试图访问一个本地的网址，然后将其内容打印出来。 Java多线程多线程是一个复杂的话题，包含了很多内容，文章主要关注线程的基本属性、如何创建线程、线程的状态切换以及线程通信，我们把线程同步的话题留到下一篇文章中。 线程是操作系统运行的基本单位，它被封装在进程中，一个进程可以包含多个线程。即使我们不手动创造线程，进程也会有一个默认的线程在运行。 对于JVM来说，当我们编写一个单线程的程序去运行时，JVM中也是有至少两个线程在运行，一个是我们创建的程序，一个是垃圾回收。 线程基本信息我们可以通过Thread.currentThread()方法获取当前线程的一些信息，并对其进行修改。 我们来看以下代码： 查看并修改当前线程的属性123456789101112131415161718String name = Thread.currentThread().getName(); int priority = Thread.currentThread().getPriority(); String groupName = Thread.currentThread().getThreadGroup().getName(); boolean isDaemon = Thread.currentThread().isDaemon(); System.out.println("Thread Name:" + name); System.out.println("Priority:" + priority); System.out.println("Group Name:" + groupName); System.out.println("IsDaemon:" + isDaemon); Thread.currentThread().setName("Test"); Thread.currentThread().setPriority(Thread.MAX_PRIORITY); name = Thread.currentThread().getName(); priority = Thread.currentThread().getPriority(); groupName = Thread.currentThread().getThreadGroup().getName(); isDaemon = Thread.currentThread().isDaemon(); System.out.println("Thread Name:" + name); System.out.println("Priority:" + priority); 其中列出的属性说明如下： GroupName，每个线程都会默认在一个线程组里，我们也可以显式的创建线程组，一个线程组中也可以包含子线程组，这样线程和线程组，就构成了一个树状结构。 Name，每个线程都会有一个名字，如果不显式指定，那么名字的规则是“Thread-xxx”。 Priority，每个线程都会有自己的优先级，JVM对优先级的处理方式是“抢占式”的。当JVM发现优先级高的线程时，马上运行该线程；对于多个优先级相等的线程，JVM对其进行轮询处理。Java的线程优先级从1到10，默认是5，Thread类定义了2个常量：MIN_PRIORITY和MAX_PRIORITY来表示最高和最低优先级。 我们可以看下面的代码，它定义了两个不同优先级的线程： 线程优先级示例1234567891011121314151617181920212223242526272829public static void priorityTest()&#123; Thread thread1 = new Thread("low") &#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("Thread 1 is running."); &#125; &#125; &#125;; Thread thread2 = new Thread("high") &#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("Thread 2 is running."); &#125; &#125; &#125;; thread1.setPriority(Thread.MIN_PRIORITY); thread2.setPriority(Thread.MAX_PRIORITY); thread1.start(); thread2.start();&#125; 从运行结果可以看出，是高优先级线程运行完成后，低优先级线程才运行。isDaemon，这个属性用来控制父子线程的关系，如果设置为true，当父线程结束后，其下所有子线程也结束，反之，子线程的生命周期不受父线程影响。 我们来看下面的例子： IsDaemon 示例123456789101112131415161718192021222324public static void daemonTest()&#123; Thread thread1 = new Thread("daemon") &#123; public void run() &#123; Thread subThread = new Thread("sub") &#123; public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; System.out.println("Sub Thread Running " + i); &#125; &#125; &#125;; subThread.setDaemon(true); subThread.start(); System.out.println("Main Thread end."); &#125; &#125;; thread1.start();&#125; 上面代码的运行结果，在和删除subThread.setDaemon(true);后对比，可以发现后者运行过程中子线程会完成执行后再结束，而前者中，子线程很快就结束了。 如何创建线程上面的内容，都是演示默认线程中的一些信息，那么应该如何创建线程呢？在Java中，我们有3种方式可以用来创建线程。 Java中的线程要么继承Thread类，要么实现Runnable接口，我们一一道来。 使用内部类来创建线程我们可以使用内部类的方式来创建线程，过程是声明一个Thread类型的变量，并重写run方法。示例代码如下： 123456789101112131415public static void createThreadByNestClass()&#123; Thread thread = new Thread() &#123; public void run() &#123; for (int i =0; i &lt; 5; i++) &#123; System.out.println("Thread " + Thread.currentThread().getName() + " is running."); &#125; System.out.println("Thread " + Thread.currentThread().getName() + " is finished."); &#125; &#125;; thread.start();&#125; 继承Thread以创建线程我们可以从Thread中派生一个类，重写其run方法，这种方式和上面相似。示例代码如下： 123456789101112131415161718class MyThread extends Thread&#123; public void run() &#123; for (int i =0; i &lt; 5; i++) &#123; System.out.println("Thread " + Thread.currentThread().getName() + " is running."); &#125; System.out.println("Thread " + Thread.currentThread().getName() + " is finished."); &#125;&#125;public static void createThreadBySubClass()&#123; MyThread thread = new MyThread(); thread.start();&#125; 实现Runnable接口以创建线程我们可以定义一个类，使其实现Runnable接口，然后将该类的实例作为构建Thread变量构造函数的参数。示例代码如下： 12345678910111213141516171819class MyRunnable implements Runnable&#123; public void run() &#123; for (int i =0; i &lt; 5; i++) &#123; System.out.println("Thread " + Thread.currentThread().getName() + " is running."); &#125; System.out.println("Thread " + Thread.currentThread().getName() + " is finished."); &#125;&#125;public static void createThreadByRunnable()&#123; MyRunnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); thread.start();&#125; 上述3种方式都可以创建线程，而且从示例代码上看，线程执行的功能是一样的，那么这三种创建方式有什么不同呢？ 这涉及到Java中多线程的运行模式，对于Java来说，多线程在运行时，有“多对象多线程”和“单对象多线程”的区别： 多对象多线程，程序在运行过程中创建多个线程对象，每个对象上运行一个线程。 单对象多线程，程序在运行过程中创建一个线程对象，在其上运行多个线程。 显然，从线程同步和调度的角度来看，多对象多线程要简单一些。上述3种线程创建方式，前两种都属于“多对象多线程”，第三种既可以使用“多对象多线程”，也可以使用“单对象单线程”。 我们来看下面的示例代码，里面会用到Object.notify方法，这个方法会唤醒对象上的一个线程；而Object.notifyAll方法，则会唤醒对象上的所有线程。 notify示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class NotifySample &#123; public static void main(String[] args) throws InterruptedException &#123; notifyTest(); notifyTest2(); notifyTest3(); &#125; private static void notifyTest() throws InterruptedException &#123; MyThread[] arrThreads = new MyThread[3]; for (int i = 0; i &lt; arrThreads.length; i++) &#123; arrThreads[i] = new MyThread(); arrThreads[i].id = i; arrThreads[i].setDaemon(true); arrThreads[i].start(); &#125; Thread.sleep(500); for (int i = 0; i &lt; arrThreads.length; i++) &#123; synchronized(arrThreads[i]) &#123; arrThreads[i].notify(); &#125; &#125; &#125; private static void notifyTest2() throws InterruptedException &#123; MyRunner[] arrMyRunners = new MyRunner[3]; Thread[] arrThreads = new Thread[3]; for (int i = 0; i &lt; arrThreads.length; i++) &#123; arrMyRunners[i] = new MyRunner(); arrMyRunners[i].id = i; arrThreads[i] = new Thread(arrMyRunners[i]); arrThreads[i].setDaemon(true); arrThreads[i].start(); &#125; Thread.sleep(500); for (int i = 0; i &lt; arrMyRunners.length; i++) &#123; synchronized(arrMyRunners[i]) &#123; arrMyRunners[i].notify(); &#125; &#125; &#125; private static void notifyTest3() throws InterruptedException &#123; MyRunner runner = new MyRunner(); Thread[] arrThreads = new Thread[3]; for (int i = 0; i &lt; arrThreads.length; i++) &#123; arrThreads[i] = new Thread(runner); arrThreads[i].setDaemon(true); arrThreads[i].start(); &#125; Thread.sleep(500); synchronized(runner) &#123; runner.notifyAll(); &#125; &#125;&#125;class MyThread extends Thread&#123; public int id = 0; public void run() &#123; System.out.println("第" + id + "个线程准备休眠5分钟。"); try &#123; synchronized(this) &#123; this.wait(5*60*1000); &#125; &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println("第" + id + "个线程被唤醒。"); &#125;&#125;class MyRunner implements Runnable&#123; public int id = 0; public void run() &#123; System.out.println("第" + id + "个线程准备休眠5分钟。"); try &#123; synchronized(this) &#123; this.wait(5*60*1000); &#125; &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println("第" + id + "个线程被唤醒。"); &#125; &#125; 示例代码中，notifyTest()和notifyTest2()是“多对象多线程”，尽管notifyTest2()中的线程实现了Runnable接口，但是它里面定义Thread数组时，每个元素都使用了一个新的Runnable实例。notifyTest3()属于“单对象多线程”，因为我们只定义了一个Runnable实例，所有的线程都会使用这个实例。 notifyAll方法适用于“单对象多线程”的情景，因为notify方法只会随机唤醒对象上的一个线程。 线程的状态切换对于线程来讲，从我们创建它一直到线程运行结束，在这个过程中，线程的状态可能是这样的： 创建：已经有Thread实例了， 但是CPU还有为其分配资源和时间片。 就绪：线程已经获得了运行所需的所有资源，只等CPU进行时间调度。 运行：线程位于当前CPU时间片中，正在执行相关逻辑。 休眠：一般是调用Thread.sleep后的状态，这时线程依然持有运行所需的各种资源，但是不会被CPU调度。 挂起：一般是调用Thread.suspend后的状态，和休眠类似，CPU不会调度该线程，不同的是，这种状态下，线程会释放所有资源。 死亡：线程运行结束或者调用了Thread.stop方法。 下面我们来演示如何进行线程状态切换，首先我们会用到下面方法： Thread()或者Thread(Runnable)：构造线程。 Thread.start：启动线程。 Thread.sleep：将线程切换至休眠状态。 Thread.interrupt：中断线程的执行。 Thread.join：等待某线程结束。 Thread.yield：剥夺线程在CPU上的执行时间片，等待下一次调度。 Object.wait：将Object上所有线程锁定，直到notify方法才继续运行。 Object.notify：随机唤醒Object上的1个线程。 Object.notifyAll：唤醒Object上的所有线程。 下面，就是演示时间啦！！！ 线程等待与唤醒这里主要使用Object.wait和Object.notify方法，请参见上面的notify实例。需要注意的是，wait和notify都必须针对同一个对象，当我们使用实现Runnable接口的方式来创建线程时，应该是在Runnable对象而非Thread对象上使用这两个方法。 线程的休眠与唤醒Thread.sleep实例线程在休眠过程中，我们可以使用Thread.interrupt将其唤醒，这时线程会抛出InterruptedException。 Thread.sleep实例1234567891011121314151617181920212223242526272829303132public class SleepSample &#123; public static void main(String[] args) throws InterruptedException &#123; sleepTest(); &#125; private static void sleepTest() throws InterruptedException &#123; Thread thread = new Thread() &#123; public void run() &#123; System.out.println("线程 " + Thread.currentThread().getName() + "将要休眠5分钟。"); try &#123; Thread.sleep(5*60*1000); &#125; catch(InterruptedException ex) &#123; System.out.println("线程 " + Thread.currentThread().getName() + "休眠被中断。"); &#125; System.out.println("线程 " + Thread.currentThread().getName() + "休眠结束。"); &#125; &#125;; thread.setDaemon(true); thread.start(); Thread.sleep(500); thread.interrupt(); &#125;&#125; 线程的终止虽然有Thread.stop方法，但该方法是不被推荐使用的，我们可以利用上面休眠与唤醒的机制，让线程在处理IterruptedException时，结束线程。 Thread.interrupt示例12345678910111213141516171819202122232425262728293031public class StopThreadSample &#123; public static void main(String[] args) throws InterruptedException &#123; stopTest(); &#125; private static void stopTest() throws InterruptedException &#123; Thread thread = new Thread() &#123; public void run() &#123; System.out.println("线程运行中。"); try &#123; Thread.sleep(1*60*1000); &#125; catch(InterruptedException ex) &#123; System.out.println("线程中断，结束线程"); return; &#125; System.out.println("线程正常结束。"); &#125; &#125;; thread.start(); Thread.sleep(500); thread.interrupt(); &#125;&#125; 线程的同步等待当我们在主线程中创建了10个子线程，然后我们期望10个子线程全部结束后，主线程在执行接下来的逻辑，这时，就该Thread.join登场了。 Thread.join示例12345678910111213141516171819202122232425262728293031323334public class JoinSample &#123; public static void main(String[] args) throws InterruptedException &#123; joinTest(); &#125; private static void joinTest() throws InterruptedException &#123; Thread thread = new Thread() &#123; public void run() &#123; try &#123; for(int i = 0; i &lt; 5; i++) &#123; System.out.println("线程在运行。"); Thread.sleep(1000); &#125; &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; thread.setDaemon(true); thread.start(); Thread.sleep(1000); thread.join(); System.out.println("主线程正常结束。"); &#125;&#125; 我们可以试着将thread.join();注释或者删除，再次运行程序，就可以发现不同了。 线程间通信我们知道，一个进程下面的所有线程是共享内存空间的，那么我们如何在不同的线程之间传递消息呢？在回顾 Java I/O时，我们谈到了PipedStream和PipedReader，这里，就是它们发挥作用的地方了。 下面的两个示例，功能完全一样，不同的是一个使用Stream，一个使用Reader/Writer。 PipeInputStream/PipedOutpueStream 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void communicationTest() throws IOException, InterruptedException&#123; final PipedOutputStream pos = new PipedOutputStream(); final PipedInputStream pis = new PipedInputStream(pos); Thread thread1 = new Thread() &#123; public void run() &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try &#123; while(true) &#123; String message = br.readLine(); pos.write(message.getBytes()); if (message.equals("end")) break; &#125; br.close(); pos.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; byte[] buffer = new byte[1024]; int bytesRead = 0; try &#123; while((bytesRead = pis.read(buffer, 0, buffer.length)) != -1) &#123; System.out.println(new String(buffer)); if (new String(buffer).equals("end")) break; buffer = null; buffer = new byte[1024]; &#125; pis.close(); buffer = null; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; PipedReader/PipedWriter 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private static void communicationTest2() throws InterruptedException, IOException&#123; final PipedWriter pw = new PipedWriter(); final PipedReader pr = new PipedReader(pw); final BufferedWriter bw = new BufferedWriter(pw); final BufferedReader br = new BufferedReader(pr); Thread thread1 = new Thread() &#123; public void run() &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try &#123; while(true) &#123; String message = br.readLine(); bw.write(message); bw.newLine(); bw.flush(); if (message.equals("end")) break; &#125; br.close(); pw.close(); bw.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; String line = null; try &#123; while((line = br.readLine()) != null) &#123; System.out.println(line); if (line.equals("end")) break; &#125; br.close(); pr.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; Java多线程同步线程同步话题。这是比多线程更复杂，稍不留意，我们就会“掉到坑里”，而且和单线程程序不同，多线程的错误是否每次都出现，也是不固定的，这给调试也带来了很大的挑战。 我们首先阐述什么是同步，不同步有什么问题，然后讨论可以采取哪些措施控制同步，接下来我们会仿照回顾网络通信时那样，构建一个服务器端的“线程池”，JDK为我们提供了一个很大的concurrent工具包，最后我们会对里面的内容进行探索。 为什么要线程同步？说到线程同步，大部分情况下，我们是在针对“单对象多线程”的情况进行讨论，一般会将其分成两部分，一部分是关于“共享变量”，一部分关于“执行步骤”。 共享变量当我们在线程对象（Runnable）中定义了全局变量，run方法会修改该变量时，如果有多个线程同时使用该线程对象，那么就会造成全局变量的值被同时修改，造成错误。我们来看下面的代码： 共享变量造成同步问题12345678910111213141516171819202122232425262728293031323334class MyRunner implements Runnable&#123; public int sum = 0; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " --- The value of sum is " + sum); System.out.println(Thread.currentThread().getName() + " End."); &#125;&#125;private static void sharedVaribleTest() throws InterruptedException&#123; MyRunner runner = new MyRunner(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 这个示例中，线程用来计算1到100的和是多少，我们知道正确结果是5050（好像是高斯小时候玩过这个？），但是上述程序返回的结果是10100，原因是两个线程同时对sum进行操作。 执行步骤我们在多个线程运行时，可能需要某些操作合在一起作为“原子操作”，即在这些操作可以看做是“单线程”的，例如我们可能希望输出结果的样子是这样的： 1234561 线程1：步骤12 线程1：步骤23 线程1：步骤34 线程2：步骤15 线程2：步骤26 线程2：步骤3 如果同步控制不好，出来的样子可能是这样的： 123456线程1：步骤1线程2：步骤1线程1：步骤2线程2：步骤2线程1：步骤3线程2：步骤3 这里我们也给出一个示例代码： 执行步骤混乱带来的同步问题123456789101112131415161718192021222324252627282930313233class MyNonSyncRunner implements Runnable&#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); for(int i = 1; i &lt;= 5; i++) &#123; System.out.println(Thread.currentThread().getName() + " Running step " + i); try &#123; Thread.sleep(50); &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " End."); &#125;&#125;private static void syncTest() throws InterruptedException&#123; MyNonSyncRunner runner = new MyNonSyncRunner(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 如何控制线程同步既然线程同步有上述问题，那么我们应该如何去解决呢？针对不同原因造成的同步问题，我们可以采取不同的策略。 控制共享变量我们可以采取3种方式来控制共享变量。 将“单对象多线程”修改成“多对象多线程” 上文提及，同步问题一般发生在“单对象多线程”的场景中，那么最简单的处理方式就是将运行模型修改成“多对象多线程”的样子，针对上面示例中的同步问题，修改后的代码如下： 解决共享变量问题方案一1234567891011private static void sharedVaribleTest2() throws InterruptedException&#123; Thread thread1 = new Thread(new MyRunner()); Thread thread2 = new Thread(new MyRunner()); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 我们可以看到，上述代码中两个线程使用了两个不同的Runnable实例，它们在运行过程中，就不会去访问同一个全局变量。 将“全局变量”降级为“局部变量”既然是共享变量造成的问题，那么我们可以将共享变量改为“不共享”，即将其修改为局部变量。这样也可以解决问题，同样针对上面的示例，这种解决方式的代码如下： 解决共享变量问题方案二123456789101112131415161718192021222324252627282930313233class MyRunner2 implements Runnable&#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " --- The value of sum is " + sum); System.out.println(Thread.currentThread().getName() + " End."); &#125;&#125;private static void sharedVaribleTest3() throws InterruptedException&#123; MyRunner2 runner = new MyRunner2(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 我们可以看出，sum变量已经由全局变量变为run方法内部的局部变量了。 使用ThreadLocal机制ThreadLocal是JDK引入的一种机制，它用于解决线程间共享变量，使用ThreadLocal声明的变量，即使在线程中属于全局变量，针对每个线程来讲，这个变量也是独立的。 我们可以用这种方式来改造上面的代码，如下所示： 解决共享变量问题方案三1234567891011121314151617181920212223242526272829303132333435363738394041class MyRunner3 implements Runnable&#123; public ThreadLocal&lt;Integer&gt; tl = new ThreadLocal&lt;Integer&gt;(); public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); for (int i = 0; i &lt;= 100; i++) &#123; if (tl.get() == null) &#123; tl.set(new Integer(0)); &#125; int sum = ((Integer)tl.get()).intValue(); sum+= i; tl.set(new Integer(sum)); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " --- The value of sum is " + ((Integer)tl.get()).intValue()); System.out.println(Thread.currentThread().getName() + " End."); &#125;&#125;private static void sharedVaribleTest4() throws InterruptedException&#123; MyRunner3 runner = new MyRunner3(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 综上三种方案，第一种方案会降低多线程执行的效率，因此，我们推荐使用第二种或者第三种方案。 控制执行步骤说到执行步骤，我们可以使用synchronized关键字来解决它。 执行步骤问题解决方案123456789101112131415161718192021222324252627282930313233343536class MySyncRunner implements Runnable&#123; public void run() &#123; synchronized(this) &#123; System.out.println(Thread.currentThread().getName() + " Start."); for(int i = 1; i &lt;= 5; i++) &#123; System.out.println(Thread.currentThread().getName() + " Running step " + i); try &#123; Thread.sleep(50); &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " End."); &#125; &#125;&#125;private static void syncTest2() throws InterruptedException&#123; MySyncRunner runner = new MySyncRunner(); Thread thread1 = new Thread(runner); Thread thread2 = new Thread(runner); thread1.setDaemon(true); thread2.setDaemon(true); thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 在线程同步的话题上，synchronized是一个非常重要的关键字。它的原理和数据库中事务锁的原理类似。我们在使用过程中，应该尽量缩减synchronized覆盖的范围,原因有二： 被它覆盖的范围是串行的，效率低； 容易产生死锁。 我们来看下面的示例： synchronized示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private static void syncTest3() throws InterruptedException&#123; final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Thread thread1 = new Thread() &#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); Random r = new Random(100); synchronized(list) &#123; for (int i = 0; i &lt; 5; i++) &#123; list.add(new Integer(r.nextInt())); &#125; System.out.println("The size of list is " + list.size()); &#125; try &#123; Thread.sleep(500); &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " End."); &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + " Start."); Random r = new Random(100); synchronized(list) &#123; for (int i = 0; i &lt; 5; i++) &#123; list.add(new Integer(r.nextInt())); &#125; System.out.println("The size of list is " + list.size()); &#125; try &#123; Thread.sleep(500); &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " End."); &#125; &#125;; thread1.start(); thread2.start(); thread1.join(); thread2.join();&#125; 我们应该把需要同步的内容集中在一起，尽量不包含其他不相关的、消耗大量资源的操作，示例中线程休眠的操作显然不应该包括在里面。 构造线程池我们在Java网络通信中，已经构建了一个Socket连接池，这里我们在此基础上，构建一个线程池，完成基本的启动、休眠、唤醒、停止操作。 基本思路还是以数组的形式保持一系列线程，通过Socket通信，客户端向服务器端发送命令，当服务器端接收到命令后，根据收到的命令对线程数组中的线程进行操作。 Socket客户端的代码保持不变，依然采用构建Socket连接池时的代码，我们主要针对服务器端进行改造。 首先，我们需要定义一个线程对象，它用来执行我们的业务操作，这里简化起见，只让线程进行休眠。 定义线程对象12345678910111213141516171819202122232425262728293031323334353637383940enum ThreadStatus&#123; Initial, Running, Sleeping, Stopped&#125;enum ThreadTask&#123; Start, Stop, Sleep, Wakeup&#125;class MyThread extends Thread&#123; public ThreadStatus status = ThreadStatus.Initial; public ThreadTask task; public void run() &#123; status = ThreadStatus.Running; while(true) &#123; try &#123; Thread.sleep(3000); if (status == ThreadStatus.Sleeping) &#123; System.out.println(Thread.currentThread().getName() + " 进入休眠状态。"); this.wait(); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + " 运行过程中出现错误。"); status = ThreadStatus.Stopped; &#125; &#125; &#125;&#125; 然后，我们需要定义一个线程管理器，它用来对线程池中的线程进行管理，代码如下： 定义线程池管理对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MyThreadManager&#123; public static void manageThread(MyThread[] threads, ThreadTask task) &#123; for (int i = 0; i &lt; threads.length; i++) &#123; synchronized(threads[i]) &#123; manageThread(threads[i], task); &#125; &#125; System.out.println(getThreadStatus(threads)); &#125; public static void manageThread(MyThread thread, ThreadTask task) &#123; if (task == ThreadTask.Start) &#123; if (thread.status == ThreadStatus.Running) &#123; return; &#125; if (thread.status == ThreadStatus.Stopped) &#123; thread = new MyThread(); &#125; thread.status = ThreadStatus.Running; thread.start(); &#125; else if (task == ThreadTask.Stop) &#123; if (thread.status != ThreadStatus.Stopped) &#123; thread.interrupt(); thread.status = ThreadStatus.Stopped; &#125; &#125; else if (task == ThreadTask.Sleep) &#123; thread.status = ThreadStatus.Sleeping; &#125; else if (task == ThreadTask.Wakeup) &#123; thread.notify(); thread.status = ThreadStatus.Running; &#125; &#125; public static String getThreadStatus(MyThread[] threads) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; threads.length; i++) &#123; sb.append(threads[i].getName() + "的状态：" + threads[i].status).append("\r\n"); &#125; return sb.toString(); &#125;&#125; 最后，是我们的服务器端，它不断接受客户端的请求，每收到一个连接请求，服务器端会新开一个线程，来处理后续客户端发来的各种操作指令。 定义服务器端线程池对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class MyThreadPool &#123; public static void main(String[] args) throws IOException &#123; MyThreadPool pool = new MyThreadPool(5); &#125; private int threadCount; private MyThread[] threads = null; public MyThreadPool(int count) throws IOException &#123; this.threadCount = count; threads = new MyThread[count]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new MyThread(); threads[i].start(); &#125; Init(); &#125; private void Init() throws IOException &#123; ServerSocket serverSocket = new ServerSocket(5678); while(true) &#123; final Socket socket = serverSocket.accept(); Thread thread = new Thread() &#123; public void run() &#123; try &#123; System.out.println("检测到一个新的Socket连接。"); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); String line = null; while((line = br.readLine()) != null) &#123; System.out.println(line); if (line.equals("Count")) &#123; System.out.println("线程池中有5个线程"); &#125; else if (line.equals("Status")) &#123; String status = MyThreadManager.getThreadStatus(threads); System.out.println(status); &#125; else if (line.equals("StartAll")) &#123; MyThreadManager.manageThread(threads, ThreadTask.Start); &#125; else if (line.equals("StopAll")) &#123; MyThreadManager.manageThread(threads, ThreadTask.Stop); &#125; else if (line.equals("SleepAll")) &#123; MyThreadManager.manageThread(threads, ThreadTask.Sleep); &#125; else if (line.equals("WakeupAll")) &#123; MyThreadManager.manageThread(threads, ThreadTask.Wakeup); &#125; else if (line.equals("End")) &#123; break; &#125; else &#123; System.out.println("Command:" + line); &#125; ps.println("OK"); ps.flush(); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; thread.start(); &#125; &#125;&#125; 探索JDK中的concurrent工具包为了简化开发人员在进行多线程开发时的工作量，并减少程序中的bug，JDK提供了一套concurrent工具包，我们可以用它来方便的开发多线程程序。 线程池 我们在上面实现了一个非常“简陋”的线程池，concurrent工具包中也提供了线程池，而且使用非常方便。 concurrent工具包中的线程池分为3类：ScheduledThreadPool、FixedThreadPool和CachedThreadPool。 首先我们来定义一个Runnable的对象 定义Runnable对象12345678910111213141516171819class MyRunner implements Runnable&#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + "运行开始"); for(int i = 0; i &lt; 1; i++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "正在运行"); Thread.sleep(200); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + "运行结束"); &#125;&#125; 可以看出，它的功能非常简单，只是输出了线程的执行过程。 ScheduledThreadPool这和我们平时使用的ScheduledTask比较类似，或者说很像Timer，它可以使得一个线程在指定的一段时间内开始运行，并且在间隔另外一段时间后再次运行，直到线程池关闭。 ScheduledThreadPool示例123456789101112131415161718192021ScheduledThreadPool示例private static void scheduledThreadPoolTest()&#123; final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(3); MyRunner runner = new MyRunner(); final ScheduledFuture&lt;?&gt; handler1 = scheduler.scheduleAtFixedRate(runner, 1, 10, TimeUnit.SECONDS); final ScheduledFuture&lt;?&gt; handler2 = scheduler.scheduleWithFixedDelay(runner, 2, 10, TimeUnit.SECONDS); scheduler.schedule(new Runnable() &#123; public void run() &#123; handler1.cancel(true); handler2.cancel(true); scheduler.shutdown(); &#125; &#125;, 30, TimeUnit.SECONDS );&#125; FixedThreadPool这是一个指定容量的线程池，即我们可以指定在同一时间，线程池中最多有多个线程在运行，超出的线程，需要等线程池中有空闲线程时，才能有机会运行。 FixedThreadPool示例12345678910private static void fixedThreadPoolTest()&#123; ExecutorService exec = Executors.newFixedThreadPool(3); for(int i = 0; i &lt; 5; i++) &#123; MyRunner runner = new MyRunner(); exec.execute(runner); &#125; exec.shutdown();&#125; 注意它的输出结果： 123456789101112131415pool-1-thread-1运行开始pool-1-thread-1正在运行pool-1-thread-2运行开始pool-1-thread-2正在运行pool-1-thread-3运行开始pool-1-thread-3正在运行pool-1-thread-1运行结束pool-1-thread-1运行开始pool-1-thread-1正在运行pool-1-thread-2运行结束pool-1-thread-2运行开始pool-1-thread-2正在运行pool-1-thread-3运行结束pool-1-thread-1运行结束pool-1-thread-2运行结束 可以看到从始至终，最多有3个线程在同时运行。 CachedThreadPool这是另外一种线程池，它不需要指定容量，只要有需要，它就会创建新的线程。 它的使用方式和FixedThreadPool非常像，来看下面的代码： CachedThreadPool示例1234567891011private static void cachedThreadPoolTest()&#123; ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i++) &#123; MyRunner runner = new MyRunner(); exec.execute(runner); &#125; exec.shutdown();&#125; 它的执行结果如下： 123456789101112131415pool-1-thread-1运行开始pool-1-thread-1正在运行pool-1-thread-2运行开始pool-1-thread-2正在运行pool-1-thread-3运行开始pool-1-thread-3正在运行pool-1-thread-4运行开始pool-1-thread-4正在运行pool-1-thread-5运行开始pool-1-thread-5正在运行pool-1-thread-1运行结束pool-1-thread-2运行结束pool-1-thread-3运行结束pool-1-thread-4运行结束pool-1-thread-5运行结束 可以看到，它创建了5个线程。 处理线程返回值在有些情况下，我们需要使用线程的返回值，在上述的所有代码中，线程这是执行了某些操作，没有任何返回值。 如何做到这一点呢？我们可以使用JDK中的Callable和CompletionService，前者返回单个线程的结果，后者返回一组线程的结果。 返回单个线程的结果 还是直接看代码吧： Callable示例1234567891011121314private static void callableTest() throws InterruptedException, ExecutionException&#123; ExecutorService exec = Executors.newFixedThreadPool(1); Callable&lt;String&gt; call = new Callable&lt;String&gt;() &#123; public String call() &#123; return "Hello World."; &#125; &#125;; Future&lt;String&gt; result = exec.submit(call); System.out.println("线程的返回值是" + result.get()); exec.shutdown();&#125; 线程的返回值是Hello World. 返回线程池中每个线程的结果 这里需要使用CompletionService，代码如下： CompletionService示例123456789101112131415161718192021222324private static void completionServiceTest() throws InterruptedException, ExecutionException&#123; ExecutorService exec = Executors.newFixedThreadPool(10); CompletionService&lt;String&gt; service = new ExecutorCompletionService&lt;String&gt;(exec); for (int i = 0; i &lt; 10; i++) &#123; Callable&lt;String&gt; call = new Callable&lt;String&gt;() &#123; public String call() throws InterruptedException &#123; return Thread.currentThread().getName(); &#125; &#125;; service.submit(call); &#125; Thread.sleep(1000); for(int i = 0; i &lt; 10; i++) &#123; Future&lt;String&gt; result = service.take(); System.out.println("线程的返回值是" + result.get()); &#125; exec.shutdown();&#125; 执行结果如下： 12345678910线程的返回值是pool-2-thread-1线程的返回值是pool-2-thread-2线程的返回值是pool-2-thread-3线程的返回值是pool-2-thread-5线程的返回值是pool-2-thread-4线程的返回值是pool-2-thread-6线程的返回值是pool-2-thread-8线程的返回值是pool-2-thread-7线程的返回值是pool-2-thread-9线程的返回值是pool-2-thread-10 实现生产者-消费者模型对于生产者-消费者模型来说，我们应该都不会陌生，通常我们都会使用某种数据结构来实现它。在concurrent工具包中，我们可以使用BlockingQueue来实现生产者-消费者模型，如下： BlockingQueue示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class BlockingQueueSample &#123; public static void main(String[] args) &#123; blockingQueueTest(); &#125; private static void blockingQueueTest() &#123; final BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;Integer&gt;(); final int maxSleepTimeForSetter = 10; final int maxSleepTimerForGetter = 10; Runnable setter = new Runnable() &#123; public void run() &#123; Random r = new Random(); while(true) &#123; int value = r.nextInt(100); try &#123; queue.put(new Integer(value)); System.out.println(Thread.currentThread().getName() + &quot;---向队列中插入值&quot; + value); Thread.sleep(r.nextInt(maxSleepTimeForSetter) * 1000); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; &#125;; Runnable getter = new Runnable() &#123; public void run() &#123; Random r = new Random(); while(true) &#123; try &#123; if (queue.size() == 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;---队列为空&quot;); &#125; else &#123; int value = queue.take().intValue(); System.out.println(Thread.currentThread().getName() + &quot;---从队列中获取值&quot; + value); &#125; Thread.sleep(r.nextInt(maxSleepTimerForGetter) * 1000); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; &#125;; ExecutorService exec = Executors.newFixedThreadPool(2); exec.execute(setter); exec.execute(getter); &#125;&#125; 我们定义了两个线程，一个线程向Queue中添加数据，一个线程从Queue中取数据。我们可以通过控制maxSleepTimeForSetter和maxSleepTimerForGetter的值，来使得程序得出不同的结果。 可能的执行结果如下： 123456789101112131415161718pool-1-thread-1---向队列中插入值88pool-1-thread-2---从队列中获取值88pool-1-thread-1---向队列中插入值75pool-1-thread-2---从队列中获取值75pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-1---向队列中插入值50pool-1-thread-2---从队列中获取值50pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-2---队列为空pool-1-thread-1---向队列中插入值51pool-1-thread-1---向队列中插入值92pool-1-thread-2---从队列中获取值51pool-1-thread-2---从队列中获取值92 因为Queue中的值和Thread的休眠时间都是随机的，所以执行结果也不是固定的。 使用信号量来控制线程JDK提供了Semaphore来实现“信号量”的功能，它提供了两个方法分别用于获取和释放信号量：acquire和release，示例代码如下： SemaPhore示例1234567891011121314151617181920212223242526272829private static void semaphoreTest()&#123; ExecutorService exec = Executors.newFixedThreadPool(10); final Semaphore semp = new Semaphore(2); for (int i = 0; i &lt; 10; i++) &#123; Runnable runner = new Runnable() &#123; public void run() &#123; try &#123; semp.acquire(); System.out.println(new Date() + " " + Thread.currentThread().getName() + "正在执行。"); Thread.sleep(5000); semp.release(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;; exec.execute(runner); &#125; exec.shutdown();&#125; 执行结果如下： 12345678910Tue May 07 11:22:11 CST 2013 pool-1-thread-1正在执行。Tue May 07 11:22:11 CST 2013 pool-1-thread-2正在执行。Tue May 07 11:22:17 CST 2013 pool-1-thread-3正在执行。Tue May 07 11:22:17 CST 2013 pool-1-thread-4正在执行。Tue May 07 11:22:22 CST 2013 pool-1-thread-5正在执行。Tue May 07 11:22:22 CST 2013 pool-1-thread-6正在执行。Tue May 07 11:22:27 CST 2013 pool-1-thread-7正在执行。Tue May 07 11:22:27 CST 2013 pool-1-thread-8正在执行。Tue May 07 11:22:32 CST 2013 pool-1-thread-10正在执行。Tue May 07 11:22:32 CST 2013 pool-1-thread-9正在执行。 可以看出，尽管线程池中创建了10个线程，但是同时运行的，只有2个线程。 控制线程池中所有线程的执行步骤在前面，我们已经提到，可以用synchronized关键字来控制单个线程中的执行步骤，那么如果我们想要对线程池中的所有线程的执行步骤进行控制的话，应该如何实现呢？ 我们有两种方式，一种是使用CyclicBarrier，一种是使用CountDownLatch。 CyclicBarrier使用了类似于Object.wait的机制，它的构造函数中需要接收一个整型数字，用来说明它需要控制的线程数目，当在线程的run方法中调用它的await方法时，它会保证所有的线程都执行到这一步，才会继续执行后面的步骤。 示例代码如下： CyclicBarrier示例1234567891011121314151617181920212223242526272829303132333435363738class MyRunner2 implements Runnable&#123; private CyclicBarrier barrier = null; public MyRunner2(CyclicBarrier barrier) &#123; this.barrier = barrier; &#125; public void run() &#123; Random r = new Random(); try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(r.nextInt(10) * 1000); System.out.println(new Date() + "--" + Thread.currentThread().getName() + "--第" + (i + 1) + "次等待。"); barrier.await(); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;private static void cyclicBarrierTest()&#123; CyclicBarrier barrier = new CyclicBarrier(3); ExecutorService exec = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 3; i++) &#123; exec.execute(new MyRunner2(barrier)); &#125; exec.shutdown();&#125; 执行结果如下： 123456789Tue May 07 11:31:20 CST 2013--pool-1-thread-2--第1次等待。Tue May 07 11:31:21 CST 2013--pool-1-thread-3--第1次等待。Tue May 07 11:31:24 CST 2013--pool-1-thread-1--第1次等待。Tue May 07 11:31:24 CST 2013--pool-1-thread-1--第2次等待。Tue May 07 11:31:26 CST 2013--pool-1-thread-3--第2次等待。Tue May 07 11:31:30 CST 2013--pool-1-thread-2--第2次等待。Tue May 07 11:31:32 CST 2013--pool-1-thread-1--第3次等待。Tue May 07 11:31:33 CST 2013--pool-1-thread-3--第3次等待。Tue May 07 11:31:33 CST 2013--pool-1-thread-2--第3次等待。 可以看出，thread-2到第1次等待点时，一直等到thread-1到达后才继续执行。 CountDownLatch则是采取类似”倒计时计数器”的机制来控制线程池中的线程，它有CountDown和Await两个方法。示例代码如下： CountDownLatch示例123456789101112131415161718192021222324252627282930313233343536private static void countdownLatchTest() throws InterruptedException&#123; final CountDownLatch begin = new CountDownLatch(1); final CountDownLatch end = new CountDownLatch(5); ExecutorService exec = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 5; i++) &#123; Runnable runner = new Runnable() &#123; public void run() &#123; Random r = new Random(); try &#123; begin.await(); System.out.println(Thread.currentThread().getName() + "运行开始"); Thread.sleep(r.nextInt(10)*1000); System.out.println(Thread.currentThread().getName() + "运行结束"); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; end.countDown(); &#125; &#125; &#125;; exec.execute(runner); &#125; begin.countDown(); end.await(); System.out.println(Thread.currentThread().getName() + "运行结束"); exec.shutdown();&#125; 执行结果如下： 1234567891011pool-1-thread-1运行开始pool-1-thread-5运行开始pool-1-thread-2运行开始pool-1-thread-3运行开始pool-1-thread-4运行开始pool-1-thread-2运行结束pool-1-thread-1运行结束pool-1-thread-3运行结束pool-1-thread-5运行结束pool-1-thread-4运行结束main运行结束 Java集合Java中的集合（Collection）。集合是编程语言中基础的一部分，Java自JDK早期，就引入了Java Collection Framework。设计JCF的那个人，后来还写了一本书，叫《Effective Java》。 Java中的集合主要集中在2部分，一部分是java.util包中，一部分是java.util.concurrent中，后者是在前者的基础上，定义了一些实现了同步功能的集合。 这篇文章主要关注java.util下的各种集合对象。Java中的集合对象可以粗略的分为3类：List、Set和Map。 完整清晰版图片请参见：http://files.cnblogs.com/wing011203/java_collection_structure.zip，解压缩后就可以看到未经缩放的版本。 Collection概述Java集合中的List和Set都从Collection出来，它是一个学习集合很不错的入口，它包含了集合中通常需要有的操作： 添加元素：add/addAll 清空集合：clear 删除元素：remove/removeAll 判断集合中是否包含某元素：contains/containsAll 判断集合是否为空：isEmpty 计算集合中元素的个数：size 将集合转换为数组：toArray 获取迭代器：iterator 我们来看一个简单的例子，下面的代码会返回一个集合，集合中的元素是随机生成的整数： 1234567891011private static Collection initCollection()&#123; Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 5; i++) &#123; collection.add(new Integer(r.nextInt(100))); &#125; return collection;&#125; 在对集合进行操作的过程中，遍历是一个经常使用的操作，我们可以使用两种方式对集合进行遍历： 使用迭代器对集合进行遍历。正如上面描述Collection接口时所说，所有集合都会有一个迭代器，我们可以用它来遍历集合。 123456789private static void accessCollectionByIterator(Collection&lt;Integer&gt; collection)&#123; Iterator&lt;Integer&gt; iterator = collection.iterator(); System.out.println("The value in the list:"); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125;&#125; 使用foreach遍历集合。 12345678private static void accessCollectionByFor(Collection&lt;Integer&gt; collection)&#123; System.out.println("The value in the list:"); for(Integer value : collection) &#123; System.out.println(value); &#125;&#125; List Java中的List是对数组的有效扩展，它是这样一种结构，如果不使用泛型，它可以容纳任何类型的元素，如果使用泛型，那么它只能容纳泛型指定的类型的元素。和数组相比，List的容量是可以动态扩展的。 List中的元素是可以重复的，里面的元素是“有序”的，这里的“有序”，并不是排序的意思，而是说我们可以对某个元素在集合中的位置进行指定。 List中常用的集合对象包括：ArrayList、Vector和LinkedList，其中前两者是基于数组来进行存储，后者是基于链表进行存储。其中Vector是线程安全的，其余两个不是线程安全的。 List中是可以包括null的，即使是使用了泛型。 ArrayList可能是我们平时用到的最多的集合对象了，在上述的示例代码中，我们也是使用它来实例化一个Collection对象，在此不再赘述。 Vector Vector的示例如下，首先我们看如何生成和输出Vector： 1234567891011private static void vectorTest1()&#123; List&lt;Integer&gt; list = new Vector&lt;Integer&gt;(); for (int i = 0 ; i &lt; 5; i++) &#123; list.add(new Integer(100)); &#125; list.add(null); System.out.println("size of vector is " + list.size()); System.out.println(list);&#125; 它的元素中，既包括了重复元素，也包括了null，输出结果如下： 12size of vector is 6[100, 100, 100, 100, 100, null] 下面的示例，演示了Vector中的一些常用方法： 12345678910111213141516171819202122private static void vectorTest2()&#123; Vector&lt;Integer&gt; list = new Vector&lt;Integer&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 10; i++) &#123; list.add(new Integer(r.nextInt(100))); &#125; System.out.println("size of vector is " + list.size()); System.out.println(list); System.out.println(list.firstElement()); System.out.println(list.lastElement()); System.out.println(list.subList(3, 8)); List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); for(int i = 4; i &lt; 7; i++) &#123; temp.add(list.get(i)); &#125; list.retainAll(temp); System.out.println("size of vector is " + list.size()); System.out.println(list);&#125; 它的输出结果如下： 1234567size of vector is 10[39, 41, 20, 9, 29, 32, 54, 12, 94, 82]3982[9, 29, 32, 54, 12]size of vector is 3[29, 32, 54] LinkedList LinkedList使用链表来存储数据，它的示例代码如下： 12345678910111213141516171819202122232425private static void linkedListTest1()&#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 10; i++) &#123; list.add(new Integer(r.nextInt(100))); &#125; list.add(null); System.out.println("size of linked list is " + list.size()); System.out.println(list); System.out.println(list.element()); System.out.println(list.getFirst()); System.out.println(list.getLast()); System.out.println(list.peek()); System.out.println(list.peekFirst()); System.out.println(list.peekLast()); System.out.println(list.poll()); System.out.println(list.pollFirst()); System.out.println(list.pollLast()); System.out.println(list.pop()); list.push(new Integer(100)); System.out.println("size of linked list is " + list.size()); System.out.println(list);&#125; 这里列出了LinkedList常用的各个方法，从方法名可以看出，LinkedList也可以用来实现栈和队列。 输出结果如下： 12345678910size of linked list is 11[17, 21, 5, 84, 19, 57, 68, 26, 27, 47, null]17null17null21nullsize of linked list is 8[100, 84, 19, 57, 68, 26, 27, 47] Set Set 和List类似，都是用来存储单个元素，单个元素的数量不确定。但Set不能包含重复元素，如果向Set中插入两个相同元素，那么后一个元素不会被插入。 Set可以大致分为两类：不排序Set和排序Set，不排序Set包括HashSet和LinkedHashSet，排序Set主要指TreeSet。其中HashSet和LinkedHashSet可以包含null。 HashSet HashSet是由Hash表支持的一种集合，它不是线程安全的。 我们来看下面的示例，它和Vector的第一个示例基本上是相同的： 12345678910111213private static void hashSetTest1()&#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; 3; i++) &#123; set.add(new Integer(100)); &#125; set.add(null); System.out.println("size of set is " + set.size()); System.out.println(set);&#125; 这里，HashSet中没有包含重复元素，但包含了null，和Vector不同，这里的输出结果如下： 12size of set is 2[null, 100] 对于HashSet是如何判断两个元素是否是重复的，我们可以深入考察一下。Object中也定义了equals方法，对于HashSet中的元素，它是根据equals方法来判断元素是否相等的，为了证明这一点，我们可以定义个“不正常”的类型： 123456789101112131415161718192021222324class MyInteger&#123; private Integer value; public MyInteger(Integer value) &#123; this.value = value; &#125; public String toString() &#123; return String.valueOf(value); &#125; public int hashCode() &#123; return 1; &#125; public boolean equals(Object obj) &#123; return false; &#125;&#125; 可以看到，对于MyInteger来说，对于任意两个实例，我们都认为它是不相等的。 下面是对应的测试方法： 123456789101112private static void hashSetTest2()&#123; Set&lt;MyInteger&gt; set = new HashSet&lt;MyInteger&gt;(); for (int i = 0; i &lt; 3; i++) &#123; set.add(new MyInteger(100)); &#125; System.out.println("size of set is " + set.size()); System.out.println(set);&#125; 它的输出结果如下： 12size of set is 3[100, 100, 100] 可以看到，现在HashSet里有“重复”元素了，但对于MyInteger来说，它们不是“相同”的。 TreeSetTreeSet是支持排序的一种Set，它的父接口是SortedSet。 我们首先来看一下TreeSet都有哪些基本操作： 1234567891011121314151617181920private static void treeSetTest1()&#123; TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 5; i++) &#123; set.add(new Integer(r.nextInt(100))); &#125; System.out.println(set); System.out.println(set.first()); System.out.println(set.last()); System.out.println(set.descendingSet()); System.out.println(set.headSet(new Integer(50))); System.out.println(set.tailSet(new Integer(50))); System.out.println(set.subSet(30, 60)); System.out.println(set.floor(50)); System.out.println(set.ceiling(50));&#125; 它的输出结果如下： 123456789[8, 42, 48, 49, 53]853[53, 49, 48, 42, 8][8, 42, 48, 49][53][42, 48, 49, 53]4953 TreeSet中的元素，一般都实现了Comparable接口，默认情况下，对于Integer来说，SortedList是采用升序来存储的，我们也可以自定义Compare方式，例如以降序的方式来存储。 下面，我们首先重新定义Integer： 定义MyInteger2对象123456789101112131415161718192021222324252627282930class MyInteger2 implements Comparable&#123; public int value; public MyInteger2(int value) &#123; this.value = value; &#125; public int compareTo(Object arg0) &#123; MyInteger2 temp = (MyInteger2)arg0; if (temp == null) return -1; if (temp.value &gt; this.value) &#123; return 1; &#125; else if (temp.value &lt; this.value) &#123; return -1; &#125; return 0; &#125; public boolean equals(Object obj)&#123; return compareTo(obj) == 0; &#125; public String toString()&#123; return String.valueOf(value); &#125;&#125; 下面是测试代码： 12345678910111213141516private static void treeSetTest2()&#123; TreeSet&lt;Integer&gt; set1 = new TreeSet&lt;Integer&gt;(); TreeSet&lt;MyInteger2&gt; set2 = new TreeSet&lt;MyInteger2&gt;(); Random r = new Random(); for (int i = 0 ; i &lt; 5; i++) &#123; int value = r.nextInt(100); set1.add(new Integer(value)); set2.add(new MyInteger2(value)); &#125; System.out.println("Set1 as below:"); System.out.println(set1); System.out.println("Set2 as below:"); System.out.println(set2);&#125; 代码的运行结果如我们所预期的那样，如下所示： 1234Set1 as below:[13, 41, 42, 45, 61]Set2 as below:[61, 45, 42, 41, 13] Map Map中存储的是“键值对”，和Set类似，Java中的Map也有两种：排序的和不排序的，不排序的包括HashMap、Hashtable和LinkedHashMap，排序的包括TreeMap。 非排序Map HashMap和Hashtable都是采取Hash表的方式进行存储，HashMap不是线程安全的，Hashtable是线程安全的，我们可以把HashMap看做是“简化”版的Hashtable。 HashMap是可以存储null的，无论是对Key还是对Value。Hashtable是不可以存储null的。 无论HashMap还是Hashtable，我们观察它的构造函数，就会发现它可以有两个参数：initialCapacity和loadFactor，默认情况下，initialCapacity等于16，loadFactor等于0.75。这和Hash表中可以存放的元素数目有关系，当元素数目超过initialCapacity*loadFactor时，会触发rehash方法，对hash表进行扩容。如果我们需要向其中插入过多元素，需要适当调整这两个参数。 我们首先来看HashMap的示例： 12345678910111213private static void hashMapTest1()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(new Integer(1), "a"); map.put(new Integer(2), "b"); map.put(new Integer(3), "c"); System.out.println(map); System.out.println(map.entrySet()); System.out.println(map.keySet()); System.out.println(map.values());&#125; 这会输出HashMap里的元素信息，如下所示。 1234&#123;1=a, 2=b, 3=c&#125;[1=a, 2=b, 3=c][1, 2, 3][a, b, c] 下面的示例是对null的演示： 1234567891011121314private static void hashMapTest2()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(null, null); map.put(null, null); map.put(new Integer(4), null); map.put(new Integer(5), null); System.out.println(map); System.out.println(map.entrySet()); System.out.println(map.keySet()); System.out.println(map.values());&#125; 执行结果如下： 1234&#123;null=null, 4=null, 5=null&#125;[null=null, 4=null, 5=null][null, 4, 5][null, null, null] 接下来我们演示Hashtable，和上述两个示例基本上完全一样（代码不再展开）： Hashtable示例12345678910111213141516171819202122232425262728private static void hashTableTest1()&#123; Map&lt;Integer,String&gt; table = new Hashtable&lt;Integer, String&gt;(); table.put(new Integer(1), "a"); table.put(new Integer(2), "b"); table.put(new Integer(3), "c"); System.out.println(table); System.out.println(table.entrySet()); System.out.println(table.keySet()); System.out.println(table.values());&#125;private static void hashTableTest2()&#123; Map&lt;Integer,String&gt; table = new Hashtable&lt;Integer, String&gt;(); table.put(null, null); table.put(null, null); table.put(new Integer(4), null); table.put(new Integer(5), null); System.out.println(table); System.out.println(table.entrySet()); System.out.println(table.keySet()); System.out.println(table.values());&#125; 执行结果如下： 12345678&#123;3=c, 2=b, 1=a&#125;[3=c, 2=b, 1=a][3, 2, 1][c, b, a]Exception in thread &quot;main&quot; java.lang.NullPointerException at java.util.Hashtable.put(Unknown Source) at sample.collections.MapSample.hashTableTest2(MapSample.java:61) at sample.collections.MapSample.main(MapSample.java:11) 可以很清楚的看到，当我们试图将null插入到hashtable中时，报出了空指针异常。 排序Map排序Map主要是指TreeMap，它对元素增、删、查操作时的时间复杂度都是O（log（n））。它不是线程安全的。 它的特点和TreeSet非常像，这里不再赘述。 Java序列化对象序列化。 首先，我们来讨论一下什么是序列化以及序列化的原理；然后给出一个简单的示例来演示序列化和反序列化；有时有些信息是不应该被序列化的，我们应该如何控制；我们如何去自定义序列化内容；最后我们讨论一下在继承结构的场景中，序列化需要注意哪些内容。 序列化概述 序列化，简单来讲，就是以“流”的方式来保存对象，至于保存的目标地址，可以是文件，可以是数据库，也可以是网络，即通过网络将对象从一个节点传递到另一个节点。 我们知道在Java的I/O结构中，有ObjectOutputStream和ObjectInputStream，它们可以实现将对象输出为二进制流，并从二进制流中获取对象，那为什么还需要序列化呢？这需要从Java变量的存储结构谈起，我们知道对Java来说，基础类型存储在栈上，复杂类型（引用类型）存储在堆中，对于基础类型来说，上述的操作时可行的，但对复杂类型来说，上述操作过程中，可能会产生重复的对象，造成错误。 而序列化的工作流程如下： 1. 输出流保存的对象都有一个唯一的序列号。 2. 个对象需要保存时，先对其序列号进行检查。 3. 当保存的对象中已包含该序列号时，不需要再次保存，否则，进入正常保存的流程。 正是通过序列号的机制，序列化才可以完整准确的保存对象的各个状态。 序列化保存的是对象中的各个属性的值，而不是方法或者方法签名之类的信息。对于方法或者方法签名，只要JVM能够找到正确的ClassLoader，那么就可以invoke方法。 序列化不会保存类的静态变量，因为静态变量是作用于类型，而序列化作用于对象。 简单的序列化示例 序列化的完整过程包括两部分： 1. 使用ObjectOutputStream将对象保存为二进制流，这一步叫做“序列化”。 2. 使用ObjectInputStream将二进制流转换成对象，这一步叫做“反序列化”。 下面我们来演示一个简单的示例，首先定义一个Person对象，它包含name和age两个信息。 定义Person对象1234567891011121314151617181920212223class Person implements Serializable&#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125;&#125; 然后是两个公共方法，用来完成读、写对象的操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static void writeObject(Object obj, String filePath)&#123; try &#123; FileOutputStream fos = new FileOutputStream(filePath); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(obj); os.flush(); fos.flush(); os.close(); fos.close(); System.out.println("序列化成功。"); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125;&#125;private static Object readObject(String filePath)&#123; try &#123; FileInputStream fis = new FileInputStream(filePath); ObjectInputStream is = new ObjectInputStream(fis); Object temp = is.readObject(); fis.close(); is.close(); if (temp != null) &#123; System.out.println("反序列化成功。"); return temp; &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; return null;&#125; 这里，我们将对象保存的二进制流输出到磁盘文件中。 接下来，我们首先来看“序列化”的方法： 12345678private static void serializeTest1()&#123; Person person = new Person(); person.setName("Zhang San"); person.setAge(30); System.out.println(person); writeObject(person, "d:\\temp\\test\\person.obj");&#125; 我们定义了一个Person实例，然后将其保存到d:\temp\test\person.obj中。 最后，是“反序列化”的方法： 123456789private static void deserializeTest1()&#123; Person temp = (Person)readObject("d:\\temp\\test\\person.obj"); if (temp != null) &#123; System.out.println(temp); &#125;&#125; 它从d:\temp\test\person.obj中读取对象，然后进行输出。 上述两个方法的执行结果如下： 1234Name:Zhang San; Age:30序列化成功。反序列化成功。Name:Zhang San; Age:30 可以看出，读取的对象和保存的对象是完全一致的。 隐藏非序列化信息 有时，我们的业务对象中会包含很多属性，而有些属性是比较隐私的，例如年龄、银行卡号等，这些信息是不太适合进行序列化的，特别是在需要通过网络来传输对象信息时，这些敏感信息很容易被窃取。 Java使用transient关键字来处理这种情况，针对那些敏感的属性，我们只需使用该关键字进行修饰，那么在序列化时，对应的属性值就不会被保存。 我们还是看一个实例，这次我们定义一个新的Person2，其中age信息是我们不希望序列化的： 12345678910111213141516171819202122class Person2 implements Serializable&#123; private String name; private transient int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125;&#125; 注意age的声明语句： 1private transient int age; 下面是“序列化”和“反序列化”的方法： 123456789101112131415161718private static void serializeTest2()&#123; Person2 person = new Person2(); person.setName("Zhang San"); person.setAge(30); System.out.println(person); writeObject(person, "d:\\temp\\test\\person2.obj");&#125;private static void deserializeTest2()&#123; Person2 temp = (Person2)readObject("d:\\temp\\test\\person2.obj"); if (temp != null) &#123; System.out.println(temp); &#125;&#125; 它的输出结果如下： 1234Name:Zhang San; Age:30序列化成功。反序列化成功。Name:Zhang San; Age:0 可以看到经过反序列化的对象，age的信息变成了Integer的默认值0。 自定义序列化过程 我们可以对序列化的过程进行定制，进行更细粒度的控制。 思路是在业务模型中添加readObject和writeObject方法。下面看一个实例，我们新建一个类型，叫Person3： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person3 implements Serializable&#123; private String name; private transient int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125; private void writeObject(ObjectOutputStream os) &#123; try &#123; os.defaultWriteObject(); os.writeObject(this.age); System.out.println(this); System.out.println("序列化成功。"); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private void readObject(ObjectInputStream is) &#123; try &#123; is.defaultReadObject(); this.setAge(((Integer)is.readObject()).intValue() - 1); System.out.println("反序列化成功。"); System.out.println(this); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 请注意观察readObject和writeObject方法，它们都是private的，接受的参数是ObjectStream，然后在方法体内调用了defaultReadObject或者defaultWriteObject方法。 这里age同样是transient的，但是在保存对象的过程中，我们单独对其进行了保存，在读取时，我们将age信息读取出来，并进行了减1处理。 下面是测试方法： 1234567891011121314151617181920212223242526272829303132333435private static void serializeTest3()&#123; Person3 person = new Person3(); person.setName("Zhang San"); person.setAge(30); System.out.println(person); try &#123; FileOutputStream fos = new FileOutputStream("d:\\temp\\test\\person3.obj"); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(person); fos.close(); os.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125;&#125;private static void deserializeTest3()&#123; try &#123; FileInputStream fis = new FileInputStream("d:\\temp\\test\\person3.obj"); ObjectInputStream is = new ObjectInputStream(fis); is.readObject(); fis.close(); is.close(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125;&#125; 输出结果如下： 1234Name:Zhang San; Age:30序列化成功。反序列化成功。Name:Zhang San; Age:29 可以看到，经过反序列化得到的对象，其age属性已经减1。 探讨serialVersionUID 在上文中，我们描述序列化原理时，曾经提及每个对象都会有一个唯一的序列号，这个序列号，就是serialVersionUID。 当我们的对象实现Serializable接口时，该接口可以为我们生成serialVersionUID。 有两种方式来生成serialVersionUID，一种是固定值：1L，一种是经过JVM计算，不同的JVM采取的计算算法可能不同。 下面就是两个serialVersionUID的示例： 12private static final long serialVersionUID = 1L;private static final long serialVersionUID = -2380764581294638541L; 第一行是采用固定值生成的；第二行是JVM经过计算得出的。 那么serialVersionUID还有其他用途吗？ 我们可以使用它来控制版本兼容。如果采用JVM生成的方式，我们可以看到，当我们业务对象的代码保持不变时，多次生成的serialVersionUID也是不变的，当我们对属性进行修改时，重新生成的serialVersionUID会发生变化，当我们对方法进行修改时，serialVersionUID不变。这也从另一个侧面说明，序列化是作用于对象属性上的。 当我们先定义了业务对象，然后对其示例进行了“序列化”，这时根据业务需求，我们修改了业务对象，那么之前“序列化”后的内容还能经过“反序列化”返回到系统中吗？这取决于业务对象是否定义了serialVersionUID，如果定义了，那么是可以返回的，如果没有定义，会抛出异常。 来看下面的示例，定义新的类型Person4： 1234567891011121314151617181920212223class Person4 implements Serializable&#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; private void xxx()&#123;&#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125;&#125; 然后运行下面的方法： 12345678private static void serializeTest4()&#123; Person4 person = new Person4(); person.setName("Zhang San"); person.setAge(30); writeObject(person, "d:\\temp\\test\\person4.obj");&#125; 接下来修改Person4，追加address属性： 123456789101112131415161718192021222324252627282930class Person4 implements Serializable&#123; private String name; private int age; private String address; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; private void xxx()&#123;&#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getAddress() &#123; return address; &#125;&#125; 然后运行“反序列化”方法： 123456789private static void deserializeTest4()&#123; Person4 temp = (Person4)readObject("d:\\temp\\test\\person4.obj"); if (temp != null) &#123; System.out.println(temp); &#125;&#125; 12345678910java.io.InvalidClassException: sample.serialization.Person4; local class incompatible: stream classdesc serialVersionUID = -2380764581294638541, local class serialVersionUID = -473458100724786987 at java.io.ObjectStreamClass.initNonProxy(Unknown Source) at java.io.ObjectInputStream.readNonProxyDesc(Unknown Source) at java.io.ObjectInputStream.readClassDesc(Unknown Source) at java.io.ObjectInputStream.readOrdinaryObject(Unknown Source) at java.io.ObjectInputStream.readObject0(Unknown Source) at java.io.ObjectInputStream.readObject(Unknown Source) at sample.serialization.Sample.readObject(Sample.java:158) at sample.serialization.Sample.deserializeTest4(Sample.java:105) at sample.serialization.Sample.main(Sample.java:16) 但是当我们在Person4中添加serialVersionUID后，再次执行上述各步骤，得出的运行结果如下： 12反序列化成功。Name:Zhang San; Age:30 有继承结构的序列化 业务对象会产生继承，这在管理系统中是经常看到的，如果我们有下面的业务对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Person5&#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String toString() &#123; return "Name:" + name + "; Age:" + age; &#125; public Person5(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;class Employee extends Person5 implements Serializable&#123; public Employee(String name, int age) &#123; super(name, age); &#125; private String companyName; public void setCompanyName(String companyName) &#123; this.companyName = companyName; &#125; public String getCompanyName() &#123; return companyName; &#125; public String toString() &#123; return "Name:" + super.getName() + "; Age:" + super.getAge() + "; Company:" + this.companyName; &#125;&#125; Employee继承在Person5，Employee实现了Serializable接口，Person5没有实现，那么运行下面的方法： 1234567891011121314151617private static void serializeTest5()&#123; Employee emp = new Employee("Zhang San", 30); emp.setCompanyName("XXX"); writeObject(emp, "d:\\temp\\test\\employee.obj");&#125;private static void deserializeTest5()&#123; Employee temp = (Employee)readObject("d:\\temp\\test\\employee.obj"); if (temp != null) &#123; System.out.println(temp); &#125;&#125; 会正常运行吗？事实上不会，它会抛出如下异常： 123456789java.io.InvalidClassException: sample.serialization.Employee; no valid constructor at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(Unknown Source) at java.io.ObjectStreamClass.checkDeserialize(Unknown Source) at java.io.ObjectInputStream.readOrdinaryObject(Unknown Source) at java.io.ObjectInputStream.readObject0(Unknown Source) at java.io.ObjectInputStream.readObject(Unknown Source) at sample.serialization.Sample.readObject(Sample.java:158) at sample.serialization.Sample.deserializeTest5(Sample.java:123) at sample.serialization.Sample.main(Sample.java:18) 原因：在有继承层次的业务对象，进行序列化时，如果父类没有实现Serializable接口，那么父类必须提供默认构造函数。 我们为Person5添加如下默认构造函数： 12345public Person5() &#123; this.name = "Test"; this.age = 1; &#125; 再次运行上述代码，结果如下： 1234Name:Zhang San; Age:30; Company:XXX序列化成功。反序列化成功。Name:Test; Age:1; Company:XXX 可以看到，反序列化后的结果，父类中的属性，已经被父类构造函数中的赋值代替了！ 因此，我们推荐在有继承层次的业务对象进行序列化时，父类也应该实现Serializable接口。我们对Person5进行修改，使其实现Serializable接口，执行结果如下： 1234Name:Zhang San; Age:30; Company:XXX序列化成功。反序列化成功。Name:Zhang San; Age:30; Company:XXX 这正是我们期望的结果。 Java反射关注反射及其相关话题。 反射可以帮助我们查看指定类型中的信息、创建类型的实例，调用类型的方法。我们平时使用框架，例如Spring、EJB、Hibernate等都大量的使用了反射技术。 反射简单示例 下面来演示反射相关的基本操作 首先是基础代码，我们定义一个接口及其实现，作为我们反射操作的目标： 1234567891011121314151617181920212223interface HelloWorldService&#123; void sayHello(String name);&#125;class MyHelloWorld implements HelloWorldService&#123; public String name; public void sayHello(String name) &#123; System.out.println("Hello " + name + "."); &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 获取方法及字段信息 下面的代码会输出给定类型中的方法和字段的声明信息： 12345678910111213141516private static void printClassTypeInfo(String type) throws ClassNotFoundException&#123; Class classType = Class.forName(type); Method[] methods = classType.getDeclaredMethods(); System.out.println("Methods info as below:"); for(Method method : methods) &#123; System.out.println(method.toGenericString()); &#125; Field[] fields = classType.getFields(); System.out.println("Fields info as below:"); for (Field field : fields) &#123; System.out.println(field.toGenericString()); &#125;&#125; 在使用反射时，我们一般会使用java.lang.reflect包中的内容。 然后我们调用下面的代码： 1printClassTypeInfo(&quot;sample.reflection.MyHelloWorld&quot;); 输出结果如下： 123456Methods info as below:public void sample.reflection.MyHelloWorld.sayHello(java.lang.String)public java.lang.String sample.reflection.MyHelloWorld.getName()public void sample.reflection.MyHelloWorld.setName(java.lang.String)Fields info as below:public java.lang.String sample.reflection.MyHelloWorld.name 实例化对象 我们可以使用class.netInstance的方式来创建一个对象，代码如下： 123456private static void createInstanceTest() throws ClassNotFoundException, InstantiationException, IllegalAccessException&#123; Class classType = Class.forName("sample.reflection.MyHelloWorld"); MyHelloWorld hello = (MyHelloWorld)classType.newInstance(); hello.sayHello("Zhang San");&#125; 输出结果： 1Hello Zhang San. 调用对象的方法 我们可以通过方法的名称以及参数类型构建一个Method实例，然后调用Method的invoke方法，来触发方法。 示例代码如下： 1234567private static void invokeMethodTest() throws InstantiationException, IllegalAccessException, ClassNotFoundException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException&#123; Class classType = Class.forName("sample.reflection.MyHelloWorld"); MyHelloWorld hello = (MyHelloWorld)classType.newInstance(); Method method = classType.getMethod("sayHello", new Class[]&#123;String.class&#125;); method.invoke(hello, new Object[]&#123;"Zhang San"&#125;);&#125; 输出结果同上。 修改字段的值 和C#不同，Java中一般使用setxxx和getxxx显示为属性赋值，因此Java中并没有Property类型，而是有Field类型。 我们可以对Field的值进行修改，代码如下： 123456789private static void setFieldTest() throws ClassNotFoundException, NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException&#123; Class classType = Class.forName("sample.reflection.MyHelloWorld"); MyHelloWorld hello = (MyHelloWorld)classType.newInstance(); System.out.println("name is " + hello.name); Field field = classType.getField("name"); field.set(hello, "Zhang San"); System.out.println("name is " + hello.name);&#125; 执行结果如下： 12name is nullname is Zhang San 可以看出，我们成功的修改了name的值。 Annotation探索 一开始我们提到，反射是很多技术的基础，Annotation就是这样的，我们可以把Annotation看做是C#中的Attribute，它可以对类型、方法、属性、字段、方法参数等信息进行修饰。我们可以使用“@+Annotation名”的方式来使用Annotation。 Annotation基本操作 来看下面的代码，我们定义了基于Type、Method、Parameter和Field上面的Annotation示例： 1234567891011121314151617181920212223242526272829303132@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@interface ClassAnnotation&#123; public String value();&#125;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documented@interface MethodAnnotation&#123; public String methodName(); public String returnType();&#125;@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)@Documented@interface ParameterAnnotation&#123; public String value();&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documented@interface FieldAnnotation&#123; public String value();&#125; 接着，我们定义了一个MyClass类型，使用了上述的Annotation： 123456789101112131415161718@ClassAnnotation("这是作用在类型上的Annotation")class MyClass&#123; @MethodAnnotation(methodName="printInfo", returnType="void") public void printInfo(String info) &#123; System.out.println(info); &#125; @MethodAnnotation(methodName="printError", returnType="void") public void printError(@ParameterAnnotation("这是作用在参数上的Annotation")String error) &#123; System.err.println(error); &#125; @FieldAnnotation("这是作用在字段上的Annotation") public int count;&#125; 对于使用了Annotation，我们可以获取其中的信息，下面两种方式都可以获取Annotation，第一种方式是通过反射遍历类型及其方法、字段，一一读取Annotation信息；第二种方式是读取指定类型的Annotation： 读取Annotation方式一1234567891011121314151617181920212223242526272829303132333435363738private static void annotationTest1()&#123; MyClass temp = new MyClass(); Annotation[] annotations = temp.getClass().getAnnotations(); for(Annotation a : annotations) &#123; System.out.println(a.toString()); &#125; Method[] methods = temp.getClass().getDeclaredMethods(); for(Method method : methods) &#123; annotations = method.getAnnotations(); for(Annotation a : annotations) &#123; System.out.println(a.toString()); &#125; Annotation[][] paraAnnotations = method.getParameterAnnotations(); for(int i = 0; i &lt; paraAnnotations.length; i++) &#123; for (Annotation a : paraAnnotations[i]) &#123; System.out.println(a.toString()); &#125; &#125; &#125; Field[] fields = temp.getClass().getFields(); for (Field field : fields) &#123; annotations = field.getAnnotations(); for(Annotation a : annotations) &#123; System.out.println(a.toString()); &#125; &#125;&#125; 读取Annotation方式二12345678910111213141516171819202122232425262728293031323334private static void annotationTest2() throws ClassNotFoundException&#123; Class classType = Class.forName("sample.reflection.annotation.MyClass"); boolean flag = classType.isAnnotationPresent(ClassAnnotation.class); if (flag) &#123; ClassAnnotation annotation = (ClassAnnotation) classType.getAnnotation(ClassAnnotation.class); System.out.println(annotation.toString()); &#125; Method[] methods = classType.getMethods(); for(Method method : methods) &#123; if (method.isAnnotationPresent(MethodAnnotation.class)) &#123; System.out.println(((MethodAnnotation)method.getAnnotation(MethodAnnotation.class)).toString()); &#125; Annotation[][] paraAnnotations = method.getParameterAnnotations(); for(int i = 0; i &lt; paraAnnotations.length; i++) &#123; for (Annotation a : paraAnnotations[i]) &#123; System.out.println(a.toString()); &#125; &#125; &#125; Field[] fields = classType.getFields(); for (Field field:fields) &#123; if (field.isAnnotationPresent(FieldAnnotation.class)) &#123; System.out.println(((FieldAnnotation)field.getAnnotation(FieldAnnotation.class)).toString()); &#125; &#125;&#125; 上述两个方法的输出都是一样的，如下： 12345@sample.reflection.annotation.ClassAnnotation(value=这是作用在类型上的Annotation)@sample.reflection.annotation.MethodAnnotation(methodName=printInfo, returnType=void)@sample.reflection.annotation.MethodAnnotation(methodName=printError, returnType=void)@sample.reflection.annotation.ParameterAnnotation(value=这是作用在参数上的Annotation)@sample.reflection.annotation.FieldAnnotation(value=这是作用在字段上的Annotation) 在WebService中使用Annotation 上述代码看上去可能有些枯燥，不能显示出Annotation的威力，那么我们接下来看WebService，在WebService中，我们可以使用WebMethod、WebParam等Annotation来声明方法或者参数。 接下来，我们来实现一个非常简单的Web服务： 1234567891011121314151617181920212223@WebService(targetNamespace="http://test", serviceName="HelloService")public class HelloServiceProvider&#123; @WebResult(name="HelloString") @WebMethod public String sayHello(@WebParam(name="userName") String name) &#123; return "Hello " + name; &#125; @Oneway @WebMethod(action="userLogin", operationName="userLogin") public void login() &#123; System.out.println("User has logged on."); &#125; public static void main(String[] args) &#123; Thread thread = new Thread(new HelloServicePublisher()); thread.start(); &#125;&#125; 然后定义一个Publisher： 1234567class HelloServicePublisher implements Runnable&#123; public void run() &#123; Endpoint.publish("http://localhost:8888/test/HelloService", new HelloServiceProvider()); &#125;&#125; 在命令行中，我们定位到源代码路径，执行下面的命令： 1wsgen -cp . HelloServiceProvider wsgen位于JDK的bin目录中。 然后我们启动HelloServiceProvider，在浏览器中输入如下地址：http://localhost:8888/test/HelloService，可以看到如下信息： 点击WSDL链接，可以看到： 1&lt;!-- Published by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. --&gt;&lt;!-- Generated by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is JAX-WS RI 2.2.4-b01. --&gt;&lt;definitions targetNamespace="http://test" name="HelloService"&gt;&lt;types&gt;&lt;xsd:schema&gt;&lt;xsd:import namespace="http://test" schemaLocation="http://localhost:8888/test/HelloService?xsd=1"/&gt;&lt;/xsd:schema&gt;&lt;/types&gt;&lt;message name="sayHello"&gt;&lt;part name="parameters" element="tns:sayHello"/&gt;&lt;/message&gt;&lt;message name="sayHelloResponse"&gt;&lt;part name="parameters" element="tns:sayHelloResponse"/&gt;&lt;/message&gt;&lt;message name="userLogin"&gt;&lt;part name="parameters" element="tns:userLogin"/&gt;&lt;/message&gt;&lt;portType name="HelloServiceProvider"&gt;&lt;operation name="sayHello"&gt;&lt;input wsam:Action="http://test/HelloServiceProvider/sayHelloRequest" message="tns:sayHello"/&gt;&lt;output wsam:Action="http://test/HelloServiceProvider/sayHelloResponse" message="tns:sayHelloResponse"/&gt;&lt;/operation&gt;&lt;operation name="userLogin"&gt;&lt;input wsam:Action="userLogin" message="tns:userLogin"/&gt;&lt;/operation&gt;&lt;/portType&gt;&lt;binding name="HelloServiceProviderPortBinding" type="tns:HelloServiceProvider"&gt;&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;&lt;operation name="sayHello"&gt;&lt;soap:operation soapAction=""/&gt;&lt;input&gt;&lt;soap:body use="literal"/&gt;&lt;/input&gt;&lt;output&gt;&lt;soap:body use="literal"/&gt;&lt;/output&gt;&lt;/operation&gt;&lt;operation name="userLogin"&gt;&lt;soap:operation soapAction="userLogin"/&gt;&lt;input&gt;&lt;soap:body use="literal"/&gt;&lt;/input&gt;&lt;/operation&gt;&lt;/binding&gt;&lt;service name="HelloService"&gt;&lt;port name="HelloServiceProviderPort" binding="tns:HelloServiceProviderPortBinding"&gt;&lt;soap:address location="http://localhost:8888/test/HelloService"/&gt;&lt;/port&gt;&lt;/service&gt;&lt;/definitions&gt; JDK中自带了Web服务器，我们不需要把上述代码部署到其他服务器中。 动态代理机制 Spring中一大特色是AOP，面向方面编程也是框架设计一个趋势。对于业务中的共通操作，诸如记录日志、维护事务等，如果和业务逻辑纠缠在一起，会造成代码职责不清，后续维护困难等问题。利用AOP，我们可以很好的分离共通操作和业务操作。 下面我们来实现一个简单的AOP框架，要实现这样一个框架，需要3部分： InvocationHandler，来触发方法； Interceptor，来定义拦截器； DynamicProxy，来动态创建代理对象。 首先我们看Interptor的定义： 1234567interface AOPInterceptor&#123; public void before(Method method, Object[] args); public void after(Method method, Object[] args); public void afterThrowing(Method method, Object[] args); public void afterFinally(Method method, Object[] args);&#125; 接下来是InvocationHandler： 12345678910111213141516171819202122232425262728293031class DynamicProxyInvocationHandler implements InvocationHandler&#123; private Object target; private AOPInterceptor interceptor; public DynamicProxyInvocationHandler(Object target, AOPInterceptor interceptor) &#123; this.target = target; this.interceptor = interceptor; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; interceptor.before(method, args); Object returnValue = method.invoke(target, args); interceptor.after(method, args); return returnValue; &#125; catch(Throwable t) &#123; interceptor.afterThrowing(method, args); throw t; &#125; finally &#123; interceptor.afterFinally(method, args); &#125; &#125;&#125; 最后是DynamicProxy： 12345678class DynamicProxyFactoryImpl implements DynamicProxyFactory&#123; public &lt;T&gt; T createProxy(Class&lt;T&gt; clazz, T target, AOPInterceptor interceptor) &#123; InvocationHandler handler = new DynamicProxyInvocationHandler(target, interceptor); return (T)Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[] &#123;clazz&#125;, handler); &#125;&#125; 至此，我们构建了一个”简易“的AOP拦截器。下面我们来创建一些测试代码。 首先是实现AOPInterceptor接口： 12345678910111213141516171819class MyInterceptor implements AOPInterceptor&#123; public void after(Method method, Object[] args) &#123; System.out.println("方法执行结束。"); &#125; public void afterFinally(Method method, Object[] args) &#123; System.out.println("方法体Finally执行结束。"); &#125; public void afterThrowing(Method method, Object[] args) &#123; System.out.println("方法抛出异常。"); &#125; public void before(Method method, Object[] args) &#123; System.out.println("方法开始执行"); &#125;&#125; 然后利用本文一开始定义的HelloWorldService，来完成测试，需要在MyHello的sayHello方法最后，追加一行代码： 1throw new RuntimeException(); 接着是测试代码： 12345678private static void test()&#123; MyInterceptor interceptor = new MyInterceptor(); HelloWorldService hello = new MyHelloWorld(); DynamicProxyFactory factory = new DynamicProxyFactoryImpl(); HelloWorldService proxy = factory.createProxy(HelloWorldService.class, hello, interceptor); proxy.sayHello("Zhang San");&#125; 最终，执行结果如下： 123456789101112131415方法开始执行Hello Zhang San.方法抛出异常。方法体Finally执行结束。Exception in thread &quot;main&quot; java.lang.reflect.UndeclaredThrowableException at sample.reflection.dynamicproxy.$Proxy0.sayHello(Unknown Source) at sample.reflection.dynamicproxy.Sample.test(Sample.java:18) at sample.reflection.dynamicproxy.Sample.main(Sample.java:9)Caused by: java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at sample.reflection.dynamicproxy.DynamicProxyInvocationHandler.invoke(Sample.java:60) ... 3 more 可以看出，我们已经在业务执行的前、后、异常抛出后以及finally执行后进行了拦截，达到了我们期望的效果。 Java一些基础概念地址下载：http://zangweiren.iteye.com/blog/241218 在看上述文章的时候，随手写了一些测试代码，以便加深理解。这也就是这篇文章的来源了。 类的初始化顺序 在Java中，类里面可能包含：静态变量，静态初始化块，成员变量，初始化块，构造函数。在类之间可能存在着继承关系，那么当我们实例化一个对象时，上述各部分的加载顺序是怎样的？ 首先来看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Parent&#123; public static StaticVarible staticVarible= new StaticVarible("父类-静态变量1"); public StaticVarible instVarible= new StaticVarible("父类-成员变量1"); static &#123; System.out.println("父类-静态块"); &#125; &#123; System.out.println("父类-初始化块"); &#125; public static StaticVarible staticVarible2= new StaticVarible("父类-静态变量2"); public StaticVarible instVarible2= new StaticVarible("父类-成员变量2"); public Parent() &#123; System.out.println("父类-实例构造函数"); &#125;&#125;class Child extends Parent&#123; public static StaticVarible staticVarible= new StaticVarible("子类-静态变量1"); public StaticVarible instVarible= new StaticVarible("子类-成员变量1"); static &#123; System.out.println("子类-静态块"); &#125; public Child() &#123; System.out.println("子类-实例构造函数"); &#125; &#123; System.out.println("子类-初始化块"); &#125; public static StaticVarible staticVarible2= new StaticVarible("子类-静态变量2"); public StaticVarible instVarible2= new StaticVarible("子类-成员变量2"); &#125;class StaticVarible&#123; public StaticVarible(String info) &#123; System.out.println(info); &#125;&#125; 然后执行下面的语句： 1Child child = new Child(); 输出结果如下： 1234567891011121314父类-静态变量1父类-静态块父类-静态变量2子类-静态变量1子类-静态块子类-静态变量2父类-成员变量1父类-初始化块父类-成员变量2父类-实例构造函数子类-成员变量1子类-初始化块子类-成员变量2子类-实例构造函数 结论 从上述结果可以看出，在实例化一个对象时，各部分的加载顺序如下： 父类静态成员/父类静态初始化块 -&gt; 子类静态成员/子类静态初始化块 -&gt; 父类成员变量/父类初始化块 -&gt; 父类构造函数 -&gt; 子类成员变量/子类初始化块 -&gt; 子类构造函数 和String相关的一些事儿 首先，我们聊一聊Java中堆和栈的事儿。 栈：存放基本类型，包括char/byte/short/int/long/float/double/boolean 堆：存放引用类型，同时一般会在栈中保留一个指向它的指针，垃圾回收判断一个对象是否可以回收，就是判断栈中是否有指针指向堆中的对象。 String作为一种特殊的数据类型，它不完全等同于基本类型，也不是全部的引用类型，许多面试题都有它的身影。 String类型变量的存储结构 String的存储结构分为两部分，我们以String a = “abc”;为例，描述String类型的存储方式： 1. 在栈中创建一个char数组，值分为是’a’，’b’，’c’。 2. 在堆中创建一个String对象。 Java中的字符串池 为了节省空间和资源，JVM会维护一个字符串池，或者说会缓存一部分曾经出现过的字符串。 例如下面的代码：12String v1 = &quot;ab&quot;;String v2 = &quot;ab&quot;; 实际上，v1==v2，因为JVM在v1声明后，已经对“ab”进行了缓存。 那么JVM对字符串进行缓存的依据是什么？我们来看下面的代码，非常有意思： 123456789101112131415161718192021222324252627282930313233public class StringTest &#123; public static final String constValue = "ab"; public static final String staticValue; static &#123; staticValue="ab"; &#125; public static void main(String[] args) &#123; String v1 = "ab"; String v2 = "ab"; System.out.println("v1 == v2 : " + (v1 == v2)); String v3 = new String("ab"); System.out.println("v1 == v3 : " + (v1 == v3)); String v4 = "abcd"; String v5 = "ab" + "cd"; System.out.println("v4 == v5 : " + (v4 == v5)); String v6 = v1 + "cd"; System.out.println("v4 == v6 : " + (v4 == v6)); String v7 = constValue + "cd"; System.out.println("v4 == v7 : " + (v4 == v7)); String v8 = staticValue + "cd"; System.out.println("v4 == v8 : " + (v4 == v8)); String v9 = v4.intern(); System.out.println("v4 == v9 :" + (v4 == v9)); String v10 = new String(new char[]&#123;'a','b','c','d'&#125;); String v11 = v10.intern(); System.out.println("v4 == v11 :" + (v4 == v11)); System.out.println("v10 == v11 :" + (v10 == v11)); &#125;&#125; 请注意它的输出结果： 123456789v1 == v2 : truev1 == v3 : falsev4 == v5 : truev4 == v6 : falsev4 == v7 : truev4 == v8 : falsev4 == v9 :truev4 == v11 :truev10 == v11 :false 我们会发现，并不是所有的判断都返回true，这似乎和我们上面的说法有矛盾了。其实不然，因为 结论 1. JVM只能缓存那些在编译时可以确定的常量，而非运行时常量。 上述代码中的constValue属于编译时常量，而staticValue则属于运行时常量。 2. 通过使用 new方式创建出来的字符串，JVM缓存的方式是不一样的。 所以上述代码中，v1不等同于v3。 String的这种设计属于享元模式吗？ 这个话题比较有意思，大部分讲设计模式的文章，在谈到享元时，一般就会拿String来做例子，但它属于享元模式吗？ 字符串与享元的关系，大家可以参考下面的文章：http://www.cnblogs.com/winter-cn/archive/2012/01/21/2328388.html 字符串的反转输出 这种情况下，一般会将字符串看做是字符数组，然后利用反转数组的方式来反转字符串。 眼花缭乱的方法调用有继承关系结构中的方法调用 继承是面向对象设计中的常见方式，它可以有效的实现”代码复用“，同时子类也有重写父类方法的自由，这就对到底是调用父类方法还是子类方法带来了麻烦。 来看下面的代码： 123456789101112131415161718192021222324252627282930public class PropertyTest &#123; public static void main(String[] args) &#123; ParentDef v1 = new ParentDef(); ParentDef v2 = new ChildDef(); ChildDef v3 = new ChildDef(); System.out.println("=====v1====="); System.out.println("staticValue:" + v1.staticValue); System.out.println("value:" + v1.value); System.out.println("=====v2====="); System.out.println("staticValue:" + v2.staticValue); System.out.println("value:" + v2.value); System.out.println("=====v3====="); System.out.println("staticValue:" + v3.staticValue); System.out.println("value:" + v3.value); &#125;&#125;class ParentDef&#123; public static final String staticValue = "父类静态变量"; public String value = "父类实例变量";&#125;class ChildDef extends ParentDef&#123; public static final String staticValue = "子类静态变量"; public String value = "子类实例变量";&#125; 输出结果如下： 123456789=====v1=====staticValue:父类静态变量value:父类实例变量=====v2=====staticValue:父类静态变量value:父类实例变量=====v3=====staticValue:子类静态变量value:子类实例变量 结论对于调用父类方法还是子类方法，只与变量的声明类型有关系，与实例化的类型没有关系。 到底是值传递还是引用传递 对于这个话题，我的观点是值传递，因为传递的都是存储在栈中的内容，无论是基本类型的值，还是指向堆中对象的指针，都是值而非引用。并且在值传递的过程中，JVM会将值复制一份，然后将复制后的值传递给调用方法。 按照这种方式，我们来看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ParamTest &#123; public void change(int value) &#123; value = 10; &#125; public void change(Value value) &#123; Value temp = new Value(); temp.value = 10; value = temp; &#125; public void add(int value) &#123; value += 10; &#125; public void add(Value value) &#123; value.value += 10; &#125; public static void main(String[] args) &#123; ParamTest test = new ParamTest(); Value value = new Value(); int v = 0; System.out.println("v:" + v); System.out.println("value.value:" + value.value); System.out.println("=====change====="); test.change(v); test.change(value); System.out.println("v:" + v); System.out.println("value.value:" + value.value); value = new Value(); v = 0; System.out.println("=====add====="); test.add(v); test.add(value); System.out.println("v:" + v); System.out.println("value.value:" + value.value); &#125;&#125;class Value&#123; public int value;&#125; 它的输出结果： 12345678v:0value.value:0=====change=====v:0value.value:0=====add=====v:0value.value:10 我们看到，在调用change方法时，即使我们传递进去的是指向对象的指针，但最终对象的属性也没有变，这是因为在change方法体内，我们新建了一个对象，然后将”复制过的指向原对象的指针“指向了“新对象”，并且对新对象的属性进行了调整。但是“复制前的指向原对象的指针”依然是指向“原对象”，并且属性没有任何变化。 final/finally/finalize的区别 final可以修饰类、成员变量、方法以及方法参数。使用final修饰的类是不可以被继承的，使用final修饰的方法是不可以被重写的，使用final修饰的变量，只能被赋值一次。 使用final声明变量的赋值时机： 1. 定义声明时赋值 2. 初始化块或静态初始化块中 3. 构造函数 来看下面的代码： 1234567891011121314151617181920212223class FinalTest&#123; public static final String staticValue1 = "静态变量1"; public static final String staticValue2; static &#123; staticValue2 = "静态变量2"; &#125; public final String value1 = "实例变量1"; public final String value2; public final String value3; &#123; value2 = "实例变量2"; &#125; public FinalTest() &#123; value3 = "实例变量3"; &#125;&#125; finally一般是和try…catch放在一起使用，主要用来释放一些资源。 我们来看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class FinallyTest &#123; public static void main(String[] args) &#123; finallyTest1(); finallyTest2(); finallyTest3(); &#125; private static String finallyTest1() &#123; try &#123; throw new RuntimeException(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; System.out.println("Finally语句被执行"); &#125; try &#123; System.out.println("Hello World"); return "Hello World"; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; System.out.println("Finally语句被执行"); &#125; return null; &#125; private static void finallyTest2() &#123; int i = 0; for (i = 0; i &lt; 3; i++) &#123; try &#123; if (i == 2) break; System.out.println(i); &#125; finally &#123; System.out.println("Finally语句被执行"); &#125; &#125; &#125; private static Test finallyTest3() &#123; try &#123; return new Test(); &#125; finally &#123; System.out.println("Finally语句被执行"); &#125; &#125;&#125; 执行结果如下： 12345678910111213java.lang.RuntimeException at sample.interview.FinallyTest.finallyTest1(FinallyTest.java:16) at sample.interview.FinallyTest.main(FinallyTest.java:7)Finally语句被执行Hello WorldFinally语句被执行0Finally语句被执行1Finally语句被执行Finally语句被执行Test实例被创建Finally语句被执行 注意在循环的过程中，对于某一次循环，即使调用了break或者continue，finally也会执行。 finalize则主要用于释放资源，在调用GC方法时，该方法就会被调用。 来看下面的示例： 1234567891011121314class FinalizeTest&#123; protected void finalize() &#123; System.out.println("finalize方法被调用"); &#125; public static void main(String[] args) &#123; FinalizeTest test = new FinalizeTest(); test = null; Runtime.getRuntime().gc(); &#125;&#125; 执行结果如下： 1finalize方法被调用 关于基本类型的一些事儿 基本类型供分为9种，包括byte/short/int/long/float/double/boolean/void，每种基本类型都对应一个“包装类”，其他一些基本信息如下： 基本类型：byte 二进制位数：8 包装类：java.lang.Byte 最小值：Byte.MIN_VALUE=-128 最大值：Byte.MAX_VALUE=127 基本类型：short 二进制位数：16 包装类：java.lang.Short 最小值：Short.MIN_VALUE=-32768 最大值：Short.MAX_VALUE=32767 基本类型：int 二进制位数：32 包装类：java.lang.Integer 最小值：Integer.MIN_VALUE=-2147483648 最大值：Integer.MAX_VALUE=2147483647 基本类型：long 二进制位数：64 包装类：java.lang.Long 最小值：Long.MIN_VALUE=-9223372036854775808 最大值：Long.MAX_VALUE=9223372036854775807 基本类型：float 二进制位数：32 包装类：java.lang.Float 最小值：Float.MIN_VALUE=1.4E-45 最大值：Float.MAX_VALUE=3.4028235E38 基本类型：double 二进制位数：64 包装类：java.lang.Double 最小值：Double.MIN_VALUE=4.9E-324 最大值：Double.MAX_VALUE=1.7976931348623157E308 基本类型：char 二进制位数：16 包装类：java.lang.Character 最小值：Character.MIN_VALUE=0 最大值：Character.MAX_VALUE=65535 关于基本类型的一些结论（来自《Java面试解惑》）未带有字符后缀标识的整数默认为int类型；未带有字符后缀标识的浮点数默认为double类型。如果一个整数的值超出了int类型能够表示的范围，则必须增加后缀“L”（不区分大小写，建议用大写，因为小写的L与阿拉伯数字1很容易混淆），表示为long型。带有“F”（不区分大小写）后缀的整数和浮点数都是float类型的；带有“D”（不区分大小写）后缀的整数和浮点数都是double类型的。编译器会在编译期对byte、short、int、long、float、double、char型变量的值进行检查，如果超出了它们的取值范围就会报错。int型值可以赋给所有数值类型的变量；long型值可以赋给long、float、double类型的变量；float型值可以赋给float、double类型的变量；double型值只能赋给double类型变量。 关于基本类型之间的转换 下面的转换是无损精度的转换： byte-&gt;shortshort-&gt;intchar-&gt;intint-&gt;longfloat-&gt;double 下面的转换是会损失精度的： int-&gt;floatlong-&gt;floatlong-&gt;double 除此之外的转换，是非法的。 和日期相关的一些事儿 Java中，有两个类和日期相关，一个是Date，一个是Calendar。我们来看下面的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; test1(); test2(); test3(); &#125; private static void test1() throws ParseException &#123; Date date = new Date(); System.out.println(date); DateFormat sf = new SimpleDateFormat("yyyy-MM-dd"); System.out.println(sf.format(date)); String formatString = "2013-05-12"; System.out.println(sf.parse(formatString)); &#125; private static void test2() &#123; Date date = new Date(); System.out.println("Year:" + date.getYear()); System.out.println("Month:" + date.getMonth()); System.out.println("Day:" + date.getDate()); System.out.println("Hour:" + date.getHours()); System.out.println("Minute:" + date.getMinutes()); System.out.println("Second:" + date.getSeconds()); System.out.println("DayOfWeek:" + date.getDay()); &#125; private static void test3() &#123; Calendar c = Calendar.getInstance(); System.out.println(c.getTime()); System.out.println(c.getTimeZone()); System.out.println("Year:" + c.get(Calendar.YEAR)); System.out.println("Month:" + c.get(Calendar.MONTH)); System.out.println("Day:" + c.get(Calendar.DATE)); System.out.println("Hour:" + c.get(Calendar.HOUR)); System.out.println("HourOfDay:" + c.get(Calendar.HOUR_OF_DAY)); System.out.println("Minute:" + c.get(Calendar.MINUTE)); System.out.println("Second:" + c.get(Calendar.SECOND)); System.out.println("DayOfWeek:" + c.get(Calendar.DAY_OF_WEEK)); System.out.println("DayOfMonth:" + c.get(Calendar.DAY_OF_MONTH)); System.out.println("DayOfYear:" + c.get(Calendar.DAY_OF_YEAR)); &#125;&#125; 输出结果如下： 12345678910111213141516171819202122Sat May 11 13:44:34 CST 20132013-05-11Sun May 12 00:00:00 CST 2013Year:113Month:4Day:11Hour:13Minute:44Second:35DayOfWeek:6Sat May 11 13:44:35 CST 2013sun.util.calendar.ZoneInfo[id=&quot;Asia/Shanghai&quot;,offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null]Year:2013Month:4Day:11Hour:1HourOfDay:13Minute:44Second:35DayOfWeek:7DayOfMonth:11DayOfYear:131 需要注意的是，Date中的getxxx方法已经变成deprecated了，因此我们尽量使用calendar.get方法来获取日期的细节信息。 另外，注意DateFormat，它不仅可以对日期的输出进行格式化，而且可以逆向操作，将符合Format的字符串转换为日期类型。 Java的JDBCJDBC相关的话题。 概述 尽管在实际开发过程中，我们一般使用ORM框架来代替传统的JDBC，例如Hibernate或者iBatis，但JDBC是Java用来实现数据访问的基础，掌握它对于我们理解Java的数据操作流程很有帮助。 JDBC的全称是Java Database Connectivity。 JDBC对数据库进行操作的流程： 连接数据库 发送数据请求，即传统的CRUD指令 返回操作结果集 JDBC中常用的对象包括： ConnectionManager Connection Statement CallableStatement PreparedStatement ResultSet SavePoint 一个简单JDBC示例 我们来看下面一个简单的示例，它使用JDK自带的Derby数据库，创建一张表，插入一些记录，然后将记录返回： 1234567891011121314151617181920212223242526272829303132333435private static void test1() throws SQLException&#123; String driver = "org.apache.derby.jdbc.EmbeddedDriver"; String dbURL = "jdbc:derby:EmbeddedDB;create=true"; Connection con = null; Statement st = null; try &#123; Class.forName(driver); con = DriverManager.getConnection(dbURL); st = con.createStatement(); st.execute("create table foo(ID INT NOT NULL, NAME VARCHAR(30))"); st.executeUpdate("insert into foo(ID,NAME) values(1, 'Zhang San')"); ResultSet rs = st.executeQuery("select ID,NAME from foo"); while(rs.next()) &#123; int id = rs.getInt("ID"); String name = rs.getString("NAME"); System.out.println("ID=" + id + "; NAME=" + name); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; if (st != null) st.close(); if (con != null) con.close(); &#125;&#125; 如何建立数据库连接 上面的示例代码中，建立数据库连接的部分如下： 12345String driver = &quot;org.apache.derby.jdbc.EmbeddedDriver&quot;;String dbURL = &quot;jdbc:derby:EmbeddedDB;create=true&quot;;Class.forName(driver);con = DriverManager.getConnection(dbURL); 建立数据库连接的过程，可以分为两步： 1. 加载数据库驱动，即上文中的driver以及Class.forName(dirver) 2. 定位数据库连接字符串， 即dbURL以及DriverManager.getConnection(dbURL) 不同的数据库，对应的dirver和dbURL不同，但加载驱动和建立连接的方式是相同的，即只需要修改上面driver和dbURL的值就可以了。 自动加载数据库驱动 如果我们每次建立连接时，都要使用Class.forName(…)来手动加载数据库驱动，这样会很麻烦，我们可以通过配置文件的方式，来保存数据库驱动的信息。 我们可以在classpath中，即编译出来的.class的存放路径，添加如下文件： 1META-INF\services\java.sql.Driver 对应的内容就是JDBC驱动的全路径，也就是上面driver变量的值： 1org.apache.derby.jdbc.EmbeddedDriver 接下来，我们在程序中，就不需要再显示的用Class.forName(…)来加载驱动了，它会被自动加载进来，当我们的数据库发生变化时，只需要修改这个文件就可以了，例如当我们的数据库由Derby变为MySQL时，只需要将上述的配置修改为： 1com.mysql.jdbc.Driver 但是，需要注意一点，这里只是配置了JDBC驱动的全路径，并没有包含jar文件的信息，因此，我们还是需要将包含该驱动的jar文件手动的放置到程序的classpath中。 JDBC中的基本操作 对于数据库操作来说，CRUD操作应该是最常见的操作了， 即我们常说的增、删、查、改。 JDBC是使用Statement和ResultSet来完成这些操作的。 如何实现CRUD 下面是JDBC实现基本的CRUD示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static void insertTest() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); st.execute("insert into user(ID,NAME) values(1, 'Zhang San')"); st.execute("insert into user(ID,NAME) values(2, 'Li Si')"); st.execute("insert into user(ID,NAME) values(3, 'Wang Wu')"); System.out.println("=====insert test====="); showUser(st); st.close(); con.close();&#125;private static void deleteTest() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); st.execute("delete from user where ID=3"); System.out.println("=====delete test====="); showUser(st); st.close(); con.close();&#125;private static void updateTest() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); st.executeUpdate("update user set NAME='TEST' where ID=2"); System.out.println("=====update test====="); showUser(st); st.close(); con.close();&#125;private static void showUser(Statement st) throws SQLException&#123; ResultSet rs = st.executeQuery("select ID, NAME from user"); while(rs.next()) &#123; int id = rs.getInt("ID"); String name = rs.getString("NAME"); System.out.println("ID:" + id + "; NAME=" + name); &#125; rs.close();&#125; 我们顺序调用上面的测试方法： 123insertTest();deleteTest();updateTest(); 执行结果如下： 12345678910=====insert test=====ID:1; NAME=Zhang SanID:2; NAME=Li SiID:3; NAME=Wang Wu=====delete test=====ID:1; NAME=Zhang SanID:2; NAME=Li Si=====update test=====ID:1; NAME=Zhang SanID:2; NAME=TEST 上面代码中的showUser方法会把user表中的所有记录打印出来。 如何调用存储过程 存储过程是做数据库开发时经常使用的技术，它可以通过节省编译时间的方式来提升系统性能，我们这里的示例使用MySQL数据库。 如何调用不带参数的存储过程 假设我们现在有一个简单的存储过程，它只是返回user表中的所有记录，存储过程如下： 1234CREATE DEFINER=`root`@`localhost` PROCEDURE `GetUser`()BEGINselect ID,NAME from user;END 我们可以使用CallableStatement来调用存储过程： 调用存储过程示例一 1234567891011121314151617private static void execStoredProcedureTest() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); CallableStatement cst = con.prepareCall("call GetUser()"); ResultSet rs = cst.executeQuery(); while(rs.next()) &#123; int id = rs.getInt("ID"); String name = rs.getString("NAME"); System.out.println("ID:" + id + "; NAME=" + name); &#125; rs.close(); cst.close(); con.close();&#125; 它的执行结果如下： 12ID:1; NAME=Zhang SanID:2; NAME=TEST 如何调用带参数的存储过程 MySQL的存储过程中的参数分为三种：in/out/inout，我们可以把in看做入力参数，out看做出力参数，JDBC对这两种类型的参数设置方式不同： in， JDBC使用类似于cst.set(1, 10)的方式来设置 out，JDBC使用类似于cst.registerOutParameter(2, Types.VARCHAR);的方式来设置 我们来看一个in参数的示例，假设我们希望返回ID为特定值的user信息，存储过程如下： 123456CREATE DEFINER=`root`@`localhost` PROCEDURE `GetUserByID`(in id int)BEGINset @sqlstr=concat('select * from user where ID=', id);prepare psmt from @sqlstr;execute psmt;END Java的调用代码如下： JDBC调用存储过程示例二 1234567891011121314151617private static void execStoredProcedureTest2(int id) throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); CallableStatement cst = con.prepareCall("call GetUserByID(?)"); cst.setInt(1, id); ResultSet rs = cst.executeQuery(); while(rs.next()) &#123; String name = rs.getString("NAME"); System.out.println("ID:" + id + "; NAME=" + name); &#125; rs.close(); cst.close(); con.close();&#125; 我们执行下面的语句： 1execStoredProcedureTest2(1); 结果如下： 1ID:1; NAME=Zhang San 对于out类型的参数，调用方式类似，不再赘述。 获取数据库以及结果集的metadata信息 在JDBC中，我们不仅能够对数据进行操作，我们还能获取数据库以及结果集的元数据信息，例如数据库的名称、驱动信息、表信息；结果集的列信息等。 获取数据库的metadata信息 我们可以通过connection.getMetaData方法来获取数据库的元数据信息，它的类型是DatabaseMetaData。 获取数据库的元数据信息 1234567891011121314151617181920private static void test1() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/mysql"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); DatabaseMetaData dbmd = con.getMetaData(); System.out.println("数据库：" + dbmd.getDatabaseProductName() + " " + dbmd.getDatabaseProductVersion()); System.out.println("驱动程序：" + dbmd.getDriverName() + " " + dbmd.getDriverVersion()); ResultSet rs = dbmd.getTables(null, null, null, null); System.out.println(String.format("|%-26s|%-9s|%-9s|%-9s|", "表名称","表类别","表类型","表模式")); while(rs.next()) &#123; System.out.println(String.format("|%-25s|%-10s|%-10s|%-10s|", rs.getString("TABLE_NAME"),rs.getString("TABLE_CAT"), rs.getString("TABLE_TYPE"), rs.getString("TABLE_SCHEM"))); &#125;&#125; 这里我们使用的数据库是MySQL中自带的默认数据库：mysql，它会记录整个数据库服务器中的一些信息。上述代码执行结果如下： 12345678数据库：MySQL 5.5.28驱动程序：MySQL-AB JDBC Driver mysql-connector-java-5.0.4 ( $Date: 2006-10-19 17:47:48 +0200 (Thu, 19 Oct 2006) $, $Revision: 5908 $ )|表名称 |表类别 |表类型 |表模式 ||columns_priv |mysql |TABLE |null ||db |mysql |TABLE |null ||event |mysql |TABLE |null ||func |mysql |TABLE |null |。。。 由于mysql中表比较多，上述结果只截取了一部分。 获取结果集的元数据信息 我们可以通过使用resultset.getMetaData方法来获取结果集的元数据信息，它的类型是ResultSetMetaData。 获取结果集的元数据信息 12345678910111213private static void test2() throws SQLException&#123; String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); ResultSet rs = st.executeQuery("select ID, NAME from user"); ResultSetMetaData rsmd = rs.getMetaData(); for (int i = 1; i &lt;= rsmd.getColumnCount(); i++) &#123; System.out.println("Column Name:" + rsmd.getColumnName(i) + "; Column Type:" + rsmd.getColumnTypeName(i)); &#125;&#125; 它的执行结果如下： 12Column Name:ID; Column Type:INTEGER UNSIGNEDColumn Name:NAME; Column Type:VARCHAR 可以看到，它返回类结果集中每一列的名称和类型。 基于ResultSet的操作 当我们需要对数据库进行修改时，除了上述通过Statement完成操作外，我们也可以借助ResultSet来完成。 需要注意的是，在这种情况下，我们定义Statement时，需要添加参数。 Statement构造函数可以包含3个参数： resultSetType，它的取值包括：ResultSet.TYPE_FORWARD_ONLY、ResultSet.TYPE_SCROLL_INSENSITIVE 或 ResultSet.TYPE_SCROLL_SENSITIVE，默认情况下，该参数的值是ResultSet.TYPE_FORWARD_ONLY。 resultSetConcurrency，它的取值包括：ResultSet.CONCUR_READ_ONLY 或 ResultSet.CONCUR_UPDATABLE，默认情况下，该参数的值是ResultSet.CONCUR_READ_ONLY。 resultSetHoldability，它的取值包括：ResultSet.HOLD_CURSORS_OVER_COMMIT 或 ResultSet.CLOSE_CURSORS_AT_COMMIT。 为了使得ResultSet能够对数据进行操作我们需要： 将resultSetType设置为ResultSet.TYPE_SCROLL_SENSITIVE。 将resultSetConcurrency设置为ResultSet.CONCUR_UPDATABLE。 在通过ResultSet对数据进行调整的过程中，下面方法可能会被调用： resultset.last() resultset.first() resultset.moveToInsertRow() resultset.absolute() resultset.setxxx() resultset.updateRow() resultset.insertRow() 下面是一个通过ResultSet对数据进行增、删、改的示例： 通过ResultSet对数据进行增、删、改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private static void getResultCount() throws SQLException&#123; System.out.println("=====Result Count====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY, ResultSet.CLOSE_CURSORS_AT_COMMIT); ResultSet rs = st.executeQuery("select * from user"); rs.last(); System.out.println("返回结果的条数："+ rs.getRow()); rs.first(); rs.close(); st.close(); con.close();&#125;private static void insertDataToResultSet() throws SQLException&#123; System.out.println("=====Insert====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); ResultSet rs = st.executeQuery("select ID,NAME from user"); rs.moveToInsertRow(); rs.updateInt(1, 4); rs.updateString(2, "Xiao Ming"); rs.insertRow(); showUser(st); rs.close(); st.close(); con.close();&#125;private static void updateDataToResultSet() throws SQLException&#123; System.out.println("=====Update====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); ResultSet rs = st.executeQuery("select * from user"); rs.last(); int count = rs.getRow(); rs.first(); rs.absolute(count); rs.updateString(2, "Xiao Qiang"); rs.updateRow(); showUser(st); rs.close(); st.close(); con.close();&#125;private static void delDataFromResultSet() throws SQLException&#123; System.out.println("=====Delete====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE, ResultSet.CLOSE_CURSORS_AT_COMMIT); ResultSet rs = st.executeQuery("select * from user"); rs.last(); int count = rs.getRow(); rs.first(); rs.absolute(count); rs.deleteRow(); showUser(st); rs.close(); st.close(); con.close();&#125; 分别调用上述方法： 12341 getResultCount();2 insertDataToResultSet();3 updateDataToResultSet();4 delDataFromResultSet(); 执行结果如下： 12345678910111213=====Result Count=====返回结果的条数：2=====Insert=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:4; NAME=Xiao Ming=====Update=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:4; NAME=Xiao Qiang=====Delete=====ID:1; NAME=Zhang SanID:2; NAME=TEST 可以看到我们对ID为4的记录进行了插入、更新和删除操作。 预处理以及批处理 预处理和批处理都是用来提升系统性能的方式，一种是利用数据库的缓存机制，一种是利用数据库一次执行多条语句的方式。 预处理 数据库服务器接收到Statement后，一般会解析Statement、分析是否有语法错误、定制最优的执行计划，这个过程可能会降低系统的性能。一般的数据库服务器都这对这种情况，设计了缓存机制，当数据库接收到指令时，如果缓存中已经存在，那么就不再解析，而是直接运行。 这里相同的指令是指sql语句完全一样，包括大小写。 JDBC使用PreparedStatement来完成预处理： 12345678910111213private static void test1() throws SQLException&#123; System.out.println("=====Insert a single record by PreparedStatement====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); PreparedStatement pst = con.prepareStatement("insert into user(id,name) values(?,?)"); pst.setInt(1, 5); pst.setString(2, "Lei Feng"); pst.executeUpdate(); showUser(pst); pst.close(); con.close();&#125; 执行结果如下： 1234=====Insert a single record by PreparedStatement=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei Feng 批处理 批处理是利用数据库一次执行多条语句的机制来提升性能，这样可以避免多次建立连接带来的性能损失。 批处理使用Statement的addBatch来添加指令，使用executeBatch方法来一次执行多条指令： 1234567891011121314private static void test2() throws SQLException&#123; System.out.println("=====Insert multiple records by Statement &amp; Batch====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); st.addBatch("insert into user(id,name) values(6,'Xiao Zhang')"); st.addBatch("insert into user(id,name) values(7,'Xiao Liu')"); st.addBatch("insert into user(id,name) values(8,'Xiao Zhao')"); st.executeBatch(); showUser(st); st.close(); con.close();&#125; 执行结果如下： 1234567=====Insert multiple records by Statement &amp; Batch=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:6; NAME=Xiao ZhangID:7; NAME=Xiao LiuID:8; NAME=Xiao Zhao 预处理和批处理相结合 我们可以把预处理和批处理结合起来，利用数据库的缓存机制，一次执行多条语句： 1234567891011121314151617181920private static void test3() throws SQLException&#123; System.out.println("=====Insert multiple records by PreparedStatement &amp; Batch====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); PreparedStatement pst = con.prepareStatement("insert into user(id,name) values(?,?)"); pst.setInt(1, 9); pst.setString(2, "Xiao Zhang"); pst.addBatch(); pst.setInt(1, 10); pst.setString(2, "Xiao Liu"); pst.addBatch(); pst.setInt(1, 11); pst.setString(2, "Xiao Zhao"); pst.addBatch(); pst.executeBatch(); showUser(pst); pst.close(); con.close();&#125; 执行结果如下： 1234567=====Insert multiple records by PreparedStatement &amp; Batch=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:9; NAME=Xiao ZhangID:10; NAME=Xiao LiuID:11; NAME=Xiao Zhao 数据库事务 谈到数据库开发，事务是一个不可回避的话题，JDBC默认情况下，是每一步都自动提交的，我们可以通过设置connection.setAutoCommit(false)的方式来强制关闭自动提交，然后通过connection.commit()和connection.rollback()来实现事务提交和回滚。 简单的数据库事务 下面是一个简单的数据库事务的示例： 12345678910111213141516171819202122232425private static void transactionTest1() throws SQLException&#123; System.out.println("=====Simple Transaction test====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); try &#123; con.setAutoCommit(false); st.executeUpdate("insert into user(id,name) values(12, 'Xiao Li')"); con.commit(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); con.rollback(); &#125; finally &#123; con.setAutoCommit(true); showUser(st); if (st != null) st.close(); if (con != null) con.close(); &#125;&#125; 连续执行上述方法两次，我们可以得出下面的结果： 1234567891011121314151617181920=====Simple Transaction test=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:12; NAME=Xiao Li=====Simple Transaction test=====ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:12; NAME=Xiao Licom.mysql.jdbc.exceptions.MySQLIntegrityConstraintViolationException: Duplicate entry &apos;12&apos; for key &apos;PRIMARY&apos; at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:931) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:2870) at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1573) at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:1665) at com.mysql.jdbc.Connection.execSQL(Connection.java:3170) at com.mysql.jdbc.Statement.executeUpdate(Statement.java:1316) at com.mysql.jdbc.Statement.executeUpdate(Statement.java:1235) at sample.jdbc.mysql.ResultSetSample.transactionTest1(ResultSetSample.java:154) at sample.jdbc.mysql.ResultSetSample.main(ResultSetSample.java:17) 可以看到，第一次调用时，操作成功，事务提交，向user表中插入了一条记录；第二次调用时，发生主键冲突异常，事务回滚。 带有SavePoint的事务 当我们的事务操作中包含多个处理，但我们有时希望一些操作完成后可以先提交，这样可以避免整个事务的回滚。JDBC使用SavePoint来实现这一点。 123456789101112131415161718192021222324252627282930private static void transactionTest2() throws SQLException&#123; System.out.println("=====Simple Transaction test====="); String dbURL = "jdbc:mysql://localhost/test"; Connection con = DriverManager.getConnection(dbURL, "root", "123"); Statement st = con.createStatement(); Savepoint svpt = null; try &#123; con.setAutoCommit(false); st.executeUpdate("insert into user(id,name) values(13, 'Xiao Li')"); st.executeUpdate("insert into user(id,name) values(14, 'Xiao Wang')"); svpt = con.setSavepoint("roll back to here"); st.executeUpdate("insert into user(id,name) values(15, 'Xiao Zhao')"); st.executeUpdate("insert into user(id,name) values(13, 'Xiao Li')"); con.commit(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); con.rollback(svpt); &#125; finally &#123; con.setAutoCommit(true); showUser(st); if (st != null) st.close(); if (con != null) con.close(); &#125;&#125; 执行结果如下： 12345678910111213141516=====Simple Transaction test=====com.mysql.jdbc.exceptions.MySQLIntegrityConstraintViolationException: Duplicate entry &apos;13&apos; for key &apos;PRIMARY&apos; at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:931) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:2870) at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1573) at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:1665) at com.mysql.jdbc.Connection.execSQL(Connection.java:3170) at com.mysql.jdbc.Statement.executeUpdate(Statement.java:1316) at com.mysql.jdbc.Statement.executeUpdate(Statement.java:1235) at sample.jdbc.mysql.ResultSetSample.transactionTest2(ResultSetSample.java:185) at sample.jdbc.mysql.ResultSetSample.main(ResultSetSample.java:18)ID:1; NAME=Zhang SanID:2; NAME=TESTID:5; NAME=Lei FengID:13; NAME=Xiao LiID:14; NAME=Xiao Wang 可以看到最终事务报出了主键冲突异常，事务回滚，但是依然向数据库中插入了ID为13和14的记录。 另外，在确定SavePoint后，ID为15的记录并没有被插入，它是通过事务进行了回滚。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我36岁了，除了收费啥都不会]]></title>
    <url>%2Fblog%2F38019.html</url>
    <content type="text"><![CDATA[我身边就有很多追求所谓稳定工作的人：干着没有挑战性的工作，拿着没有竞争力的薪水，但他们滋润而且满足。作者说，追求稳定，你只能在稳定中死去。你怎么看？ 河北唐山市地方政府为人民办了一件好事，把地方的各个路桥收费站取消了，这种收费站很多人头疼已久，莫名奇妙地收费不说，还是造成道路拥堵的源头，好好的公路，隔段时间就要被迫停下交费，市有市界，县有县界，实际上已经成为大家出行的一个阻碍，对于从事交通运输业的人来说，更是阻碍发展的一大杀手。 之所以搞运输越来越不赚钱，就是因为这些拦路虎的存在，把本来就微薄的利润降到了最低。 所以，取消路桥收费站这事可谓大快人心，但是有些人却不满意了，这些人就是收费站的工作人员。网上流传的一个视频里显示，这些收费人员围住了领导要一个说法，在人社局已经按照《劳动法》给予经济补偿的情况下，要求政府解决工作。 而且其中一位姐姐振振有词，“我今年36了，我的青春都交给收费了，我现在啥也不会，也没人喜欢我们，我也学不了什么东西了。” 这样的言辞听起来令人瞠目结舌，不知道这位只有36岁的员工大姐，哪来的自信，在这个任何人都可能被随时淘汰的时代，敢说自己除了收费啥也不会，而且也学不会了。 对她，我们只能怒其不争，哀其不幸，可怜之人必有可恨之处。这位收费员大姐工资不高，工作技能也没有，认知范围也有限，固然有可悲之处。 但是同时我们也要看到，有多少高薪高知高技能的职场人，在30多岁的时候，也同样会遭遇工作危机，本来高枕无忧的生活一下子跌入谷底，有些甚至万劫不复。比如前不久跳楼的中兴程序员，比如华为清理的35岁员工，比如高盛那些被AI取代的交易员。 所有稳定工作都是高风险职业追求稳定，你只能在稳定中死去 很多人以为的稳定，其实根本不是稳定。 收费站的收费员这种工作，不要看不起眼，薪资也不高，但是，很多人不知道的是，有很多人，为了这样一份工作，甘愿花上十几万甚至几十万元，去疏通关系，走后门来获取这样一个职位。 为什么？就是因为在他们看来，清闲事少，稳定。但是这种稳定不叫稳定，这叫偷懒，叫一成不变的混日子。希望不用付出太多努力就能获得长期可持续的、足够维持舒适生活的收入。 这种稳定，如果能叫做稳定的话，只能叫稳定地受穷，在贫困中慢慢地温水煮青蛙。可以想见，对这些收费员而言，20年前的时候，当她们青春年少，2000-3000元的工作，还能让他们维持相对还算体面的生活，他们所说的，青春交给收费站，其实就是蹉跎青春，浪费时间在一个单调重复的工作上，心安理得地混日子。 所有稳定的工作都有一个特点，缺乏高强度的竞争。那么其另一面就是，市场也绝不会给你有竞争力的薪酬，你的薪资不与能力挂钩。 但是20年过去了，即使不发生任何结构性的变化，在别人的行业随着业绩节节攀升的时候，你的薪资还是雷打不动，单是这二十年间，物价的上涨已经把你的稳定变得一无是处，所以，你所谓的稳定不过是稳定地受穷。 稳定就是躺在舒适区当年，我曾经也有一个获得稳定工作的机会。刚毕业时，我们能去的最好的公司都是发电厂、设计院。那时候，我已经拿到一个发电厂的offer，但最后犹豫再三还是拒绝了，那个公司的人事非常惊讶，他说，“从来没有人在拿到offer后拒绝我们”。 确实，那是一个理想的职业，薪酬高，休息时间多，福利多，公司基本都是校友，面试我的人就连未来公司篮球队的位置都给我了，连业余时间都包办，可以说除了老婆不发啥都发。 但在最后签约的那个晚上我却犹豫了，只要想想稳定在一个地方，几乎放弃与外界的接触，交往的都是一个系统内的人，我就不寒而栗，最终在HR的不解中放弃了那个工作。 不是所有的稳定都是受穷，但是如同华为的程序员，中兴的工程师们，外企的中层们一样，稳定的最大问题在于形成了一个舒适区，而通常只有极少数意志坚韧的家伙，可以突破舒适区。 呆在舒适区没有什么不对，实际上，所有人都乐于呆在舒适区，但是，不幸的是，我们处于有史以来变动最快的时代。 工业革命之前的古人，在他们有生之年甚至祖孙几代之间，他们生活的世界可能从来不会发生变化，所以木匠的儿子是木匠，木匠的孙子还是木匠，木匠的孙子可以完全使用跟爷爷一样的手艺谋生。 而第一次工业革命到第二次工业革命之间经历了100年，第二次工业革命到第三次工业革命之间有50年。在第三次工业革命之前，一个人如果足够幸运，他的工作经验，还能够支撑他完整地度过一个平稳的30年。 但是，我们已经没有这样的幸运了，或者说，我们比古人更幸运了，我们的寿命足够长，而世界的变化足够大。在我们的一生中，我们甚至要经历最少两次的重大改变，而这种改变，任何一次抓住机会都意味着巨大的财富和成功，但同时，也意味着，任何一次跟不上时代，都意味着你要被历史的车轮狠狠碾轧。 这是一个对年轻人非常友好的时代，同时，这是一个对老年人和中年人非常残酷的时代。 所有的老板都如女人一样，喜欢体力好耐操的小奶狗，等你的精力、体力大不如前，等你的经验落后，等你的知识更新速度比不上年轻人，危机也就随之而来。 真正的稳定不是来自外界，而是把命运把握在自己手里在这样的时代，没有人可以说自己学不会了，可以不学习，不学习的唯一结果就是被其他人抛弃。 真正的稳定不是来自外界的施舍，不是来自于体制的庇护，而是来自于自身，把命运把握在自己手里才是稳定。 任何一个行业，任何一个职业与人一样，都有他的生老病死。 新华字典上有句话，“张华考上了北京大学；李萍进了中等技术学校；我在百货公司当售货员：我们都有光明的前途。” 我父亲曾经是当地百货大楼的副经理，那时候的百货大楼，员工守则贴在柜台上，其中第一条就是：不准殴打顾客。 那时候的售货员，是人人羡慕的职业，殴打顾客的事，是常有发生的，我父亲主要的工作之一是给柜员做思想工作，让他们承认打人有错。 就是在这种背景之下，我父亲一直在坚持学习财务和打字，很早就放弃了这种工作，找到一个机会调入了政府。当时的政府干部，待遇远远比不上售货员，当时的所有人都觉得他疯了。 但没有几年，当他在政府开始站稳脚跟，百货公司转入市场竞争，曾经那些趾高气昂不可一世的同事一下子从天之骄子变成了市场的弃儿。 真正的稳定是你在风暴之前就未雨绸缪，抓住机会学习，野蛮生长，而不是说燕雀处堂不知大厦之将倾，在你最好的年华，满足于优越感和舒适区。 在这个时代，你的工作会背叛你，你的行业会背叛你，你的专业会背叛你，唯一不能背叛你的，是你的认知和你的能力。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Assert断言工具类使用]]></title>
    <url>%2Fblog%2F11911.html</url>
    <content type="text"><![CDATA[Web 应用在接受表单提交的数据后都需要对其进行合法性检查，如果表单数据不合法，请求将被驳回。类似的，当我们在编写类的方法时，也常常需要对方法入参进行合法性检查，如果入参不符合要求，方法将通过抛出异常的方式拒绝后续处理。org.springframework.util.Assert Assert断言工具类，通常用于数据合法性检查. 平时做判断123if (message== null || message.equls("")) &#123; throw new IllegalArgumentException("输入信息错误!"); &#125; 用Assert工具类简化：1Assert.hasText((message, "输入信息错误!"); Assert 类的常用断言方法：123456Assert.notNull(Object object, "object is required") - 对象非空 Assert.isTrue(Object object, "object must be true") - 对象必须为true Assert.notEmpty(Collection collection, "collection must not be empty") - 集合非空 Assert.hasLength(String text, "text must be specified") - 字符不为null且字符长度不为0 Assert.hasText(String text, "text must not be empty") - text 不为null且必须至少包含一个非空格的字符 Assert.isInstanceOf(Class clazz, Object obj, "clazz must be of type [clazz]") - obj必须能被正确造型成为clazz 指定的类 举一个例子：有一个根据文件名获取输入流的方法：InputStream getData(String file)，为了使方法能够成功执行，必须保证 file 入参不能为 null 或空白字符，否则根本无须进行后继的处理。这时方法的编写者通常会在方法体的最前面编写一段对入参进行检测的代码，如下所示： 123456public InputStream getData(String file) &#123; if (file == null || file.length() == 0|| file.replaceAll("\\s", "").length() == 0) &#123; throw new IllegalArgumentException("file入参不是有效的文件地址"); &#125; … &#125; 类似以上检测方法入参的代码是非常常见，但是在每个方法中都使用手工编写检测逻辑的方式并不是一个好主意。阅读 Spring 源码，您会发现 Spring 采用一个 org.springframework.util.Assert 通用类完成这一任务。 Assert 翻译为中文为“断言”，使用过 JUnit的读者都熟知这个概念，它断定某一个实际的运行值和预期想一样，否则就抛出异常。Spring对方法入参的检测借用了这个概念，其提供的 Assert 类拥有众多按规则对方法入参进行断言的方法，可以满足大部分方法入参检测的要求。这些断言方法在入参不满足要求时就会抛出 IllegalArgumentException。下面，我们来认识一下 Assert 类中的常用断言方法： Spring Assert的所有方法：断言方法 说明 notNull(Object object) 当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null； isTrue(boolean expression) / isTrue(boolean expression, String message) 当 expression 不为 true 抛出异常； notEmpty(Collection collection) / notEmpty(Collection collection, String message) 当集合未包含元素时抛出异常。notEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断； hasLength(String text) / hasLength(String text, String message) 当 text 为 null 或长度为 0 时抛出异常； hasText(String text) / hasText(String text, String message) text 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常； isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message) 如果 obj 不能被正确造型为 clazz 指定的类将抛出异常； isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message) subType 必须可以按类型匹配于 superType，否则将抛出异常； 使用 Assert 断言类可以简化方法入参检测的代码，如 InputStream getData(String file) 在应用 Assert 断言类后，其代码可以简化为以下的形式： 12345public InputStream getData(String file)&#123; Assert.hasText(file,"file入参不是有效的文件地址"); ① 使用 Spring 断言类进行方法入参检测 … &#125; 只记录这么多，具体自己去找Spring的工具类（import org.springframework.util.Assert） 查阅API http://www.apihome.cn/api/spring/Assert.html]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis CI持续集成Github]]></title>
    <url>%2Fblog%2F60076.html</url>
    <content type="text"><![CDATA[Travis CI 介绍CI即持续集成系统。对个人而言，就是让你的代码在提交到远程(这里是GitHub)，立即自动编译，自动化测试、自动部署等。 不需要在担心更换电脑时，还要从新部署环境的问题，只要你能向远程推送文章，其他的事情就都可以交给Travis CI处理就ok了。 Travis CI 使用默认前提是已经通过Github进行授权登录Travis网站，并关联了GitHub上的仓库和相关配置。 增加以下文件：gulpfile.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108(function() &#123; 'use strict'; var gulp = require('gulp'), less = require('gulp-less'), rename = require('gulp-rename'), minifycss = require('gulp-minify-css'), autoprefixer = require('gulp-autoprefixer'), uglify = require('gulp-uglify'), jshint = require('gulp-jshint'), stylish = require('jshint-stylish'), notify = require('gulp-notify'), plumber = require('gulp-plumber'), htmlclean = require('gulp-htmlclean'), htmlmin = require('gulp-htmlmin'), rev = require('gulp-rev-append'), sequence = require('gulp-sequence'), path = require('path'), paths = &#123; root: './', source: './themes/snippet/source/' //主题下原文件 &#125; /*==================================================== 开发主题 ====================================================*/ // CSS预处理 gulp.task('less-task', function() &#123; return gulp.src(paths.source + 'css/less/_style.less') .pipe(plumber(&#123; errorHandler: notify.onError('Error: &lt;%= error.message %&gt;') &#125;)) .pipe(less()) .pipe(rename(&#123;basename: "style"&#125;)) .pipe(gulp.dest(paths.source + 'css')) .pipe(notify(&#123;message: 'less compile complete'&#125;)); &#125;); // 校验JS语法和风格 gulp.task('js-task', function() &#123; return gulp.src(paths.source + 'js/*.js') .pipe(jshint()) .pipe(jshint.reporter(stylish)) .pipe(gulp.dest(paths.source + 'js/')) .pipe(notify(&#123;message: 'js compile complete'&#125;)); &#125;); // 监听任务-主题开发模式 gulp.task('dev', function() &#123; gulp.watch(paths.source + 'css/less/*.less', ['less-task']); gulp.watch(paths.source + 'js/*.js', ['js-task']); &#125;); /*==================================================== 部署前代码处理 ====================================================*/ // 压缩处理 css gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(autoprefixer(&#123; browsers: ['last 10 versions', 'Firefox &gt;= 20', 'Opera &gt;= 36', 'ie &gt;= 9', 'Android &gt;= 4.0', ], cascade: true, //是否美化格式 remove: false //是否删除不必要的前缀 &#125;)) .pipe(minifycss()) .pipe(gulp.dest('./public')) .pipe(notify(&#123;message: 'css minify complete'&#125;)); &#125;); // 压缩处理 js gulp.task('minify-js', function() &#123; return gulp.src('./public/js/*.js') .pipe(uglify()) .pipe(gulp.dest('./public/js')) .pipe(notify(&#123;message: 'js minify complete'&#125;)); &#125;); // 压缩处理 html gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true &#125;)) .pipe(gulp.dest('./public')); &#125;); // 添加版本号 gulp.task('rev', function() &#123; return gulp.src('./public/**/*.html') .pipe(rev()) .pipe(gulp.dest('./public')); &#125;); // 同步执行task gulp.task('deploy',sequence(['minify-css','minify-js'],'rev','minify-html')); // 部署前代码处理 gulp.task('default',['deploy'],function(e)&#123; console.log("[complete] please execute： hexo d"); &#125;)&#125;)(); travis.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647language: node_jsnode_js: stablesudo: false #cachecache: directories: - "node_modules"notifications: email: recipients: - snippet@91h5.cc on_success: never on_failure: always# S: Build Lifecycleinstall: - npm install# - gem install travis# - travis login --pro --github-token $&#123;GH_TOKEN&#125;before_script: - export TZ='Asia/Shanghai' - npm install -g gulp - chmod +x _travis.shscript: - hexo clean &amp;&amp; hexo g - gulp after_success: # - LAST_BUILD_NUMBER=68 # - for i in $(seq 1 $LAST_BUILD_NUMBER ); do travis logs $i --delete --force ; doneafter_script: - ./_travis.sh# E: Build LifeCyclebranches: only: - devenv: global: - GH_REF: github.com/shenliyang/shenliyang.github.io.git travis.sh 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#--------------------------------------------#!/bin/bash# author：shenliyang# website：https://github.com/shenliyang# slogan：梦想还是要有的，万一实现了呢。#--------------------------------------------#定义时间time=`date +%Y-%m-%d\ %H:%M:%S`#执行成功function success()&#123; echo "success"&#125;#执行失败function failure()&#123; echo "failure"&#125;#默认执行function default()&#123; git clone https://$&#123;GH_REF&#125; .deploy_git cd .deploy_git git checkout master cd ../ mv .deploy_git/.git/ ./public/ cd ./publiccat &lt;&lt;EOF &gt;&gt; README.md 部署状态 | 集成结果 | 参考值---|---|---完成时间 | $time | yyyy-mm-dd hh:mm:ss部署环境 | $TRAVIS_OS_NAME + $TRAVIS_NODE_VERSION | window \| linux + stable部署类型 | $TRAVIS_EVENT_TYPE | push \| pull_request \| api \| cron启用Sudo | $TRAVIS_SUDO | false \| true仓库地址 | $TRAVIS_REPO_SLUG | owner_name/repo_name提交分支 | $TRAVIS_COMMIT | hash 16位提交信息 | $TRAVIS_COMMIT_MESSAGE |Job ID | $TRAVIS_JOB_ID | Job NUM | $TRAVIS_JOB_NUMBER | EOF git init git config user.name "shenliyang" git config user.email "" git add . git commit -m "Build by Travis CI" git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:master&#125; case $1 in "success") success ;; "failure") failure ;; *) default esac 配置travis.yml 文件 123456789101112131415161718192021222324252627282930313233343536373839404142language: node_js #使用Node语言环境node_js: stable #安装稳定版Nodesudo: false #cache 启用缓存，加快构建速度cache: directories: - "node_modules"notifications: #启用通知 email: recipients: - snippet@91h5.cc #接收构建消息的邮件 不需要可设置为false on_success: never #部署成功时，可设置alway never change on_failure: always #部署失败时，同上# S: Build Lifecycleinstall: - npm install #安装依赖before_script: - export TZ='Asia/Shanghai' #设置时区 - npm install -g gulp #安装Gulp - chmod +x _travis.sh #授权脚本执行权限script: - hexo clean &amp;&amp; hexo g #清除缓存并生成静态文件 - gulp #执行gulp任务after_success: #实行成功时(以后扩展功能使用)after_script: - ./_travis.sh #执行部署脚本# E: Build LifeCyclebranches: only: - dev #需要监听部署的分支env: global: - GH_REF: github.com/shenliyang/shenliyang.github.io.git #更改为自己git地址 提交代码到Github，实现自动部署当 .travis.yml 配置文件修改完成后，将其提交到远程仓库的 hexo 分支下，此时如果之前的配置一切ok，我们应该能在 Travis CI 的博客项目主页页面中看到自动构建已经在开始执行了。上面会显示出构建过程中的日志信息及状态等。]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS单点登录（二）]]></title>
    <url>%2Fblog%2F54220.html</url>
    <content type="text"><![CDATA[Cas的全称是Centeral Authentication Service，是对单点登录SSO（Single Sign On）的一种实现。其由Cas Server和Cas Client两部分组成，Cas Server是核心，而Cas Client通常就对应于我们的应用。一个Cas Server可以对应于多个Cas Client。它允许我们在一个Client进行登录以后无需再让用户输入用户名和密码进行认证即可访问其它Client应用。 CAS简介Cas Server的主要作用是通过发行和验证Ticket（票）来对用户进行认证和授权访问Client应用，用于认证的凭证信息都是由Cas Server管理的。而Cas Client就对应于我们真正的应用，当然其中会使用到Cas相关的类，用于与Cas Server进行交互。官网有两张图最能体现Cas的架构和原理。 如你所见，在第一次访问应用app1时，由于没有登录会直接跳转到Cas Server去进行登录认证，此时将附带查询参数service在Cas Server的登录地址上，表示登录成功后将要跳转的地址。此时Cas Server检查到没有之前成功登录后生成的SSO Session信息，那么就会引导用户到登录页面进行登录。用户输入信息提交登录请求，Cas Server认证成功后将生成对应的SSO Session，以及名为CASTGC的cookie，该cookie包含用来确定用户SSO Session的Ticket Granting Ticket（TGT）。之后会生成一个Service Ticket（ST），并将以ticket作为查询参数名，以该ST作为查询参数值跳转到登录时service对应的URL。如： http(s)://domain/app1?ticket=ST-2-59fS6KxvmykibRXyoPJE 之后的操作对用户来说都是透明的，即不可见的。app1之后将以service和ticket作为查询参数请求Cas Server对service进行验证，验证通过后Cas Server将返回当前用户的用户名等信息。app1就会给当前用户生成其自身的Session，以后该用户以该Session都可以成功的访问app1，而不需要再去请求Cas Server进行认证。当该用户再去访问app2的时候，由于其在app2上没有对应的Session信息，将会跳转到Cas Server的登录地址，Cas Server此时发现其包含名为CASTGC的cookie，将获取其中包含的TGT来获取对应的SSO Session，然后会将用户重定向到app2对应的地址，以Service Ticket作为查询参数。之后app2会向Cas Server发送请求校验该Service Ticket，校验成功后app2将建立该用户对应的Session信息，以后该用户以该Session就可以自由的访问app2了。 综上所述，我们知道，各系统之间的单点登录是通过Cas Server生成的SSO Session来交流的，而用户与实际的应用系统进行交互的时候，各应用系统将建立单独的Session，以满足用户与该系统的交互需求。 （注：本文是基于cas 3.5.2所写） 部署Cas ServerCas应用都需要有一个Cas Server。Cas Server是基于Java Servlet实现的，其要求部署在Servlet2.4以上版本的Web容器中。在此笔者将其部署到tomcat7中。Cas Server是要求使用https协议进行访问的，所以如果你的Web容器没有开启https通道，则需先开启。 开启tomcat7的https通道官方文档在这里http://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html。简单来说具体步骤如下： 利用Java的keytool工具创建一个keystore文件，该文件保存了服务端的证书和私钥。打开命令窗口敲入如下命令： 1%JAVA_HOME%\bin\keytool -genkey -alias tomcat -keyalg RSA 根据提示输入密码等信息，笔者选择的是“password”，该密码稍后将用于配置tomcat。 打开tomcat安装目录conf/server.xml文件，将如下语句的注释打开，并加上属性keystorePass，密码为我们在建立keystore时设立的密码。这样我们就可以使用https来访问tomcat了。默认其会到${user.home}/.keystore寻找keystore文件，我们之前建立的keystore文件默认就在这个位置。 1234&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" SSLEnabled="true" maxThreads="150" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystorePass="password"/&gt; 部署Cas Server从官网下载的cas server中会含有一个cas server对应的war包，对应路径为cas-server-3.5.2\modules\cas-server-webapp-3.5.2.war，我们可以把该war包重命名为cas.war，然后丢到tomcat的webapps目录下。之后我们就可以启动tomcat，然后访问https://localhost:8443/cas/login就可以看到Cas的登录页面了。 这些UI如果不想用，都是可以进行修改，自定义的。敲入用户名和密码就可以进行登录了。默认使用的AuthenticationHandler的处理逻辑是，只要用户名和密码一致就可以登录成功。 Cas Server中各配置文件介绍 Cas Server中所有的配置文件都是放在WEB-INF目录及其子目录下的。 在WEB-INF/classes下的配置文件有： cas-theme-default.properties：该文件存放的是css文件的路径，用户可以在这里指定使用的css文件为自定义的css文件，也可以更改配置文件中对应的css文件已更改默认的样式。 系列messages_*.properties：国际化支持对应的资源文件。 default_views.properties和protocol_views.properties：Cas Server中使用到的视图配置文件，用于定义对应视图的处理类及其文件路径。 log4j.xml：log4j的配置文件。 在WEB-INF根目录下的配置文件有： web.xml：这个文件就是大伙熟悉的web.xml文件。 cas-servlet.xml：该文件是Cas Server使用到的Spring MVC的配置文件，里面定义了一些Controller及View相关的内容。 cas.properties：该文件是Cas Server配置的主要文件。与Spring相关的所有配置使用的外部属性都定义在这个文件中。 deployerConfigContext.xml：该文件是专为Cas Server部署人员抽取出来的一个文件，其中的内容通常都是Cas Server部署人员需要进行更改的内容。 login-webflow.xml：登录使用到的Spring Web Flow配置文件。 restlet-servlet.xml：使用到的Restful API的相关配置。 WEB-INF/spring-configuration：该目录中存放的是Cas Server加载的Spring相关的配置文件。 WEB-INF/unused-spring-configuration：该目录中存放的是没有用到，但是有需要时可以将它们copy到spring-configuration目录下的文件。 在WEB-INF/spring-configuration目录下的配置文件是Cas Server中使用到的所有与Spring相关的配置文件，具体有： applicationContext.xml：该文件中定义了主要使用的bean，通常不需要修改。 argumentExtractorsConfiguration.xml：该文件中定义了需要使用的协议，默认只有CAS和SAML是可用的。 log4jConfiguration.xml：log4j初始化对应的配置。 propertyFileConfigure.xml：用于指定外部属性文件的位置，默认指定的就是前面提到的cas.properties文件。 securityContext.xml：这是Cas Server中使用到的Spring Security相关内容的配置文件，默认不需要进行修改。 ticketExpirationPolicies.xml：用于指定TicketGranting Ticket和Service Ticket的过期策略，一般不需要修改。 ticketGrantingTicketCookieGenerator.xml：TicketGranting Ticket对应的CookieGenerator的配置。 ticketRegistry.xml：DefaultTicketRegistry对应的配置。 uniqueIdGenerators.xml：唯一主键生成相关的配置。 warnCookieGenerator.xml：用于生成警告的CookieGenerator对应配置。 Cas（04）——更改认证方式在Cas Server的WEB-INF目录下有一个deployerConfigContext.xml文件，该文件是基于Spring的配置文件，里面存放的内容常常是部署人员需要修改的内容。其中认证方式也是定义在这个文件中的，id为authenticationManager的bean的authenticationHandlers即定义了需要使用的AuthenticationHandler列表。默认使用了两个AuthenticationHandler，第一个是用来确保当前使用的是https协议的HttpBasedServiceCredentialsAuthenticationHandler，第二个是我们需要改的，其简单认证用户名与密码相等的SimpleTestUsernamePasswordAuthenticationHandler。我们只需要更改这里的SimpleTestUsernamePasswordAuthenticationHandler就行了。Cas中已经为我们提供了不少AuthenticationHandler的实现，包括基于数据库认证的实现，当然用户也可以实现自己的AuthenticationHandler。下面将以使用数据库进行认证为例讲解如何更改认证方式。 Cas的各个模块都是基于Maven开发的，Cas Server也不例外。所以官方推荐我们使用Maven的War覆盖机制来修改Cas Server的配置文件。Maven的War覆盖机制是指当一个package类型为war的Maven项目A中引入了一个package类型为war的项目B作为依赖时，最终项目A打包的war包中不仅会包含项目A的内容，还会包含项目B的内容，且相同位置的文件项目A中的会覆盖项目B中的，即当项目A和项目B在WEB-INF下都拥有一个web.xml文件时，最终生成的war包中将使用项目A在WEB-INF下的web.xml文件；而当项目A在WEB-INF下没有web.xml文件，而项目B在WEB-INF下拥有web.xml文件时最终生成的war包中将使用项目B在WEB-INF下的web.xml文件。所以如果我们要修改Cas Server的配置文件，我们可以建立一个自己的基于Maven的Web项目，然后引入Cas Server作为依赖，并在自己的项目中建立对应的deployerConfigContext.xml文件。下面来看详细步骤。 建立基于Maven的Web项目，取名为myCasServer。 打开pom.xml文件，删除默认的依赖项，添加如下内容。 12345678910111213141516171819202122232425262728&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;warName&gt;cas&lt;/warName&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-webapp&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;type&gt;war&lt;/type&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;cas.version&gt;3.5.2&lt;/cas.version&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;ja-sig&lt;/id&gt; &lt;url&gt;http://oss.sonatype.org/content/repositories/releases/ &lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 删除myCasServer项目中src/main/webapp下的index.jsp文件和src/main/webapp/WEB-INF下的web.xml文件，因为在cas-server-webapp中都存在对应的文件，不删除的话打包后的结果将是myCasServer中的覆盖cas-server-webapp中的。如果这个时候使用Maven进行打包的话你将得到一个和cas-server-webapp一模一样的war包。 使用数据库进行认证的话还需要添加对应的依赖，打开myCasServer的pom.xml文件，添加如下依赖。 123456&lt;dependency&gt; &lt;groupId&gt;org.jasig.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 将cas-server-webapp/WEB-INF下的deployerConfigContext.xml文件copy到myCasServer的src/main/webapp/WEB-INF目录下。 基于数据库的AuthenticationHandler有多种，这里以QueryDatabaseAuthenticationHandler为例。QueryDatabaseAuthenticationHandler需要配置两个参数，dataSource和sql。dataSource就是数据源，表示从哪个数据源进行查询。sql是对应的查询语句，其会接收username作为参数，然后查询出对应的密码，之后QueryDatabaseAuthenticationHandler会将查询出来的密码与用户提交的密码进行匹配。所以这里我们打开复制到myCasServer中的deployerConfigContext.xml文件，找到id为authenticationManager的bean的authenticationHandlers属性定义，将最后一个AuthenticationHandler替换成我们想要的QueryDatabaseAuthenticationHandler。 替换前： 12345678&lt;property name="authenticationHandlers"&gt; &lt;list&gt; &lt;beanclass="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpClient-ref="httpClient" /&gt; &lt;bean class="org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler"/&gt; &lt;/list&gt; &lt;/property&gt; 替换后： 12345678910&lt;property name="authenticationHandlers"&gt; &lt;list&gt; &lt;beanclass="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpClient-ref="httpClient" /&gt; &lt;beanclass="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="sql" value="select password from t_user where username = ?"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; 像dataSource的定义及其需要使用到的依赖包我就不贴了，比较常用。 打包以后生成的war包中使用的AuthenticationHandler就会是我们在myCasServer的src/main/webapp/WEB-INF目录下的deployerConfigContext.xml文件中定义的QueryDatabaseAuthenticationHandler了。以后需要修改Cas Server中的其它内容也可以依照此种方式进行修改。 修改Cas Server的其它配置修改host.namehost.name是定义在cas.properties文件中的一个属性。该属性将被定义在uniqueIdGenerators.xml文件中的各种UniqueTicketIdGenerator用来生成TGT、ST等ticket。默认在生成这些ticket时会将host.name作为对应ticket的后缀。host.name的设置在集群环境下将非常有用，其值对于每个节点来说都必须是唯一的，这样在整个集群环境下生成出的各种ticket也必定是唯一的。当然，如果只是在单机环境下使用，我们也可以不修改它。 修改SSO Session的超时策略SSO Session的超时策略是由TicketGrantingTicketExpirationPolicy来描述的，其定义在ticketExpirationPolicies.xml文件中的。以下是其定义： 1234&lt;!-- Provides both idle and hard timeouts, for instance 2 hour sliding window with an 8 hour max lifetime --&gt; &lt;bean id="grantingTicketExpirationPolicy"class="org.jasig.cas.ticket.support.TicketGrantingTicketExpirationPolicy" p:maxTimeToLiveInSeconds="$&#123;tgt.maxTimeToLiveInSeconds:28800&#125;" p:timeToKillInSeconds="$&#123;tgt.timeToKillInSeconds:7200&#125;"/&gt; 我们可以看到它需要指定两个参数，maxTimeToLiveInSeconds和timeToKillInSeconds，它们的单位都是秒。其中timeToKillInSeconds表示用户在多久不进行操作的情况下将超时，maxTimeToLiveInSeconds表示SSO Session的最大有效时间，从生成到指定时间后就将超时。timeToKillInSeconds默认是7200秒，即2小时；maxTimeToLiveInSeconds默认是28800秒，即8小时。用户如果需要修改的话可以之前介绍的Maven War覆盖的方式在ticketExpirationPolicies.xml文件中修改，也可以在cas.properties文件中通过对应的属性进行修改。 修改允许管理service的角色有的时候我们需要查看或管理Cas Server端的service注册情况。这就需要我们在cas.properties文件中指定用户访问service管理页面需要的角色，这是通过cas.securityContext.serviceProperties.adminRoles来指定的，默认是ROLE_ADMIN。之后我们就可以通过访问“/services/manage.html”来对Cas Server上注册的service进行管理了。在访问该URL时可能会出现国际化时某信息在zh_CN中找不到的问题，解决方法可以将对应的信息在messages_zh_CN.properties中加上，或者将messages_en.properties文件copy一份重命名为messages.properties，英文版本的messages相对而言应该是比较全的。Cas Server的权限控制也是基于Spring Security的，其主要配置文件是WEB-INF/spring目录下的securityContext.xml文件，关于权限相关的内容可以在这里查找。 修改logout后的重定向默认情况下，Cas客户端应用通过Cas Server的logout登出后是会展示Cas Server的默认登出结果页面的。如果用户希望在Cas Server登出后能够跳转到自己的应用来，则可以在访问Cas Server的logout时通过参数service传递登出后需要跳转的地址。有一点需要注意的是指定的service需要是在Cas Server注册过的，我们可以通过访问Cas Server的“/services/manage.html”对service进行管理，包括增、删、改、查等。另外我们还需要启用Cas Server在logout后的重定向功能，该功能默认是不启用的。通过去掉cas.properties文件中属性cas.logout.followServiceRedirects=false前面的注释，并修改其值为true可以启用logout后的重定向了。 禁用logout后的回调默认情况下在通过访问Cas Server的logout进行登出后Cas Server将依次回调其中注册的各个Cas Client应用，以进行单点登出。如果用户不希望Cas Server在logout后回调Cas Client应用，则可以通过设置cas.properties文件中的slo.callbacks.disabled=true来禁用其回调。 修改service ticket的超时时间service ticket的默认有效时间是10秒。通常来说这已经足够了，因为从Cas Server生成service ticket返回给Cas client应用，到Cas client应用发送service ticket到Cas Server进行验证这个过程10秒已经足够。这也是为什么如果我们使用debug追踪Cas应用的认证过程时经常会失败的原因，因为追踪的时候service ticket已经过了10秒的有效期了。如果用户需要修改它可以通过cas .properties文件中的st.timeToKillInSeconds属性进行修改。 基于数据库的认证Cas Server自身已经为我们实现了几种基于JDBC的AuthenticationHandler实现，但它们不包含在Cas Server的核心包里面，而是包含在cas-server-support-jdbc中，如果我们要使用Cas Server已经实现好的基于JDBC的AuthenticationHandler，我们必须先将cas-server-support-jdbc对应的jar包、相关数据库的驱动，以及所需要使用的数据源实现等jar包加入Cas Server的类路径中。如果是基于Maven的war覆盖机制来修改Cas Server的配置文件，则我们可以在自己的Maven项目的依赖中加入如下项（对应的驱动就没贴出来了）。 123456&lt;dependency&gt; &lt;groupId&gt;org.jasig.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; Cas Server默认已经实现好的基于JDBC的AuthenticationHandler有三个，它们都继承自AbstractJdbcUsernamePasswordAuthenticationHandler，而且在认证过程中都需要一个DataSource。下面来对它们做一个简要的介绍。 BindModeSearchDatabaseAuthenticationHandlerBindModeSearchDatabaseAuthenticationHandler将试图以传入的用户名和密码从配置的DataSource中建立一个连接，如果连接成功，则表示认证成功，否则就是认证失败。以下是BindModeSearchDatabaseAuthenticationHandler源码的一段主要代码，通过它我们可以明显的看清其逻辑： 1234567891011121314protected final boolean authenticateUsernamePasswordInternal( final UsernamePasswordCredentials credentials) throws AuthenticationException &#123; final String username = credentials.getUsername(); final String password = credentials.getPassword(); try &#123; final Connection c = this.getDataSource() .getConnection(username, password); DataSourceUtils.releaseConnection(c, this.getDataSource()); returntrue; &#125; catch (final SQLException e) &#123; returnfalse; &#125; &#125; 当然，这种实现也需要你的DataSource支持getConnection(user,password)才行，否则将返回false。dbcp的BasicDataSource的不支持的，而c3p0的ComboPooledDataSource支持。 以下是一个使用BindModeSearchDatabaseAuthenticationHandler的配置示例： 1234567891011121314&lt;bean id="authenticationManager" class="org.jasig.cas.authentication.AuthenticationManagerImpl"&gt; ... &lt;property name="authenticationHandlers"&gt; &lt;list&gt; ... &lt;beanclass="org.jasig.cas.adaptors.jdbc.BindModeSearchDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; ... &lt;/list&gt; &lt;/property&gt; ... &lt;/bean&gt; QueryDatabaseAuthenticationHandler使用QueryDatabaseAuthenticationHandler需要我们指定一个SQL，该SQL将接收一个用户名作为查询条件，然后返回对应的密码。该SQL将被QueryDatabaseAuthenticationHandler用来通过传入的用户名查询对应的密码，如果存在则将查询的密码与查询出来的密码进行匹配，匹配结果将作为认证结果。如果对应的用户名不存在也将返回false。 以下是QueryDatabaseAuthenticationHandler的一段主要代码： 1234567891011121314151617181920212223protected final boolean authenticateUsernamePasswordInternal(finalUsernamePasswordCredentials credentials) throws AuthenticationException &#123; final String username = getPrincipalNameTransformer().transform(credentials.getUsername()); final String password = credentials.getPassword(); final String encryptedPassword = this.getPasswordEncoder().encode( password); try &#123; final String dbPassword = getJdbcTemplate().queryForObject(this.sql, String.class, username); return dbPassword.equals(encryptedPassword); &#125; catch (final IncorrectResultSizeDataAccessException e) &#123; // this means the username was not found. returnfalse; &#125; &#125; 上面的逻辑非常明显。此外，如你所见，QueryDatabaseAuthenticationHandler使用的用户名会经过PrincipalNameTransformer进行转换，而密码会经过PasswordEncoder进行编码。Cas Server中基于JDBC的AuthenticationHandler实现中使用到的PrincipalNameTransformer默认是不进行任何转换的NoOpPrincipalNameTransformer，而默认使用的PasswordEncoder也是不会经过任何编码的PlainTextPasswordEncoder。当然了，cas-server-jdbc-support对它们也有另外两种支持，即PrefixSuffixPrincipalNameTransformer和DefaultPasswordEncoder。 PrefixSuffixPrincipalNameTransformerPrefixSuffixPrincipalNameTransformer的作用很明显，如其名称所描述的那样，其在转换时会将用户名加上指定的前缀和后缀。所以用户在使用的时候需要指定prefix和suffix两个属性，默认是空。 DefaultPasswordEncoderDefaultPasswordEncoder底层使用的是标准Java类库中的MessageDigest进行加密的，其支持MD5、SHA等加密算法。在使用时需要通过构造参数encodingAlgorithm来指定使用的加密算法，可以使用characterEncoding属性注入来指定获取字节时使用的编码，不指定则使用默认编码。以下是DefaultPasswordEncoder的源码，其展示了DefaultPasswordEncoder的加密逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public final class DefaultPasswordEncoder implements PasswordEncoder &#123; privatestaticfinalchar[] HEX_DIGITS = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8','9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; @NotNull privatefinal String encodingAlgorithm; private String characterEncoding; public DefaultPasswordEncoder(final String encodingAlgorithm) &#123; this.encodingAlgorithm = encodingAlgorithm; &#125; public String encode(final String password) &#123; if (password == null) &#123; returnnull; &#125; try &#123; MessageDigest messageDigest = MessageDigest.getInstance(this.encodingAlgorithm); if (StringUtils.hasText(this.characterEncoding)) &#123; messageDigest.update(password.getBytes(this.characterEncoding)); &#125; else &#123; messageDigest.update(password.getBytes()); &#125; finalbyte[] digest = messageDigest.digest(); return getFormattedText(digest); &#125; catch (final NoSuchAlgorithmException e) &#123; thrownew SecurityException(e); &#125; catch (final UnsupportedEncodingException e) &#123; thrownew RuntimeException(e); &#125; &#125; /** * Takes the raw bytes from the digest and formats them correct. * @param bytes the raw bytes from the digest. * @return the formatted bytes. */ private String getFormattedText(byte[] bytes) &#123; final StringBuilder buf = new StringBuilder(bytes.length * 2); for (int j = 0; j &lt; bytes.length; j++) &#123; buf.append(HEX_DIGITS[(bytes[j] &gt;&gt; 4) &amp; 0x0f]); buf.append(HEX_DIGITS[bytes[j] &amp; 0x0f]); &#125; return buf.toString(); &#125; publicfinalvoid setCharacterEncoding(final String characterEncoding) &#123; this.characterEncoding = characterEncoding; &#125;&#125; 如果在认证时需要使用DefaultPasswordEncoder，则需要确保数据库中保存的密码的加密方式和DefaultPasswordEncoder的加密算法及逻辑是一致的。如果这些都不能满足你的需求，则用户可以实现自己的PrincipalNameTransformer和PasswordEncoder。 以下是一个配置使用QueryDatabaseAuthenticationHandler进行认证，且使用DefaultPasswordEncoder对密码进行MD5加密的示例： 123456789101112131415161718192021222324&lt;bean id="authenticationManager" class="org.jasig.cas.authentication.AuthenticationManagerImpl"&gt; ... &lt;property name="authenticationHandlers"&gt; &lt;list&gt; ... &lt;beanclass="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="passwordEncoder" ref="passwordEncoder"/&gt; &lt;property name="sql" value="select password from t_user where username = ?"/&gt; &lt;/bean&gt; ... &lt;/list&gt; &lt;/property&gt; ... &lt;/bean&gt; &lt;bean id="passwordEncoder"class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder"&gt; &lt;constructor-arg value="MD5"/&gt;&lt;!-- 加密算法 --&gt; &lt;/bean&gt; SearchModeSearchDatabaseAuthenticationHandlerSearchModeSearchDatabaseAuthenticationHandler的主要逻辑是将传入的用户名和密码作为条件从指定的表中进行查询，如果对应记录存在则表示认证通过。使用该AuthenticationHandler时需要我们指定查询时使用的表名（tableUsers）、用户名对应的字段名（fieldUser）和密码对应的字段名（fieldPassword）。此外，还可以选择性的使用PrincipalNameTransformer和PasswordEncoder。以下是SearchModeSearchDatabaseAuthenticationHandler源码中的一段主要代码： 123456789101112131415161718192021222324252627282930private static final String SQL_PREFIX = "Select count('x') from "; @NotNull private String fieldUser; @NotNull private String fieldPassword; @NotNull private String tableUsers; private String sql; protectedfinalboolean authenticateUsernamePasswordInternal(finalUsernamePasswordCredentials credentials) throws AuthenticationException &#123; final String transformedUsername = getPrincipalNameTransformer().transform(credentials.getUsername()); final String encyptedPassword = getPasswordEncoder().encode(credentials.getPassword()); finalint count = getJdbcTemplate().queryForInt(this.sql, transformedUsername, encyptedPassword); return count &gt; 0; &#125; publicvoid afterPropertiesSet() throws Exception &#123; this.sql = SQL_PREFIX + this.tableUsers + " Where " + this.fieldUser + " = ? And " + this.fieldPassword + " = ?"; &#125; 以下是一个使用SearchModeSearchDatabaseAuthenticationHandler的配置示例： 123456789101112131415161718192021222324252627282930313233&lt;bean id="authenticationManager" class="org.jasig.cas.authentication.AuthenticationManagerImpl"&gt; ... &lt;property name="authenticationHandlers"&gt; &lt;list&gt; ... &lt;beanclass="org.jasig.cas.adaptors.jdbc.SearchModeSearchDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="passwordEncoder" ref="passwordEncoder"/&gt; &lt;property name="tableUsers" value="t_user"/&gt;&lt;!-- 指定从哪个用户表查询用户信息 --&gt; &lt;property name="fieldUser" value="username"/&gt;&lt;!-- 指定用户名在用户表对应的字段名 --&gt; &lt;property name="fieldPassword" value="password"/&gt;&lt;!-- 指定密码在用户表对应的字段名 --&gt; &lt;/bean&gt; ... &lt;/list&gt; &lt;/property&gt; ... &lt;/bean&gt; 至此，cas-server-support-jdbc中支持JDBC的三个AuthenticationHandler就讲完了。如果用户觉得它们都不能满足你的要求，则还可以选择使用自己实现的AuthenticationHandler。至于其它认证方式，请参考官方文档。 建立使用Cas进行单点登录的应用根据之前的描述我们知道，Cas由两部分组成，Cas Server和Cas Client。Cas Server是Cas自己的服务端，而Cas Client是Cas客户端，其需要与我们自己的应用进行集成。 加入cas-client-core-xxx.jar到classpath在我们下载的Cas Client压缩包的modules目录下可以找到一个名为cas-client-core-xxx.jar的jar文件，首先需要将该jar包加入我们应用的类路径下，笔者这里使用的是cas-client-core-3.1.11.jar。如果用户的应用是使用Maven构造的，则可以在应用的pom.xml文件中加入如下依赖。 1234567&lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;version&gt;3.1.11&lt;/version&gt; &lt;/dependency&gt; 配置Filter然后需要我们在应用的web.xml文件中配置四个Filter，这四个Filter必须按照固定的顺序来进行配置，而且它们必须配置在应用的其它Filter之前。它们的先后顺序要求如下： AuthenticationFilter TicketValidationFilter HttpServletRequestWrapperFilter AssertionThreadLocalFilter 这些Filter有的必须指定某些参数，有的可以指定某些参数，这些参数可以通过context-param来指定，也可以通过init-param来指定。Cas Client默认会先从init-param取，没取到则从context-param取，所以当init-param和context-param都指定了某个参数时，init-param指定的将拥有更高的优先级。所以当多个Filter需要共用一个参数时，我们可以把它定义为context-param。 AuthenticationFilterAuthenticationFilter用来拦截所有的请求，用以判断用户是否需要通过Cas Server进行认证，如果需要则将跳转到Cas Server的登录页面。如果不需要进行登录认证，则请求会继续往下执行。 AuthenticationFilter有两个用户必须指定的参数，一个是用来指定Cas Server登录地址的casServerLoginUrl，另一个是用来指定认证成功后需要跳转地址的serverName或service。service和serverName只需要指定一个就可以了。当两者都指定了，参数service将具有更高的优先级，即将以service指定的参数值为准。service和serverName的区别在于service指定的是一个确定的URL，认证成功后就会确切的跳转到service指定的URL；而serverName则是用来指定主机名，其格式为{protocol}:{hostName}:{port}，如：https://localhost:8443，当指定的是serverName时，AuthenticationFilter将会把它附加上当前请求的URI，以及对应的查询参数来构造一个确定的URL，如指定serverName为“http://localhost”，而当前请求的URI为“/app”，查询参数为“a=b&amp;b=c”，则对应认证成功后的跳转地址将为“http://localhost/app?a=b&amp;b=c”。 除了上述必须指定的参数外，AuthenticationFilter还可以指定如下可选参数： renew：当指定renew为true时，在请Cas Server时将带上参数“renew=true”，默认为false。 gateway：指定gateway为true时，在请求Cas Server时将带上参数“gateway=true”，默认为false。 artifactParameterName：指定ticket对应的请求参数名称，默认为ticket。 serviceParameterName：指定service对应的请求参数名称，默认为service。 如下是一个配置AuthenticationFilter的示例，serverName由于在接下来配置的Filter中还要用，所以利用context-param将其配置为一个公用的参数。“elim”对应我的电脑名。 123456789101112131415161718&lt;context-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://elim:8080&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas/login&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; TicketValidationFilter在请求通过AuthenticationFilter的认证之后，如果请求中携带了参数ticket则将会由TicketValidationFilter来对携带的ticket进行校验。TicketValidationFilter只是对验证ticket的这一类Filter的统称，其并不对应Cas Client中的一个具体类型。Cas Client中有多种验证ticket的Filter，都继承自AbstractTicketValidationFilter，它们的验证逻辑都是一致的，都有AbstractTicketValidationFilter实现，所不同的是使用的TicketValidator不一样。笔者这里将以Cas10TicketValidationFilter为例，其它还有Cas20ProxyReceivingTicketValidationFilter和Saml11TicketValidationFilter。 12345678910111213&lt;filter&gt; &lt;filter-name&gt;casTicketValidationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas10TicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casTicketValidationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 必须指定的参数： casServerUrlPrefix：用来指定Cas Server对应URL地址的前缀，如上面示例的“https://elim:8443/cas”。 serverName或service：语义跟前面介绍的一致。 可选参数： redirectAfterValidation ：表示是否验证通过后重新跳转到该URL，但是不带参数ticket，默认为true。 useSession ：在验证ticket成功后会生成一个Assertion对象，如果useSession为true，则会将该对象存放到Session中。如果为false，则要求每次请求都需要携带ticket进行验证，显然useSession为false跟redirectAfterValidation为true是冲突的。默认为true。 exceptionOnValidationFailure ：表示ticket验证失败后是否需要抛出异常，默认为true。 renew：当值为true时将发送“renew=true”到Cas Server，默认为false。 HttpServletRequestWrapperFilterHttpServletRequestWrapperFilter用于将每一个请求对应的HttpServletRequest封装为其内部定义的CasHttpServletRequestWrapper，该封装类将利用之前保存在Session或request中的Assertion对象重写HttpServletRequest的getUserPrincipal()、getRemoteUser()和isUserInRole()方法。这样在我们的应用中就可以非常方便的从HttpServletRequest中获取到用户的相关信息。以下是一个配置HttpServletRequestWrapperFilter的示例： 123456789&lt;filter&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; AssertionThreadLocalFilterAssertionThreadLocalFilter是为了方便用户在应用的其它地方获取Assertion对象，其会将当前的Assertion对象存放到当前的线程变量中，那么以后用户在程序的任何地方都可以从线程变量中获取当前Assertion，无需再从Session或request中进行解析。该线程变量是由AssertionHolder持有的，我们在获取当前的Assertion时也只需要通过AssertionHolder的getAssertion()方法获取即可，如： 1Assertion assertion = AssertionHolder.getAssertion(); 像AssertionThreadLocalFilter这种设计理念是非常好的，实际应用中使用的也比较多，Spring Security中也有用到这种理念。为了便于大家了解，特贴出AssertionHolder的源码如下： 123456789101112131415161718192021222324252627282930public class AssertionHolder &#123; /** * ThreadLocal to hold the Assertion for Threads to access. */ private static final ThreadLocal threadLocal = new ThreadLocal(); /** * Retrieve the assertion from the ThreadLocal. */ public static Assertion getAssertion() &#123; return (Assertion) threadLocal.get(); &#125; /** * Add the Assertion to the ThreadLocal. */ public static void setAssertion(final Assertion assertion) &#123; threadLocal.set(assertion); &#125; /** * Clear the ThreadLocal. */ public static void clear() &#123; threadLocal.set(null); &#125;&#125; 以下是配置AssertionThreadLocalFilter的示例： 123456789101112131415&lt;filter&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 基于Spring的Filter配置使用Cas单点登录的应用需要我们在应用的web.xml文件中配置上述介绍的四个Filter，但如果用户的应用是使用Spring开发的，则我们可以只在web.xml文件中配置四个Spring的DelegatingFilterProxy用来代理需要配置的四个Filter，对应的Filter名称对应我们需要代理的Spring ApplicationContext中bean的名称，此时我们需要将对应的Filter配置为Spring ApplicationContext中的一个bean对象。所以此时对应的web.xml文件的定义应该是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;filter&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casTicketValidationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casTicketValidationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 而对应的Filter应该都以对应的名称定义为Spring ApplicationContext中的一个bean。 12345678910111213141516171819&lt;bean name="casAuthenticationFilter" class="org.jasig.cas.client.authentication.AuthenticationFilter" p:casServerLoginUrl="https://elim:8443/cas/login" p:renew="false" p:gateway="false" p:serverName="http://elim:8080" /&gt; &lt;bean name="casTicketValidationFilter" class="org.jasig.cas.client.validation.Cas10TicketValidationFilter" p:serverName="http://elim:8080" p:redirectAfterValidation="true"&gt; &lt;property name="ticketValidator"&gt; &lt;bean class="org.jasig.cas.client.validation.Cas10TicketValidator"&gt; &lt;!-- 对应于casServerUrlPrefix --&gt; &lt;constructor-arg index="0" value="https://elim:8443/cas" /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="casHttpServletRequestWrapperFilter"class="org.jasig.cas.client.util.HttpServletRequestWrapperFilter"/&gt; &lt;bean id="casAssertionThreadLocalFilter"class="org.jasig.cas.client.util.AssertionThreadLocalFilter"/&gt; 添加证书到信任库在ticket验证成功后，还需要验证证书，这需要我们将之前建立的证书导出并添加到当前JRE的证书信任库中，否则将验证失败。JRE在寻找证书时将根据当前使用的host来寻找，且会用该host匹配之前创建证书时指定的用户名称，如果匹配则表示找到。这也就意味着我们在创建证书时指定的用户名称需要是我们的host。我的机器名称为“elim”，我就把它作为我的host，那么对应的证书应该这样创建。 1keytool -genkey -keyalg RSA -alias tomcat -dname &quot;cn=elim&quot; -storepass changeit 该语句是对我们之前介绍的keytool -genkey -alias tomcat -keyalg RSA的精写，它已经通过相应的参数指定了对应的参数值，而不需要再与用户交互了。如果还用之前的语句生成证书的话，那么对应的值应该这样填： 之后会在用户的对应目录下生成一个.keystore文件。之后需要将该文件导出为一个证书到%JAVA_HOME%/jre/lib/security目录下，对应指令为： 1keytool -export -alias tomcat -file %JAVA_HOME%/jre/lib/security/tomcat.crt -storepass changeit 之后需要将导出的tomcat.crt证书添加到运行时使用的JRE的受信任证书库中，此时如果出现异常可将原本%JAVA_HOME%/jre/lib/security目录下的cacerts删除后继续执行以下指令。 1keytool -import -alias tomcat -file %JAVA_HOME%/jre/lib/security/tomcat.crt -keystore %JAVA_HOME%/jre/lib/security/cacerts -storepass changeit 经过以上几步后就可以启用我们自己的Cas Client应用了，然后初次访问该应用时就会跳转到Cas Server进行登录认证。认证成功后将跳转到我们自己的Client应用进行ticket的验证，验证通过后就可以自由的访问我们的Client应用了。 （注：本文是基于Cas Server3.5.2和Cas Client3.1.11所写） 单点登出Cas Client端配置单点登出单点登出功能跟单点登录功能是相对应的，旨在通过Cas Server的登出使所有的Cas Client都登出。Cas Server的登出是通过请求“/logout”发生的，即如果你的Cas Server部署的访问路径为“https://localhost:8443/cas”时，通过访问“https://localhost:8443/cas/logout”可以触发Cas Server的登出操作，进而触发Cas Client的登出。在请求Cas Server的logout时，Cas Server会将客户端携带的TGT删除，同时回调该TGT对应的所有service，即所有的Cas Client。Cas Server中对应的TGT失效时默认也会触发同样的操作。Cas Client如果需要响应该回调，进而在Cas Client端进行登出操作的话就需要有对应的支持。具体来说，需要在Cas Client应用的web.xml文件中添加如下Filter和Listener。 12345678910111213&lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;casSingleSignOutFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casSingleSignOutFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; SingleSignOutFilter需要配置在所有Filter之前，当Cas Client通过Cas Server登录成功，Cas Server会携带生成的Service Ticket回调Cas Client，此时SingleSignOutFilter会将Service Ticket与当前的Session绑定在一起。当Cas Server在进行logout后回调Cas Client应用时也会携带该Service Ticket，此时Cas Client配置的SingleSignOutFilter将会使对应的Session失效，进而达到登出的目的。 SingleSignOutHttpSessionListener用于在Cas Client应用中的Session过期时将其从对应的映射关系中移除。 Cas Server端禁用单点登出单点登出功能默认在Cas Server端是启用的。可能因为某种原因用户想禁用它。在Cas Server的WEB-INF/spring-configuration目录下有一个argumentExtractorsConfiguration.xml文件，其中定义了两个ArgumentExtractor类型的bean，一个是针对于Cas协议的，一个是针对于SAMP1.1协议的，但是它们都定义了一个共同的属性disableSingleSignOut，如下所示，该值对应的是一个属性替换变量，默认为false。 12345678&lt;bean id="casArgumentExtractor" class="org.jasig.cas.web.support.CasArgumentExtractor" p:httpClient-ref="noRedirectHttpClient" p:disableSingleSignOut="$&#123;slo.callbacks.disabled:false&#125;" /&gt; &lt;bean id="samlArgumentExtractor"class="org.jasig.cas.web.support.SamlArgumentExtractor" p:httpClient-ref="noRedirectHttpClient" p:disableSingleSignOut="$&#123;slo.callbacks.disabled:false&#125;" /&gt; 在前面的内容中已经介绍过，Cas Server的所有属性替换变量都是定义在WEB-INF/cas.properties文件中的。所以如果需要禁用Cas Server的logout功能，我们可以在cas.properties文件中指定“slo.callbacks.disabled=true”。 （注：本文是基于Cas Server3.5.2和Cas Client3.1.11所写） 通过Proxy访问其它Cas应用考虑这样一种场景：有两个应用App1和App2，它们都是受Cas Server保护的，即请求它们时都需要通过Cas Server的认证。现需要在App1中通过Http请求访问App2，显然该请求将会被App2配置的Cas的AuthenticationFilter拦截并转向Cas Server，Cas Server将引导用户进行登录认证，这样我们也就不能真正的访问到App2了。针对这种应用场景，Cas也提供了对应的支持。 原理Cas Proxy可以让我们轻松的通过App1访问App2时通过Cas Server的认证，从而访问到App2。其主要原理是这样的，App1先通过Cas Server的认证，然后向Cas Server申请一个针对于App2的proxy ticket，之后在访问App2时把申请到的针对于App2的proxy ticket以参数ticket传递过去。App2的AuthenticationFilter将拦截到该请求，发现该请求携带了ticket参数后将放行交由后续的Ticket Validation Filter处理。Ticket Validation Filter将会传递该ticket到Cas Server进行认证，显然该ticket是由Cas Server针对于App2发行的，App2在申请校验时是可以校验通过的，这样我们就可以正常的访问到App2了。针对Cas Proxy的原理，官网有一张图很能说明问题，如下所示。 配置Cas Proxy实现的核心是Cas20ProxyReceivingTicketValidationFilter，该Filter是Ticket Validation Filter的一种。使用Cas Proxy时我们需要使用Cas20ProxyReceivingTicketValidationFilter作为我们的Ticket Validation Filter，而且对于代理端而言该Filter需要放置在AuthenticationFilter之前。对于上述应用场景而言，App1就是我们的代理端，而App2就是我们的被代理端。Cas20ProxyReceivingTicketValidationFilter在代理端与被代理端的配置是不一样的。我们先来看一下在代理端的配置。 代理端既然Cas20ProxyReceivingTicketValidationFilter是一个Ticket Validation Filter，所以之前我们介绍的Ticket Validation Filter需要配置的参数，在这里也需要配置，Ticket Validation Filter可以配置的参数这里也可以配置。所不同的是对于代理端的Cas20ProxyReceivingTicketValidationFilter必须指定另外的两个参数，proxyCallbackUrl和proxyReceptorUrl。 proxyCallbackUrl： 用于指定一个回调地址，在代理端通过Cas Server校验ticket成功后，Cas Server将回调该地址以传递pgtId和pgtIou，Cas20ProxyReceivingTicketValidationFilter在接收到对应的响应后会将它们保存在内部持有的ProxyGrantingTicketStorage中。之后在对传递过来的ticket进行validate的时候又会根据pgtIou从ProxyGrantingTicketStorage中获取对应的pgtId，用以保存在AttributePrincipal中，而AttributePrincipal又会保存在Assertion中。proxyCallbackUrl因为是指定Cas Server回调的地址，所以其必须是一个可以供外部访问的绝对地址。此外，因为Cas Server默认只回调使用安全通道协议https进行通信的地址，所以我们的proxyCallbackUrl需要是一个使用https协议访问的地址。 proxyReceptorUrl： 该地址是proxyCallbackUrl相对于代理端的一个地址，Cas20ProxyReceivingTicketValidationFilter将根据该地址来决定请求是否来自Cas Server的回调。 下面是一个Cas20ProxyReceivingTicketValidationFilter在代理端配置的示例，需要注意的是该Filter需要配置在AuthenticationFilter之前，所以完整配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;context-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;https://elim:8043&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;proxyValidationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;proxyCallbackUrl&lt;/param-name&gt; &lt;param-value&gt;https://elim:8043/app1/proxyCallback&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;proxyReceptorUrl&lt;/param-name&gt; &lt;param-value&gt;/proxyCallback&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;proxyValidationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas/login&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 被代理端在被代理端Cas20ProxyReceivingTicketValidationFilter是扮演Ticket Validation Filter的角色，它可以验证正常通过Cas Server登录认证成功后返回的ticket，也可以认证来自其它代理端传递过来的proxy ticket，当然，最终的认证都是通过Cas Server来完成的。既然Cas20ProxyReceivingTicketValidationFilter在被代理端是作为Ticket Validation Filter来使用的，所以Ticket Validation Filter可以有的参数其都可以配置。在被代理端需要配置一个参数用以表示接受来自哪些应用的代理，这个参数可以是acceptAnyProxy，也可以是allowedProxyChains。acceptAnyProxy表示接受所有的，其对应的参数值是true或者false；而allowedProxyChains则用以指定具体接受哪些应用的代理，多个应用就写多行，allowedProxyChains的值对应的是代理端提供给Cas Server的回调地址，如果使用前文示例的代理端配置，我们就可以指定被代理端的allowedProxyChains为“https://elim:8043/app1/proxyCallback”，这样当app1作为代理端来访问该被代理端时就能通过验证，得到正确的响应。下面是一个被代理端配置Cas20ProxyReceivingTicketValidationFilter的完整配置示例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;context-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://elim:8081&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;casSingleSignOutFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casSingleSignOutFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https:// elim:8443/cas/login&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAuthenticationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;proxyValidationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://elim:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;acceptAnyProxy&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;proxyValidationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casHttpServletRequestWrapperFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;casAssertionThreadLocalFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 请求示例配置好以后接下来将展示一个app1作为代理端访问app2的应用示例。该示例的重点在于app1的请求发起，对于需要请求的app2端的内容我们假设就是一个简单的jsp文件，其简单的输出一些文本。对于代理端而言，其请求的发起通常需要经过如下步骤： 获取到当前的AttributePrincipal对象，如果当前可以获取到request对象并且使用了HttpServletRequestWrapperFilter，我们则可以直接从request中获取。 1AttributePrincipal principal = (AttributePrincipal) req.getUserPrincipal(); 当然，如果使用了AssertionThreadLocalFilter，我们也可以从AssertionHolder中获取Assertion，进而获取到对应的AttributePrincipal对象。 1AttributePrincipal principal = AssertionHolder.getAssertion().getPrincipal(); 通过AttributePrincipal获取针对于被代理端对应的proxy ticket，该操作将促使AttributePrincipal向Cas Server发起请求，从而获取到对应的proxy ticket。针对同一URL每次从Cas Server请求获取到的proxy ticket都是不一样的。以下是一个获取针对于“http://elim:8081/app2/getData.jsp”的proxy ticket的示例： 1String proxyTicket = principal.getProxyTicketFor(&quot;http://elim:8081/app2/getData.jsp&quot;); 在请求被代理端时将获取到的proxy ticket以参数ticket一起传递过去，如： 1URL url = new URL(&quot;http://elim:8081/app2/getData.jsp?ticket=&quot; + proxyTicket); 完整的示例代码如下所示： 1234567891011121314151617181920212223242526272829@WebServlet(name="casProxyTest", urlPatterns="/cas/proxy/test")public class CasProxyTestServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取到AttributePrincipal对象 AttributePrincipal principal = AssertionHolder.getAssertion().getPrincipal(); //2、获取对应的proxy ticket String proxyTicket = principal.getProxyTicketFor("http://elim:8081/app/getData.jsp"); //3、请求被代理应用时将获取到的proxy ticket以参数ticket进行传递 URL url = new URL("http://elim:8081/app/getData.jsp?ticket=" + URLEncoder.encode(proxyTicket, "UTF-8")); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8")); StringBuffer content = new StringBuffer(); String line = null; while ((line=br.readLine()) != null) &#123; content.append(line).append("&lt;br/&gt;"); &#125; resp.getWriter().write(content.toString()); &#125;&#125;]]></content>
      <categories>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Redis的CAS集群]]></title>
    <url>%2Fblog%2F34811.html</url>
    <content type="text"><![CDATA[单点登录（SSO）是复杂应用系统的基本需求，Yale CAS是目前常用的开源解决方案。CAS认证中心，基于其特殊作用，自然会成为整个应用系统的核心，所有应用系统的认证工作，都将请求到CAS来完成。因此CAS服务器是整个应用的关键节点，CAS发生故障，所有系统都将陷入瘫痪。同时，CAS的负载能力要足够强，能够承担所有的认证请求响应。利用负载均衡和集群技术，不仅能克服CAS单点故障，同时将认证请求分布到多台CAS服务器上，有效减轻单台CAS服务器的请求压力。下面将基于CAS 3.4.5来讨论下CAS集群。 CAS的工作原理，主要是基于票据(Ticket)来实现的（参见 CAS基本原理）。CAS票据，存储在TicketRegistry中，因此要想实现CAS Cluster, 必须要多台CAS之间共享所有的Ticket，采用统一的TicketRegistry，可以达到此目的。 缺省的CAS实现中，TicketRegistry在内存中实现，不同的CAS服务器有自己单独的TicketRegistry，因此是不支持分布式集群的。但CAS提供了支持TicketRegistry分布式的接口org.jasig.cas.ticket.registry.AbstractDistributedTicketRegistry，我们可以实现这个接口实现多台CAS服务器TicketRegistry共享，从而实现CAS集群。 同时，较新版本CAS使用SpringWebFlow作为认证流程，而webflow需要使用session存储流程相关信息，因此实现CAS集群，我们还得需要让不同服务器的session进行共享。 我们采用内存数据库Redis来实现TicketRegistry,让多个CAS服务器共用同一个TicketRegistry。同样方法，我们让session也存储在Redis中，达到共享session的目的。下面就说说如何用Redis来实现TicketRegistry，我们使用Java调用接口Jedis来操作Redis，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Collection;import org.jasig.cas.ticket.Ticket;import org.jasig.cas.ticket.TicketGrantingTicket;import org.jasig.cas.ticket.registry.AbstractDistributedTicketRegistry;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/* * TicketRegistry using Redis, to solve CAS Cluster. */public class RedisTicketRegistry extends AbstractDistributedTicketRegistry &#123; private static int redisDatabaseNum; private static String hosts; private static int port; private static int st_time; // ST最大空闲时间 private static int tgt_time; // TGT最大空闲时间 private static JedisPool cachePool; static &#123; redisDatabaseNum = PropertiesConfigUtil.getPropertyInt("redis_database_num"); hosts = PropertiesConfigUtil.getProperty("hosts"); port = PropertiesConfigUtil.getPropertyInt("port"); st_time = PropertiesConfigUtil.getPropertyInt("st_time"); tgt_time = PropertiesConfigUtil.getPropertyInt("tgt_time"); cachePool = new JedisPool(new JedisPoolConfig(), hosts, port); &#125; public void addTicket(Ticket ticket) &#123; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); int seconds = 0; String key = ticket.getId(); if (ticket instanceof TicketGrantingTicket) &#123; // key = // ((TicketGrantingTicket)ticket).getAuthentication().getPrincipal().getId(); seconds = tgt_time / 1000; &#125; else &#123; seconds = st_time / 1000; &#125; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(bos); oos.writeObject(ticket); &#125; catch (Exception e) &#123; log.error("adding ticket to redis error."); &#125; finally &#123; try &#123; if (null != oos) oos.close(); &#125; catch (Exception e) &#123; log.error("oos closing error when adding ticket to redis."); &#125; &#125; jedis.set(key.getBytes(), bos.toByteArray()); jedis.expire(key.getBytes(), seconds); cachePool.returnResource(jedis); &#125; public Ticket getTicket(final String ticketId) &#123; return getProxiedTicketInstance(getRawTicket(ticketId)); &#125; private Ticket getRawTicket(final String ticketId) &#123; if (null == ticketId) return null; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); Ticket ticket = null; ByteArrayInputStream bais = new ByteArrayInputStream(jedis.get(ticketId.getBytes())); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(bais); ticket = (Ticket) ois.readObject(); &#125; catch (Exception e) &#123; log.error("getting ticket to redis error."); &#125; finally &#123; try &#123; if (null != ois) ois.close(); &#125; catch (Exception e) &#123; log.error("ois closing error when getting ticket to redis."); &#125; &#125; cachePool.returnResource(jedis); return ticket; &#125; public boolean deleteTicket(final String ticketId) &#123; if (ticketId == null) &#123; return false; &#125; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); jedis.del(ticketId.getBytes()); cachePool.returnResource(jedis); return true; &#125; public Collection&lt;Ticket&gt; getTickets() &#123; throw new UnsupportedOperationException("GetTickets not supported."); &#125; protected boolean needsCallback() &#123; return false; &#125; protected void updateTicket(final Ticket ticket) &#123; addTicket(ticket); &#125;&#125; 同时，我们在ticketRegistry.xml配置文件中，将TicketRegistry实现类指定为上述实现。即修改下面的class值 123 &lt;!-- Ticket Registry --&gt; &lt;bean id="ticketRegistry" class="org.jasig.cas.util.RedisTicketRegistry" /&gt; &lt;!-- &lt;bean id="ticketRegistry" class="org.jasig.cas.ticket.registry.DefaultTicketRegistry" /&gt; --&gt; 因为使用了Redis的expire功能，注释掉如下代码： 12345678910&lt;!-- TICKET REGISTRY CLEANER --&gt; lt;!-- &lt;bean id="ticketRegistryCleaner" class="org.jasig.cas.ticket.registry.support.DefaultTicketRegistryCleaner" p:ticketRegistry-ref="ticketRegistry" /&gt; &lt;bean id="jobDetailTicketRegistryCleaner" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean" p:targetObject-ref="ticketRegistryCleaner" p:targetMethod="clean" /&gt; &lt;bean id="triggerJobDetailTicketRegistryCleaner" class="org.springframework.scheduling.quartz.SimpleTriggerBean" p:jobDetail-ref="jobDetailTicketRegistryCleaner" p:startDelay="20000" p:repeatInterval="5000000" /&gt; --&gt; 通过上述实现TicketRegistry,多台CAS服务器就可以共用同一个TicketRegistry。对于如何共享session，我们可以采用现成的第三方工具tomcat-redis-session-manager直接集成即可。对于前端web服务器(如nginx)，做好负载均衡配置，将认证请求分布转发给后面多台CAS，实现负载均衡和容错目的。]]></content>
      <categories>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS单点登录(一)]]></title>
    <url>%2Fblog%2F34685.html</url>
    <content type="text"><![CDATA[单点登录（Single Sign On），简称为SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。CAS（Central Authentication Service），中央认证服务。CAS(Central Authentication Service)是一款不错的针对 Web应用的单点登录框架。 CAS基本原理讲解CAS之前先来学习两个基本术语 术语解释：Ticket Grangting Ticket(TGT) ：TGT是CAS为用户签发的登录票据，拥有了TGT，用户就可以证明自己在CAS成功登录过。TGT封装了Cookie值以及此Cookie值对应的用户信息。用户在CAS认证成功后，CAS生成cookie（叫TGC），写入浏览器，同时生成一个TGT对象，放入自己的缓存，TGT对象的ID就是cookie的值。当HTTP再次请求到来时，如果传过来的有CAS生成的cookie，则CAS以此cookie值为key查询缓存中有无TGT，如果有的话，则说明用户之前登录过，如果没有，则用户需要重新登录。 Ticket-granting cookie(TGC)：存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CASServer用来明确用户身份的凭证。 Service ticket(ST) ：服务票据，服务的惟一标识码 , 由 CASServer 发出（ Http 传送），用户访问Service时，service发现用户没有ST，则要求用户去CAS获取ST.用户向CAS发出获取ST的请求，CAS发现用户有TGT，则签发一个ST，返回给用户。用户拿着ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源 深入CAS从结构上看，CAS包含两个部分：CAS ServerCASServer 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 /密码等凭证 (Credentials) 。 CAS Client负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。 CASClient 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。 CAS最基本的协议过程： CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护 Web应用的受保护资源，过滤从客户端过来的每一个 Web 请求 （step 1）Web浏览器访问CAS Client，无session并且无票据(ST)，定向到CASServer（step 2），又因为浏览器中并没有cookie，故服务端拿不到TGC，因此需要重新登录 （Step 3）是用户认证过程，如果用户提供了正确的CAS Server 会处理用户名 / 密码等凭证 (Credentials) ，认证成功后，CAS生成cookie（叫TGC），写入浏览器，同时生成一个TGT对象，再根据TGT发放票据ST，并且重定向用户到CAS Client（附带刚才产生的ServiceTicket）， Service Ticket 是不可以伪造的（step4） 注：ST前半部分为登录url，后半部分为我客户端要访问的页面地址，只有当登录成功才会直接转向客户端访问的页面 （Step 5）拿着ST去 CAS Server验证一下，验证成功返回用户信息（step6） 注：收到ST后，为什么还要验证呢？ 因为CAS知道这个用户已经登录过了，但是对于这个项目来说，我并不知道这个用户已经登录过了，故需要验证 当用户访问另一个应用的服务再次被重定向到 CAS Server 的时候， CAS Server 会主动获到这个 TGC cookie ，然后做下面的事情： 1)如果 User 持有 TGC 且其还没失效，那么就走基础协议图的 Step4 ，达到了 SSO 的效果； 2)如果 TGC 失效，那么用户还是要重新认证 ( 走基础协议图的 Step3) 。 CAS 请求认证时序图如下： CAS服务端登录时处理：第一步：cas往浏览器增加cookie（TGC） CAS向浏览器送回一个所谓的“内存cookie”。这种cookie并不是真的保存在内存中，而只是浏览器一关闭，cookie就自动过期。这个cookie称为“ticket-grantingcookie”，用来表明用户已经成功地登录。 这个Cookie是一个加密的Cookie，其中保存了用户登录的信息。用于以后其它应用客户端登录。 第二步：cas同时创建一个ticket(ST)重定向到原来的cas客户端 认证成功后，CAS服务器创建一个很长的、随机生成的字符串，称为“Ticket”。随后，CAS将这个ticket和成功登录的用户，以及服务联系在一起。这个ticket是一次性使用的一种凭证，它只对登录成功的用户及其服务使用一次。使用过以后立刻失效。 CAS 客户端应用Ａ的处理第一步：收到ticket后，向cas提交验证ticket 第二步：ticket验证后创建session 以后登录此应用时，没有ticket，但IE能提供session,从session中取得CASReceipt,并验证如果有效说明已经在此应用认证过，允许访问此应用 到此为止，CAS会记录用户已在应用Ａ已经登录 用户登录到应用Ｂ是如何处理用户进入应用Ｂ时，首先仍然会重定向到CAS服务器。不过此时CAS服务器不再要求用户输入用户名和密码，而是首先自动寻找Cookie，根据Cookie中保存的信息，进行登录。然后，CAS同样给出新的ticket重定向应用Ｂ给cas验证（流程同应用Ａ验证方式），如果验证成功则应用Ｂ创建session记录CASReceipt信息到session中，以后凭此session登录应用Ｂ。 原理：１个cookie+Ｎ个sessionCAS创建cookie在所有应用中登录时cas使用,各应用通过在IE创建各自的session来标识应用是否已经登录。 Cookie:在cas为各应用登录时使用，实现了只须一次录入用户密码 Session:各应用会创建自己的session表示是否登录 具体描述一下客户端消息流程 第一次访问http://localhost:8080/a, CLIENT：没票据且SESSION中没有消息所以跳转至CAS CAS：拿不到TGC故要求用户登录 认证成功后回跳 CAS：通过TGT生成ST发给客户端，客户端保存TGC，并重定向到http://localhost:8080/a CLIENT：带有票据(ST)所以不跳转只是后台发给CAS验证票据（浏览器中无法看到这一过程） 第一次访问http://localhost:8080/b CLIENT：没票据且SESSION中没有消息所以跳转至CAS CAS：从客户端取出TGC，如果TGC有效则给用户ST并后台验证ST，从而SSO。【如果失效重登录或注销时，怎么通知其它系统更新SESSION信息呢？？TicketGrantingTicketImpl类grantServiceTicket方法里this.services.put(id,service);可见CAS端已经记录了当前登录的子系统】 单点退出： 再次访问http://localhost:8080/a CLIENT：没票据但是SESSION中有消息故不跳转也不用发CAS验证票据，允许用户访问 实例域名地址的修改：根据演示需求，用修改hosts文件的方法添加域名最简单方便（这个非常重要），在文件 C:\Windows\System32\drivers\etc\hosts 文件中添加三条 12345127.0.0.1 demo.micmiu.com127.0.0.1 app1.micmiu.com127.0.0.1 app2.micmiu.com •demo.micmiu.com =&gt;&gt; 对应部署cas server的tomcat，这个虚拟域名还用于证书生成 •app1.micmiu.com =&gt;&gt; 对应部署app1 的tomcat •app2.micmiu.com =&gt;&gt; 对应部署app2 的tomcat 注：可选配置 端口号的修改：修改tomcat的启动端口（共计5处），在文件conf/server.xml文件找到如下内容： 12345&lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; 修改成： 123456&lt;Server port="18005" shutdown="SHUTDOWN"&gt; &lt;Connector port="18080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="18443" /&gt; &lt;Connector port="18009" protocol="AJP/1.3" redirectPort="18443" /&gt; 注：由于需要在同一个机器上演示，故需要修改端口号 安全证书配置：CAS默认使用的是HTTPS协议，如果对安全要求不高，可使用HTTP协议。 修改deployerConfigContext.xml(cas/WEB-INF)增加参数p:requireSecure=”false”，是否需要安全验证，即HTTPS，false为不采用。 12&lt;bean class="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpClient-ref="httpClient" p:requireSecure="false" /&gt; 修改 ticketGrantingTicketCookieGenerator.xml(cas/WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml) 中ticketGrantingTicketCookieGenerator p:cookieSecure 属性修改为 false。 12&lt;bean id="ticketGrantingTicketCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator" :cookieSecure="false" p:cookieMaxAge="-1" p:cookieName="CASTGC" p:cookiePath="/cas" /&gt; 配置服务端CAS-Server下载地址：http://www.jasig.org/cas/download 我们以cas-server-3.4.11-release.zip为例，解压提取cas-server-3.4.11/modules/cas-server-webapp-3.4.11.war文件，把该文件copy到G:\sso\tomcat-cas\webapps\ 目录下，并重命名为：cas.war. 启动tomcat-cas，在浏览器地址栏输入：https://demo.micmiu.com:8080/cas/login，回车 CAS-server的默认验证规则：只要用户名和密码相同就认证通过（仅仅用于测试，生成环境需要根据实际情况修改），输入admin/admin点击登录，就可以看到登录成功的页面： 输入用户名admin和密码admin登录则会出现 看到上述页面表示CAS-Server已经部署成功。 配置客户端Cas-Client 下载 CAS-Client下载地址：http://downloads.jasig.org/cas-clients/ 以cas-client-3.2.1-release.zip为例，解压提取cas-client-3.2.1/modules/cas-client-core-3.2.1.jar 借以tomcat默认自带的webapps\examples 作为演示的简单web项目 启动tomcat-app1，浏览器输入http://app1.micmiu.com:18080/examples/servlets/回车： 注：端口号修改 1234&lt;Connector port="18080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="18443" /&gt; &lt;Connector port="18009" protocol="AJP/1.3" redirectPort="18443" /&gt; 看到上述界面表示tomcat-app1的基本安装配置已经成功。 接下来复制client的lib包cas-client-core-3.2.1.jar和commons-logging-1.1.jar到tomcat-app1\webapps\examples\WEB-INF\lib\目录下，在tomcat-app1\webapps\examples\WEB-INF\web.xml文件中增加如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置--&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责用户的认证工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;https://demo.micmiu.com:8080/cas/login&lt;/param-value&gt; &lt;!--这里的server是服务端的IP --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://app1.micmiu.com:18080&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责对Ticket的校验工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://demo.micmiu.com:8080/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://app1.micmiu.com:18080&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责实现HttpServletRequest请求的包裹， 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- ======================== 单点登录结束 ======================== --&gt; 第二个examples类似配置。 启动之前配置好的三个tomcat分别为：tomcat-cas、tomcat-app1、tomcat-app2. 基本的测试预期流程： 打开app1 url —-&gt;跳转cas server 验证 —-&gt; 显示app1的应用 —-&gt; 打开app2 url —-&gt; 显示app2应用 —-&gt; 注销casserver —-&gt; 打开app1/app2 url —-&gt; 重新跳转到cas server 验证. 打开浏览器地址栏中输入：http://app1.micmiu.com:18080/examples/servlets/servlet/HelloWorldExample，回车： 出现CAS登录页 验证通过后显示出 hello world. 教程：http://www.micmiu.com/enterprise-app/sso/sso-cas-sample/#viewSource 数据库查询认证机制-xml方式前面服务端认证机制采用的是默认配置即CAS Servier默认用户名和密码一致即可登录成功，下面侧重于应用方面，真正通过查询用户名密码来进程验证用户是否可以登录。 CAS Server添加相关的jar包需要在web项目的lib下添加两个包：cas-server-support-jdbc-x.x.x.jar和 mysql-connector-java-x.x.x-bin.jar（具体版本号根据情况而定） 修改CAS Server的配置在%tomcat_cas%/webapps/cas/WEB_INF/deployerConfigContext.xml找到如下信息： 1&lt;bean class="org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler" /&gt; 修改成如下： 12345&lt;bean class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;property name="sql" value="select password from t_user where login_name=?" &gt;&lt;/property&gt; &lt;!--&lt;property name="passwordEncoder" ref="MD5PasswordEncoder" &gt;&lt;/property&gt;--&gt; &lt;/bean&gt; 同时增加datasource和加密处理两个bean的定义： 1234567891011&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost/test" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt; &lt;bean id="MD5PasswordEncoder" class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder"&gt; &lt;constructor-arg index="0" value="MD5" /&gt; &lt;/bean&gt; 修改后的效果： 本地数据库中添加用户数据信息 登录。 注意: 密码加密过程，如果不用，注释掉即可。 QueryDatabaseAuthenticationHandler是cas-server-support-jdbc提供的查询接口其中一个是通过配置一个SQL 语句查出密码，与所给密码匹配； sql语句就是查询哪一张表，本例根据t_user表的login_name字段查询密码，CAS会匹配用户输入的密码，如果匹配则通过； passwordEncoder这个是处理密码的加密，如果想要你的应用中数据库保存的是加密过的，比如本例是使用MD5加密的，所以配置了MD5PasswordEncoder这个Handler，cas内置了MD5的功能所以只需要配置一下就可以了；如果在实际应用中使用的是公司自己的加密算法那么就需要自己写一个Handler来处理密码，实现方式也比较简单，创建一个类继承org.jasig.cas.authentication.handler.PasswordEncoder然后在encode方法中加密用户输入的密码然后返回即可。 配置多个数据库如果需要配置多个数据库，可以配置多个QueryDatabaseAuthenticationHandler和多个datasource 假如a_user中有一个用户：auser，b_user中有一个用户buser，这样你无论用哪一个用户登录，CAS就会先查a_user，如果用户名密码都正确，那么就通过，如果a_user中验证失败，那么CAS就会再查b_user，用户名密码都正确就算通过了，此时不正确，就算这次登录验证没通过。 数据库查询认证机制-自定义编码方式通过xml配置方式实现数据库查询认证，的确简单但是不够灵活。但是如果登录验证逻辑稍微复杂些，可能通过这种配置方式就不能满足需求了，比如：当用户登录时，需要判断该用户是否绑定了邮箱，如果未绑定，拒绝登录并给出提示信息。 遇到类似的情况，就需要使用自定义登录来完成，并且给出的提示信息也需要是自定义的。自定义登录验证（默认实现QueryDatabaseAuthenticationHandler） CAS内置了一些AuthenticationHandler实现类，如下图所示，在cas-server-support-jdbc包中提供了基于jdbc的用户认证类。 如果需要实现自定义登录，只需要实现org.jasig.cas.authentication.handler.AuthenticationHandler接口即可，当然也可以利用已有的实现，比如创建一个继承自org.jasig.cas.adaptors.jdbc.AbstractJdbcUsernamePasswordAuthenticationHandler的类，实现方法可以参考org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler类： 修改authenticateUsernamePasswordInternal方法中的代码为自己的认证逻辑即可。 操作步骤： Eclipse中引入cas-server-webapp项目，并在lib下添加两个jar包 123cas-server-webapp-3.5.2.warcas-server-support-jdbc-x.x.x.jarmysql-connector-java-x.x.x-bin.jar 自定义一个类，这个类的内容可以是复制QueryDatabaseAuthenticationHandler 类中的核心方法： 1234567891011121314151617181920protected final boolean authenticateUsernamePasswordInternal(final UsernamePasswordCredentials credentials) throws AuthenticationException &#123; //获取前台传递过来的值，用户名和密码 final String username = getPrincipalNameTransformer().transform(credentials.getUsername()); final String password = credentials.getPassword(); final String encryptedPassword = this.getPasswordEncoder().encode( password); try &#123; /** * 以下的代码为CAS的数据库认证默认实现，如果想编写自己的实现方式，可以删除一下代码实现自己的登录认证 */ //sql为配置文件中配置的sql语句 final String dbPassword = getJdbcTemplate().queryForObject(this.sql, String.class, username); return dbPassword.equals(encryptedPassword); &#125; catch (final IncorrectResultSizeDataAccessException e) &#123; // this means the username was not found. return false; &#125; &#125; 根据业务需求编写自己的自定义登录方法，修改如下代码即可 12final String dbPassword = getJdbcTemplate().queryForObject(this.sql, String.class, username); return dbPassword.equals(encryptedPassword); 当然也可以访问进行 http://localhost:8080/cas-server-webapp/login 调试。 配置使自定义登录认证生效 1234567891011&lt;!-- 注释掉默认的配置，使用自定义类配置 --&gt; &lt;!-- &lt;bean class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;property name="sql" value="select password from t_user where login_name=?" &gt;&lt;/property&gt; &lt;property name="passwordEncoder" ref="MD5PasswordEncoder" &gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;bean class="com.tgb.handler.CustomQueryDBHandler"&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;property name="sql" value="select password from t_user where login_name=?" &gt;&lt;/property&gt; &lt;!-- &lt;property name="passwordEncoder" ref="MD5PasswordEncoder" &gt;&lt;/property&gt; --&gt; &lt;/bean&gt; 完成以上步骤，自定义登录即可实现！ 自定义错误提示消息（默认实现IncorrectResultSizeDataAccessException继承自RuntimeException） CAS AuthenticationException结构如下图，CAS已经内置了一些异常，比如用户名密码错误、未知的用户名错误等。 当用户名输入正确，而密码错误时提示“密码错误” 只需要在自定义的AuthenticationHandler类的验证方法中，验证失败的地方抛出异常即可。 密码错误的异常类： 请注意代码中的CODE私有属性，该属性定义了一个本地化资源文件中的键，通过该键获取本地化资源中对应语言的文字，这里只实现中文错误消息提示，修改WEB-INF/classes/messages_zh_CN.properties文件，添加CODE定义的键值对，如下示例： error.authentication.credentials.bad.usernameorpassword.password=\u5bc6\u7801\u9519\u8bef 后面面的文字是使用jdk自带的native2ascii编码工具：native2ascii转换成utf-8格式。 接下来只需要在自定义的AuthenticationHandler类的验证方法中，验证失败的地方抛出异常即可。 自定义AuthenticationHandler示例代码如下： 123456789101112131415161718@Override protected final boolean authenticateUsernamePasswordInternal(final UsernamePasswordCredentials credentials) throws AuthenticationException &#123; //获取前台传递过来的值，用户名和密码 final String username = getPrincipalNameTransformer().transform(credentials.getUsername()); final String password = credentials.getPassword(); final String encryptedPassword = this.getPasswordEncoder().encode( password); try &#123; final String dbPassword = null; if (dbPassword == null || dbPassword == "") &#123; throw new BadPasswordAuthenticationException(); &#125; return dbPassword.equals(encryptedPassword); &#125; catch (final IncorrectResultSizeDataAccessException e) &#123; // this means the username was not found. return false; &#125; 配置使自定义错误提示生效 同上（配置自定义登录认证）！ 配置转换器返回更多用户信息从cas server登录成功后，默认只能从cas server得到用户名。但程序中也可能遇到需要得到更多如姓名，手机号，email等更多用户信息的情况。 cas client拿到用户名后再到数据库中查询，的确可以得到关于该用户的更多信息。 但是如果用户登录成功后，直接从cas server返回给cas client用户的详细信息，这也是一个不错的做法。这个好处，尤其是在分布式中得以彰显，cas server可以把用户信息传递给各个应用系统，如果是上面那种做法，那么各个系统得到用户名后，都得去数据库中查询一遍，无疑是一件重复性工作。 首先需要配置属性attributeRepository首先，你需要到WEB-INF目录找到 deployerConfigContext.xml文件，同时配置 attributeRepository 如下： 1234567891011121314151617181920212223&lt;bean class="org.jasig.services.persondir.support.jdbc.SingleRowJdbcPersonAttributeDao" id="attributeRepository"&gt; &lt;constructor-arg index="0" ref="dataSource"/&gt; &lt;constructor-arg index="1" value="select * from t_user where &#123;0&#125;"/&gt; &lt;property name="queryAttributeMapping"&gt; &lt;map&gt; &lt;!--这里的key需写username和登录页面一致，value对应数据库用户名字段--&gt; &lt;entry key="username" value="loginname"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="resultAttributeMapping"&gt; &lt;map&gt; &lt;!--key为对应的数据库字段名称，value为提供给客户端获取的属性名字，系统会自动填充值--&gt; &lt;entry key="Id" value="Id"/&gt; &lt;entry key="password" value="password"/&gt; &lt;entry key="age" value="age"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- &lt;property name="queryType"&gt; &lt;value&gt;OR&lt;/value&gt; &lt;/property&gt; --&gt; &lt;/bean&gt; 其中： 切记：查询出来的字段名中间不能使用 _ (下划线)，否则获取不到数据，如 cell_phone 需要 设置别名为 cellPhone. queryAttributeMapping是组装sql用的查询条件属性，上述配置后，结合封装成查询sql就是 select* from userinfo where loginname=#username# resultAttributeMapping是sql执行完毕后返回的结构属性， key对应数据库字段，value对应客户端获取参数。 如果要组装多个查询条件，需要加上下面这个，默认为AND 12345&lt;property name="queryType"&gt;&lt;value&gt;OR&lt;/value&gt; &lt;/property&gt; 配置用户认证凭据转化的解析器也是在 deployerConfigContext.xml中，为 UsernamePasswordCredentialsToPrincipalResolver注入 attributeRepository，那么 attributeRepository就会被触发并通过此类进行解析，红色为新添部分。 123456789&lt;property name="credentialsToPrincipalResolvers"&gt; &lt;list&gt; &lt;bean class="org.jasig.cas.authentication.principal.UsernamePasswordCredentialsToPrincipalResolver" &gt; &lt;property name="attributeRepository" ref="attributeRepository" /&gt; &lt;/bean&gt; &lt;bean class="org.jasig.cas.authentication.principal.HttpBasedServiceCredentialsToPrincipalResolver" /&gt; &lt;/list&gt; &lt;/property&gt; 修改 deployerConfigContext.xmldeployerConfigContext.xml中的 org.jasig.cas.services.InMemoryServiceRegistryDaoImpl的属性 registeredServices 修改 registeredServices 列表中的每个协议中的 allowedAttributes属性的值。列出的每个值，在客户端就可以访问了 123456789101112131415161718192021&lt;bean id="serviceRegistryDao" class="org.jasig.cas.services.InMemoryServiceRegistryDaoImpl"&gt; &lt;property name="registeredServices"&gt; &lt;list&gt; &lt;bean class="org.jasig.cas.services.RegexRegisteredService"&gt; &lt;property name="id" value="0" /&gt; &lt;property name="name" value="HTTP and IMAP" /&gt; &lt;property name="description" value="Allows HTTP(S) and IMAP(S) protocols" /&gt; &lt;property name="serviceId" value="^(https?|imaps?)://.*" /&gt; &lt;property name="evaluationOrder" value="10000001" /&gt; &lt;property name="allowedAttributes"&gt; &lt;list&gt; &lt;value&gt;Id&lt;/value&gt; &lt;value&gt;password&lt;/value&gt; &lt;value&gt;age&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 此步骤灰常重要，可以看看 org.jasig.cas.services.RegexRegisteredService的源码，其中的 allowedAttributes是关键 【提示】网上说此bean中的ignoreAttributes属性默认是不添加用户信息，查看了 CAS 3.5.2版本的 AbstractRegisteredService 源码后，发现其默认值就是 false，即：添加属性后，客户端就可见了 修改casServiceValidationSuccess.jsp1WEB-INF/view/jsp/protocol/2.0/casServiceValidationSuccess.jsp 在server验证成功后，这个页面负责生成与客户端交互的xml信息，在默认的casServiceValidationSuccess.jsp中，只包括用户名，并不提供其他的属性信息，因此需要对页面进行扩展，如下，红色为新添加部分 123456789101112131415161718192021222324&lt;cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'&gt; &lt;cas:authenticationSuccess&gt; &lt;cas:user&gt;$&#123;fn:escapeXml(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.id)&#125;&lt;/cas:user&gt; &lt;c:if test="$&#123;fn:length(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes) &gt; 0&#125;"&gt; &lt;cas:attributes&gt; &lt;c:forEach var="attr" items="$&#123;assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes&#125;"&gt; &lt;cas:$&#123;fn:escapeXml(attr.key)&#125;&gt;$&#123;fn:escapeXml(attr.value)&#125;&lt;/cas:$&#123;fn:escapeXml(attr.key)&#125;&gt; &lt;/c:forEach&gt; &lt;/cas:attributes&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;not empty pgtIou&#125;"&gt; &lt;cas:proxyGrantingTicket&gt;$&#123;pgtIou&#125;&lt;/cas:proxyGrantingTicket&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;fn:length(assertion.chainedAuthentications) &gt; 1&#125;"&gt; &lt;cas:proxies&gt; &lt;c:forEach var="proxy" items="$&#123;assertion.chainedAuthentications&#125;" varStatus="loopStatus" begin="0" end="$&#123;fn:length(assertion.chainedAuthentications)-2&#125;" step="1"&gt; &lt;cas:proxy&gt;$&#123;fn:escapeXml(proxy.principal.id)&#125;&lt;/cas:proxy&gt; &lt;/c:forEach&gt; &lt;/cas:proxies&gt; &lt;/c:if&gt; &lt;/cas:authenticationSuccess&gt; &lt;/cas:serviceResponse&gt; 通过完成上面四个步骤的配置后，CAS Server端的工作就完成了，那么如何在客户端获取这些信息呢？下面进行说明： cas client获取用户信息： 1234AttributePrincipal principal = (AttributePrincipal) request.getUserPrincipal(); Map attributes = principal.getAttributes(); String email=attributes .get("age"); 补充：cas_client项目：web.XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;cas_client&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;userInfoView.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- ======================== 单点登录开始 ======================== --&gt; &lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置--&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8080/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:18080&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责对Ticket的校验工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8080/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:18080&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责实现HttpServletRequest请求的包裹， --&gt; &lt;!-- 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 --&gt; &lt;!-- 比如AssertionHolder.getAssertion().getPrincipal().getName()。根据客户端获取的方式可以选择使用这两种 --&gt; &lt;!-- &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; --&gt; &lt;!-- ======================== 单点登录结束 ======================== --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;servlet-class&gt;com.tgb.cas.client.HelloWorldExample&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorldExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/HelloWorldExample&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; HelloWorldExample：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class HelloWorldExample extends HttpServlet &#123; private static final long serialVersionUID = 1L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;html&gt;"); out.println("&lt;head&gt;"); String title = "Hello"; out.println("&lt;title&gt;" + title + "&lt;/title&gt;"); out.println("&lt;/head&gt;"); out.println("&lt;body bgcolor=\"white\"&gt;"); out.println("&lt;a href=\"../helloworld.html\"&gt;"); out.println("&lt;img src=\"../images/code.gif\" height=24 " + "width=24 align=right border=0 alt=\"view code\"&gt;&lt;/a&gt;"); out.println("&lt;a href=\"../index.html\"&gt;"); out.println("&lt;img src=\"../images/return.gif\" height=24 " + "width=24 align=right border=0 alt=\"return\"&gt;&lt;/a&gt;"); out.println("&lt;h1&gt;" + title + "&lt;/h1&gt;"); //以下是两种获取用户信息的两种方式，分别与Web.XML中的配置相对应，大家结合理解 // 通过 CAS HttpServletRequest Wrapper Filter 获取用户信息 String userNameString = request.getRemoteUser(); AttributePrincipal principal = (AttributePrincipal) request.getUserPrincipal(); if (null != principal) &#123; Map&lt;String, Object&gt; attMap = principal.getAttributes(); out.println(" Log | getAttributes Map size = " + attMap.size() + "&lt;br&gt;"); for (Entry&lt;String, Object&gt; entry : attMap.entrySet()) &#123; out.println(" | " + entry.getKey() + "=:" + entry.getValue() + "&lt;br&gt;"); &#125; String username = null; out.print(" Log | UserName:"); if (null != principal) &#123; username = principal.getName(); out.println("&lt;span style='color:red;'&gt;" + username + "&lt;/span&gt;&lt;br&gt;"); &#125; &#125; // 通过CAS Assertion Thread Local Filter 获取用户信息，共两种方式 // Assertion assertion = (Assertion) request.getSession().getAttribute( // AbstractCasFilter.CONST_CAS_ASSERTION); // if (null != assertion) &#123; // // Map&lt;String, Object&gt; attMap = assertion.getPrincipal().getAttributes(); // out.println(" Log | getAttributes Map size = " + attMap.size() + "&lt;br&gt;"); // for (Entry&lt;String, Object&gt; entry : attMap.entrySet()) &#123; // out.println(" | " + entry.getKey() + "=:" + entry.getValue() + "&lt;br&gt;"); // &#125; // // AttributePrincipal principal = assertion.getPrincipal(); // // AttributePrincipal principal = (AttributePrincipal) request // // .getUserPrincipal(); // String username = null; // out.print(" Log | UserName:"); // if (null != principal) &#123; // username = principal.getName(); // out.println("&lt;span style='color:red;'&gt;" + username + "&lt;/span&gt;&lt;br&gt;"); // &#125; // &#125; out.println("&lt;/body&gt;"); out.println("&lt;/html&gt;"); &#125; &#125; userInfoView.jsp（未使用）：1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="servlet/HelloWorldExample"&gt;获取Server端用户信息&lt;/a&gt; &lt;br&gt; &lt;a href="http://localhost:8080/cas/logout?service=http://localhost:18080/cas_client/servlet/HelloWorldExample"&gt;单点退出&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 访问：http://localhost:18080/cas_client/servlet/HelloWorldExample 查看效果 其中cas服务端对应的代码是官网中提供的cas-server-webapp-3.5.2.war，而cas_client客户端代码是我们自己编写的，参照tomcat中的example项目。 附录：JS实现cas登录成功跳转其他页面123456789101112131415161718192021222324252627282930313233&lt;!-- 根据url跳转到不同系统的登录界面. --&gt; &lt;script language="javascript" type="text/javascript"&gt; window.onload=function()//用window的onload事件，窗体加载完毕的时候 &#123; //do something var result = location.search.match(new RegExp("[\?\&amp;]" + 'systemId'+ "=([^\&amp;]+)","i")); if(result == || result.length &lt; 1)&#123; //return ""; result =""; &#125; //alert(result[1]); //return result[1]; if("security"==result[1])&#123; //alert("dfdfsdfasdfasdfasdf"); window.location.href="https://www.xx.com:8443/cas/login?service=http%3A%2F%2F172.16.3.199%3A8080%2Fsecurity%2F"; &#125;else&#123; window.location.href="https://www.xx.com:8443/cas/login?service=http%3A%2F%2F172.16.3.199%3A8080%2Fvms2.0%2Fuser%2FtoMain%2F"; &#125; &#125; &lt;!--封装为函数,也可以直接调用.--&gt; function getQueryStringByName(name) &#123; var result = location.search.match(new RegExp("[\?\&amp;]" + name+ "=([^\&amp;]+)","i")); if(result == || result.length &lt; 1)&#123; return ""; &#125; alert(result[1]); return result[1]; &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git查看、删除、重命名远程分支和tag]]></title>
    <url>%2Fblog%2F30226.html</url>
    <content type="text"><![CDATA[Git查看、删除、重命名远程分支和tag 查看远程分支加上-a参数可以查看远程分支，远程分支会用红色表示出来（如果你开了颜色支持的话）： 12345678910$ git branch -a master remote tungway v1.52* zrong remotes/origin/master remotes/origin/tungway remotes/origin/v1.52 remotes/origin/zrong 删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支： 1$ git push origin --delete &lt;branchName&gt; 删除tag这么用： 1git push origin --delete tag &lt;tagName&gt; 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支： 1git push origin : &lt;branchName&gt; 这是删除tag的方法，推送一个空tag到远程tag： 12git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt; 两种语法作用完全相同。删除不存在对应远程分支的本地分支假设这样一种情况： 我创建了本地分支b1并pull到远程分支 origin/b1； 其他人在本地使用fetch或pull创建了本地的b1分支； 我删除了 origin/b1 远程分支； 其他人再次执行fetch或者pull并不会删除这个他们本地的 b1 分支，运行 git branch -a 也不能看出这个branch被删除了，如何处理？ 使用下面的代码查看b1的状态： 123456789101112$ git remote show origin* remote origin Fetch URL: git@github.com:xxx/xxx.git Push URL: git@github.com:xxx/xxx.git HEAD branch: master Remote branches: master tracked refs/remotes/origin/b1 stale (use 'git remote prune' to remove) Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 这时候能够看到b1是stale的，使用 git remote prune origin 可以将其从本地版本库中去除。更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支： 1git fetch -p 重命名远程分支在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。例如下面的例子中，我需要把 devel 分支重命名为 develop 分支： 12345678910$ git branch -av* devel 752bb84 Merge pull request #158 from Gwill/devel master 53b27b8 Merge pull request #138 from tdlrobin/master zrong 2ae98d8 modify CCFileUtils, export getFileData remotes/origin/HEAD -&gt; origin/master remotes/origin/add_build_script d4a8c4f Merge branch 'master' into add_build_script remotes/origin/devel 752bb84 Merge pull request #158 from Gwill/devel remotes/origin/devel_qt51 62208f1 update .gitignore remotes/origin/master 53b27b8 Merge pull request #138 from tdlrobin/master remotes/origin/zrong 2ae98d8 modify CCFileUtils, export getFileData 删除远程分支： 123$ git push --delete origin develTo git@github.com:zrong/quick-cocos2d-x.git - [deleted] devel 重命名本地分支： 1git branch -m devel develop 推送本地分支： 12345678$ git push origin developCounting objects: 92, done.Delta compression using up to 4 threads.Compressing objects: 100% (48/48), done.Writing objects: 100% (58/58), 1.38 MiB, done.Total 58 (delta 34), reused 12 (delta 5)To git@github.com:zrong/quick-cocos2d-x.git * [new branch] develop -&gt; develop 然而，在 github 上操作的时候，我在删除远程分支时碰到这个错误： 12345$ git push --delete origin develremote: error: refusing to delete the current branch: refs/heads/develTo git@github.com:zrong/quick-cocos2d-x.git ! [remote rejected] devel (deletion of the current branch prohibited)error: failed to push some refs to 'git@github.com:zrong/quick-cocos2d-x.git' 这是由于在 github 中，devel 是项目的默认分支。要解决此问题，这样操作：进入 github 中该项目的 Settings 页面；设置 Default Branch 为其他的分支（例如 master）；重新执行删除远程分支命令。把本地tag推送到远程 1git push --tags 获取远程tag 1git fetch origin tag]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术教育的兴起]]></title>
    <url>%2Fblog%2F39389.html</url>
    <content type="text"><![CDATA[有一年，我在台湾环岛旅行。 花莲的海边，我遇到一对台湾青年夫妻，带着女儿在海滩上玩。我们聊了起来。 当时，我还在高校当老师。他们问我，是否觉得台湾的孩子很幸福。我说为什么？爸爸指着女儿说：”这些小孩没有升学压力啊。“ 这倒是事实。台湾有100多所高校，可是生育率不断萎缩，导致很多大学招不到学生。有一篇报道说： 2006年，台湾考生每科只需考到15分就可以上大学，2007年这个纪录被打破，4科加起来只需18分，2008年更夸张，总分7分就能当大学生了。7分就能上大学，因此成为年度笑话。有人调侃：”即使什么都不会，选择题全部猜 C 都能上不错的学校吧！“ 但是，这不能解释一个现象。我想了一会，对那位爸爸道出我的疑惑：”如果考大学如此容易，为什么台湾有那么多补习班呢？“ 没到过台湾的人，想象不到补习班可以做成一个这么大的产业：台湾最热闹的商业街上，都是补习班的霓虹广告；补习班老师是高收入行业，名师就是富豪，也是全社会的知名人物。我不明白，为什么补习班有那么多学生，明明没有升学压力啊？ 爸爸答不出来，想了半天，只说“父母都希望孩子出人头地啊”。 旅行回来后，我发现大陆的补习班行业也蓬勃兴起了，比台湾有过之而无不及。 每个居住小区的周围，都有好几家补习班公司，招生对象从两三岁的娃娃到十几岁的中学生，全部通吃。补习科目无所不包，从语数外到艺术和体育，寒暑假还提供美日欧的游学项目，供家长选择。每到夜晚，灯火通明，门口都是接送孩子的家长。 我们的补习班公司，还上市了。从最早的新东方，到后来的达内科技、正保教育、学而思、51Talk都是绩优公司，在纽约交易所上市，受到投资者追捧。后面还有一大批培训类创业公司，排队等着上市。这在全世界恐怕也是绝无仅有。 历史最悠久、市场需求最大的培训项目，就是外语培训。 我读中学时，同学里面流行上《新概念英语》和口语补习班。到了大学，流行的是托福和 GRE 补习班。大家认定，英语好，人生才有出路。 那时，外企的收入高，比国企要高好几倍，还有出国的机会。如果能拿到美国大学的奖学金，那就是”鱼跃龙门，过而为龙”了。大家都想走这条路。马克思的名言”外语是人生斗争的武器“，是大家的座右铭。 外语改变了很多中国人的人生。马云说，他小时候整天就在西湖边，跟外国人搭讪练习口语，因此认识了澳大利亚的一家人，受邀出国去澳大利亚待了一个月。他大学读的是英语系，第一个创业项目是翻译社，1995年第一次去美国，在西雅图见到了互联网，觉得这玩意有前途，开始互联网创业。也是因为英语，结识了雅虎的创始人杨致远，得到了一笔对于阿里巴巴最为关键的投资。 中国人对于英语的学习热情，造就了新东方这样的补习班巨头。但是，20年过去了，我渐渐发现，英语学习没有以前那么重要了。 一方面，国内的机会和收入越来越多，不比国外少。更重要的是，技术的快速发展，使得语言的壁垒越来越低，甚至消失。 最早的时候是词典软件，只要鼠标一指，就有中文解释，省得查字典了。后来有了翻译软件，都不需要鼠标指来指去了，直接把全文翻译成中文。到了现在，机器翻译已经很可靠了，语法规则的文献，机器翻译的质量接近人工翻译。 最新的技术成果是，谷歌公司推出了一款实时翻译耳机 Buds，已经上市了。你把耳机戴上，对方说英语，你会实时听到翻译后的中文；你用中文回答，对方会听到英文！有了这个东西，未来还有必要去上口语补习班吗？ 我曾经一个人在摩洛哥旅行两周。当地的官方语言是阿拉伯语，上层人士说法语，底层民众说柏柏语，我就会一点英语，大多数时候都无法进行语言交流。但是居然没遇到一点困难，顺利地把这个非洲国家玩了一圈，还在撒哈拉沙漠住了两个晚上。这要感谢两样东西，一是遍及摩洛哥全国的3G网络（华为的功劳），可以随时查交通和酒店的信息，二是准确的地图软件，使我不用问路。 技术使得学好外语，不再那么重要了。对于多数人，这不啻于一个福音，因为外语学习非常耗费生命。 2004年，新加坡领导人李光耀承认了一个错误。独立之初，他决定所有新加坡人不管智商如何，都要学习两门语言，一门是英语，另一门是该人的母语（马来语或汉语）。后来，他发现这个决定有大问题，熟练掌握两门语言，对于人民的要求实在太高了。大多数人根本做不到双语，哪怕学习多年英语，一开口还是结结巴巴，词不达意。强迫所有人学英语，实在是浪费国民的生命。于是，这一年新加坡政府改变规定，只要求人民学习一门语言即可。 随着外语培训的重要性下降，我认为，培训的重头将转为技术培训。以前大家排队去上外语补习班，将来会排队去上技术补习班。 原因就是技术正变得比语言更重要。回到20年前，掌握流利的英语，你会比别人有更多的机会；如今，轮到了技术。谁掌握了技术，谁就有大把的机会。许多家长已经意识到了这一点，小朋友从小不仅要教 ABC，还要教一点编程。 未来的形势远比我们想象的严峻，技术会取代越来越多的人工。展望未来，大部分人，甚至90%以上的人，终其一生只是在社会的底层挣扎，拿着小康或比温饱线略高的工资。 只有技术，才有可能让你翻身。比特币就是一个例子，过去几年中，价格上涨了几百万倍。我知道的许多技术人都通过比特币发了财，而这只是技术带来的财富浪潮之中的一个突出案例。如果你了解技术，你就会看到有这样的机会。现在看上去，只有技术才能提供这样的从底层快速上升的机会。 我有一种悲观的预感。未来只有两种途径可以改变人生，一种是学习技术，另一种是购买彩票。 阮一峰著]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术和执行力]]></title>
    <url>%2Fblog%2F35691.html</url>
    <content type="text"><![CDATA[技术和执行力技术是什么？技术用来解决什么问题？技术能为自己带来什么？ 如上三个问题，是近半年来自己一直思考的问题。曾经听一位老师说过一句话，印象深刻。 技术是不值钱的。 技术为何不值钱呢？我也思考过很多次，现在的感觉就是，技术需要依托场景。没有需求，技术是玩具，无用武之地。技术是用来解决问题的，解决业务需求的。不同的业务场景需要不同的技术去解决，资深技术人员拥有的素质是对业务和技术的结合有评判，技术是否适合，性价比高还是低，都需要一个权衡过程。经验不够丰富的技术人员常常追求新技术，忽视业务的重要性。但也有另一个极端，为了保持业务稳定亘古不化，排斥技术升级换代。这两者都是不可取的，有时，需要技术倒逼业务，实现技术进步。 回到开头三个问题，技术是什么？技术是手段。技术解决什么问题？解决业务需求，提供解决方案。结束能为自己带来什么？ 金钱、声望、成就感。 这是我对技术的理解，谈技术的回报，我更愿意相信技术带来的成就感。精神之愉悦远胜物质的愉悦，若技术人员把技术视作糊口的工具，那技术之路也就走的差不多了。搞技术是需要一点热情和极客精神的。“工作不是为了赚钱，还能是为了情怀吗？”很多人如此说，那么，若工作的技术非你所热爱，那就将你所热爱的技术成为业余的精神补品吧。技术的热爱和技术的进步，带来金钱回报。而不应本末倒置，迷失于铜臭金钱之内。 钻研技术的回报，远远超过你现在短视的利益。 而对技术的热情去付诸实施，需要一定的执行力。过去的一年里，技术了解了不少，技术的广度对于能消化的范围内来讲是足够了。学习新技术，能写出的是 demo 级别的小玩具，但是它在真实的生产环境怎么用，复杂业务场景下的使用方式，和一个人写着玩是有很大区别的。这就产生了矛盾，让你保持技术热情的东西没有发挥的余地，工作用不到，如何实践呢？最好的方式就是参加开源社区了吧，这也是将技术的执行力贯彻的一种方式 摘自:https://rainylog.com/post/2017-2018/]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE.js官方API]]></title>
    <url>%2Fblog%2F14214.html</url>
    <content type="text"><![CDATA[VUE是什么? Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 全局配置Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性： silent 类型：boolean 默认值：false 用法： 1Vue.config.silent = true 取消 Vue 所有的日志与警告。 optionMergeStrategies 类型：{ [key: string]: Function } 默认值：{} 用法： 123456789Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123; return child + 1&#125;const Profile = Vue.extend(&#123; _my_option: 1&#125;)// Profile.options._my_option = 2 自定义合并策略的选项。 合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue 实例上下文被作为第三个参数传入。 参考 自定义选项的混合策略 devtools 类型：boolean 默认值：true (生产版为 false) 用法： 12// 务必在加载 Vue 之后，立即同步设置以下内容Vue.config.devtools = true 配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 errorHandler 类型：Function 默认值：undefined 用法： 12345Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125; 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃。 从 2.4.0 起这个钩子也会捕获 Vue 自定义事件句柄内部的错误了。 错误追踪服务 Sentry 和 Bugsnag 都通过此选项提供了官方支持。 warnHandler 2.4.0 新增 类型：Function 默认值：undefined 用法： 123Vue.config.warnHandler = function (msg, vm, trace) &#123; // `trace` 是组件的继承关系追踪&#125; 为 Vue 的运行时警告赋于一个自定义句柄。注意这只会在开发者环境下生效，在生产环境下它会被忽略。 ignoredElements 类型：Array&lt;string | RegExp&gt; 默认值：[] 用法： 1234567Vue.config.ignoredElements = [ 'my-custom-web-component', 'another-web-component', // 用一个 `RegExp` 忽略所有“ion-”开头的元素 // 仅在 2.5+ 支持 /^ion-/] 须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。 keyCodes 类型：{ [key: string]: number | Array&lt;number&gt; } 默认值：{} 用法： 123456789Vue.config.keyCodes = &#123; v: 86, f1: 112, // camelCase 不可用 mediaPlayPause: 179, // 取而代之的是 kebab-case 且用双引号括起来 "media-play-pause": 179, up: [38, 87]&#125; 1&lt;input type="text" @keyup.media-play-pause="method"&gt; 给 v-on 自定义键位别名。 performance 2.2.0 新增 类型：boolean 默认值：false (自 2.2.3 起) 用法： 设置为 true 以在浏览器开发工具中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。 productionTip 2.2.0 新增 类型：boolean 默认值：true 用法： 设置为 false 以阻止 vue 在启动时生成生产提示。 全局 APIVue.extend( options ) 参数： {Object} options 用法： 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。 data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 1&lt;div id="mount-point"&gt;&lt;/div&gt; 12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point') 结果如下： 1&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; 参考：组件 Vue.nextTick( [callback, context] ) 参数： {Function} [callback] {Object} [context] 用法： 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 123456789101112// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick() .then(function () &#123; // DOM 更新了 &#125;) 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。 Vue.set( target, key, value ) 参数： {Object | Array} target {string | number} key {any} value 返回值：设置的值。 用法： 设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 Vue.delete( target, key ) 参数： {Object | Array} target {string | number} key/index 仅在 2.2.0+ 版本中支持 Array + index 用法。 用法： 删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。 在 2.2.0+ 中同样支持在数组上工作。 目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。 Vue.directive( id, [definition] ) 参数： {string} id {Function | Object} [definition] 用法： 注册或获取全局指令。 12345678910111213141516// 注册Vue.directive('my-directive', &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;)// 注册 (指令函数)Vue.directive('my-directive', function () &#123; // 这里将会被 `bind` 和 `update` 调用&#125;)// getter，返回已注册的指令var myDirective = Vue.directive('my-directive') 参考：自定义指令 Vue.filter( id, [definition] ) 参数： {string} id {Function} [definition] 用法： 注册或获取全局过滤器。 1234567// 注册Vue.filter('my-filter', function (value) &#123; // 返回处理后的值&#125;)// getter，返回已注册的过滤器var myFilter = Vue.filter('my-filter') Vue.component( id, [definition] ) 参数： {string} id {Function | Object} [definition] 用法： 注册或获取全局组件。注册还会自动使用给定的id设置组件的名称 12345678// 注册组件，传入一个扩展过的构造器Vue.component('my-component', Vue.extend(&#123; /* ... */ &#125;))// 注册组件，传入一个选项对象 (自动调用 Vue.extend)Vue.component('my-component', &#123; /* ... */ &#125;)// 获取注册的组件 (始终返回构造器)var MyComponent = Vue.component('my-component') 参考：组件 Vue.use( plugin ) 参数： {Object | Function} plugin 用法： 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法将被作为 Vue 的参数调用。 当 install 方法被同一个插件多次调用，插件将只会被安装一次。 参考：插件 Vue.mixin( mixin ) 参数： {Object} mixin 用法： 全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混合，向组件注入自定义的行为。不推荐在应用代码中使用。 参考：全局混合 Vue.compile( template ) 参数： {string} template 用法： 在 render 函数中编译模板字符串。只在独立构建时有效 123456789var res = Vue.compile('&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;')new Vue(&#123; data: &#123; msg: 'hello' &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) 参考：渲染函数 Vue.version 细节：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。 用法： 123456789var version = Number(Vue.version.split('.')[0])if (version === 2) &#123; // Vue v2.x.x&#125; else if (version === 1) &#123; // Vue v1.x.x&#125; else &#123; // Unsupported versions of Vue&#125; 选项 / 数据data 类型：Object | Function 限制：组件的定义只接受 function。 详细： Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。 一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。 实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a。 以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。 当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(...)) 得到深拷贝的原始数据对象。 示例： 123456789101112131415var data = &#123; a: 1 &#125;// 直接创建一个实例var vm = new Vue(&#123; data: data&#125;)vm.a // =&gt; 1vm.$data === data // =&gt; true// Vue.extend() 中 data 必须是函数var Component = Vue.extend(&#123; data: function () &#123; return &#123; a: 1 &#125; &#125;&#125;) 注意，不应该对 data 属性使用箭头函数 (例如data: () =&gt; { return { a: this.myProp }})。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.myProp 将是 undefined。 props 类型：Array&lt;string&gt; | Object 详细： props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。 示例： 123456789101112131415161718192021// 简单语法Vue.component('props-demo-simple', &#123; props: ['size', 'myMessage']&#125;)// 对象语法，提供校验Vue.component('props-demo-advanced', &#123; props: &#123; // 检测类型 height: Number, // 检测类型 + 其他验证 age: &#123; type: Number, default: 0, required: true, validator: function (value) &#123; return value &gt;= 0 &#125; &#125; &#125;&#125;) 参考：Props propsData 类型：{ [key: string]: any } 限制：只用于 new 创建的实例中。 详细： 创建实例时传递 props。主要作用是方便测试。 示例： 12345678910var Comp = Vue.extend(&#123; props: ['msg'], template: '&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'&#125;)var vm = new Comp(&#123; propsData: &#123; msg: 'hello' &#125;&#125;) 参考：Props computed 类型：{ [key: string]: Function | { get: Function, set: Function } } 详细： 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。 注意，不应该使用箭头函数来定义计算属性函数 (例如 aDouble: () =&gt; this.a * 2)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果实例范畴之外的依赖 (比如非响应式的 not reactive) 是不会触发计算属性更新的。 示例： 12345678910111213141516171819202122var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // =&gt; 2vm.aPlus = 3vm.a // =&gt; 2vm.aDouble // =&gt; 4 参考：计算属性 methods 类型：{ [key: string]: Function } 详细： methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 示例： 12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 2 参考：事件处理器 watch 类型：{ [key: string]: string | Function | Object } 详细： 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 示例： 1234567891011121314151617181920212223242526var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4 &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 方法名 b: 'someMethod', // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, immediate: true &#125; &#125;&#125;)vm.a = 2 // =&gt; new: 2, old: 1 注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 参考：实例方法 / 数据 - vm.$watch 选项 / DOMel 类型：string | HTMLElement 限制：只在由 new 创建的实例中遵守。 详细： 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。 在实例挂载之后，元素可以用 vm.$el 访问。 如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 &lt;html&gt; 或者 &lt;body&gt; 上。 如果 render 函数和 template 属性都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。 参考： 生命周期图示 运行时 + 编译器 vs. 只包含运行时 template 类型：string 详细： 一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。 如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 &lt;script type=&quot;x-template&quot;&gt; 包含模板。 出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。 如果 Vue 选项中包含渲染函数，该模板将被忽略。 参考： 生命周期图示 用插槽分发内容 render 类型：(createElement: () =&gt; VNode) =&gt; VNode 详细： 字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。 如果组件是一个函数组件，渲染函数还会接收一个额外的 context 参数，为没有实例的函数组件提供上下文信息。 Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。 参考：渲染函数 renderError 2.2.0 新增 类型：(createElement: () =&gt; VNode, error: Error) =&gt; VNode 详细： 只在开发者环境下工作。 当 render 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 renderError。这个功能配合 hot-reload 非常实用。 示例： 12345678new Vue(&#123; render (h) &#123; throw new Error('oops') &#125;, renderError (h, err) &#123; return h('pre', &#123; style: &#123; color: 'red' &#125;&#125;, err.stack) &#125;&#125;).$mount('#app') 参考：渲染函数 选项 / 生命周期钩子所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 beforeCreate 类型：Function 详细： 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 参考：生命周期图示 created 类型：Function 详细： 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 参考：生命周期图示 beforeMount 类型：Function 详细： 在挂载开始之前被调用：相关的 render 函数首次被调用。 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 mounted 类型：Function 详细： el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted： 123456mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 beforeUpdate 类型：Function 详细： 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 updated 类型：Function 详细： 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated： 123456updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been re-rendered &#125;)&#125; 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 activated 类型：Function 详细： keep-alive 组件激活时调用。 该钩子在服务器端渲染期间不被调用。 参考： 构建组件 - keep-alive 动态组件 - keep-alive deactivated 类型：Function 详细： keep-alive 组件停用时调用。 该钩子在服务器端渲染期间不被调用。 参考： 构建组件 - keep-alive 动态组件 - keep-alive beforeDestroy 类型：Function 详细： 实例销毁之前调用。在这一步，实例仍然完全可用。 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 destroyed 类型：Function 详细： Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 参考：生命周期图示 errorCaptured 2.5.0+ 新增 类型：(err: Error, vm: Component, info: string) =&gt; ?boolean 详细： 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。 错误传播规则 默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。 如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。 如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。 一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。 选项 / 资源directives 类型：Object 详细： 包含 Vue 实例可用指令的哈希表。 参考：自定义指令 filters 类型：Object 详细： 包含 Vue 实例可用过滤器的哈希表。 参考：Vue.filter components 类型：Object 详细： 包含 Vue 实例可用组件的哈希表。 参考：组件 选项 / 组合parent 类型：Vue instance 详细： 指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。 节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信 mixins 类型：Array&lt;Object&gt; 详细： mixins 选项接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你混合包含一个钩子而创建组件本身也有一个，两个函数将被调用。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。 示例： 123456789var mixin = &#123; created: function () &#123; console.log(1) &#125;&#125;var vm = new Vue(&#123; created: function () &#123; console.log(2) &#125;, mixins: [mixin]&#125;)// =&gt; 1// =&gt; 2 参考：混合 extends 类型：Object | Function 详细： 允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。 这和 mixins 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。 示例： 1234567var CompA = &#123; ... &#125;// 在没有调用 `Vue.extend` 时候继承 CompAvar CompB = &#123; extends: CompA, ...&#125; provide / inject 2.2.0 新增 类型： provide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细： provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是一个字符串数组或一个对象，该对象的 key 代表了本地绑定的名称，value 为其 key (字符串或 Symbol) 以在可用的注入中搜索。 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 示例： 1234567891011121314var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; "bar" &#125; // ...&#125; 利用 ES2015 Symbols、函数 provide 和对象 inject： 1234567891011121314const s = Symbol()const Provider = &#123; provide () &#123; return &#123; [s]: 'foo' &#125; &#125;&#125;const Child = &#123; inject: &#123; s &#125;, // ...&#125; 接下来 2 个例子只工作在 Vue 2.2.1 或更高版本。低于这个版本时，注入的值会在 props 和 data 初始化之后得到。 使用一个注入的值作为一个属性的默认值： 12345678910const Child = &#123; inject: ['foo'], props: &#123; bar: &#123; default () &#123; return this.foo &#125; &#125; &#125;&#125; 使用一个注入的值作为数据入口： 12345678const Child = &#123; inject: ['foo'], data () &#123; return &#123; bar: this.foo &#125; &#125;&#125; 在 2.5.0+ 的注入可以通过设置默认值使其变成可选项： 12345const Child = &#123; inject: &#123; foo: &#123; default: 'foo' &#125; &#125;&#125; 如果它需要从一个不同名字的属性注入，则使用 from 来表示其源属性： 12345678const Child = &#123; inject: &#123; foo: &#123; from: 'bar', default: 'foo' &#125; &#125;&#125; 对于 prop 的默认值来说是类似的，你需要对非原始值使用一个工厂方法： 12345678const Child = &#123; inject: &#123; foo: &#123; from: 'bar', default: () =&gt; [1, 2, 3] &#125; &#125;&#125; 选项 / 其它name 类型：string 限制：只有作为组件选项时起作用。 详细： 允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。 指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools，未命名组件将显示成 &lt;AnonymousComponent&gt;，这很没有语义。通过提供 name 选项，可以获得更有语义信息的组件树。 delimiters 类型：Array&lt;string&gt; 默认值：["{{", "}}"] 限制：这个选项只在完整构建版本中的浏览器内编译时可用。 详细： 改变纯文本插入分隔符。 示例： 12345new Vue(&#123; delimiters: ['$&#123;', '&#125;']&#125;)// 分隔符变成了 ES6 模板字符串的风格 functional 类型：boolean 详细： 使组件无状态 (没有 data ) 和无实例 (没有 this 上下文)。他们用一个简单的 render 函数返回虚拟节点使他们更容易渲染。 参考：函数式组件 model 2.2.0 新增 类型：{ prop?: string, event?: string } 详细： 允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能像使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。 Example： 12345678910111213141516Vue.component('my-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; // this allows using the `value` prop for a different purpose value: String, // use `checked` as the prop which take the place of `value` checked: &#123; type: Number, default: 0 &#125; &#125;, // ...&#125;) 1&lt;my-checkbox v-model="foo" value="some value"&gt;&lt;/my-checkbox&gt; 上述代码相当于： 12345&lt;my-checkbox :checked="foo" @change="val =&gt; &#123; foo = val &#125;" value="some value"&gt;&lt;/my-checkbox&gt; inheritAttrs 2.4.0 新增 类型：boolean 默认值：true 详细： 默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。 注意：这个选项不影响 class 和 style 绑定。 comments 2.4.0 新增 类型：boolean 默认值：false 限制：这个选项只在完整构建版本中的浏览器内编译时可用。 详细： 当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。 实例属性vm.$data 类型：Object 详细： Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。 参考：选项 / 数据 - data vm.$props 2.2.0 新增 类型：Object 详细： 当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问。 vm.$el 类型：HTMLElement 只读 详细： Vue 实例使用的根 DOM 元素。 vm.$options 类型：Object 只读 详细： 用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处： 123456new Vue(&#123; customOption: 'foo', created: function () &#123; console.log(this.$options.customOption) // =&gt; 'foo' &#125;&#125;) vm.$parent 类型：Vue instance 只读 详细： 父实例，如果当前实例有的话。 vm.$root 类型：Vue instance 只读 详细： 当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。 vm.$children 类型：Array&lt;Vue instance&gt; 只读 详细： 当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。 vm.$slots 类型：{ [name: string]: ?Array&lt;VNode&gt; } 只读 详细： 用来访问被插槽分发的内容。每个具名插槽 有其相应的属性 (例如：slot=&quot;foo&quot; 中的内容将会在 vm.$slots.foo 中被找到)。default 属性包括了所有没有被包含在具名插槽中的节点。 在使用渲染函数书写一个组件时，访问 vm.$slots 最有帮助。 示例： 12345678910111213&lt;blog-post&gt; &lt;h1 slot="header"&gt; About Me &lt;/h1&gt; &lt;p&gt;Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.&lt;/p&gt; &lt;p slot="footer"&gt; Copyright 2016 Evan You &lt;/p&gt; &lt;p&gt;If I have some content down here, it will also be included in vm.$slots.default.&lt;/p&gt;.&lt;/blog-post&gt; 123456789101112Vue.component('blog-post', &#123; render: function (createElement) &#123; var header = this.$slots.header var body = this.$slots.default var footer = this.$slots.footer return createElement('div', [ createElement('header', header), createElement('main', body), createElement('footer', footer) ]) &#125;&#125;) 参考： &lt;slot&gt; 组件 使用插槽分发内容 渲染函数 - 插槽 vm.$scopedSlots 2.1.0 新增 类型：{ [name: string]: props =&gt; VNode | Array&lt;VNode&gt; } 只读 详细： 用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。 vm.$scopedSlots 在使用渲染函数开发一个组件时特别有用。 参考： &lt;slot&gt; 组件 作用域插槽 渲染函数 - 插槽 vm.$refs 类型：Object 只读 详细： 一个对象，持有已注册过 ref 的所有子组件。 参考： 子组件引用 特殊特性 - ref vm.$isServer 类型：boolean 只读 详细： 当前 Vue 实例是否运行于服务器。 参考：服务端渲染 vm.$attrs 类型：{ [key: string]: string } 只读 详细： 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建更高层次的组件时非常有用。 vm.$listeners 类型：{ [key: string]: Function | Array&lt;Function&gt; } 只读 详细： 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。 实例方法 / 数据vm.$watch( expOrFn, callback, [options] ) 参数： {string | Function} expOrFn {Function | Object} callback {Object} [options] {boolean} deep {boolean} immediate 返回值：{Function} unwatch 用法： 观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 示例： 1234567891011121314// 键路径vm.$watch('a.b.c', function (newVal, oldVal) &#123; // 做点什么&#125;)// 函数vm.$watch( function () &#123; return this.a + this.b &#125;, function (newVal, oldVal) &#123; // 做点什么 &#125;) vm.$watch 返回一个取消观察函数，用来停止触发回调： 123var unwatch = vm.$watch('a', cb)// 之后取消观察unwatch() 选项：deep 为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 12345vm.$watch('someObject', callback, &#123; deep: true&#125;)vm.someObject.nestedValue = 123// callback is fired 选项：immediate 在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调： 1234vm.$watch('a', callback, &#123; immediate: true&#125;)// 立即以 `a` 的当前值触发回调 vm.$set( target, key, value ) 参数： {Object | Array} target {string | number} key {any} value 返回值：设置的值。 用法： 这是全局 Vue.set 的别名。 参考：Vue.set vm.$delete( target, key ) 参数： {Object | Array} target {string | number} key 用法： 这是全局 Vue.delete 的别名。 参考：Vue.delete 实例方法 / 事件vm.$on( event, callback ) 参数： {string | Array&lt;string&gt;} event (数组只在 2.2.0+ 中支持) {Function} callback 用法： 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。 示例： 12345vm.$on('test', function (msg) &#123; console.log(msg)&#125;)vm.$emit('test', 'hi')// =&gt; "hi" vm.$once( event, callback ) 参数： {string} event {Function} callback 用法： 监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。 vm.$off( [event, callback] ) 参数： {string | Array&lt;string&gt;} event (只在 2.2.2+ 支持数组) {Function} [callback] 用法： 移除自定义事件监听器。 如果没有提供参数，则移除所有的事件监听器； 如果只提供了事件，则移除该事件所有的监听器； 如果同时提供了事件与回调，则只移除这个回调的监听器。 vm.$emit( event, […args] ) 参数： {string} event [...args] 触发当前实例上的事件。附加参数都会传给监听器回调。 实例方法 / 生命周期vm.$mount( [elementOrSelector] ) 参数： {Element | string} [elementOrSelector] {boolean} [hydrating] 返回值：vm - 实例自身 用法： 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。 如果没有提供 elementOrSelector 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。 这个方法返回实例自身，因而可以链式调用其它实例方法。 示例： 12345678910111213var MyComponent = Vue.extend(&#123; template: '&lt;div&gt;Hello!&lt;/div&gt;'&#125;)// 创建并挂载到 #app (会替换 #app)new MyComponent().$mount('#app')// 同上new MyComponent(&#123; el: '#app' &#125;)// 或者，在文档之外渲染并且随后挂载var component = new MyComponent().$mount()document.getElementById('app').appendChild(component.$el) 参考： 生命周期图示 服务端渲染 vm.$forceUpdate() 示例： 迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。 vm.$nextTick( [callback] ) 参数： {Function} [callback] 用法： 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。 示例： 12345678910111213141516new Vue(&#123; // ... methods: &#123; // ... example: function () &#123; // 修改数据 this.message = 'changed' // DOM 还没有更新 this.$nextTick(function () &#123; // DOM 现在更新了 // `this` 绑定到当前实例 this.doSomethingElse() &#125;) &#125; &#125;&#125;) 参考：Vue.nextTick vm.$destroy() 用法： 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。 触发 beforeDestroy 和 destroyed 的钩子。 在大多数场景中你不应该调用这个方法。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。 参考：生命周期图示 指令v-text 预期：string 详细： 更新元素的 textContent。如果要更新部分的 textContent ，需要使用 {{ Mustache }} 插值。 示例： 123&lt;span v-text="msg"&gt;&lt;/span&gt;&lt;!-- 和下面的一样 --&gt;&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; 参考：数据绑定语法 - 插值 v-html 预期：string 详细： 更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。 在单文件组件里，scoped 的样式不会应用在 v-html 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 v-html 的内容设置带作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 &lt;style&gt; 元素手动设置类似 BEM 的作用域策略。 示例： 1&lt;div v-html="html"&gt;&lt;/div&gt; 参考：数据绑定语法 - 插值 v-show 预期：any 用法： 根据表达式之真假值，切换元素的 display CSS 属性。 当条件变化时该指令触发过渡效果。 当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。详见列表渲染教程 参考：条件渲染 - v-show v-if 预期：any 用法： 根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 &lt;template&gt; ，将提出它的内容作为条件块。 当条件变化时该指令触发过渡效果。 参考：条件渲染 - v-if v-else 不需要表达式 限制：前一兄弟元素必须有 v-if 或 v-else-if。 用法： 为 v-if 或者 v-else-if 添加“else 块”。 123456&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; 参考：条件渲染 - v-else v-else-if 2.1.0 新增 类型：any 限制：前一兄弟元素必须有 v-if 或 v-else-if。 用法： 表示 v-if 的 “else if 块”。可以链式调用。 123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 参考：条件渲染 - v-else-if v-for 预期：Array | Object | number | string 用法： 基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 alias in expression ，为当前遍历的元素提供别名： 123&lt;div v-for="item in items"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; 另外也可以为数组索引指定别名 (或者用于对象的键)： 123&lt;div v-for="(item, index) in items"&gt;&lt;/div&gt;&lt;div v-for="(val, key) in object"&gt;&lt;/div&gt;&lt;div v-for="(val, key, index) in object"&gt;&lt;/div&gt; v-for 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 key 的特殊属性： 123&lt;div v-for="item in items" :key="item.id"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; v-for 的详细用法可以通过以下链接查看教程详细说明。 参考： 列表渲染 key v-on 缩写：@ 预期：Function | Inline Statement | Object 参数：event 修饰符： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 用法： 绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。 从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。 用在普通元素上时，只能监听 原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。 在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;。 示例： 1234567891011121314151617181920212223242526272829303132&lt;!-- 方法处理器 --&gt;&lt;button v-on:click="doThis"&gt;&lt;/button&gt;&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on="&#123; mousedown: doThis, mouseup: doThat &#125;"&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click="doThat('hello', $event)"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click="doThis"&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter="onEnter"&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13="onEnter"&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button v-on:click.once="doThis"&gt;&lt;/button&gt; 在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)： 1234567&lt;my-component @my-event="handleThis"&gt;&lt;/my-component&gt;&lt;!-- 内联语句 --&gt;&lt;my-component @my-event="handleThis(123, $event)"&gt;&lt;/my-component&gt;&lt;!-- 组件中的原生事件 --&gt;&lt;my-component @click.native="onClick"&gt;&lt;/my-component&gt; 参考： 事件处理器 组件 - 自定义事件 v-bind 缩写：: 预期：any (with argument) | Object (without argument) 参数：attrOrProp (optional) 修饰符： .prop - 被用于绑定 DOM 属性 (property)。(差别在哪里？) .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持) .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 用法： 动态地绑定一个或多个特性，或一个组件 prop 到表达式。 在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。 在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。 没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。 示例： 1234567891011121314151617181920212223242526272829303132&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src="imageSrc"&gt;&lt;!-- 缩写 --&gt;&lt;img :src="imageSrc"&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src="'/path/to/images/' + fileName"&gt;&lt;!-- class 绑定 --&gt;&lt;div :class="&#123; red: isRed &#125;"&gt;&lt;/div&gt;&lt;div :class="[classA, classB]"&gt;&lt;/div&gt;&lt;div :class="[classA, &#123; classB: isB, classC: isC &#125;]"&gt;&lt;!-- style 绑定 --&gt;&lt;div :style="&#123; fontSize: size + 'px' &#125;"&gt;&lt;/div&gt;&lt;div :style="[styleObjectA, styleObjectB]"&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind="&#123; id: someProp, 'other-attr': otherProp &#125;"&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop="text"&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop="someThing"&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind="$props"&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special="foo"&gt;&lt;/a&gt;&lt;/svg&gt; .camel 修饰符允许在使用 DOM 模板时将 v-bind 属性名称驼峰化，例如 SVG 的 viewBox 属性： 1&lt;svg :view-box.camel="viewBox"&gt;&lt;/svg&gt; 在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel。 参考： Class 与 Style 绑定 组件 - Props 组件 - .sync 修饰符 v-model 预期：随表单控件类型不同而不同。 限制： &lt;input&gt; &lt;select&gt; &lt;textarea&gt; components 修饰符： .lazy - 取代 input 监听 change 事件 .number - 输入字符串转为数字 .trim - 输入首尾空格过滤 用法： 在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。 参考： 表单控件绑定 组件 - 在输入组件上使用自定义事件 v-pre 不需要表达式 用法： 跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 示例： 1&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt; v-cloak 不需要表达式 用法： 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 示例： 123[v-cloak] &#123; display: none;&#125; 123&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 不会显示，直到编译结束。 v-once 不需要表达式 详细： 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 12345678910111213&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt; &lt;h1&gt;comment&lt;/h1&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment="msg"&gt;&lt;/my-component&gt;&lt;!-- `v-for` 指令--&gt;&lt;ul&gt; &lt;li v-for="i in list" v-once&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 参考： 数据绑定语法- 插值 组件 - 对低开销的静态组件使用 v-once 特殊特性key 预期：number | string key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。 最常见的用例是结合 v-for： 123&lt;ul&gt; &lt;li v-for="item in items" :key="item.id"&gt;...&lt;/li&gt;&lt;/ul&gt; 它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用： 完整地触发组件的生命周期钩子 触发过渡 例如： 123&lt;transition&gt; &lt;span :key="text"&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时，&lt;span&gt; 会随时被更新，因此会触发过渡。 ref 预期：string ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： 12345&lt;!-- vm.$refs.p will be the DOM node --&gt;&lt;p ref="p"&gt;hello&lt;/p&gt;&lt;!-- vm.$refs.child will be the child comp instance --&gt;&lt;child-comp ref="child"&gt;&lt;/child-comp&gt; 当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。 关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 参考：子组件 Refs slot 预期：string 用于标记往哪个具名插槽中插入子组件内容。 详细用法，请参考下面指南部分的链接。 参考：具名插槽 slot-scope 2.5.0 新增 预期：function argument expression 用法： 用于将元素或组件表示为作用域插槽。特性的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 scope。 此属性不支持动态绑定。 参考：Scoped Slots scope replaced用于表示一个作为带作用域的插槽的 &lt;template&gt; 元素，它在 2.5.0+ 中被 slot-scope 替代。 用法： 除了 scope 只可以用于 &lt;template&gt; 元素，其它和 slot-scope 都相同。 is 预期：string 用于动态组件且基于 DOM 内模板的限制来工作。 示例： 12345678&lt;!-- component changes when currentView changes --&gt;&lt;component v-bind:is="currentView"&gt;&lt;/component&gt;&lt;!-- necessary because `&lt;my-row&gt;` would be invalid inside --&gt;&lt;!-- a `&lt;table&gt;` element and so would be hoisted out --&gt;&lt;table&gt; &lt;tr is="my-row"&gt;&lt;/tr&gt;&lt;/table&gt; 更多的使用细节，请移步至下面的链接。 See also： 动态组件 DOM 模板解析说明 内置的组件component Props： is - string | ComponentDefinition | ComponentConstructor inline-template - boolean 用法： 渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。 12345&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;&lt;component :is="componentId"&gt;&lt;/component&gt;&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;&lt;component :is="$options.components.child"&gt;&lt;/component&gt; 参考：动态组件 transition Props： name - string，用于自动生成 CSS 过渡类名。例如：name: &#39;fade&#39; 将自动拓展为.fade-enter，.fade-enter-active等。默认类名为 &quot;v&quot; appear - boolean，是否在初始渲染时使用过渡。默认为 false。 css - boolean，是否使用 CSS 过渡类。默认为 true。如果设置为 false，将只通过组件事件触发注册的 JavaScript 钩子。 type - string，指定过渡事件类型，侦听过渡何时结束。有效值为 &quot;transition&quot; 和 &quot;animation&quot;。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。 mode - string，控制离开/进入的过渡时间序列。有效的模式有 &quot;out-in&quot; 和 &quot;in-out&quot;；默认同时生效。 enter-class - string leave-class - string appear-class - string enter-to-class - string leave-to-class - string appear-to-class - string enter-active-class - string leave-active-class - string appear-active-class - string 事件： before-enter before-leave before-appear enter leave appear after-enter after-leave after-appear enter-cancelled leave-cancelled (v-show only) appear-cancelled 用法： &lt;transition&gt; 元素作为单个元素/组件的过渡效果。&lt;transition&gt; 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在检测过的组件层级中。 12345678910111213141516&lt;!-- 简单元素 --&gt;&lt;transition&gt; &lt;div v-if="ok"&gt;toggled content&lt;/div&gt;&lt;/transition&gt;&lt;!-- 动态组件 --&gt;&lt;transition name="fade" mode="out-in" appear&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/transition&gt;&lt;!-- 事件钩子 --&gt;&lt;div id="transition-demo"&gt; &lt;transition @after-enter="transitionComplete"&gt; &lt;div v-show="ok"&gt;toggled content&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt; 123456789new Vue(&#123; ... methods: &#123; transitionComplete: function (el) &#123; // 传入 'el' 这个 DOM 元素作为参数。 &#125; &#125; ...&#125;).$mount('#transition-demo') 参考：过渡：进入，离开和列表 transition-group Props： tag - string，默认为 span move-class - 覆盖移动过渡期间应用的 CSS 类。 除了 mode，其他特性和 &lt;transition&gt; 相同。 事件： 事件和 &lt;transition&gt; 相同。 用法： &lt;transition-group&gt; 元素作为多个元素/组件的过渡效果。&lt;transition-group&gt; 渲染一个真实的 DOM 元素。默认渲染 &lt;span&gt;，可以通过 tag 属性配置哪个元素应该被渲染。 注意，每个 &lt;transition-group&gt; 的子节点必须有 独立的 key ，动画才能正常工作 &lt;transition-group&gt; 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类 (通过 name 属性或配置 move-class 属性自动生成)。如果 CSS transform 属性是“可过渡”属性，当应用移动类时，将会使用 FLIP 技术 使元素流畅地到达动画终点。 12345&lt;transition-group tag="ul" name="slide"&gt; &lt;li v-for="item in items" :key="item.id"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt;&lt;/transition-group&gt; 参考：过渡：进入，离开和列表 keep-alive Props： include - 字符串或正则表达式。只有匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何匹配的组件都不会被缓存。 用法： &lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &lt;transition&gt; 相似，&lt;keep-alive&gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 &lt;keep-alive&gt; 树内的所有嵌套组件中触发。 主要用于保留组件状态或避免重新渲染。 1234567891011121314151617&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if="a &gt; 1"&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 注意，&lt;keep-alive&gt; 是用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，&lt;keep-alive&gt; 要求同时只有一个子元素被渲染。 include and exclude 2.1.0 新增 include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示： 1234567891011121314&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include="a,b"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include="/a|b/"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include="['a', 'b']"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。 &lt;keep-alive&gt; 不会在函数式组件中正常工作，因为它们没有缓存实例。 参考：动态组件 - keep-alive slot Props： name - string，用于命名插槽。 Usage： &lt;slot&gt; 元素作为组件模板之中的内容分发插槽。&lt;slot&gt; 元素自身将被替换。 详细用法，请参考下面教程的链接。 参考：使用插槽分发内容 VNode 接口 请参考 VNode class declaration。 服务端渲染 请参考 vue-server-renderer package documentation。本文内容来自 https://cn.vuejs.org]]></content>
      <categories>
        <category>VueJs</category>
      </categories>
      <tags>
        <tag>VueJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot微服框架学习(二)]]></title>
    <url>%2Fblog%2F31996.html</url>
    <content type="text"><![CDATA[简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 监听器、过滤器和拦截器监听器、过滤器和拦截器监听器监听器Listener，它是实现了javax.servlet.XXXListener接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 在javax.servlet.XXXListener接口中定义了2种方法： void contextInitialized(ServletContextEvent sce) 监听器的初始化 void contextDestroyed(ServletContextEvent sce) 监听器销毁 过滤器Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。其工作原理是，只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可以进行逻辑判断，如用户是否已经登录、有没有权限访问该页面等等工作，它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关的请求，只有当你的web应用停止或重新部署的时候才能销毁。 在javax.servlet.Filter接口中定义了3个方法： void init(FilterConfig filterConfig) 用于完成过滤器的初始化 void destroy() 用于过滤器销毁前，完成某些资源的回收 void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) 实现过滤功能，该方法对每个请求增加额外的处理 拦截器拦截器主要是用在插件上，扩展件上比如spring、struts2等有点类似面向切片的技术，它是基于java反射机制。定义拦截器： 实现HandlerInterceptor 接口，或者继承实现了HandlerInterceptor 接口的类（常用） 。 监听器、过滤器和拦截器的关系及区别 过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。 对请求起到过滤的作用，它在监听器之后，作用在servlet之前，对请求进行过滤。 拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。 监听器（Listener）：当一个事件发生的时候，你希望获得这个事件发生的详细信息，而并不想干预这个事件本身的进程，这就要用到监听器。对项目起到监听的作用，它能感知到包括request(请求域)，session(会话域)和applicaiton(应用程序)的初始化和属性的变化 。对请求和返回进行拦截，它作用在servlet的内部 。 它们之间的关系，可以用一张图来表示： 使用原则对整个流程清楚之后，然后就是各自的使用，在使用之前应该有一个使用规则，为什么这个说，因为有些功能比如判断用户是否登录，既可以用过滤器，也可以用拦截器，用哪一个才是合理的呢？那么如果有一个原则，使用起来就会更加合理。实际上这个原则是有的：把整个项目的流程比作一条河，那么监听器的作用就是能够听到河流里的所有声音，过滤器就是能够过滤出其中的鱼，而拦截器则是拦截其中的部分鱼，并且作标记。所以当需要监听到项目中的一些信息，并且不需要对流程做更改时，用监听器；当需要过滤掉其中的部分信息，只留一部分时，就用过滤器；当需要对其流程进行更改，做相关的记录时用拦截器。 监听器实现过程代码注册方式1234567891011121314151617181920import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class IndexListener implements ServletContextListener&#123; @Override public void contextDestroyed(ServletContextEvent arg0) &#123; System.out.println("IndexListener contextDestroyed method"); &#125; @Override public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println("IndexListener contextInitialized method"); &#125;&#125;@Beanpublic ServletListenerRegistrationBean servletListenerRegistrationBean()&#123; ServletListenerRegistrationBean servletListenerRegistrationBean = new ServletListenerRegistrationBean(); servletListenerRegistrationBean.setListener(new IndexListener()); return servletListenerRegistrationBean;&#125; 注解方式1234567891011121314151617181920212223import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;@WebListenerpublic class IndexListener2 implements ServletContextListener&#123; @Override public void contextDestroyed(ServletContextEvent arg0) &#123; System.out.println("IndexListener2 contextDestroyed method"); &#125; @Override public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println("IndexListener2 contextInitialized method"); &#125;&#125;@SpringBootApplication@ServletComponentScanpublic class SpringBootSimpleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSimpleApplication.class, args); &#125;&#125; 过滤器实现过程代码注册方式1234567891011121314151617181920212223242526272829303132333435363738public class TestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (......) &#123; ...... response.getWriter().write(writeValueAsString); &#125; else &#123; chain.doFilter(request, response); &#125; &#125; @Override public void destroy() &#123; &#125;&#125;@Beanpublic FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); TestFilter testFilter = new TestFilter(); registrationBean.setFilter(testFilter); List&lt;String&gt; urlPatterns = new ArrayList&lt;String&gt;(); urlPatterns.add("/service/extract/json/*"); registrationBean.setUrlPatterns(urlPatterns); return registrationBean;&#125; 注解方式12345678910111213141516171819202122232425262728293031323334353637383940414243import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; /** * 实现javax.servlet.Filter,覆盖其三个方法 * @author Administrator * */ @WebFilter(filterName="testFilter",urlPatterns="/*") public class TestFilter implements Filter&#123; @Override public void destroy() &#123; System.out.println("TestFilter过滤器销毁"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("TestFilter指定过滤器操作......"); //执行操作后必须doFilter chain.doFilter(request, response); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; System.out.println("TestFilter初始化......"); &#125; &#125; @SpringBootApplication@ServletComponentScanpublic class SpringBootSimpleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSimpleApplication.class, args); &#125;&#125; 拦截器实现过程 创建自己的拦截器实现HandlerInterceptor接口 创建自己的拦截器链，继承WebMvcConfigurerAdapter类，重写addInterceptors方法。 实例化自己的拦截器，并加入到拦截器链中。 123456789101112131415161718192021222324252627282930import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; public class CustomInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object object, Exception exception) throws Exception &#123; //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） System.out.println("3. 整个请求结束之后被调用......CustomInterceptor1......"); &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object object, ModelAndView view) throws Exception &#123; // 请求处理之后进行调用，但是在视图被渲染之前 System.out.println("2. 请求处理之后进行调用，但是在视图被渲染之前......CustomInterceptor1......"); &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object object) throws Exception &#123; // 在请求处理之前进行调用 System.out.println("1. 在请求处理之前进行调用......CustomInterceptor1......"); // 只有返回true才会继续向下执行，返回false取消当前请求 return true; &#125; &#125; 123456789101112131415161718192021222324252627import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; import com.example.Interceptor.CustomInterceptor; import com.example.Interceptor.CustomInterceptor2; /** * 继承WebMvcConfigurerAdapter，复写addInterceptors方法 * @author Administrator * */ @Configuration public class WebAdapter extends WebMvcConfigurerAdapter&#123; /** * 主要方法说明： * addPathPatterns 用于添加拦截规则 * excludePathPatterns 用于排除拦截 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; //众多的拦截器组成了一个拦截器链 registry.addInterceptor(new CustomInterceptor()).addPathPatterns("/*"); super.addInterceptors(registry); &#125; &#125; 默认日志logback配置日志简介Spring Boot使用Commons Logging记录所有内部日志，但是它将底层日志实现打开，为Java.Util.Logging，Log4J2和Logback提供默认配置。 在每个案例中，loggers都预先配置，以使用控制台输出，同时还提供可选的文件输出。 默认情况下，如果你使用“starters”，Logback将会被用于记录日志。还包括占用Logback路由，以确保使用Java Util Logging、Commons logging、Log4J或SLF4J的依赖库都能正常工作。 默认日志logbacklogback日志简介SLF4J——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的绑定。 Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。 默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，可以看到很多INFO级别的日志。 从上图可以看到，日志输出内容元素具体如下： 时间日期：精确到毫秒 日志级别：ERROR, WARN, INFO, DEBUG or TRACE 进程ID 分隔符：— 标识实际日志的开始 线程名：方括号括起来（可能会截断控制台输出） Logger名：通常使用源代码的类名 日志内容 用Logback来记录日志，需添加日志依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 实际开发中我们不需要直接添加该依赖，你会发现spring-boot-starter其中包含了spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。 application.properties配置中的日志相关属性控制台输出日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。您还可以通过启动您的应用程序–debug标志来启用“调试”模式（开发的时候推荐开启）,以下两种方式皆可： 在运行命令后加入–debug标志，如： 1$ java -jar springTest.jar --debug 在application.properties中配置debug=true 该属性置为true的时候，核心Loggers（包含嵌入式容器、hibernate、spring）会输出更多内容，启用debug模式并不会使用debug级别配置您的应用程序来记录所有信息。或者，您可以通过在应用程序中使用-trace标志(或在application.properties中配置trace=true)启动应用程序来启用“跟踪”模式。 文件输出默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。 logging.file，设置指定的日志文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log logging.path，设置指定的目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log 默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO日志系统在应用程序生命周期的早期被初始化，并且在通过@propertysource注解加载的属性文件中不会找到这样的日志属性。日志属性与实际的日志基础结构无关。因此，特定的配置键(例如logback中的 logback.configurationFile )不是由spring boot管理的。 彩色日志输出省略... 日志级别所有支持日志记录的系统都可以在Spring环境中设置记录级别（例如在application.properties中）格式为：’logging.level.* = LEVEL’ logging.level：日志级别控制前缀，*为包名或Logger名 LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF root日志可以使用 logging.level.root 配置，application.properties实例： 123logging.level.root=WARNlogging.level.org.springframework.web=DEBUGlogging.level.org.hibernate=ERROR 默认情况下，Spring boot对 Thymeleaf INFO 消息进行了重新映射，使它们在调试级别上被记录，这有助于减少标准日志输出中的噪声。有关如何在自己的配置中应用重新映射的详细信息，请参阅LevelRemappingAppender。 自定义日志配置可以通过在classpath中包含适当的库来激活各种日志系统，并通过在classpath根目录提供适当的配置进行定制。或者在适当的位置提供spring 环境属性logging.config。 还可以强制spring boot使用特定的日志系统通过使用 org.springframework.boot.logging.LoggingSystem 系统属性。 该值应该是一个 LoggingSystem 实现的完全限定类名。 您还可以使用none值完全禁用Spring boot的日志记录配置。 由于日志是在应用程序applicationContext上下文创建之前初始化的，所以不可能在Spring @configuration注解文件中控制来自@propertySource的日志记录。系统属性和常规的Spring boot外部配置文件已经工作得很好。 根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载： Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy Log4j2：log4j2-spring.xml, log4j2.xml JDK (Java Util Logging)：logging.properties 在可能的情况下，我们建议您使用-spring变体来进行日志配置( 如使用logback-spring.xml，而不是logback.xml )。如果使用标准配置logback.xml，Spring无法完全控制日志初始化。 Spring boot包含许多对Logback的扩展，可以帮助高级配置，您可以在您的logback-spring.xml文件中使用这些扩展。在标准配置logback.xml中不能使用这些扩展因为它太早被加载，当然如果一定要使用，需定义一个 logging.config 属性。 注：这些扩展不能与Logback的配置扫描一起使用。如果您尝试这样做，对配置文件进行更改将导致类似于以下日志记录之一的错误: 12ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]] logback日志介绍与配置logback介绍Logback是由log4j创始人设计的又一个开源日志组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个 改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging。logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能。 Logback是要与SLF4J结合起来用两个组件的官方网站如下： logback的官方网站： http://logback.qos.ch SLF4J的官方网站：http://www.slf4j.org logback取代log4j的理由Logback和log4j是非常相似的，如果你对log4j很熟悉，那对logback很快就会得心应手。下面列了logback相对于log4j的一些优点： 更快的实现 Logback的内核重写，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升，初始化内存加载也更小。 非常充分的测试 Logback经过了几年，数不清小时的测试，Logback的测试完全不同级别的。在作者的观点，这是简单重要的原因选择logback而不是log4j。 Logback-classic非常自然实现了SLF4j 因为logback-classic非常自然地实现了SLF4J， 所 以切换到log4j或者其他，非常容易，只需要提供成另一个jar包就OK，根本不需要去动那些通过SLF4JAPI实现的代码。 非常充分的文档 官方网站有两百多页的文档。 自动重新加载配置文件 当配置文件修改，Logback-classic能自动重新加载配置文件。扫描过程快且安全，它并不需要另外创建一个扫描线程。 Lilith Lilith是log事件的观察者，和log4j的chainsaw类似。而lilith还能处理大数量的log数据 。 谨慎的模式和非常友好的恢复 在谨慎模式下，多个FileAppender实例跑在多个JVM下，能 够安全地写道同一个日志文件，RollingFileAppender会有些限制。Logback的FileAppender和它的子类包括 RollingFileAppender能够非常友好地从I/O异常中恢复。 配置文件可以处理不同的情况 开发人员经常需要判断不同的Logback配置文件在不同的环境下（开发，测试，生产）。 Filters（过滤器） 有些时候，需要诊断一个问题，需要打出日志。在log4j，只有降低日志级别，不过这样会打出大量的日志，会影响应用性能。在Logback，你可以继续 保持那个日志级别而除掉某种特殊情况，如alice这个用户登录，她的日志将打在DEBUG级别而其他用户可以继续打在WARN级别。要实现这个功能只需 加4行XML配置。可以参考MDCFIlter 。 SiftingAppender（一个非常多功能的Appender） 它可以用来分割日志文件根据任何一个给定的运行参数。如，SiftingAppender能够区别日志事件跟进用户的Session，然后每个用户会有一个日志文件。 自动压缩已经打出来的log RollingFileAppender在产生新文件的时候，会自动压缩已经打出来的日志文件。压缩是个异步过程，所以甚至对于大的日志文件，在压缩过程中应用不会受任何影响。 堆栈树带有包版本 Logback在打出堆栈树日志时，会带上包的数据。 自动去除旧的日志文件 通过设置TimeBasedRollingPolicy或者SizeAndTimeBasedFNATP的maxHistory属性，你可以控制已经产生日志文件的最大数量。 总之，logback比log4j优秀。 logback配置Logback 配置文件的语法非常灵活。正因为灵活，所以无法用 DTD 或 XML schema 进行定义。尽管如此，可以这样描述配置文件的基本结构：以开头，后面有零个或多个元素，有零个或多个元素，有最多一个元素。 logback配置文件实例： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="false"&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt; &lt;property name="LOG_HOME" value="/home" /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!--myibatis log configure--&gt; &lt;logger name="com.apache.ibatis" level="TRACE"/&gt; &lt;logger name="java.sql.Connection" level="DEBUG"/&gt; &lt;logger name="java.sql.Statement" level="DEBUG"/&gt; &lt;logger name="java.sql.PreparedStatement" level="DEBUG"/&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt; &lt;/configuration&gt; logback日志详解根节点包含的属性scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 例如： 123&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 其他配置省略--&gt;&lt;/configuration&gt; 根节点的子节点 设置上下文名称：每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改。 1234&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;myAppName&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 设置变量：用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 例如使用定义上下文名称，然后在设置logger上下文时使用。 12345&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;property name="APP_Name" value="myAppName" /&gt; &lt;contextName&gt;$&#123;APP_Name&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 获取时间戳字符串：有两个属性，key:标识此 的名字；datePattern：设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循java.txt.SimpleDateFormat的格式。 例如将解析配置文件的时间作为上下文名称： 12345&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/&gt; &lt;contextName&gt;$&#123;bySecond&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 设置logger节点 用来设置某一个包或者具体的某一个类的日志打印级别、以及指定。有一个必选的name属性，一个可选的level和一个可选的addtivity属性。 name:用来指定受此loger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特殊值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。这里总结下各个节点的优先级：root&lt;appender&lt;logger。还需要在实践中不断总结，精确控制日志的输出 addtivity:是否向上级logger传递打印信息。默认是true。（用的不多）可以包含零个或多个元素，标识这个appender将会添加到这个logger。 实践总结：当中包含时，如果addtivity=true，则会将打印信息传递到root；如果addtivity=false，则只会在中打印信息，不会向上传递。 设置root节点也是元素，但是它是根logger， 只有一个level属性。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。默认是DEBUG。 可以包含零个或多个元素，标识这个appender将会添加到这个logger。 实例： 12345678910111213141516package com.logback;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class LogbackDemo &#123; private static final Logger log = LoggerFactory.getLogger(LogbackDemo.class); public static void main(String[] args) &#123; log.trace("======trace"); log.debug("======debug"); log.info("======info"); log.warn("======warn"); log.error("======error"); &#125;&#125; logback.xml配置文件 第1种：只配置root 123456789101112&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )；将root的打印级别设置为“INFO”，指定了名字为“STDOUT”的appender。 当执行com.logback.LogbackDemo类的main方法时，root将级别为“INFO”及大于“INFO”的日志信息交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台； 打印结果如下： 12313:30:38.484 [main] INFO com.logback.LogbackDemo - ======info 13:30:38.500 [main] WARN com.logback.LogbackDemo - ======warn 13:30:38.500 [main] ERROR com.logback.LogbackDemo - ======error 第2种：带有logger的配置，不指定级别，不指定appender， 123456789101112&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- com.logback为java中的包 --&gt; &lt;logger name="com.logback" /&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )；将控制logback包下的所有类的日志的打印，但是并没有设置打印级别，所以继承他的上级的日志级别“DEBUG”；没有设置addtivity，默认为true，将此logger的打印信息向上级传递；没有设置appender，此logger本身不打印任何信息。将root的打印级别设置为“DEBUG”，指定了名字为“STDOUT”的appender。 当执行com.logback.LogbackDemo类的main方法时，因为LogbackDemo 在包logback中，所以首先执行，将级别为“DEBUG”及大于“DEBUG”的日志信息传递给root，本身并不打印； root接到下级传递的信息，交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台。 打印结果如下： 123413:19:15.406 [main] DEBUG com.logback.LogbackDemo - ======debug 13:19:15.406 [main] INFO com.logback.LogbackDemo - ======info 13:19:15.406 [main] WARN com.logback.LogbackDemo - ======warn 13:19:15.406 [main] ERROR com.logback.LogbackDemo - ======error 第3种：带有多个loger的配置，指定级别，指定appender 123456789101112131415&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="com.logback" /&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name="com.logback.LogbackDemo" level="INFO" additivity="false"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/logger&gt; &lt;root level="ERROR"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )；将控制logback包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级的日志级别“DEBUG”；没有设置addtivity，默认为true，将此loger的打印信息向上级传递；没有设置appender，此loger本身不打印任何信息。 控制logback.LogbackDemo类的日志打印，打印级别为“INFO”；additivity属性为false，表示此loger的打印信息不再向上级传递，指定了名字为“STDOUT”的appender。将root的打印级别设置为“ERROR”，指定了名字为“STDOUT”的appender。 当执行com.logback.LogbackDemo类的main方法时，先执行，将级别为“INFO”及大于“INFO”的日志信息交给此loger指定的名为“STDOUT”的appender处理，在控制台中打出日志，不再向次loger的上级 传递打印信息；未接到任何打印信息，当然也不会给它的上级root传递任何打印信息； 打印结果如下： 12314:05:35.937 [main] INFO com.logback.LogbackDemo - ======info14:05:35.937 [main] WARN com.logback.LogbackDemo - ======warn14:05:35.937 [main] ERROR com.logback.LogbackDemo - ======error 如果将修改为 那打印结果将是什么呢？ 没错，日志打印了两次，想必大家都知道原因了，因为打印信息向上级传递，logger本身打印一次，root接到后又打印一次。 这里要注意，中是包含的，所以和节点中的append-ref同时打印日志信息。但是logger的优先级高于root，所以日志信息以logger为主 打印结果如下： 12345614:09:01.531 [main] INFO com.logback.LogbackDemo - ======info14:09:01.531 [main] INFO com.logback.LogbackDemo - ======info14:09:01.531 [main] WARN com.logback.LogbackDemo - ======warn14:09:01.531 [main] WARN com.logback.LogbackDemo - ======warn14:09:01.531 [main] ERROR com.logback.LogbackDemo - ======error14:09:01.531 [main] ERROR com.logback.LogbackDemo - ======error 设置appender节点 是的子节点，是负责写日志的组件。 有两个必要属性name和class。name指定appender名称，class指定appender的全限定名。 ConsoleAppender: 把日志添加到控制台，有以下子节点： ：对日志进行格式化。（具体参数稍后讲解 ） ：字符串 System.out 或者 System.err ，默认 System.out ； 例如： 1234567891011&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/configuration&gt; FileAppender: 把日志添加到文件，有以下子节点： ：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 ：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 ：对记录事件进行格式化。（具体参数稍后讲解 ） ：如果是 true，日志会被安全的写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认是 false。 例如： 12345678910111213&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt; &lt;file&gt;testFile.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; RollingFileAppender: 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。有以下子节点： ：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 ：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 ：对记录事件进行格式化。（具体参数稍后讲解 ） :当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 : 告知 RollingFileAppender 合适激活滚动。 ：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。 rollingPolicy： TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。有以下子节点： :必要节点，包含文件名及“%d”转换符， “%d”可以包含一个java.text.SimpleDateFormat指定的时间格式，如：%d{yyyy-MM}。如果直接使用 %d，默认格式是 yyyy-MM-dd。RollingFileAppender 的file字节点可有可无，通过设置file，可以为活动文件和归档文件指定不同位置，当前日志总是记录到file指定的文件（活动文件），活动文件的名字不会改变；如果没设置file，活动文件的名字会根据fileNamePattern 的值，每隔一段时间改变一次。“/”或者“\”会被当做目录分隔符。 :可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。 FixedWindowRollingPolicy： 根据固定窗口算法重命名文件的滚动策略。有以下子节点： :窗口索引最小值 :窗口索引最大值，当用户指定的窗口过大时，会自动将窗口设置为12。 :必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者 没有log%i.log.zip triggeringPolicy: SizeBasedTriggeringPolicy： 查看当前活动文件的大小，如果超过指定大小会告知RollingFileAppender 触发当前活动文件滚动。只有一个节点::这是活动文件的大小，默认值是10MB。 例如：每天生成一个日志文件，保存30天的日志文件。 1234567891011121314151617&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; 例如：按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。 12345678910111213141516171819202122&lt;configuration&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;test.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt; &lt;fileNamePattern&gt;tests.%i.log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其他Appender 另外还有SocketAppender、SMTPAppender、DBAppender、SyslogAppender、SiftingAppender，并不常用，这些就不在这里讲解了，大家可以参考官方文档。当然大家可以编写自己的Appender。 节点详解： 负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流。 目前PatternLayoutEncoder 是唯一有用的且默认的encoder ，有一个节点，用来设置日志的输入格式。使用“%”加“转换符”方式，如果要输出“%”，则必须用“\”对“\%”进行转义。 例如： 123&lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder 里面的转换符说明： 格式修饰符，与转换符共同使用： 可选的格式修饰符位于“%”和转换符之间。 第一个可选修饰符是左对齐 标志，符号是减号“-”；接着是可选的最小宽度 修饰符，用十进制数表示。如果字符小于最小宽度，则左填充或右填充，默认是左填充（即右对齐），填充符为空格。如果字符大于最小宽度，字符永远不会被截断。最大宽度 修饰符，符号是点号”.”后面加十进制数。如果字符大于最大宽度，则从前面截断。点符号“.”后面加减号“-”在加数字，表示从尾部截断。 例如：%-4relative 表示，将输出从程序启动到创建日志记录的时间 进行左对齐 且最小宽度为4。 appender节点的子节点filter详解: 过滤器，执行一个过滤器会有返回个枚举值，即DENY，NEUTRAL，ACCEPT其中之一。返回DENY，日志将立即被抛弃不再经过其他过滤器；返回NEUTRAL，有序列表里的下个过滤器过接着处理日志；返回ACCEPT，日志会被立即处理，不再经过剩余过滤器。 过滤器被添加到 中，为 添加一个或多个过滤器后，可以用任意条件对日志进行过滤。 有多个过滤器时，按照配置顺序执行。 下面是几个常用的过滤器： LevelFilter： 级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。有以下子节点： :设置过滤级别 :用于配置符合过滤条件的操作 :用于配置不符合过滤条件的操作 例如：将过滤器的日志级别配置为INFO，所有INFO级别的日志交给appender处理，非INFO级别的日志，被过滤掉。 1234567891011121314151617&lt;configuration&gt; &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="CONSOLE" /&gt; &lt;/root&gt;&lt;/configuration&gt; ThresholdFilter： 临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回NEUTRAL；当日志级别低于临界值时，日志会被拒绝。 例如：过滤掉所有低于INFO级别的日志。 12345678910111213141516&lt;configuration&gt; &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 过滤掉 TRACE 和 DEBUG 级别的日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="CONSOLE" /&gt; &lt;/root&gt;&lt;/configuration&gt; EvaluatorFilter： 求值过滤器，评估、鉴别日志是否符合指定条件。有一下子节点： :鉴别器，常用的鉴别器是JaninoEventEvaluato，也是默认的鉴别器，它以任意的java布尔值表达式作为求值条件，求值条件在配置文件解释过成功被动态编译，布尔值表达式返回true就表示符合过滤条件。evaluator有个子标签，用于配置求值条件。 求值表达式作用于当前日志，logback向求值表达式暴露日志的各种字段： :用于配置符合过滤条件的操作 :用于配置不符合过滤条件的操作 例如：过滤掉所有日志消息中不包含“billing”字符串的日志。 123456789101112131415161718192021&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter"&gt; &lt;evaluator&gt; &lt;!-- 默认为 ch.qos.logback.classic.boolex.JaninoEventEvaluator --&gt; &lt;expression&gt;return message.contains("billing");&lt;/expression&gt; &lt;/evaluator&gt; &lt;OnMatch&gt;ACCEPT &lt;/OnMatch&gt; &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %-4relative [%thread] %-5level %logger - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; ：匹配器，尽管可以使用String类的matches()方法进行模式匹配，但会导致每次调用过滤器时都会创建一个新的Pattern对象，为了消除这种开销，可以预定义一个或多个matcher对象，定以后就可以在求值表达式中重复引用。是的子标签。中包含两个子标签，一个是，用于定义matcher的名字，求值表达式中使用这个名字来引用matcher；另一个是，用于配置匹配条件。 例如： 12345678910111213141516171819202122232425&lt;configuration debug="true"&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter"&gt; &lt;evaluator&gt; &lt;matcher&gt; &lt;Name&gt;odd&lt;/Name&gt; &lt;!-- filter out odd numbered statements --&gt; &lt;regex&gt;statement [13579]&lt;/regex&gt; &lt;/matcher&gt; &lt;expression&gt;odd.matches(formattedMessage)&lt;/expression&gt; &lt;/evaluator&gt; &lt;OnMismatch&gt;NEUTRAL&lt;/OnMismatch&gt; &lt;OnMatch&gt;DENY&lt;/OnMatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其他Filter不太常用我这里就不讲了，大家可以参见官网。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot微服框架学习(一)]]></title>
    <url>%2Fblog%2F48216.html</url>
    <content type="text"><![CDATA[简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。Spring Boot具有如下特性： 简化maven配置，快速创建独立的spring应用程序。 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求。 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。 Spring Boot并不是不对Spring功能上的增强，而是提供了一种快速使用Spring的方式。 SpringBoot快速入门快速入门本博客Spring Boot使用版本1.5.8.RELEASE，Spring Boot 1.5.8.RELEASE需要Java 7和Spring Framework 4.3.12.RELEASE或更高版本,你也可以使用Spring Boot with Java 6和一些额外的配置（不建议）,使用Maven（3.2+）或Gradle 2（2.9或更高版本）和3来构建。 本博客系列统一使用Java 1.8，Spring Boot 1.5.8.RELEASE以及Maven3.2.5版本。 一个简单的spring boot项目结构如下： pom.xml：Maven构建说明文件。 DemoApplication.java：一个带有main()方法的类，用于启动应用程序（关键）。 application.properties：一个空的properties文件，你可以根据需要添加配置属性。 创建项目步骤 首先创建一个一般的Maven项目，有一个pom.xml和基本的src/main/java结构。 修改pom.xml为如下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; spring boot父级依赖&gt; 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt;&lt;/parent&gt; 这块配置就是Spring Boot父级依赖，有了这个，当前的项目就是Spring Boot项目了，spring-boot-starter-parent是一个特殊的starter,它用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去version标签。 如果你不想使用某个依赖默认的版本，您还可以通过覆盖自己的项目中的属性来覆盖各个依赖项，例如，要升级到另一个Spring Data版本系列，您可以将以下内容添加到pom.xml中。 123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 原本默认版本是Ingalls-RELEASE的，现在就使用Fowler-SR2版本了。 并不是每个人都喜欢继承自spring-boot-starter-parentPOM。您可能有您需要使用的自己的公司标准parent，或者您可能更喜欢显式声明所有的Maven配置。如果你不想使用spring-boot-starter-parent，您仍然可以通过使用scope = import依赖关系来保持依赖关系管理： 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 该设置不允许您使用如上所述的属性(properties)覆盖各个依赖项，要实现相同的结果，您需要在spring-boot-dependencies项之前的项目的dependencyManagement中添加一个配置，例如，要升级到另一个Spring Data版本系列，您可以将以下内容添加到pom.xml中。 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 起步依赖spring-boot-starter-*&gt; Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。打个比方来说明一下这个起步依赖的好处，比如组装台式机和品牌机，自己组装的话需要自己去选择不同的零件，最后还要组装起来，期间有可能会遇到零件不匹配的问题。耗时又消力，而品牌机就好一点，买来就能直接用的，后续想换零件也是可以的。相比较之下，后者带来的效果更好点（这里就不讨论价格问题哈），起步依赖就像这里的品牌机，自动给你封装好了你想要实现的功能的依赖。就比如我们之前要实现web功能，引入了spring-boot-starter-web这个起步依赖。 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或者某类功能。 spring boot maven插件&gt; 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 上面的配置就是Spring Boot Maven插件，Spring Boot Maven插件提供了许多方便的功能： 把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。 搜索public static void main()方法来标记为可运行类。 应用入口类DemoApplication 123456789101112package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication(scanBasePackages = "com.example")public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; DemoApplication是一个很关键的启动类，程序的入口就是这里。@SpringBootApplication是Sprnig Boot项目的核心注解，主要目的是开启自动配置。main方法这是一个标准的Java应用的main的方法，主要作用是作为项目启动的入口。 控制类DemoController 123456789101112package com.example.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DemoController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; 控制类中添加@RestController以及index方法，@RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出。 运行 启动应用入口类，打开浏览器访问http://localhost:8080/hello, 你就能看到页面显示Hello Spring Boot效果了，一个简单的Web的项目就是如此简单。 单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。 1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new DemoController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125; 开发环境的调试热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 起步依赖spring-boot-starter- 详解 spring-boot-starter –The core Spring Boot starter, including auto-configuration support, logging and YAML. –Spring Boot starter核心模块，包括自动配置支持，日志和YAML。 spring-boot-starter-amqp –Support for the “Advanced Message Queuing Protocol” via spring-rabbit. –高级消息队列协议支持，通过spring-rabbit。 spring-boot-starter-aop –Support for aspect-oriented programming including spring-aop and AspectJ. –面向方面编程支持，包括spring-aop和AspectJ。 spring-boot-starter-batch –Support for “Spring Batch” including HSQLDB database. –Spring Batch批处理框架支持，包括HSQLDB。 spring-boot-starter-cloud-connectors –Support for “Spring Cloud Connectors” which simplifies connecting to services in cloud platforms like Cloud Foundry and Heroku. –简化云平台（Clound Foundry和Heroku）上服务连接的Spring Cloud Connectors支持。 spring-boot-starter-data-elasticsearch –Support for the Elasticsearch search and analytics engine including spring-data-elasticsearch. –Elasticsearch搜索和分析引擎支持，包括spring-data-elasticsearch。 spring-boot-starter-data-gemfire –Support for the GemFire distributed data store including spring-data-gemfire. –GemFire分布式数据存储支持，包括spring-data-gemfire。 spring-boot-starter-data-jpa –Support for the “Java Persistence API” including spring-data-jpa, spring-orm and Hibernate. –持久化支持，包括spring-data-jpa，spring-orm，Hibernate。 spring-boot-starter-data-mongodb –Support for the MongoDB NoSQL Database, including spring-data-mongodb. –MongoDB非关系型数据库支持，包括spring-data-mongodb。 spring-boot-starter-data-rest –Support for exposing Spring Data repositories over REST via spring-data-rest-webmvc. –在REST上暴露spring数据资源库支持，通过spring-data-rest-webmvc。 spring-boot-starter-data-solr –Support for the Apache Solr search platform, including spring-data-solr. –Apache Solr搜索平台支持，包括spring-data-solr。 spring-boot-starter-freemarker –Support for the FreeMarker templating engine. –FreeMarker模版引擎支持。 spring-boot-starter-groovy-templates –Support for the Groovy templating engine. –Groovy模版引擎支持。 spring-boot-starter-hateoas –Support for HATEOAS-based RESTful services via spring-hateoas. –基于hateoas的RESTful服务支持，通过spring-hateoas。 spring-boot-starter-hornetq –Support for “Java Message Service API” via HornetQ. –JMS（java消息服务）API支持，通过HornetQ（支持集群和多种协议，可嵌入、高性能的异步消息系统）。 spring-boot-starter-integration –Support for common spring-integration modules. –公用spring-integeration模块。 spring-boot-starter-jdbc –Support for JDBC databases. –数据库连接支持。 spring-boot-starter-jersey –Support for the Jersey RESTful Web Services framework. –Jersey RESTful Web服务框架支持。 spring-boot-starter-jta-atomikos –Support for JTA distributed transactions via Atomikos. –JTA分布式事务支持，通过Atomikos（Java平台提供增值服务的并且开源类事务管理器）。 spring-boot-starter-jta-bitronix –Support for JTA distributed transactions via Bitronix. –JTA分布式事务支持，通过Bitronix（事务管理器）。 spring-boot-starter-jta-narayana –JTA分布式事务支持，通过narayana（事务管理器）。 spring-boot-starter-mail –Support for javax.mail. spring-boot-starter-mobile –Support for spring-mobile. spring-boot-starter-mustache –Support for the Mustache templating engine. –Mustache模版引擎支持。 spring-boot-starter-redis –Support for the REDIS key-value data store, including spring-redis. –REDIS键值数据存储支持，包括spring-redis。 spring-boot-starter-security –Support for spring-security（基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架）. spring-boot-starter-social-facebook –Support for spring-social-facebook（提供了对Facebook社交网站的支持，只需要简单配置即可）. spring-boot-starter-social-linkedin –Support for spring-social-linkedin（提供了对Linkedin社交网站的支持，只需要简单配置即可）. spring-boot-starter-social-twitter –Support for spring-social-twitter（提供了对Twitter社交网站的支持，只需要简单配置即可）. spring-boot-starter-test –Support for common test dependencies, including JUnit, Hamcrest and Mockito along with the spring-test module. –公用测试依赖支持，包括JUnit，Hamcrest和Mockito，以及spring-test模块。 spring-boot-starter-thymeleaf –Support for the Thymeleaf templating engine, including integration with Spring. –Thymeleaf模版引擎支持，包括spring集成。 spring-boot-starter-velocity –Support for the Velocity templating engine. –Velocity模版引擎支持。 spring-boot-starter-web –Support for full-stack web development, including Tomcat and spring-webmvc. –完整的web开发支持，包括Tomcat和spring-webmvc。 spring-boot-starter-websocket –Support for WebSocket development. spring-boot-starter-ws –Support for Spring Web Services. spring-boot-starter-jooq –对jooq支持，使用jooq访问数据库。 spring-boot-starter-validation –对validation支持，使用Hibernate validation。 spring-boot-starter-activemq –对activemq支持。 spring-boot-starter-data-couchbase –对Couchbase面向文档的数据库和Spring Data Couchbase 的支持。 spring-boot-starter-data-neo4j –对neo4j（高性能的,NOSQL图形数据库）支持。 spring-boot-starter-data-cassandra –对cassandra（开源分布式NoSQL数据库系统）支持。 spring-boot-starter-cache –对缓存支持。 spring-boot-starter-data-ldap –对Spring data 准生产特性的Starter spring-boot-starter-actuator –Production ready features to help you monitor and manage your application. –生产就绪型功能，帮助你监控和管理你的应用。 spring-boot-starter-remote-shell –Adds remote ssh shell support. 排除或替换技术类的Starter spring-boot-starter-jetty –Imports the Jetty HTTP engine (to be used as an alternative to Tomcat). –导入Jetty HTTP引擎(用于作为Tomcat的另一种选择)。 spring-boot-starter-log4j –Support the Log4J logging framework. spring-boot-starter-logging –Import Spring Boot’s default logging framework (Logback). spring-boot-starter-tomcat –Import Spring Boot’s default HTTP engine (Tomcat). spring-boot-starter-undertow –Imports the Undertow HTTP engine (to be used as an alternative to Tomcat). –导入Undertow HTTP引擎(用于作为Tomcat的另一种选择)。 application.properties默认属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193#==============================================================# COMMON SPRING BOOT PROPERTIES## This sample file is provided as a guideline. Do NOT copy it in its# entirety to your own application. ^^^#==============================================================# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# BANNERbanner.charset=UTF-8 # Banner file encoding.banner.location=classpath:banner.txt # Banner file location.banner.image.location=classpath:banner.gif # Banner image file location (jpg/png can also be used).banner.image.width= # Width of the banner image in chars (default 76)banner.image.height= # Height of the banner image in chars (default based on image height)banner.image.margin= # Left hand image margin in chars (default 2)banner.image.invert= # If images should be inverted for dark terminal themes (default false)# LOGGINGlogging.config= # Location of the logging configuration file. For instance `classpath:logback.xml` for Logbacklogging.exception-conversion-word=%wEx # Conversion word used when logging exceptions.logging.file= # Log file name. For instance `myapp.log`logging.level.*= # Log levels severity mapping. For instance `logging.level.org.springframework=DEBUG`logging.path= # Location of the log file. For instance `/var/log`logging.pattern.console= # Appender pattern for output to the console. Only supported with the default logback setup.logging.pattern.file= # Appender pattern for output to the file. Only supported with the default logback setup.logging.pattern.level= # Appender pattern for log level (default %5p). Only supported with the default logback setup.logging.register-shutdown-hook=false # Register a shutdown hook for the logging system when it is initialized.# AOPspring.aop.auto=true # Add @EnableAspectJAutoProxy.spring.aop.proxy-target-class= # Whether subclass-based (CGLIB) proxies are to be created (true) as opposed to standard Java interface-based proxies (false). Defaults to &quot;true&quot; when using Spring Transaction Management, otherwise &quot;false&quot;.# IDENTITY (ContextIdApplicationContextInitializer)spring.application.index= # Application index.spring.application.name= # Application name.# ADMIN (SpringApplicationAdminJmxAutoConfiguration)spring.application.admin.enabled=false # Enable admin features for the application.spring.application.admin.jmx-name=org.springframework.boot:type=Admin,name=SpringApplication # JMX name of the application admin MBean.# AUTO-CONFIGURATIONspring.autoconfigure.exclude= # Auto-configuration classes to exclude.# SPRING COREspring.beaninfo.ignore=true # Skip search of BeanInfo classes.# SPRING CACHE (CacheProperties)spring.cache.cache-names= # Comma-separated list of cache names to create if supported by the underlying cache manager.spring.cache.caffeine.spec= # The spec to use to create caches. Check CaffeineSpec for more details on the spec format.spring.cache.couchbase.expiration=0 # Entry expiration in milliseconds. By default the entries never expire.spring.cache.ehcache.config= # The location of the configuration file to use to initialize EhCache.spring.cache.guava.spec= # The spec to use to create caches. Check CacheBuilderSpec for more details on the spec format.spring.cache.infinispan.config= # The location of the configuration file to use to initialize Infinispan.spring.cache.jcache.config= # The location of the configuration file to use to initialize the cache manager.spring.cache.jcache.provider= # Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Only needed if more than one JSR-107 implementation is available on the classpath.spring.cache.type= # Cache type, auto-detected according to the environment by default.# SPRING CONFIG - using environment property only (ConfigFileApplicationListener)spring.config.location= # Config file locations.spring.config.name=application # Config file name.# HAZELCAST (HazelcastProperties)spring.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.# PROJECT INFORMATION (ProjectInfoProperties)spring.info.build.location=classpath:META-INF/build-info.properties # Location of the generated build-info.properties file.spring.info.git.location=classpath:git.properties # Location of the generated git.properties file.# JMXspring.jmx.default-domain= # JMX domain name.spring.jmx.enabled=true # Expose management beans to the JMX domain.spring.jmx.server=mbeanServer # MBeanServer bean name.# Email (MailProperties)spring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.spring.mail.host= # SMTP server host. For instance `smtp.example.com`spring.mail.jndi-name= # Session JNDI name. When set, takes precedence to others mail settings.spring.mail.password= # Login password of the SMTP server.spring.mail.port= # SMTP server port.spring.mail.properties.*= # Additional JavaMail session properties.spring.mail.protocol=smtp # Protocol used by the SMTP server.spring.mail.test-connection=false # Test that the mail server is available on startup.spring.mail.username= # Login user of the SMTP server.# APPLICATION SETTINGS (SpringApplication)spring.main.banner-mode=console # Mode used to display the banner when the application runs.spring.main.sources= # Sources (class name, package name or XML resource location) to include in the ApplicationContext.spring.main.web-environment= # Run the application in a web environment (auto-detected by default).# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding= # Expected character encoding the application must use.# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.always-use-message-format=false # Set whether to always apply the MessageFormat rules, parsing even messages without arguments.spring.messages.basename=messages # Comma-separated list of basenames, each following the ResourceBundle convention.spring.messages.cache-seconds=-1 # Loaded resource bundle files cache expiration, in seconds. When set to -1, bundles are cached forever.spring.messages.encoding=UTF-8 # Message bundles encoding.spring.messages.fallback-to-system-locale=true # Set whether to fall back to the system Locale if no files for a specific Locale have been found.# OUTPUTspring.output.ansi.enabled=detect # Configure the ANSI output.# PID FILE (ApplicationPidFileWriter)spring.pid.fail-on-write-error= # Fail if ApplicationPidFileWriter is used but it cannot write the PID file.spring.pid.file= # Location of the PID file to write (if ApplicationPidFileWriter is used).# PROFILESspring.profiles.active= # Comma-separated list (or list if using YAML) of active profiles.spring.profiles.include= # Unconditionally activate the specified comma separated profiles (or list of profiles if using YAML).# SENDGRID (SendGridAutoConfiguration)spring.sendgrid.api-key= # SendGrid api key (alternative to username/password).spring.sendgrid.username= # SendGrid account username.spring.sendgrid.password= # SendGrid account password.spring.sendgrid.proxy.host= # SendGrid proxy host.spring.sendgrid.proxy.port= # SendGrid proxy port.# ----------------------------------------# WEB PROPERTIES# ----------------------------------------# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.address= # Network address to which the server should bind to.server.compression.enabled=false # If response compression is enabled.server.compression.excluded-user-agents= # List of user-agents to exclude from compression.server.compression.mime-types=text/html,text/xml,text/plain,text/css,text/javascript,application/javascript # Comma-separated list of MIME types that should be compressed.server.compression.min-response-size=2048 # Minimum response size that is required for compression to be performed.server.connection-timeout= # Time in milliseconds that connectors will wait for another HTTP request before closing the connection. When not set, the connector&apos;s container-specific default will be used. Use a value of -1 to indicate no (i.e. infinite) timeout.server.context-parameters.*= # Servlet context init parameters. For instance `server.context-parameters.a=alpha`server.context-path= # Context path of the application.server.display-name=application # Display name of the application.server.max-http-header-size=0 # Maximum size in bytes of the HTTP message header.server.error.include-stacktrace=never # When to include a &quot;stacktrace&quot; attribute.server.error.path=/error # Path of the error controller.server.error.whitelabel.enabled=true # Enable the default error page displayed in browsers in case of a server error.server.jetty.acceptors= # Number of acceptor threads to use.server.jetty.max-http-post-size=0 # Maximum size in bytes of the HTTP post or put content.server.jetty.selectors= # Number of selector threads to use.server.jsp-servlet.class-name=org.apache.jasper.servlet.JspServlet # The class name of the JSP servlet.server.jsp-servlet.init-parameters.*= # Init parameters used to configure the JSP servletserver.jsp-servlet.registered=true # Whether or not the JSP servlet is registeredserver.port=8080 # Server HTTP port.server.server-header= # Value to use for the Server response header (no header is sent if empty)server.servlet-path=/ # Path of the main dispatcher servlet.server.use-forward-headers= # If X-Forwarded-* headers should be applied to the HttpRequest.server.session.cookie.comment= # Comment for the session cookie.server.session.cookie.domain= # Domain for the session cookie.server.session.cookie.http-only= # &quot;HttpOnly&quot; flag for the session cookie.server.session.cookie.max-age= # Maximum age of the session cookie in seconds.server.session.cookie.name= # Session cookie name.server.session.cookie.path= # Path of the session cookie.server.session.cookie.secure= # &quot;Secure&quot; flag for the session cookie.server.session.persistent=false # Persist session data between restarts.server.session.store-dir= # Directory used to store session data.server.session.timeout= # Session timeout in seconds.server.session.tracking-modes= # Session tracking modes (one or more of the following: &quot;cookie&quot;, &quot;url&quot;, &quot;ssl&quot;).server.ssl.ciphers= # Supported SSL ciphers.server.ssl.client-auth= # Whether client authentication is wanted (&quot;want&quot;) or needed (&quot;need&quot;). Requires a trust store.server.ssl.enabled= # Enable SSL support.server.ssl.enabled-protocols= # Enabled SSL protocols.server.ssl.key-alias= # Alias that identifies the key in the key store.server.ssl.key-password= # Password used to access the key in the key store.server.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file).server.ssl.key-store-password= # Password used to access the key store.server.ssl.key-store-provider= # Provider for the key store.server.ssl.key-store-type= # Type of the key store.server.ssl.protocol=TLS # SSL protocol to use.server.ssl.trust-store= # Trust store that holds SSL certificates.server.ssl.trust-store-password= # Password used to access the trust store.server.ssl.trust-store-provider= # Provider for the trust store.server.ssl.trust-store-type= # Type of the trust store.server.tomcat.accept-count= # Maximum queue length for incoming connection requests when all possible request processing threads are in use.server.tomcat.accesslog.buffered=true # Buffer output such that it is only flushed periodically.server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be relative to the tomcat base dir or absolute.server.tomcat.accesslog.enabled=false # Enable access log.server.tomcat.accesslog.file-date-format=.yyyy-MM-dd # Date format to place in log file name.server.tomcat.accesslog.pattern=common # Format pattern for access logs.server.tomcat.accesslog.prefix=access_log # Log file name prefix.server.tomcat.accesslog.rename-on-rotate=false # Defer inclusion of the date stamp in the file name until rotate time.server.tomcat.accesslog.request-attributes-enabled=false # Set request attributes for IP address, Hostname, protocol and port used for the request.server.tomcat.accesslog.rotate=true # Enable access log rotation.server.tomcat.accesslog.suffix=.log # Log file name suffix.server.tomcat.additional-tld-skip-patterns= # Comma-separated list of additional patterns that match jars to ignore for TLD scanning.server.tomcat.background-processor-delay=30 # Delay in seconds between the invocation of backgroundProcess methods.server.tomcat.basedir= # Tomcat base directory. If not specified a temporary directory will be used.server.tomcat.internal-proxies=10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\ 172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125; # regular expression matching trusted IP addresses.server.tomcat.max-connections= # Maximum number of connections that the server will accept and process at any given time.server.tomcat.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.tomcat.max-threads=0 # Maximum amount of worker threads.server.tomcat.min-spare-threads=0 # Minimum amount of worker threads.server.tomcat.port-header=X-Forwarded-Port # Name of the HTTP header used to override the original port value.server.tomcat.protocol-header= # Header that holds the incoming protocol, usually named &quot;X-Forwarded-Proto&quot;.server.tomcat.protocol-header-https-value=https # Value of the protocol header that indicates that the incoming request uses SSL.server.tomcat.redirect-context-root= # Whether requests to the context root should be redirected by appending a / to the path.server.tomcat.remote-ip-header= # Name of the http header from which the remote ip is extracted. For instance `X-FORWARDED-FOR`server.tomcat.uri-encoding=UTF-8 # Character encoding to use to decode the URI.server.undertow.accesslog.dir= # Undertow access log directory.server.undertow.accesslog.enabled=false # Enable access log.server.undertow.accesslog.pattern=common # Format pattern for access logs.server.undertow.accesslog.prefix=access_log. # Log file name prefix.server.undertow.accesslog.rotate=true # Enable access log rotation.server.undertow.accesslog.suffix=log # Log file name suffix.server.undertow.buffer-size= # Size of each buffer in bytes.server.undertow.direct-buffers= # Allocate buffers outside the Java heap.server.undertow.io-threads= # Number of I/O threads to create for the worker.server.undertow.max-http-post-size=0 # Maximum size in bytes of the HTTP post content.server.undertow.worker-threads= # Number of worker threads.# FREEMARKER (FreeMarkerAutoConfiguration)spring.freemarker.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.freemarker.cache=false # Enable template caching.spring.freemarker.charset=UTF-8 # Template encoding.spring.freemarker.check-template-location=true # Check that the templates location exists.spring.freemarker.content-type=text/html # Content-Type value.spring.freemarker.enabled=true # Enable MVC view resolution for this technology.spring.freemarker.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.freemarker.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.freemarker.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&apos;s macro library, under the name &quot;springMacroRequestContext&quot;.spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker&apos;s Configuration.spring.freemarker.suffix=.ftl # Suffix that gets appended to view names when building a URL.spring.freemarker.template-loader-path=classpath:/templates/ # Comma-separated list of template paths.spring.freemarker.view-names= # White list of view names that can be resolved.# GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)spring.groovy.template.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.groovy.template.cache= # Enable template caching.spring.groovy.template.charset=UTF-8 # Template encoding.spring.groovy.template.check-template-location=true # Check that the templates location exists.spring.groovy.template.configuration.*= # See GroovyMarkupConfigurerspring.groovy.template.content-type=test/html # Content-Type value.spring.groovy.template.enabled=true # Enable MVC view resolution for this technology.spring.groovy.template.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.groovy.template.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&apos;s macro library, under the name &quot;springMacroRequestContext&quot;.spring.groovy.template.prefix= # Prefix that gets prepended to view names when building a URL.spring.groovy.template.request-context-attribute= # Name of the RequestContext attribute for all views.spring.groovy.template.resource-loader-path=classpath:/templates/ # Template path.spring.groovy.template.suffix=.tpl # Suffix that gets appended to view names when building a URL.spring.groovy.template.view-names= # White list of view names that can be resolved.# SPRING HATEOAS (HateoasProperties)spring.hateoas.use-hal-as-default-json-media-type=true # Specify if application/hal+json responses should be sent to requests that accept application/json.# HTTP message conversionspring.http.converters.preferred-json-mapper=jackson # Preferred JSON mapper to use for HTTP message conversion. Set to &quot;gson&quot; to force the use of Gson when both it and Jackson are on the classpath.# HTTP encoding (HttpEncodingProperties)spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not set explicitly.spring.http.encoding.enabled=true # Enable http encoding support.spring.http.encoding.force= # Force the encoding to the configured charset on HTTP requests and responses.spring.http.encoding.force-request= # Force the encoding to the configured charset on HTTP requests. Defaults to true when &quot;force&quot; has not been specified.spring.http.encoding.force-response= # Force the encoding to the configured charset on HTTP responses.spring.http.encoding.mapping= # Locale to Encoding mapping.# MULTIPART (MultipartProperties)spring.http.multipart.enabled=true # Enable support of multi-part uploads.spring.http.multipart.file-size-threshold=0 # Threshold after which files will be written to disk. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.spring.http.multipart.location= # Intermediate location of uploaded files.spring.http.multipart.max-file-size=1MB # Max file size. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.spring.http.multipart.max-request-size=10MB # Max request size. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.spring.http.multipart.resolve-lazily=false # Whether to resolve the multipart request lazily at the time of file or parameter access.# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance `yyyy-MM-dd HH:mm:ss`.spring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization.spring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.spring.jackson.generator.*= # Jackson on/off features for generators.spring.jackson.joda-date-time-format= # Joda date time format string. If not configured, &quot;date-format&quot; will be used as a fallback if it is configured with a format string.spring.jackson.locale= # Locale used for formatting.spring.jackson.mapper.*= # Jackson general purpose on/off features.spring.jackson.parser.*= # Jackson on/off features for parsers.spring.jackson.property-naming-strategy= # One of the constants on Jackson&apos;s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.spring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.spring.jackson.time-zone= # Time zone used when formatting dates. For instance `America/Los_Angeles`# JERSEY (JerseyProperties)spring.jersey.application-path= # Path that serves as the base URI for the application. Overrides the value of &quot;@ApplicationPath&quot; if specified.spring.jersey.filter.order=0 # Jersey filter chain order.spring.jersey.init.*= # Init parameters to pass to Jersey via the servlet or filter.spring.jersey.servlet.load-on-startup=-1 # Load on startup priority of the Jersey servlet.spring.jersey.type=servlet # Jersey integration type.# SPRING LDAP (LdapProperties)spring.ldap.urls= # LDAP URLs of the server.spring.ldap.base= # Base suffix from which all operations should originate.spring.ldap.username= # Login user of the server.spring.ldap.password= # Login password of the server.spring.ldap.base-environment.*= # LDAP specification settings.# EMBEDDED LDAP (EmbeddedLdapProperties)spring.ldap.embedded.base-dn= # The base DNspring.ldap.embedded.credential.username= # Embedded LDAP username.spring.ldap.embedded.credential.password= # Embedded LDAP password.spring.ldap.embedded.ldif=classpath:schema.ldif # Schema (LDIF) script resource reference.spring.ldap.embedded.port= # Embedded LDAP port.spring.ldap.embedded.validation.enabled=true # Enable LDAP schema validation.spring.ldap.embedded.validation.schema= # Path to the custom schema.# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enable-fallback=false # Enable support for fallback resolution.spring.mobile.devicedelegatingviewresolver.enabled=false # Enable device view resolver.spring.mobile.devicedelegatingviewresolver.mobile-prefix=mobile/ # Prefix that gets prepended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.mobile-suffix= # Suffix that gets appended to view names for mobile devices.spring.mobile.devicedelegatingviewresolver.normal-prefix= # Prefix that gets prepended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.normal-suffix= # Suffix that gets appended to view names for normal devices.spring.mobile.devicedelegatingviewresolver.tablet-prefix=tablet/ # Prefix that gets prepended to view names for tablet devices.spring.mobile.devicedelegatingviewresolver.tablet-suffix= # Suffix that gets appended to view names for tablet devices.# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # Enable SitePreferenceHandler.# MUSTACHE TEMPLATES (MustacheAutoConfiguration)spring.mustache.allow-request-override= # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.allow-session-override= # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.spring.mustache.cache= # Enable template caching.spring.mustache.charset= # Template encoding.spring.mustache.check-template-location= # Check that the templates location exists.spring.mustache.content-type= # Content-Type value.spring.mustache.enabled= # Enable MVC view resolution for this technology.spring.mustache.expose-request-attributes= # Set whether all request attributes should be added to the model prior to merging with the template.spring.mustache.expose-session-attributes= # Set whether all HttpSession attributes should be added to the model prior to merging with the template.spring.mustache.expose-spring-macro-helpers= # Set whether to expose a RequestContext for use by Spring&apos;s macro library, under the name &quot;springMacroRequestContext&quot;.spring.mustache.prefix=classpath:/templates/ # Prefix to apply to template names.spring.mustache.request-context-attribute= # Name of the RequestContext attribute for all views.spring.mustache.suffix=.html # Suffix to apply to template names.spring.mustache.view-names= # White list of view names that can be resolved.# SPRING MVC (WebMvcProperties)spring.mvc.async.request-timeout= # Amount of time (in milliseconds) before asynchronous request handling times out.spring.mvc.date-format= # Date format to use. For instance `dd/MM/yyyy`.spring.mvc.dispatch-trace-request=false # Dispatch TRACE requests to the FrameworkServlet doService method.spring.mvc.dispatch-options-request=true # Dispatch OPTIONS requests to the FrameworkServlet doService method.spring.mvc.favicon.enabled=true # Enable resolution of favicon.ico.spring.mvc.formcontent.putfilter.enabled=true # Enable Spring&apos;s HttpPutFormContentFilter.spring.mvc.ignore-default-model-on-redirect=true # If the content of the &quot;default&quot; model should be ignored during redirect scenarios.spring.mvc.locale= # Locale to use. By default, this locale is overridden by the &quot;Accept-Language&quot; header.spring.mvc.locale-resolver=accept-header # Define how the locale should be resolved.spring.mvc.log-resolved-exception=false # Enable warn logging of exceptions resolved by a &quot;HandlerExceptionResolver&quot;.spring.mvc.media-types.*= # Maps file extensions to media types for content negotiation.spring.mvc.message-codes-resolver-format= # Formatting strategy for message codes. For instance `PREFIX_ERROR_CODE`.spring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.spring.mvc.static-path-pattern=/** # Path pattern used for static resources.spring.mvc.throw-exception-if-no-handler-found=false # If a &quot;NoHandlerFoundException&quot; should be thrown if no Handler was found to process a request.spring.mvc.view.prefix= # Spring MVC view prefix.spring.mvc.view.suffix= # Spring MVC view suffix.# SPRING RESOURCES HANDLING (ResourceProperties)spring.resources.add-mappings=true # Enable default resource handling.spring.resources.cache-period= # Cache period for the resources served by the resource handler, in seconds.spring.resources.chain.cache=true # Enable caching in the Resource chain.spring.resources.chain.enabled= # Enable the Spring Resource Handling chain. Disabled by default unless at least one strategy has been enabled.spring.resources.chain.gzipped=false # Enable resolution of already gzipped resources.spring.resources.chain.html-application-cache=false # Enable HTML5 application cache manifest rewriting.spring.resources.chain.strategy.content.enabled=false # Enable the content Version Strategy.spring.resources.chain.strategy.content.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.enabled=false # Enable the fixed Version Strategy.spring.resources.chain.strategy.fixed.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.spring.resources.chain.strategy.fixed.version= # Version string to use for the Version Strategy.spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # Locations of static resources.# SPRING SESSION (SessionProperties)spring.session.hazelcast.flush-mode=on-save # Sessions flush mode.spring.session.hazelcast.map-name=spring:session:sessions # Name of the map used to store sessions.spring.session.jdbc.initializer.enabled= # Create the required session tables on startup if necessary. Enabled automatically if the default table name is set or a custom schema is configured.spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.session.jdbc.table-name=SPRING_SESSION # Name of database table used to store sessions.spring.session.mongo.collection-name=sessions # Collection name used to store sessions.spring.session.redis.flush-mode=on-save # Sessions flush mode.spring.session.redis.namespace= # Namespace for keys used to store sessions.spring.session.store-type= # Session store type.# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=false # Enable the connection status view for supported providers.# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application&apos;s Facebook App IDspring.social.facebook.app-secret= # your application&apos;s Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application&apos;s LinkedIn App IDspring.social.linkedin.app-secret= # your application&apos;s LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application&apos;s Twitter App IDspring.social.twitter.app-secret= # your application&apos;s Twitter App Secret# THYMELEAF (ThymeleafAutoConfiguration)spring.thymeleaf.cache=true # Enable template caching.spring.thymeleaf.check-template=true # Check that the template exists before rendering it.spring.thymeleaf.check-template-location=true # Check that the templates location exists.spring.thymeleaf.content-type=text/html # Content-Type value.spring.thymeleaf.enabled=true # Enable MVC Thymeleaf view resolution.spring.thymeleaf.encoding=UTF-8 # Template encoding.spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.# SPRING WEB SERVICES (WebServicesProperties)spring.webservices.path=/services # Path that serves as the base URI for the services.spring.webservices.servlet.init= # Servlet init parameters to pass to Spring Web Services.spring.webservices.servlet.load-on-startup=-1 # Load on startup priority of the Spring Web Services servlet.# ----------------------------------------# SECURITY PROPERTIES# ----------------------------------------# SECURITY (SecurityProperties)security.basic.authorize-mode=role # Security authorize mode to apply.security.basic.enabled=true # Enable basic authentication.security.basic.path=/** # Comma-separated list of paths to secure.security.basic.realm=Spring # HTTP basic realm name.security.enable-csrf=false # Enable Cross Site Request Forgery support.security.filter-order=0 # Security filter chain order.security.filter-dispatcher-types=ASYNC, FORWARD, INCLUDE, REQUEST # Security filter chain dispatcher types.security.headers.cache=true # Enable cache control HTTP headers.security.headers.content-security-policy= # Value for content security policy header.security.headers.content-security-policy-mode=default # Content security policy mode.security.headers.content-type=true # Enable &quot;X-Content-Type-Options&quot; header.security.headers.frame=true # Enable &quot;X-Frame-Options&quot; header.security.headers.hsts=all # HTTP Strict Transport Security (HSTS) mode (none, domain, all).security.headers.xss=true # Enable cross site scripting (XSS) protection.security.ignored= # Comma-separated list of paths to exclude from the default secured paths.security.require-ssl=false # Enable secure channel for all requests.security.sessions=stateless # Session creation policy (always, never, if_required, stateless).security.user.name=user # Default user name.security.user.password= # Password for the default user name. A random password is logged on startup by default.security.user.role=USER # Granted roles for the default user name.# SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)security.oauth2.client.client-id= # OAuth2 client id.security.oauth2.client.client-secret= # OAuth2 client secret. A random secret is generated by default# SECURITY OAUTH2 RESOURCES (ResourceServerProperties)security.oauth2.resource.filter-order= # The order of the filter chain used to authenticate tokens.security.oauth2.resource.id= # Identifier of the resource.security.oauth2.resource.jwt.key-uri= # The URI of the JWT token. Can be set if the value is not available and the key is public.security.oauth2.resource.jwt.key-value= # The verification key of the JWT token. Can either be a symmetric secret or PEM-encoded RSA public key.security.oauth2.resource.jwk.key-set-uri= # The URI for getting the set of keys that can be used to validate the token.security.oauth2.resource.prefer-token-info=true # Use the token info, can be set to false to use the user info.security.oauth2.resource.service-id=resource #security.oauth2.resource.token-info-uri= # URI of the token decoding endpoint.security.oauth2.resource.token-type= # The token type to send when using the userInfoUri.security.oauth2.resource.user-info-uri= # URI of the user endpoint.# SECURITY OAUTH2 SSO (OAuth2SsoProperties)security.oauth2.sso.filter-order= # Filter order to apply if not providing an explicit WebSecurityConfigurerAdaptersecurity.oauth2.sso.login-path=/login # Path to the login page, i.e. the one that triggers the redirect to the OAuth2 Authorization Server# ----------------------------------------# DATA PROPERTIES# ----------------------------------------# FLYWAY (FlywayProperties)flyway.baseline-description= #flyway.baseline-version=1 # version to start migrationflyway.baseline-on-migrate= #flyway.check-location=false # Check that migration scripts location exists.flyway.clean-on-validation-error= #flyway.enabled=true # Enable flyway.flyway.encoding= #flyway.ignore-failed-future-migration= #flyway.init-sqls= # SQL statements to execute to initialize a connection immediately after obtaining it.flyway.locations=classpath:db/migration # locations of migrations scriptsflyway.out-of-order= #flyway.password= # JDBC password if you want Flyway to create its own DataSourceflyway.placeholder-prefix= #flyway.placeholder-replacement= #flyway.placeholder-suffix= #flyway.placeholders.*= #flyway.schemas= # schemas to updateflyway.sql-migration-prefix=V #flyway.sql-migration-separator= #flyway.sql-migration-suffix=.sql #flyway.table= #flyway.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.flyway.user= # Login user of the database to migrate.flyway.validate-on-migrate= ## LIQUIBASE (LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml # Change log configuration path.liquibase.check-change-log-location=true # Check the change log location exists.liquibase.contexts= # Comma-separated list of runtime contexts to use.liquibase.default-schema= # Default database schema.liquibase.drop-first=false # Drop the database schema first.liquibase.enabled=true # Enable liquibase support.liquibase.labels= # Comma-separated list of runtime labels to use.liquibase.parameters.*= # Change log parameters.liquibase.password= # Login password of the database to migrate.liquibase.rollback-file= # File to which rollback SQL will be written when an update is performed.liquibase.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.liquibase.user= # Login user of the database to migrate.# COUCHBASE (CouchbaseProperties)spring.couchbase.bootstrap-hosts= # Couchbase nodes (host or IP address) to bootstrap from.spring.couchbase.bucket.name=default # Name of the bucket to connect to.spring.couchbase.bucket.password= # Password of the bucket.spring.couchbase.env.endpoints.key-value=1 # Number of sockets per node against the Key/value service.spring.couchbase.env.endpoints.query=1 # Number of sockets per node against the Query (N1QL) service.spring.couchbase.env.endpoints.view=1 # Number of sockets per node against the view service.spring.couchbase.env.ssl.enabled= # Enable SSL support. Enabled automatically if a &quot;keyStore&quot; is provided unless specified otherwise.spring.couchbase.env.ssl.key-store= # Path to the JVM key store that holds the certificates.spring.couchbase.env.ssl.key-store-password= # Password used to access the key store.spring.couchbase.env.timeouts.connect=5000 # Bucket connections timeout in milliseconds.spring.couchbase.env.timeouts.key-value=2500 # Blocking operations performed on a specific key timeout in milliseconds.spring.couchbase.env.timeouts.query=7500 # N1QL query operations timeout in milliseconds.spring.couchbase.env.timeouts.socket-connect=1000 # Socket connect connections timeout in milliseconds.spring.couchbase.env.timeouts.view=7500 # Regular and geospatial view operations timeout in milliseconds.# DAO (PersistenceExceptionTranslationAutoConfiguration)spring.dao.exceptiontranslation.enabled=true # Enable the PersistenceExceptionTranslationPostProcessor.# CASSANDRA (CassandraProperties)spring.data.cassandra.cluster-name= # Name of the Cassandra cluster.spring.data.cassandra.compression=none # Compression supported by the Cassandra binary protocol.spring.data.cassandra.connect-timeout-millis= # Socket option: connection time out.spring.data.cassandra.consistency-level= # Queries consistency level.spring.data.cassandra.contact-points=localhost # Comma-separated list of cluster node addresses.spring.data.cassandra.fetch-size= # Queries default fetch size.spring.data.cassandra.keyspace-name= # Keyspace name to use.spring.data.cassandra.load-balancing-policy= # Class name of the load balancing policy.spring.data.cassandra.port= # Port of the Cassandra server.spring.data.cassandra.password= # Login password of the server.spring.data.cassandra.read-timeout-millis= # Socket option: read time out.spring.data.cassandra.reconnection-policy= # Reconnection policy class.spring.data.cassandra.repositories.enabled= # Enable Cassandra repositories.spring.data.cassandra.retry-policy= # Class name of the retry policy.spring.data.cassandra.serial-consistency-level= # Queries serial consistency level.spring.data.cassandra.schema-action=none # Schema action to take at startup.spring.data.cassandra.ssl=false # Enable SSL support.spring.data.cassandra.username= # Login user of the server.# DATA COUCHBASE (CouchbaseDataProperties)spring.data.couchbase.auto-index=false # Automatically create views and indexes.spring.data.couchbase.consistency=read-your-own-writes # Consistency to apply by default on generated queries.spring.data.couchbase.repositories.enabled=true # Enable Couchbase repositories.# ELASTICSEARCH (ElasticsearchProperties)spring.data.elasticsearch.cluster-name=elasticsearch # Elasticsearch cluster name.spring.data.elasticsearch.cluster-nodes= # Comma-separated list of cluster node addresses. If not specified, starts a client node.spring.data.elasticsearch.properties.*= # Additional properties used to configure the client.spring.data.elasticsearch.repositories.enabled=true # Enable Elasticsearch repositories.# DATA LDAPspring.data.ldap.repositories.enabled=true # Enable LDAP repositories.# MONGODB (MongoProperties)spring.data.mongodb.authentication-database= # Authentication database name.spring.data.mongodb.database=test # Database name.spring.data.mongodb.field-naming-strategy= # Fully qualified name of the FieldNamingStrategy to use.spring.data.mongodb.grid-fs-database= # GridFS database name.spring.data.mongodb.host=localhost # Mongo server host. Cannot be set with uri.spring.data.mongodb.password= # Login password of the mongo server. Cannot be set with uri.spring.data.mongodb.port=27017 # Mongo server port. Cannot be set with uri.spring.data.mongodb.repositories.enabled=true # Enable Mongo repositories.spring.data.mongodb.uri=mongodb://localhost/test # Mongo database URI. Cannot be set with host, port and credentials.spring.data.mongodb.username= # Login user of the mongo server. Cannot be set with uri.# DATA REDISspring.data.redis.repositories.enabled=true # Enable Redis repositories.# NEO4J (Neo4jProperties)spring.data.neo4j.compiler= # Compiler to use.spring.data.neo4j.embedded.enabled=true # Enable embedded mode if the embedded driver is available.spring.data.neo4j.open-in-view=false # Register OpenSessionInViewInterceptor. Binds a Neo4j Session to the thread for the entire processing of the request.spring.data.neo4j.password= # Login password of the server.spring.data.neo4j.repositories.enabled=true # Enable Neo4j repositories.spring.data.neo4j.uri= # URI used by the driver. Auto-detected by default.spring.data.neo4j.username= # Login user of the server.# DATA REST (RepositoryRestProperties)spring.data.rest.base-path= # Base path to be used by Spring Data REST to expose repository resources.spring.data.rest.default-page-size= # Default size of pages.spring.data.rest.detection-strategy=default # Strategy to use to determine which repositories get exposed.spring.data.rest.enable-enum-translation= # Enable enum value translation via the Spring Data REST default resource bundle.spring.data.rest.limit-param-name= # Name of the URL query string parameter that indicates how many results to return at once.spring.data.rest.max-page-size= # Maximum size of pages.spring.data.rest.page-param-name= # Name of the URL query string parameter that indicates what page to return.spring.data.rest.return-body-on-create= # Return a response body after creating an entity.spring.data.rest.return-body-on-update= # Return a response body after updating an entity.spring.data.rest.sort-param-name= # Name of the URL query string parameter that indicates what direction to sort results.# SOLR (SolrProperties)spring.data.solr.host=http://127.0.0.1:8983/solr # Solr host. Ignored if &quot;zk-host&quot; is set.spring.data.solr.repositories.enabled=true # Enable Solr repositories.spring.data.solr.zk-host= # ZooKeeper host address in the form HOST:PORT.# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.continue-on-error=false # Do not stop if an error occurs while initializing the database.spring.datasource.data= # Data (DML) script resource references.spring.datasource.data-username= # User of the database to execute DML scripts (if different).spring.datasource.data-password= # Password of the database to execute DML scripts (if different).spring.datasource.dbcp2.*= # Commons DBCP2 specific settingsspring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.spring.datasource.generate-unique-name=false # Generate a random datasource name.spring.datasource.hikari.*= # Hikari specific settingsspring.datasource.initialize=true # Populate the database using &apos;data.sql&apos;.spring.datasource.jmx-enabled=false # Enable JMX support (if provided by the underlying pool).spring.datasource.jndi-name= # JNDI location of the datasource. Class, url, username &amp; password are ignored when set.spring.datasource.name=testdb # Name of the datasource.spring.datasource.password= # Login password of the database.spring.datasource.platform=all # Platform to use in the DDL or DML scripts (e.g. schema-$&#123;platform&#125;.sql or data-$&#123;platform&#125;.sql).spring.datasource.schema= # Schema (DDL) script resource references.spring.datasource.schema-username= # User of the database to execute DDL scripts (if different).spring.datasource.schema-password= # Password of the database to execute DDL scripts (if different).spring.datasource.separator=; # Statement separator in SQL initialization scripts.spring.datasource.sql-script-encoding= # SQL scripts encoding.spring.datasource.tomcat.*= # Tomcat datasource specific settingsspring.datasource.type= # Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.spring.datasource.url= # JDBC url of the database.spring.datasource.username= # Login user of the database.spring.datasource.xa.data-source-class-name= # XA datasource fully qualified name.spring.datasource.xa.properties= # Properties to pass to the XA data source.# JEST (Elasticsearch HTTP client) (JestProperties)spring.elasticsearch.jest.connection-timeout=3000 # Connection timeout in milliseconds.spring.elasticsearch.jest.multi-threaded=true # Enable connection requests from multiple execution threads.spring.elasticsearch.jest.password= # Login password.spring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.spring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.spring.elasticsearch.jest.read-timeout=3000 # Read timeout in milliseconds.spring.elasticsearch.jest.uris=http://localhost:9200 # Comma-separated list of the Elasticsearch instances to use.spring.elasticsearch.jest.username= # Login user.# H2 Web Console (H2ConsoleProperties)spring.h2.console.enabled=false # Enable the console.spring.h2.console.path=/h2-console # Path at which the console will be available.spring.h2.console.settings.trace=false # Enable trace output.spring.h2.console.settings.web-allow-others=false # Enable remote access.# JOOQ (JooqAutoConfiguration)spring.jooq.sql-dialect= # SQLDialect JOOQ used when communicating with the configured datasource. For instance `POSTGRES`# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.data.jpa.repositories.enabled=true # Enable JPA repositories.spring.jpa.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the &quot;databasePlatform&quot; property.spring.jpa.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the &quot;Database&quot; enum.spring.jpa.generate-ddl=false # Initialize the schema on startup.spring.jpa.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the &quot;hibernate.hbm2ddl.auto&quot; property. Default to &quot;create-drop&quot; when using an embedded database, &quot;none&quot; otherwise.spring.jpa.hibernate.naming.implicit-strategy= # Hibernate 5 implicit naming strategy fully qualified name.spring.jpa.hibernate.naming.physical-strategy= # Hibernate 5 physical naming strategy fully qualified name.spring.jpa.hibernate.naming.strategy= # Hibernate 4 naming strategy fully qualified name. Not supported with Hibernate 5.spring.jpa.hibernate.use-new-id-generator-mappings= # Use Hibernate&apos;s newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.spring.jpa.properties.*= # Additional native properties to set on the JPA provider.spring.jpa.show-sql=false # Enable logging of SQL statements.# JTA (JtaAutoConfiguration)spring.jta.enabled=true # Enable JTA support.spring.jta.log-dir= # Transaction logs directory.spring.jta.transaction-manager-id= # Transaction manager unique identifier.# ATOMIKOS (AtomikosProperties)spring.jta.atomikos.connectionfactory.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag=true # Whether or not to ignore the transacted flag when creating session.spring.jta.atomikos.connectionfactory.local-transaction-mode=false # Whether or not local transactions are desired.spring.jta.atomikos.connectionfactory.maintenance-interval=60 # The time, in seconds, between runs of the pool&apos;s maintenance thread.spring.jta.atomikos.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.connectionfactory.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.connectionfactory.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.connectionfactory.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.connectionfactory.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.connectionfactory.unique-resource-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.atomikos.datasource.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.spring.jta.atomikos.datasource.default-isolation-level= # Default isolation level of connections provided by the pool.spring.jta.atomikos.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.atomikos.datasource.maintenance-interval=60 # The time, in seconds, between runs of the pool&apos;s maintenance thread.spring.jta.atomikos.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.atomikos.datasource.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.spring.jta.atomikos.datasource.max-pool-size=1 # The maximum size of the pool.spring.jta.atomikos.datasource.min-pool-size=1 # The minimum size of the pool.spring.jta.atomikos.datasource.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.spring.jta.atomikos.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.atomikos.datasource.unique-resource-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.atomikos.properties.checkpoint-interval=500 # Interval between checkpoints.spring.jta.atomikos.properties.default-jta-timeout=10000 # Default timeout for JTA transactions.spring.jta.atomikos.properties.enable-logging=true # Enable disk logging.spring.jta.atomikos.properties.force-shutdown-on-vm-exit=false # Specify if a VM shutdown should trigger forced shutdown of the transaction core.spring.jta.atomikos.properties.log-base-dir= # Directory in which the log files should be stored.spring.jta.atomikos.properties.log-base-name=tmlog # Transactions log file base name.spring.jta.atomikos.properties.max-actives=50 # Maximum number of active transactions.spring.jta.atomikos.properties.max-timeout=300000 # Maximum timeout (in milliseconds) that can be allowed for transactions.spring.jta.atomikos.properties.serial-jta-transactions=true # Specify if sub-transactions should be joined when possible.spring.jta.atomikos.properties.service= # Transaction manager implementation that should be started.spring.jta.atomikos.properties.threaded-two-phase-commit=false # Use different (and concurrent) threads for two-phase commit on the participating resources.spring.jta.atomikos.properties.transaction-manager-unique-name= # Transaction manager&apos;s unique name.# BITRONIXspring.jta.bitronix.connectionfactory.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.connectionfactory.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.connectionfactory.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.connectionfactory.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.connectionfactory.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.connectionfactory.cache-producers-consumers=true # Whether or not produces and consumers should be cached.spring.jta.bitronix.connectionfactory.defer-connection-release=true # Whether or not the provider can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.connectionfactory.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.connectionfactory.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.connectionfactory.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.connectionfactory.password= # The password to use to connect to the JMS provider.spring.jta.bitronix.connectionfactory.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.connectionfactory.test-connections=true # Whether or not connections should be tested when acquired from the pool.spring.jta.bitronix.connectionfactory.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.connectionfactory.unique-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.spring.jta.bitronix.connectionfactory.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.connectionfactory.user= # The user to use to connect to the JMS provider.spring.jta.bitronix.datasource.acquire-increment=1 # Number of connections to create when growing the pool.spring.jta.bitronix.datasource.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.spring.jta.bitronix.datasource.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.spring.jta.bitronix.datasource.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.spring.jta.bitronix.datasource.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.spring.jta.bitronix.datasource.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.spring.jta.bitronix.datasource.cursor-holdability= # The default cursor holdability for connections.spring.jta.bitronix.datasource.defer-connection-release=true # Whether or not the database can run many transactions on the same connection and supports transaction interleaving.spring.jta.bitronix.datasource.enable-jdbc4-connection-test= # Whether or not Connection.isValid() is called when acquiring a connection from the pool.spring.jta.bitronix.datasource.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.spring.jta.bitronix.datasource.isolation-level= # The default isolation level for connections.spring.jta.bitronix.datasource.local-auto-commit= # The default auto-commit mode for local transactions.spring.jta.bitronix.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.spring.jta.bitronix.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.spring.jta.bitronix.datasource.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.spring.jta.bitronix.datasource.min-pool-size=0 # The minimum size of the pool.spring.jta.bitronix.datasource.prepared-statement-cache-size=0 # The target size of the prepared statement cache. 0 disables the cache.spring.jta.bitronix.datasource.share-transaction-connections=false # Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.spring.jta.bitronix.datasource.test-query= # SQL query or statement used to validate a connection before returning it.spring.jta.bitronix.datasource.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).spring.jta.bitronix.datasource.unique-name=dataSource # The unique name used to identify the resource during recovery.spring.jta.bitronix.datasource.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.spring.jta.bitronix.properties.allow-multiple-lrc=false # Allow multiple LRC resources to be enlisted into the same transaction.spring.jta.bitronix.properties.asynchronous2-pc=false # Enable asynchronously execution of two phase commit.spring.jta.bitronix.properties.background-recovery-interval-seconds=60 # Interval in seconds at which to run the recovery process in the background.spring.jta.bitronix.properties.current-node-only-recovery=true # Recover only the current node.spring.jta.bitronix.properties.debug-zero-resource-transaction=false # Log the creation and commit call stacks of transactions executed without a single enlisted resource.spring.jta.bitronix.properties.default-transaction-timeout=60 # Default transaction timeout in seconds.spring.jta.bitronix.properties.disable-jmx=false # Enable JMX support.spring.jta.bitronix.properties.exception-analyzer= # Set the fully qualified name of the exception analyzer implementation to use.spring.jta.bitronix.properties.filter-log-status=false # Enable filtering of logs so that only mandatory logs are written.spring.jta.bitronix.properties.force-batching-enabled=true # Set if disk forces are batched.spring.jta.bitronix.properties.forced-write-enabled=true # Set if logs are forced to disk.spring.jta.bitronix.properties.graceful-shutdown-interval=60 # Maximum amount of seconds the TM will wait for transactions to get done before aborting them at shutdown time.spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name= # JNDI name of the TransactionSynchronizationRegistry.spring.jta.bitronix.properties.jndi-user-transaction-name= # JNDI name of the UserTransaction.spring.jta.bitronix.properties.journal=disk # Name of the journal. Can be &apos;disk&apos;, &apos;null&apos; or a class name.spring.jta.bitronix.properties.log-part1-filename=btm1.tlog # Name of the first fragment of the journal.spring.jta.bitronix.properties.log-part2-filename=btm2.tlog # Name of the second fragment of the journal.spring.jta.bitronix.properties.max-log-size-in-mb=2 # Maximum size in megabytes of the journal fragments.spring.jta.bitronix.properties.resource-configuration-filename= # ResourceLoader configuration file name.spring.jta.bitronix.properties.server-id= # ASCII ID that must uniquely identify this TM instance. Default to the machine&apos;s IP address.spring.jta.bitronix.properties.skip-corrupted-logs=false # Skip corrupted transactions log entries.spring.jta.bitronix.properties.warn-about-zero-resource-transaction=true # Log a warning for transactions executed without a single enlisted resource.# NARAYANA (NarayanaProperties)spring.jta.narayana.default-timeout=60 # Transaction timeout in seconds.spring.jta.narayana.expiry-scanners=com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner # Comma-separated list of expiry scanners.spring.jta.narayana.log-dir= # Transaction object store directory.spring.jta.narayana.one-phase-commit=true # Enable one phase commit optimisation.spring.jta.narayana.periodic-recovery-period=120 # Interval in which periodic recovery scans are performed in seconds.spring.jta.narayana.recovery-backoff-period=10 # Back off period between first and second phases of the recovery scan in seconds.spring.jta.narayana.recovery-db-pass= # Database password to be used by recovery manager.spring.jta.narayana.recovery-db-user= # Database username to be used by recovery manager.spring.jta.narayana.recovery-jms-pass= # JMS password to be used by recovery manager.spring.jta.narayana.recovery-jms-user= # JMS username to be used by recovery manager.spring.jta.narayana.recovery-modules= # Comma-separated list of recovery modules.spring.jta.narayana.transaction-manager-id=1 # Unique transaction manager id.spring.jta.narayana.xa-resource-orphan-filters= # Comma-separated list of orphan filters.# EMBEDDED MONGODB (EmbeddedMongoProperties)spring.mongodb.embedded.features=SYNC_DELAY # Comma-separated list of features to enable.spring.mongodb.embedded.storage.database-dir= # Directory used for data storage.spring.mongodb.embedded.storage.oplog-size= # Maximum size of the oplog in megabytes.spring.mongodb.embedded.storage.repl-set-name= # Name of the replica set.spring.mongodb.embedded.version=2.6.10 # Version of Mongo to use.# REDIS (RedisProperties)spring.redis.cluster.max-redirects= # Maximum number of redirects to follow when executing commands across the cluster.spring.redis.cluster.nodes= # Comma-separated list of &quot;host:port&quot; pairs to bootstrap from.spring.redis.database=0 # Database index used by the connection factory.spring.redis.url= # Connection URL, will override host, port and password (user will be ignored), e.g. redis://user:password@example.com:6379spring.redis.host=localhost # Redis server host.spring.redis.password= # Login password of the redis server.spring.redis.ssl=false # Enable SSL support.spring.redis.pool.max-active=8 # Max number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.spring.redis.pool.max-idle=8 # Max number of &quot;idle&quot; connections in the pool. Use a negative value to indicate an unlimited number of idle connections.spring.redis.pool.max-wait=-1 # Maximum amount of time (in milliseconds) a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.spring.redis.pool.min-idle=0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.spring.redis.port=6379 # Redis server port.spring.redis.sentinel.master= # Name of Redis server.spring.redis.sentinel.nodes= # Comma-separated list of host:port pairs.spring.redis.timeout=0 # Connection timeout in milliseconds.# TRANSACTION (TransactionProperties)spring.transaction.default-timeout= # Default transaction timeout in seconds.spring.transaction.rollback-on-commit-failure= # Perform the rollback on commit failures.# ----------------------------------------# INTEGRATION PROPERTIES# ----------------------------------------# ACTIVEMQ (ActiveMQProperties)spring.activemq.broker-url= # URL of the ActiveMQ broker. Auto-generated by default.spring.activemq.close-timeout=15000 # Time to wait, in milliseconds, before considering a close complete.spring.activemq.in-memory=true # Specify if the default broker URL should be in memory. Ignored if an explicit broker has been specified.spring.activemq.non-blocking-redelivery=false # Do not stop message delivery before re-delivering messages from a rolled back transaction. This implies that message order will not be preserved when this is enabled.spring.activemq.password= # Login password of the broker.spring.activemq.send-timeout=0 # Time to wait, in milliseconds, on Message sends for a response. Set it to 0 to indicate to wait forever.spring.activemq.user= # Login user of the broker.spring.activemq.packages.trust-all= # Trust all packages.spring.activemq.packages.trusted= # Comma-separated list of specific packages to trust (when not trusting all packages).spring.activemq.pool.block-if-full=true # Block when a connection is requested and the pool is full. Set it to false to throw a &quot;JMSException&quot; instead.spring.activemq.pool.block-if-full-timeout=-1 # Blocking period, in milliseconds, before throwing an exception if the pool is still full.spring.activemq.pool.create-connection-on-startup=true # Create a connection on startup. Can be used to warm-up the pool on startup.spring.activemq.pool.enabled=false # Whether a PooledConnectionFactory should be created instead of a regular ConnectionFactory.spring.activemq.pool.expiry-timeout=0 # Connection expiration timeout in milliseconds.spring.activemq.pool.idle-timeout=30000 # Connection idle timeout in milliseconds.spring.activemq.pool.max-connections=1 # Maximum number of pooled connections.spring.activemq.pool.maximum-active-session-per-connection=500 # Maximum number of active sessions per connection.spring.activemq.pool.reconnect-on-exception=true # Reset the connection when a &quot;JMXException&quot; occurs.spring.activemq.pool.time-between-expiration-check=-1 # Time to sleep, in milliseconds, between runs of the idle connection eviction thread. When negative, no idle connection eviction thread runs.spring.activemq.pool.use-anonymous-producers=true # Use only one anonymous &quot;MessageProducer&quot; instance. Set it to false to create one &quot;MessageProducer&quot; every time one is required.# ARTEMIS (ArtemisProperties)spring.artemis.embedded.cluster-password= # Cluster password. Randomly generated on startup by default.spring.artemis.embedded.data-directory= # Journal file directory. Not necessary if persistence is turned off.spring.artemis.embedded.enabled=true # Enable embedded mode if the Artemis server APIs are available.spring.artemis.embedded.persistent=false # Enable persistent store.spring.artemis.embedded.queues= # Comma-separated list of queues to create on startup.spring.artemis.embedded.server-id= # Server id. By default, an auto-incremented counter is used.spring.artemis.embedded.topics= # Comma-separated list of topics to create on startup.spring.artemis.host=localhost # Artemis broker host.spring.artemis.mode= # Artemis deployment mode, auto-detected by default.spring.artemis.password= # Login password of the broker.spring.artemis.port=61616 # Artemis broker port.spring.artemis.user= # Login user of the broker.# SPRING BATCH (BatchProperties)spring.batch.initializer.enabled= # Create the required batch tables on startup if necessary. Enabled automatically if no custom table prefix is set or if a custom schema is configured.spring.batch.job.enabled=true # Execute all Spring Batch jobs in the context on startup.spring.batch.job.names= # Comma-separated list of job names to execute on startup (For instance `job1,job2`). By default, all Jobs found in the context are executed.spring.batch.schema=classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.batch.table-prefix= # Table prefix for all the batch meta-data tables.# JMS (JmsProperties)spring.jms.jndi-name= # Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.spring.jms.listener.acknowledge-mode= # Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.spring.jms.listener.auto-startup=true # Start the container automatically on startup.spring.jms.listener.concurrency= # Minimum number of concurrent consumers.spring.jms.listener.max-concurrency= # Maximum number of concurrent consumers.spring.jms.pub-sub-domain=false # Specify if the default destination type is topic.spring.jms.template.default-destination= # Default destination to use on send/receive operations that do not have a destination parameter.spring.jms.template.delivery-delay= # Delivery delay to use for send calls in milliseconds.spring.jms.template.delivery-mode= # Delivery mode. Enable QoS when set.spring.jms.template.priority= # Priority of a message when sending. Enable QoS when set.spring.jms.template.qos-enabled= # Enable explicit QoS when sending a message.spring.jms.template.receive-timeout= # Timeout to use for receive calls in milliseconds.spring.jms.template.time-to-live= # Time-to-live of a message when sending in milliseconds. Enable QoS when set.# APACHE KAFKA (KafkaProperties)spring.kafka.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.auto-commit-interval= # Frequency in milliseconds that the consumer offsets are auto-committed to Kafka if &apos;enable.auto.commit&apos; true.spring.kafka.consumer.auto-offset-reset= # What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server.spring.kafka.consumer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.consumer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.consumer.enable-auto-commit= # If true the consumer&apos;s offset will be periodically committed in the background.spring.kafka.consumer.fetch-max-wait= # Maximum amount of time in milliseconds the server will block before answering the fetch request if there isn&apos;t sufficient data to immediately satisfy the requirement given by &quot;fetch.min.bytes&quot;.spring.kafka.consumer.fetch-min-size= # Minimum amount of data the server should return for a fetch request in bytes.spring.kafka.consumer.group-id= # Unique string that identifies the consumer group this consumer belongs to.spring.kafka.consumer.heartbeat-interval= # Expected time in milliseconds between heartbeats to the consumer coordinator.spring.kafka.consumer.key-deserializer= # Deserializer class for keys.spring.kafka.consumer.max-poll-records= # Maximum number of records returned in a single call to poll().spring.kafka.consumer.value-deserializer= # Deserializer class for values.spring.kafka.listener.ack-count= # Number of records between offset commits when ackMode is &quot;COUNT&quot; or &quot;COUNT_TIME&quot;.spring.kafka.listener.ack-mode= # Listener AckMode; see the spring-kafka documentation.spring.kafka.listener.ack-time= # Time in milliseconds between offset commits when ackMode is &quot;TIME&quot; or &quot;COUNT_TIME&quot;.spring.kafka.listener.concurrency= # Number of threads to run in the listener containers.spring.kafka.listener.poll-timeout= # Timeout in milliseconds to use when polling the consumer.spring.kafka.producer.acks= # Number of acknowledgments the producer requires the leader to have received before considering a request complete.spring.kafka.producer.batch-size= # Number of records to batch before sending.spring.kafka.producer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.spring.kafka.producer.buffer-memory= # Total bytes of memory the producer can use to buffer records waiting to be sent to the server.spring.kafka.producer.client-id= # Id to pass to the server when making requests; used for server-side logging.spring.kafka.producer.compression-type= # Compression type for all data generated by the producer.spring.kafka.producer.key-serializer= # Serializer class for keys.spring.kafka.producer.retries= # When greater than zero, enables retrying of failed sends.spring.kafka.producer.value-serializer= # Serializer class for values.spring.kafka.properties.*= # Additional properties used to configure the client.spring.kafka.ssl.key-password= # Password of the private key in the key store file.spring.kafka.ssl.keystore-location= # Location of the key store file.spring.kafka.ssl.keystore-password= # Store password for the key store file.spring.kafka.ssl.truststore-location= # Location of the trust store file.spring.kafka.ssl.truststore-password= # Store password for the trust store file.spring.kafka.template.default-topic= # Default topic to which messages will be sent.# RABBIT (RabbitProperties)spring.rabbitmq.addresses= # Comma-separated list of addresses to which the client should connect.spring.rabbitmq.cache.channel.checkout-timeout= # Number of milliseconds to wait to obtain a channel if the cache size has been reached.spring.rabbitmq.cache.channel.size= # Number of channels to retain in the cache.spring.rabbitmq.cache.connection.mode=channel # Connection factory cache mode.spring.rabbitmq.cache.connection.size= # Number of connections to cache.spring.rabbitmq.connection-timeout= # Connection timeout, in milliseconds; zero for infinite.spring.rabbitmq.dynamic=true # Create an AmqpAdmin bean.spring.rabbitmq.host=localhost # RabbitMQ host.spring.rabbitmq.listener.simple.acknowledge-mode= # Acknowledge mode of container.spring.rabbitmq.listener.simple.auto-startup=true # Start the container automatically on startup.spring.rabbitmq.listener.simple.concurrency= # Minimum number of consumers.spring.rabbitmq.listener.simple.default-requeue-rejected= # Whether or not to requeue delivery failures; default `true`.spring.rabbitmq.listener.simple.idle-event-interval= # How often idle container events should be published in milliseconds.spring.rabbitmq.listener.simple.max-concurrency= # Maximum number of consumers.spring.rabbitmq.listener.simple.prefetch= # Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).spring.rabbitmq.listener.simple.retry.enabled=false # Whether or not publishing retries are enabled.spring.rabbitmq.listener.simple.retry.initial-interval=1000 # Interval between the first and second attempt to deliver a message.spring.rabbitmq.listener.simple.retry.max-attempts=3 # Maximum number of attempts to deliver a message.spring.rabbitmq.listener.simple.retry.max-interval=10000 # Maximum interval between attempts.spring.rabbitmq.listener.simple.retry.multiplier=1.0 # A multiplier to apply to the previous delivery retry interval.spring.rabbitmq.listener.simple.retry.stateless=true # Whether or not retry is stateless or stateful.spring.rabbitmq.listener.simple.transaction-size= # Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.spring.rabbitmq.password= # Login to authenticate against the broker.spring.rabbitmq.port=5672 # RabbitMQ port.spring.rabbitmq.publisher-confirms=false # Enable publisher confirms.spring.rabbitmq.publisher-returns=false # Enable publisher returns.spring.rabbitmq.requested-heartbeat= # Requested heartbeat timeout, in seconds; zero for none.spring.rabbitmq.ssl.enabled=false # Enable SSL support.spring.rabbitmq.ssl.key-store= # Path to the key store that holds the SSL certificate.spring.rabbitmq.ssl.key-store-password= # Password used to access the key store.spring.rabbitmq.ssl.trust-store= # Trust store that holds SSL certificates.spring.rabbitmq.ssl.trust-store-password= # Password used to access the trust store.spring.rabbitmq.ssl.algorithm= # SSL algorithm to use. By default configure by the rabbit client library.spring.rabbitmq.template.mandatory=false # Enable mandatory messages.spring.rabbitmq.template.receive-timeout=0 # Timeout for `receive()` methods.spring.rabbitmq.template.reply-timeout=5000 # Timeout for `sendAndReceive()` methods.spring.rabbitmq.template.retry.enabled=false # Set to true to enable retries in the `RabbitTemplate`.spring.rabbitmq.template.retry.initial-interval=1000 # Interval between the first and second attempt to publish a message.spring.rabbitmq.template.retry.max-attempts=3 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.max-interval=10000 # Maximum number of attempts to publish a message.spring.rabbitmq.template.retry.multiplier=1.0 # A multiplier to apply to the previous publishing retry interval.spring.rabbitmq.username= # Login user to authenticate to the broker.spring.rabbitmq.virtual-host= # Virtual host to use when connecting to the broker.# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# ENDPOINTS (AbstractEndpoint subclasses)endpoints.enabled=true # Enable endpoints.endpoints.sensitive= # Default endpoint sensitive setting.endpoints.actuator.enabled=true # Enable the endpoint.endpoints.actuator.path= # Endpoint URL path.endpoints.actuator.sensitive=false # Enable security on the endpoint.endpoints.auditevents.enabled= # Enable the endpoint.endpoints.auditevents.path= # Endpoint path.endpoints.auditevents.sensitive=false # Enable security on the endpoint.endpoints.autoconfig.enabled= # Enable the endpoint.endpoints.autoconfig.id= # Endpoint identifier.endpoints.autoconfig.path= # Endpoint path.endpoints.autoconfig.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.beans.enabled= # Enable the endpoint.endpoints.beans.id= # Endpoint identifier.endpoints.beans.path= # Endpoint path.endpoints.beans.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.configprops.enabled= # Enable the endpoint.endpoints.configprops.id= # Endpoint identifier.endpoints.configprops.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.configprops.path= # Endpoint path.endpoints.configprops.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.docs.curies.enabled=false # Enable the curie generation.endpoints.docs.enabled=true # Enable actuator docs endpoint.endpoints.docs.path=/docs #endpoints.docs.sensitive=false #endpoints.dump.enabled= # Enable the endpoint.endpoints.dump.id= # Endpoint identifier.endpoints.dump.path= # Endpoint path.endpoints.dump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.env.enabled= # Enable the endpoint.endpoints.env.id= # Endpoint identifier.endpoints.env.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.endpoints.env.path= # Endpoint path.endpoints.env.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.flyway.enabled= # Enable the endpoint.endpoints.flyway.id= # Endpoint identifier.endpoints.flyway.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.enabled= # Enable the endpoint.endpoints.health.id= # Endpoint identifier.endpoints.health.mapping.*= # Mapping of health statuses to HTTP status codes. By default, registered health statuses map to sensible defaults (i.e. UP maps to 200).endpoints.health.path= # Endpoint path.endpoints.health.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.health.time-to-live=1000 # Time to live for cached result, in milliseconds.endpoints.heapdump.enabled= # Enable the endpoint.endpoints.heapdump.path= # Endpoint path.endpoints.heapdump.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.hypermedia.enabled=false # Enable hypermedia support for endpoints.endpoints.info.enabled= # Enable the endpoint.endpoints.info.id= # Endpoint identifier.endpoints.info.path= # Endpoint path.endpoints.info.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.jolokia.enabled=true # Enable Jolokia endpoint.endpoints.jolokia.path=/jolokia # Endpoint URL path.endpoints.jolokia.sensitive=true # Enable security on the endpoint.endpoints.liquibase.enabled= # Enable the endpoint.endpoints.liquibase.id= # Endpoint identifier.endpoints.liquibase.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.logfile.enabled=true # Enable the endpoint.endpoints.logfile.external-file= # External Logfile to be accessed.endpoints.logfile.path=/logfile # Endpoint URL path.endpoints.logfile.sensitive=true # Enable security on the endpoint.endpoints.loggers.enabled=true # Enable the endpoint.endpoints.loggers.id= # Endpoint identifier.endpoints.loggers.path=/logfile # Endpoint path.endpoints.loggers.sensitive=true # Mark if the endpoint exposes sensitive information.endpoints.mappings.enabled= # Enable the endpoint.endpoints.mappings.id= # Endpoint identifier.endpoints.mappings.path= # Endpoint path.endpoints.mappings.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.metrics.enabled= # Enable the endpoint.endpoints.metrics.filter.enabled=true # Enable the metrics servlet filter.endpoints.metrics.filter.gauge-submissions=merged # Http filter gauge submissions (merged, per-http-method)endpoints.metrics.filter.counter-submissions=merged # Http filter counter submissions (merged, per-http-method)endpoints.metrics.id= # Endpoint identifier.endpoints.metrics.path= # Endpoint path.endpoints.metrics.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.shutdown.enabled= # Enable the endpoint.endpoints.shutdown.id= # Endpoint identifier.endpoints.shutdown.path= # Endpoint path.endpoints.shutdown.sensitive= # Mark if the endpoint exposes sensitive information.endpoints.trace.enabled= # Enable the endpoint.endpoints.trace.filter.enabled=true # Enable the trace servlet filter.endpoints.trace.id= # Endpoint identifier.endpoints.trace.path= # Endpoint path.endpoints.trace.sensitive= # Mark if the endpoint exposes sensitive information.# ENDPOINTS CORS CONFIGURATION (EndpointCorsProperties)endpoints.cors.allow-credentials= # Set whether credentials are supported. When not set, credentials are not supported.endpoints.cors.allowed-headers= # Comma-separated list of headers to allow in a request. &apos;*&apos; allows all headers.endpoints.cors.allowed-methods=GET # Comma-separated list of methods to allow. &apos;*&apos; allows all methods.endpoints.cors.allowed-origins= # Comma-separated list of origins to allow. &apos;*&apos; allows all origins. When not set, CORS support is disabled.endpoints.cors.exposed-headers= # Comma-separated list of headers to include in a response.endpoints.cors.max-age=1800 # How long, in seconds, the response from a pre-flight request can be cached by clients.# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.domain= # JMX domain name. Initialized with the value of &apos;spring.jmx.default-domain&apos; if set.endpoints.jmx.enabled=true # Enable JMX export of all endpoints.endpoints.jmx.static-names= # Additional static properties to append to all ObjectNames of MBeans representing Endpoints.endpoints.jmx.unique-names=false # Ensure that ObjectNames are modified in case of conflict.# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.add-application-context-header=true # Add the &quot;X-Application-Context&quot; HTTP header in each response.management.address= # Network address that the management endpoints should bind to.management.context-path= # Management endpoint context-path. For instance `/actuator`management.cloudfoundry.enabled= # Enable extended Cloud Foundry actuator endpointsmanagement.cloudfoundry.skip-ssl-validation= # Skip SSL verification for Cloud Foundry actuator endpoint security callsmanagement.port= # Management endpoint HTTP port. Uses the same port as the application by default. Configure a different port to use management-specific SSL.management.security.enabled=true # Enable security.management.security.roles=ACTUATOR # Comma-separated list of roles that can access the management endpoint.management.security.sessions=stateless # Session creating policy to use (always, never, if_required, stateless).management.ssl.ciphers= # Supported SSL ciphers. Requires a custom management.port.management.ssl.client-auth= # Whether client authentication is wanted (&quot;want&quot;) or needed (&quot;need&quot;). Requires a trust store. Requires a custom management.port.management.ssl.enabled= # Enable SSL support. Requires a custom management.port.management.ssl.enabled-protocols= # Enabled SSL protocols. Requires a custom management.port.management.ssl.key-alias= # Alias that identifies the key in the key store. Requires a custom management.port.management.ssl.key-password= # Password used to access the key in the key store. Requires a custom management.port.management.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file). Requires a custom management.port.management.ssl.key-store-password= # Password used to access the key store. Requires a custom management.port.management.ssl.key-store-provider= # Provider for the key store. Requires a custom management.port.management.ssl.key-store-type= # Type of the key store. Requires a custom management.port.management.ssl.protocol=TLS # SSL protocol to use. Requires a custom management.port.management.ssl.trust-store= # Trust store that holds SSL certificates. Requires a custom management.port.management.ssl.trust-store-password= # Password used to access the trust store. Requires a custom management.port.management.ssl.trust-store-provider= # Provider for the trust store. Requires a custom management.port.management.ssl.trust-store-type= # Type of the trust store. Requires a custom management.port.# HEALTH INDICATORSmanagement.health.db.enabled=true # Enable database health check.management.health.cassandra.enabled=true # Enable cassandra health check.management.health.couchbase.enabled=true # Enable couchbase health check.management.health.defaults.enabled=true # Enable default health indicators.management.health.diskspace.enabled=true # Enable disk space health check.management.health.diskspace.path= # Path used to compute the available disk space.management.health.diskspace.threshold=0 # Minimum disk space that should be available, in bytes.management.health.elasticsearch.enabled=true # Enable elasticsearch health check.management.health.elasticsearch.indices= # Comma-separated index names.management.health.elasticsearch.response-timeout=100 # The time, in milliseconds, to wait for a response from the cluster.management.health.jms.enabled=true # Enable JMS health check.management.health.ldap.enabled=true # Enable LDAP health check.management.health.mail.enabled=true # Enable Mail health check.management.health.mongo.enabled=true # Enable MongoDB health check.management.health.rabbit.enabled=true # Enable RabbitMQ health check.management.health.redis.enabled=true # Enable Redis health check.management.health.solr.enabled=true # Enable Solr health check.management.health.status.order=DOWN, OUT_OF_SERVICE, UP, UNKNOWN # Comma-separated list of health statuses in order of severity.# INFO CONTRIBUTORS (InfoContributorProperties)management.info.build.enabled=true # Enable build info.management.info.defaults.enabled=true # Enable default info contributors.management.info.env.enabled=true # Enable environment info.management.info.git.enabled=true # Enable git info.management.info.git.mode=simple # Mode to use to expose git information.# REMOTE SHELL (ShellProperties)management.shell.auth.type=simple # Authentication type. Auto-detected according to the environment.management.shell.auth.jaas.domain=my-domain # JAAS domain.management.shell.auth.key.path= # Path to the authentication key. This should point to a valid &quot;.pem&quot; file.management.shell.auth.simple.user.name=user # Login user.management.shell.auth.simple.user.password= # Login password.management.shell.auth.spring.roles=ACTUATOR # Comma-separated list of required roles to login to the CRaSH console.management.shell.command-path-patterns=classpath*:/commands/**,classpath*:/crash/commands/** # Patterns to use to look for commands.management.shell.command-refresh-interval=-1 # Scan for changes and update the command if necessary (in seconds).management.shell.config-path-patterns=classpath*:/crash/* # Patterns to use to look for configurations.management.shell.disabled-commands=jpa*,jdbc*,jndi* # Comma-separated list of commands to disable.management.shell.disabled-plugins= # Comma-separated list of plugins to disable. Certain plugins are disabled by default based on the environment.management.shell.ssh.auth-timeout = # Number of milliseconds after user will be prompted to login again.management.shell.ssh.enabled=true # Enable CRaSH SSH support.management.shell.ssh.idle-timeout = # Number of milliseconds after which unused connections are closed.management.shell.ssh.key-path= # Path to the SSH server key.management.shell.ssh.port=2000 # SSH port.management.shell.telnet.enabled=false # Enable CRaSH telnet support. Enabled by default if the TelnetPlugin is available.management.shell.telnet.port=5000 # Telnet port.# TRACING (TraceProperties)management.trace.include=request-headers,response-headers,cookies,errors # Items to be included in the trace.# METRICS EXPORT (MetricExportProperties)spring.metrics.export.aggregate.key-pattern= # Pattern that tells the aggregator what to do with the keys from the source repository.spring.metrics.export.aggregate.prefix= # Prefix for global repository if active.spring.metrics.export.delay-millis=5000 # Delay in milliseconds between export ticks. Metrics are exported to external sources on a schedule with this delay.spring.metrics.export.enabled=true # Flag to enable metric export (assuming a MetricWriter is available).spring.metrics.export.excludes= # List of patterns for metric names to exclude. Applied after the includes.spring.metrics.export.includes= # List of patterns for metric names to include.spring.metrics.export.redis.key=keys.spring.metrics # Key for redis repository export (if active).spring.metrics.export.redis.prefix=spring.metrics # Prefix for redis repository if active.spring.metrics.export.send-latest= # Flag to switch off any available optimizations based on not exporting unchanged metric values.spring.metrics.export.statsd.host= # Host of a statsd server to receive exported metrics.spring.metrics.export.statsd.port=8125 # Port of a statsd server to receive exported metrics.spring.metrics.export.statsd.prefix= # Prefix for statsd exported metrics.spring.metrics.export.triggers.*= # Specific trigger properties per MetricWriter bean name.# ----------------------------------------# DEVTOOLS PROPERTIES# ----------------------------------------# DEVTOOLS (DevToolsProperties)spring.devtools.livereload.enabled=true # Enable a livereload.com compatible server.spring.devtools.livereload.port=35729 # Server port.spring.devtools.restart.additional-exclude= # Additional patterns that should be excluded from triggering a full restart.spring.devtools.restart.additional-paths= # Additional paths to watch for changes.spring.devtools.restart.enabled=true # Enable automatic restart.spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties # Patterns that should be excluded from triggering a full restart.spring.devtools.restart.poll-interval=1000 # Amount of time (in milliseconds) to wait between polling for classpath changes.spring.devtools.restart.quiet-period=400 # Amount of quiet time (in milliseconds) required without any classpath changes before a restart is triggered.spring.devtools.restart.trigger-file= # Name of a specific file that when changed will trigger the restart check. If not specified any classpath file change will trigger the restart.# REMOTE DEVTOOLS (RemoteDevToolsProperties)spring.devtools.remote.context-path=/.~~spring-boot!~ # Context path used to handle the remote connection.spring.devtools.remote.debug.enabled=true # Enable remote debug support.spring.devtools.remote.debug.local-port=8000 # Local remote debug server port.spring.devtools.remote.proxy.host= # The host of the proxy to use to connect to the remote application.spring.devtools.remote.proxy.port= # The port of the proxy to use to connect to the remote application.spring.devtools.remote.restart.enabled=true # Enable remote restart.spring.devtools.remote.secret= # A shared secret required to establish a connection (required to enable remote support).spring.devtools.remote.secret-header-name=X-AUTH-TOKEN # HTTP header used to transfer the shared secret.# ----------------------------------------# TESTING PROPERTIES# ----------------------------------------spring.test.database.replace=any # Type of existing DataSource to replace.spring.test.mockmvc.print=default # MVC Print option. application.properties配置和使用 摘要: Spring Boot使用“约定优于配置”（项目中存在大量配置，此外还内置了一个约定的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。所以，我们想要熟练使用Spring Boot，就要懂得如何开启各个功能模块的默认配置，这就需要了解Spring Boot的配置文件application.properties。 Spring Boot使用了一个全局的配置文件application.properties，放在src/main/resources目录下或者类路径的/config下。Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改。接下来，让我们一起来解开配置文件的面纱。 注:如果你工程没有这个application.properties，那就在src/main/java/resources目录下新建一个。 自定义属性application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里： 12com.qiuqiu.name=&quot;球球&quot;com.qiuqiu.want=&quot;祝大家鸡年大吉！&quot; 然后直接在要使用的地方通过注解@Value(value=”${XXX}”)就可以绑定到你想要的属性上面 123456789101112@RestControllerpublic class UserController &#123; @Value("$&#123;com.qiuqiu.name&#125;") private String name; @Value("$&#123;com.qiuqiu.want&#125;") private String want; @RequestMapping("/hello") public String hello()&#123; return name+","+want; &#125;&#125; 属性很多时，一个个绑定到属性字段上太麻烦，官方提倡绑定一个对象的bean，这里我们建一个ConfigBean.java类，顶部需要使用注解@ConfigurationProperties(prefix = “XXX”)来指明使用哪个 1234567@ConfigurationProperties(prefix = "com.qiuqiu")public class ConfigBean &#123; private String name; private String want; // 省略getter和setter&#125; Spring Boot 会自动转换类型，当使用List的时候需要注意在配置中对List进行初始化！Spring Boot 还支持嵌套属性注入。 123456789101112131415161718name=Isea533servers[0]=dev.bar.comservers[1]=foo.bar.comjdbc.username=rootjdbc.password=root@ConfigurationPropertiespublic class Config &#123; private String name; private List&lt;String&gt; servers = new ArrayList&lt;String&gt;(); private Jdbc jdbc; // 省略getter和setter class Jdbc &#123; private String username; private String password; // 省略getter和setter &#125;&#125; 另外一种使用配置文件属性的方式，在@Bean方法上使用@ConfigurationProperties 12345@ConfigurationProperties(prefix = "com.qiuqiu")@Beanpublic ConfigBean configBean() &#123; ...&#125; 属性占位符例如： 12app.name=MyAppapp.description=$&#123;app.name&#125; is a Spring Boot application 可以在配置文件中引用前面配置过的属性（优先级前面配置过的这里都能用）。通过如${app.name:默认名称}方法还可以设置默认值，当找不到引用的属性时，会使用默认的属性。由于${}方式会被Maven处理。如果你pom继承的spring-boot-starter-parent，Spring Boot 已经将maven-resources-plugins默认的${}方式改为了@ @方式，例如@name@。如果你是引入的Spring Boot，你可以修改使用其他的分隔符。 通过属性占位符还能缩短命令参数 例如修改web默认端口需要使用–server.port=9090方式，如果在配置中写上： 1server.port=$&#123;port:8080&#125; 那么就可以使用更短的–port=9090，当不提供该参数的时候使用默认值8080。 使用自定义配置文件有时我们不希望把所有配置都放在application.properties里面，这时候我们可以另外定义一个，这里我们定义一个名为test.properties配置文件，路径跟也放在src/main/resources下面。 12345678910com.md.name="球球"com.md.want="祝大家鸡年大吉"@Configuration@ConfigurationProperties(prefix = "com.md") @PropertySource("classpath:test.properties")public class ConfigTestBean &#123; private String name; private String want; // 省略getter和setter&#125; 注：如果你使用的是1.5以前的版本，那么可以通过locations指定properties文件的位置，这样： 1@ConfigurationProperties(prefix = "config2",locations="classpath:test.properties") 但是1.5版本之后就没有这个属性，需要添加@Configuration和@PropertySource(“classpath:test.properties”)后才可以读取。 随机值配置配置文件中${random.*} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。 123456qiuqiu.secret=$&#123;random.value&#125;qiuqiu.number=$&#123;random.int&#125;qiuqiu.bignumber=$&#123;random.long&#125;qiuqiu.uuid=$&#123;random.uuid&#125;qiuqiu.number.less.than.ten=$&#123;random.int(10)&#125;qiuqiu.number.in.range=$&#123;random.int[1024,65536]&#125; 外部配置-命令行参数配置Spring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行： 1java -jar xx.jar 可以以下命令修改tomcat端口号： 1java -jar xx.jar --server.port=9090 可以看出，命令行中连续的两个减号–就是对application.properties中的属性值进行赋值的标识。 所以java -jar xx.jar –server.port=9090等价于在application.properties中添加属性server.port=9090。 如果你怕命令行有风险，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。 实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种： 根目录下的开发工具全局设置属性(当开发工具激活时为~/.spring-boot-devtools.properties)。 测试中的@TestPropertySource注解。 测试中的@SpringBootTest#properties注解特性。 命令行参数 SPRING_APPLICATION_JSON中的属性(环境变量或系统属性中的内联JSON嵌入)。 ServletConfig初始化参数。 ServletContext初始化参数。 java:comp/env里的JNDI属性 JVM系统属性 操作系统环境变量 随机生成的带random.* 前缀的属性（在设置其他属性时，可以应用他们，比如${random.long}）应用程序以外的application.properties或者appliaction.yml文件打包在应用程序内的application.properties或者appliaction.yml文件通过@PropertySource标注的属性源 默认属性(通过SpringApplication.setDefaultProperties指定). 这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性，例如我们上面提到的命令行属性就覆盖了application.properties的属性。 配置文件优先级application.properties和application.yml文件可以放在以下四个位置： 外置，在相对于应用程序运行目录的/config子目录里。 外置，在应用程序运行的目录里 内置，在config包内 内置，在Classpath根目录 同样，这个列表按照优先级排序，也就是说，src/main/resources/config下application.properties覆盖src/main/resources下application.properties中相同的属性，如图： 此外，如果你在相同优先级位置同时有application.properties和application.yml，那么application.properties里的属性里面的属性就会覆盖application.yml。 profile-多环境配置当应用程序需要部署到不同运行环境时，一些配置细节通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。 如果按照以前的做法，就是每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了解决方案，命令带上参数就搞定。 在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如： application-dev.properties：开发环境 application-prod.properties：生产环境 想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod这2个。 当然你也可以用命令行启动的时候带上参数： 1java -jar xxx.jar --spring.profiles.active=dev 除了可以用profile的配置文件来分区配置我们的环境变量，在代码里，我们还可以直接用@Profile注解来进行配置，例如数据库配置，这里我们先定义一个接口 : 123public interface DBConnector &#123; public void configure(); &#125; 定义俩个实现类来实现它: 12345678910111213141516171819202122/** * 测试数据库 */@Component@Profile("testdb")public class TestDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("testdb"); &#125;&#125;/** * 生产数据库 */@Component@Profile("devdb")public class DevDBConnector implements DBConnector &#123; @Override public void configure() &#123; System.out.println("devdb"); &#125;&#125; 通过在配置文件激活具体使用哪个实现类 1spring.profiles.active=testdb 然后就可以如下方使用： 12345678910111213@RestController@RequestMapping("/task")public class TaskController &#123; @Autowired DBConnector connector ; @RequestMapping(value = "/hello") public String helloTask()&#123; connector.configure(); //最终打印testdb return "hello task !! myage is " + myage; &#125;&#125; 除了spring.profiles.active来激活一个或者多个profile之外，还可以用spring.profiles.include来叠加profile。 12spring.profiles.active=testdb spring.profiles.include=proddb,prodmq 读取系统环境变量和application配置文件中的属性实现EnvironmentAware接口 12345678910111213141516171819202122232425import org.springframework.boot.bind.RelaxedPropertyResolver;import org.springframework.context.EnvironmentAware;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;@Configurationpublic class MyEnvironmentAware implements EnvironmentAware &#123; /** * 注意重写的方法 setEnvironment是在系统启动的时候被执行。 */ @Override public void setEnvironment(Environment environment) &#123; // 通过 environment 获取到系统属性. System.out.println(environment.getProperty("JAVA_HOME")); // 通过 environment 同样能获取到application.properties配置的属性. System.out.println(environment.getProperty("spring.datasource.url")); // 获取到前缀是"spring.datasource." 的属性列表值. RelaxedPropertyResolver relaxedPropertyResolver = new RelaxedPropertyResolver(environment, "spring.datasource."); System.out.println("spring.datasource.url=" + relaxedPropertyResolver.getProperty("url")); System.out.println("spring.datasource.driverClassName=" + relaxedPropertyResolver.getProperty("driverClassName")); &#125;&#125; 实现ApplicationContextAware接口 123456789101112131415161718192021222324252627282930313233343536373839import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.core.env.Environment;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;@Componentpublic class SpringCtxHolder implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; private static Environment env; public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringCtxHolder.applicationContext = applicationContext; env = applicationContext.getEnvironment(); &#125; public static Environment getEnv() &#123; return env; &#125; public static void setEnv(Environment env) &#123; SpringCtxHolder.env = env; &#125; public static String getProperty(String key) &#123; if (StringUtils.isEmpty(key)) &#123; return ""; &#125; return env.getProperty(key); &#125;&#125; 1SpringCtxHolder.getProperty("spring.datasource.url"); 全局异常处理简介全局异常处理是个比较重要的功能，一般在项目里都会用到。 实现方式使用@ControllerAdvice或@RestControllerAdvice注解使用@ExceptionHandler注解 通过使用@ControllerAdvice或@RestControllerAdvice定义统一的异常处理类。@ExceptionHandler用来定义函数针对的异常类型， 自定义错误处理器，可自己组装json字符串，并返回 。 应用实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.dao.DataIntegrityViolationException;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.HttpMediaTypeNotSupportedException;import org.springframework.web.HttpRequestMethodNotSupportedException;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.MissingServletRequestParameterException;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;import com.nxtcec.ordering.mlsoa.exception.SoaException;import com.nxtcec.ordering.mlsoa.model.BodyStatus;import com.nxtcec.ordering.mlsoa.model.BodyValidStatus;import com.nxtcec.ordering.mlsoa.util.Constants;import com.nxtcec.ordering.mlsoa.util.DataUtil;/** * 全局Exception处理 * * @author liusq * */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.class); @SuppressWarnings("rawtypes") @ExceptionHandler(value = Exception.class) public ResponseEntity handle(Exception e) &#123; e.printStackTrace(); BodyStatus bodyStatus; if (e instanceof SoaException) &#123; bodyStatus = ((SoaException) e).getBodyStatus(); &#125; else if (e instanceof MissingServletRequestParameterException) &#123; bodyStatus = DataUtil.bodyStatus("0002"); &#125; else if (e instanceof HttpRequestMethodNotSupportedException) &#123; bodyStatus = DataUtil.bodyStatus("0003"); &#125; else if (e instanceof HttpMediaTypeNotSupportedException) &#123; bodyStatus = DataUtil.bodyStatus("0004"); &#125; else if (e instanceof HttpMessageNotReadableException) &#123; bodyStatus = DataUtil.bodyStatus("0005"); &#125; else if (e instanceof BindException) &#123; bodyStatus = DataUtil.bodyStatus("0006"); &#125; else if (e instanceof NumberFormatException) &#123; bodyStatus = DataUtil.bodyStatus("0007"); &#125; else if (e instanceof DataIntegrityViolationException) &#123; bodyStatus = DataUtil.bodyStatus("0008"); &#125; else &#123; bodyStatus = DataUtil.bodyStatus(Constants.ERROR_CODE); &#125; LOGGER.error(bodyStatus.getMessage() + e); return new ResponseEntity&lt;&gt;(bodyStatus, HttpStatus.OK); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435import org.apache.commons.lang.builder.ToStringBuilder;/** * 处理成功或失败时的响应体 * * @author liusq * */public class BodyStatus &#123; // 代码 private String code; // 代码解释 private String message; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; @Override public String toString() &#123; return ToStringBuilder.reflectionToString(this); &#125;&#125; 1234567891011121314151617181920212223242526272829import com.nxtcec.ordering.mlsoa.model.BodyStatus;import com.nxtcec.ordering.mlsoa.util.DataUtil;public class SoaException extends RuntimeException &#123; private static final long serialVersionUID = -2945796190275982393L; private BodyStatus bodyStatus; public SoaException() &#123; super(); &#125; public SoaException(String code) &#123; this.bodyStatus = DataUtil.bodyStatus(code); &#125; public SoaException(String code, String message) &#123; this.bodyStatus = DataUtil.bodyStatus(code, message); &#125; public BodyStatus getBodyStatus() &#123; return bodyStatus; &#125; public void setBodyStatus(BodyStatus bodyStatus) &#123; this.bodyStatus = bodyStatus; &#125;&#125; validation参数校验对于任何一个应用而言在客户端做的数据有效性验证都不是安全有效的，这时候就要求我们在开发的时候在服务端也对数据的有效性进行验证。 Spring Boot自身对数据在服务端的校验有一个比较好的支持，它能将我们提交到服务端的数据按照我们事先的约定进行数据有效性验证。 pom依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 校验使用实例配置要验证的请求实体123456789public class User &#123; @Null private Long id; @NotBlank private String name; @Email private String email; // 省略getter和setter&#125; 控制器方法配置1234@PostMapping("/addUser")public String addUser(@Valid @RequestBody User user)&#123; ...&#125; 校验失败统一处理校验失败时将抛出MethodArgumentNotValidException异常 123456789101112131415161718192021222324252627282930313233/** * 全局Exception处理 * * @author liusq * */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.class); @SuppressWarnings("rawtypes") @ExceptionHandler(value = Exception.class) public ResponseEntity handle(Exception e) &#123; if (e instanceof MethodArgumentNotValidException) &#123; BindingResult bindingResult = ((MethodArgumentNotValidException) e).getBindingResult(); if (bindingResult.hasErrors() &amp;&amp; bindingResult.hasFieldErrors()) &#123; FieldError fieldError = bindingResult.getFieldError(); BodyValidStatus bodyValidStatus = new BodyValidStatus.Builder().code("0009") .message(fieldError.getDefaultMessage()) .field(fieldError.getField()).build(); LOGGER.warn(bodyValidStatus.getMessage() + e); return new ResponseEntity&lt;&gt;(bodyValidStatus, HttpStatus.OK); &#125; else &#123; bodyStatus = DataUtil.bodyStatus("0009"); &#125; &#125; else &#123; bodyStatus = DataUtil.bodyStatus(Constants.ERROR_CODE); &#125; LOGGER.error(bodyStatus.getMessage() + e); return new ResponseEntity&lt;&gt;(bodyStatus, HttpStatus.OK); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class BodyValidStatus &#123; // 错误代码 private String code; // 错误代码解释 private String message; // 错误字段 private String field; public BodyValidStatus() &#123; &#125; public BodyValidStatus(String code, String message, String field) &#123; this.code = code; this.message = message; this.field = field; &#125; private BodyValidStatus(Builder builder) &#123; setCode(builder.code); setMessage(builder.message); setField(builder.field); &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public String getField() &#123; return field; &#125; public void setField(String field) &#123; this.field = field; &#125; @Override public String toString() &#123; return ToStringBuilder.reflectionToString(this); &#125; public static final class Builder &#123; private String code; private String message; private String field; public Builder() &#123; &#125; public Builder code(String val) &#123; code = val; return this; &#125; public Builder message(String val) &#123; message = val; return this; &#125; public Builder field(String val) &#123; field = val; return this; &#125; public BodyValidStatus build() &#123; return new BodyValidStatus(this); &#125; &#125;&#125; 验证注解详解 自定义验证注解和验证规则12345678910111213141516171819202122import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import javax.validation.Constraint; import javax.validation.Payload; import com.xxx.xxx.constraint.impl.MoneyValidator; @Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy=MoneyValidator.class) public @interface Money &#123; String message() default"不是金额形式"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; &#125; 12345678910111213141516171819202122232425import java.util.regex.Pattern; import javax.validation.ConstraintValidator; import javax.validation.ConstraintValidatorContext; import com.xxx.xxx.constraint.Money; public class MoneyValidator implements ConstraintValidator&lt;Money, Double&gt; &#123; private String moneyReg = "^\\d+(\\.\\d&#123;1,2&#125;)?$";//表示金额的正则表达式 private Pattern moneyPattern = Pattern.compile(moneyReg); public void initialize(Money money) &#123; // TODO Auto-generated method stub &#125; public boolean isValid(Double value, ConstraintValidatorContext arg1) &#123; // TODO Auto-generated method stub if (value == null) return true; return moneyPattern.matcher(value.toString()).matches(); &#125; &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot开发新一代项目]]></title>
    <url>%2Fblog%2F10370.html</url>
    <content type="text"><![CDATA[Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 Spring Boot特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置 安装Spring Boot从最根本上来讲，Spring Boot就是一些库的集合，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。一种更为简便的方式是使用Groovy环境管理器（Groovy enVironment Manager，GVM），它会处理Boot版本的安装和管理。Boot及其CLI可以通过GVM的命令行gvm install springboot进行安装。在OS X上安装Boot可以使用Homebrew包管理器。为了完成安装，首先要使用brew tap pivotal/tap切换到Pivotal仓库中，然后执行brew install springboot命令。要进行打包和分发的工程会依赖于像Maven或Gradle这样的构建系统。为了简化依赖图，Boot的功能是模块化的，通过导入Boot所谓的“starter”模块，可以将许多的依赖添加到工程之中。为了更容易地管理依赖版本和使用默认配置，框架提供了一个parent POM，工程可以继承它。 构建项目步骤 首先要下载maven 用maven管理项目很方便，下载完maven配置好环境，maven我就不细说了。 创建一个maven项目 pom.xml文件里面写这些: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;springboot&lt;/groupId&gt; &lt;artifactId&gt;testSpringBoot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;testSpringBoot&lt;/name&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 继承父包 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.1.3.RELEASE&lt;/version&gt; &lt;relativePath&gt;&lt;/relativePath&gt; &lt;/parent&gt; &lt;!-- spring-boot的web启动的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jpa的jar包 ，操作数据库的，类似hibernate--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--thymeleaf模板jar，是很不错的html数据传递取值，类似jsp的jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--maven的插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 配置java版本 不配置的话默认父类配置的是1.6--&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 创建的文件目录如图: 在com.boot(即最外层目录文件)下写一个如下main方法: 12345678910111213141516package com.boot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@EnableAutoConfiguration@ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; 在com.boot.web下创建一个类如下: 123456789101112131415161718package com.boot.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MainController &#123;// @RequestMapping("")// public String index()&#123;// return "examples/index";// &#125; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125;&#125; @RequestMapping @ResponseBody 这两个注解都是springMVC的,不懂得可以看springMVC 在resources下增加一个application.properties文件 文件内容如下配置: 123456789101112131415161718192021222324252627spring.datasource.platform=mysqlspring.datasource.url=jdbc:mysql://localhost/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true&amp;autoReconnect=true&amp;failOverReadOnly=falsespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driverClassName=com.mysql.jdbc.Driver# Advanced configuration...spring.datasource.max-active=50spring.datasource.max-idle=6spring.datasource.min-idle=2spring.datasource.initial-size=6#create tablespring.jpa.hibernate.ddl-auto=validateserver.port=8080server.session-timeout=30server.tomcat.uri-encoding=UTF-8spring.thymeleaf.prefix=classpath:templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.content-type=text/html spring.thymeleaf.cache=false 该文件的配置可以参考springboot的官网 该文件的全部参数配置；如下(摘自官网) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410# ===================================================================# COMMON SPRING BOOT PROPERTIES## This sample file is provided as a guideline. Do NOT copy it in its# entirety to your own application. ^^^# ===================================================================# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# SPRING CONFIG (ConfigFileApplicationListener)spring.config.name= # config file name (default to &apos;application&apos;)spring.config.location= # location of config file# PROFILESspring.profiles.active= # comma list of active profiles# APPLICATION SETTINGS (SpringApplication)spring.main.sources=spring.main.web-environment= # detect by defaultspring.main.show-banner=truespring.main....= # see class for all properties# LOGGINGlogging.path=/var/logslogging.file=myapp.loglogging.config= # location of config file (default classpath:logback.xml for logback)logging.level.*= # levels for loggers, e.g. &quot;logging.level.org.springframework=DEBUG&quot; (TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF)# IDENTITY (ContextIdApplicationContextInitializer)spring.application.name=spring.application.index=# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.port=8080server.address= # bind to a specific NICserver.session-timeout= # session timeout in secondsserver.context-path= # the context path, defaults to &apos;/&apos;server.servlet-path= # the servlet path, defaults to &apos;/&apos;server.ssl.client-auth= # want or needserver.ssl.key-alias=server.ssl.key-password=server.ssl.key-store=server.ssl.key-store-password=server.ssl.key-store-provider=server.ssl.key-store-type=server.ssl.protocol=TLSserver.ssl.trust-store=server.ssl.trust-store-password=server.ssl.trust-store-provider=server.ssl.trust-store-type=server.tomcat.access-log-pattern= # log pattern of the access logserver.tomcat.access-log-enabled=false # is access logging enabledserver.tomcat.internal-proxies=10\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;|\ 192\.168\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;|\ 169\.254\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;|\ 127\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125; # regular expression matching trusted IP addressesserver.tomcat.protocol-header=x-forwarded-proto # front end proxy forward headerserver.tomcat.port-header= # front end proxy port headerserver.tomcat.remote-ip-header=x-forwarded-forserver.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp)server.tomcat.background-processor-delay=30; # in secondsserver.tomcat.max-threads = 0 # number of threads in protocol handlerserver.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding# SPRING MVC (HttpMapperProperties)http.mappers.json-pretty-print=false # pretty print JSONhttp.mappers.json-sort-keys=false # sort keysspring.mvc.locale= # set fixed locale, e.g. en_UKspring.mvc.date-format= # set fixed date format, e.g. dd/MM/yyyyspring.mvc.message-codes-resolver-format= # PREFIX_ERROR_CODE / POSTFIX_ERROR_CODEspring.view.prefix= # MVC view prefixspring.view.suffix= # ... and suffixspring.resources.cache-period= # cache timeouts in headers sent to browserspring.resources.add-mappings=true # if default mappings should be added# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string (e.g. yyyy-MM-dd HH:mm:ss), or a fully-qualified date format class name (e.g. com.fasterxml.jackson.databind.util.ISO8601DateFormat)spring.jackson.property-naming-strategy= # One of the constants on Jackson&apos;s PropertyNamingStrategy (e.g. CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES) or the fully-qualified class name of a PropertyNamingStrategy subclassspring.jackson.deserialization.*= # see Jackson&apos;s DeserializationFeaturespring.jackson.generator.*= # see Jackson&apos;s JsonGenerator.Featurespring.jackson.mapper.*= # see Jackson&apos;s MapperFeaturespring.jackson.parser.*= # see Jackson&apos;s JsonParser.Featurespring.jackson.serialization.*= # see Jackson&apos;s SerializationFeature# THYMELEAF (ThymeleafAutoConfiguration)spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.content-type=text/html # ;charset=&lt;encoding&gt; is addedspring.thymeleaf.cache=true # set to false for hot refresh# FREEMARKER (FreeMarkerAutoConfiguration)spring.freemarker.allowRequestOverride=falsespring.freemarker.cache=truespring.freemarker.checkTemplateLocation=truespring.freemarker.charSet=UTF-8spring.freemarker.contentType=text/htmlspring.freemarker.exposeRequestAttributes=falsespring.freemarker.exposeSessionAttributes=falsespring.freemarker.exposeSpringMacroHelpers=falsespring.freemarker.prefix=spring.freemarker.requestContextAttribute=spring.freemarker.settings.*=spring.freemarker.suffix=.ftlspring.freemarker.templateLoaderPath=classpath:/templates/ # comma-separated listspring.freemarker.viewNames= # whitelist of view names that can be resolved# GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)spring.groovy.template.cache=truespring.groovy.template.charSet=UTF-8spring.groovy.template.configuration.*= # See Groovy&apos;s TemplateConfigurationspring.groovy.template.contentType=text/htmlspring.groovy.template.prefix=classpath:/templates/spring.groovy.template.suffix=.tplspring.groovy.template.viewNames= # whitelist of view names that can be resolved# VELOCITY TEMPLATES (VelocityAutoConfiguration)spring.velocity.allowRequestOverride=falsespring.velocity.cache=truespring.velocity.checkTemplateLocation=truespring.velocity.charSet=UTF-8spring.velocity.contentType=text/htmlspring.velocity.dateToolAttribute=spring.velocity.exposeRequestAttributes=falsespring.velocity.exposeSessionAttributes=falsespring.velocity.exposeSpringMacroHelpers=falsespring.velocity.numberToolAttribute=spring.velocity.prefix=spring.velocity.properties.*=spring.velocity.requestContextAttribute=spring.velocity.resourceLoaderPath=classpath:/templates/spring.velocity.suffix=.vmspring.velocity.viewNames= # whitelist of view names that can be resolved# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.basename=messagesspring.messages.cacheSeconds=-1spring.messages.encoding=UTF-8# SECURITY (SecurityProperties)security.user.name=user # login usernamesecurity.user.password= # login passwordsecurity.user.role=USER # role assigned to the usersecurity.require-ssl=false # advanced settings ...security.enable-csrf=falsesecurity.basic.enabled=truesecurity.basic.realm=Springsecurity.basic.path= # /**security.filter-order=0security.headers.xss=falsesecurity.headers.cache=falsesecurity.headers.frame=falsesecurity.headers.contentType=falsesecurity.headers.hsts=all # none / domain / allsecurity.sessions=stateless # always / never / if_required / statelesssecurity.ignored=false# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.name= # name of the data sourcespring.datasource.initialize=true # populate using data.sqlspring.datasource.schema= # a schema (DDL) script resource referencespring.datasource.data= # a data (DML) script resource referencespring.datasource.sqlScriptEncoding= # a charset for reading SQL scriptsspring.datasource.platform= # the platform to use in the schema resource (schema-$&#123;platform&#125;.sql)spring.datasource.continueOnError=false # continue even if can&apos;t be initializedspring.datasource.separator=; # statement separator in SQL initialization scriptsspring.datasource.driver-class-name= # JDBC Settings...spring.datasource.url=spring.datasource.username=spring.datasource.password=spring.datasource.jndi-name # For JNDI lookup (class, url, username &amp; password are ignored when set)spring.datasource.max-active=100 # Advanced configuration...spring.datasource.max-idle=8spring.datasource.min-idle=8spring.datasource.initial-size=10spring.datasource.validation-query=spring.datasource.test-on-borrow=falsespring.datasource.test-on-return=falsespring.datasource.test-while-idle=spring.datasource.time-between-eviction-runs-millis=spring.datasource.min-evictable-idle-time-millis=spring.datasource.max-wait=# MONGODB (MongoProperties)spring.data.mongodb.host= # the db hostspring.data.mongodb.port=27017 # the connection port (defaults to 27107)spring.data.mongodb.uri=mongodb://localhost/test # connection URLspring.data.mongo.repositories.enabled=true # if spring data repository support is enabled# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.jpa.properties.*= # properties to set on the JPA connectionspring.jpa.openInView=truespring.jpa.show-sql=truespring.jpa.database-platform=spring.jpa.database=spring.jpa.generate-ddl=false # ignored by Hibernate, might be useful for other vendorsspring.jpa.hibernate.naming-strategy= # naming classnamespring.jpa.hibernate.ddl-auto= # defaults to create-drop for embedded dbsspring.data.jpa.repositories.enabled=true # if spring data repository support is enabled# JTA (JtaAutoConfiguration)spring.jta.log-dir= # transaction log dirspring.jta.*= # technology specific configuration# SOLR (SolrProperties&#125;)spring.data.solr.host=http://127.0.0.1:8983/solrspring.data.solr.zkHost=spring.data.solr.repositories.enabled=true # if spring data repository support is enabled# ELASTICSEARCH (ElasticsearchProperties&#125;)spring.data.elasticsearch.cluster-name= # The cluster name (defaults to elasticsearch)spring.data.elasticsearch.cluster-nodes= # The address(es) of the server node (comma-separated; if not specified starts a client node)spring.data.elasticsearch.repositories.enabled=true # if spring data repository support is enabled# DATA RESET (RepositoryRestConfiguration&#125;)spring.data.rest.baseUri=foo # base URI against which the exporter should calculate its links# FLYWAY (FlywayProperties)flyway.locations=classpath:db/migrations # locations of migrations scriptsflyway.schemas= # schemas to updateflyway.initVersion= 1 # version to start migrationflyway.sql-migration-prefix=Vflyway.sql-migration-suffix=.sqlflyway.enabled=trueflyway.url= # JDBC url if you want Flyway to create its own DataSourceflyway.user= # JDBC username if you want Flyway to create its own DataSourceflyway.password= # JDBC password if you want Flyway to create its own DataSource# LIQUIBASE (LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yamlliquibase.contexts= # runtime contexts to useliquibase.default-schema= # default database schema to useliquibase.drop-first=falseliquibase.enabled=trueliquibase.url= # specific JDBC url (if not set the default datasource is used)liquibase.user= # user name for liquibase.urlliquibase.password= # password for liquibase.url# JMXspring.jmx.enabled=true # Expose MBeans from Spring# RABBIT (RabbitProperties)spring.rabbitmq.host= # connection hostspring.rabbitmq.port= # connection portspring.rabbitmq.addresses= # connection addresses (e.g. myhost:9999,otherhost:1111)spring.rabbitmq.username= # login userspring.rabbitmq.password= # login passwordspring.rabbitmq.virtualHost=spring.rabbitmq.dynamic=# REDIS (RedisProperties)spring.redis.host=localhost # server hostspring.redis.password= # server passwordspring.redis.port=6379 # connection portspring.redis.pool.max-idle=8 # pool settings ...spring.redis.pool.min-idle=0spring.redis.pool.max-active=8spring.redis.pool.max-wait=-1spring.redis.sentinel.master= # name of Redis serverspring.redis.sentinel.nodes= # comma-separated list of host:port pairs# ACTIVEMQ (ActiveMQProperties)spring.activemq.broker-url=tcp://localhost:61616 # connection URLspring.activemq.user=spring.activemq.password=spring.activemq.in-memory=true # broker kind to create if no broker-url is specifiedspring.activemq.pooled=false# HornetQ (HornetQProperties)spring.hornetq.mode= # connection mode (native, embedded)spring.hornetq.host=localhost # hornetQ host (native mode)spring.hornetq.port=5445 # hornetQ port (native mode)spring.hornetq.embedded.enabled=true # if the embedded server is enabled (needs hornetq-jms-server.jar)spring.hornetq.embedded.serverId= # auto-generated id of the embedded server (integer)spring.hornetq.embedded.persistent=false # message persistencespring.hornetq.embedded.data-directory= # location of data content (when persistence is enabled)spring.hornetq.embedded.queues= # comma-separated queues to create on startupspring.hornetq.embedded.topics= # comma-separated topics to create on startupspring.hornetq.embedded.cluster-password= # customer password (randomly generated by default)# JMS (JmsProperties)spring.datasource.jndi-name= # JNDI location of a JMS ConnectionFactoryspring.jms.pub-sub-domain= # false for queue (default), true for topic# SPRING BATCH (BatchDatabaseInitializer)spring.batch.job.names=job1,job2spring.batch.job.enabled=truespring.batch.initializer.enabled=truespring.batch.schema= # batch schema to load# AOPspring.aop.auto=spring.aop.proxy-target-class=# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding=false# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=true # Set to true for default connection views or false if you provide your own# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application&apos;s Facebook App IDspring.social.facebook.app-secret= # your application&apos;s Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application&apos;s LinkedIn App IDspring.social.linkedin.app-secret= # your application&apos;s LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application&apos;s Twitter App IDspring.social.twitter.app-secret= # your application&apos;s Twitter App Secret# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # enabled by default# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enabled=true # disabled by defaultspring.mobile.devicedelegatingviewresolver.normalPrefix=spring.mobile.devicedelegatingviewresolver.normalSuffix=spring.mobile.devicedelegatingviewresolver.mobilePrefix=mobile/spring.mobile.devicedelegatingviewresolver.mobileSuffix=spring.mobile.devicedelegatingviewresolver.tabletPrefix=tablet/spring.mobile.devicedelegatingviewresolver.tabletSuffix=# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.port= # defaults to &apos;server.port&apos;management.address= # bind to a specific NICmanagement.contextPath= # default to &apos;/&apos;management.add-application-context-header= # default to true# ENDPOINTS (AbstractEndpoint subclasses)endpoints.autoconfig.id=autoconfigendpoints.autoconfig.sensitive=trueendpoints.autoconfig.enabled=trueendpoints.beans.id=beansendpoints.beans.sensitive=trueendpoints.beans.enabled=trueendpoints.configprops.id=configpropsendpoints.configprops.sensitive=trueendpoints.configprops.enabled=trueendpoints.configprops.keys-to-sanitize=password,secret,key # suffix or regexendpoints.dump.id=dumpendpoints.dump.sensitive=trueendpoints.dump.enabled=trueendpoints.env.id=envendpoints.env.sensitive=trueendpoints.env.enabled=trueendpoints.env.keys-to-sanitize=password,secret,key # suffix or regexendpoints.health.id=healthendpoints.health.sensitive=falseendpoints.health.enabled=trueendpoints.health.time-to-live=1000endpoints.info.id=infoendpoints.info.sensitive=falseendpoints.info.enabled=trueendpoints.metrics.id=metricsendpoints.metrics.sensitive=trueendpoints.metrics.enabled=trueendpoints.shutdown.id=shutdownendpoints.shutdown.sensitive=trueendpoints.shutdown.enabled=falseendpoints.trace.id=traceendpoints.trace.sensitive=trueendpoints.trace.enabled=true# HEALTH INDICATORShealth.diskspace.path=.health.diskspace.threshold=10485760# MVC ONLY ENDPOINTSendpoints.jolokia.path=jolokiaendpoints.jolokia.sensitive=trueendpoints.jolokia.enabled=true # when using Jolokia# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.enabled=trueendpoints.jmx.domain= # the JMX domain, defaults to &apos;org.springboot&apos;endpoints.jmx.unique-names=falseendpoints.jmx.staticNames=# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# REMOTE SHELLshell.auth=simple # jaas, key, simple, springshell.command-refresh-interval=-1shell.command-path-patterns= # classpath*:/commands/**, classpath*:/crash/commands/**shell.config-path-patterns= # classpath*:/crash/*shell.disabled-plugins=false # don&apos;t expose pluginsshell.ssh.enabled= # ssh settings ...shell.ssh.keyPath=shell.ssh.port=shell.telnet.enabled= # telnet settings ...shell.telnet.port=shell.auth.jaas.domain= # authentication settings ...shell.auth.key.path=shell.auth.simple.user.name=shell.auth.simple.user.password=shell.auth.spring.roles=# GIT INFOspring.git.properties= # resource ref to generated git info properties file 找到com.boot下的Application 以java Application方式启动，然后打开浏览器输入localhost:8080就会出现Hello World! 这样一个简单的web开发就搭建好了。 启动图片:]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark抓包工具使用以及常用抓包规则]]></title>
    <url>%2Fblog%2F64619.html</url>
    <content type="text"><![CDATA[Wireshark是一个非常好用的抓包工具，当我们遇到一些和网络相关的问题时，可以通过这个工具进行分析，不过要说明的是，这只是一个工具，用法是非常灵活的，所以今天讲述的内容可能无法直接帮你解决问题，但是只要你有解决问题的思路，学习用这个软件就非常有用了。 Wireshark官方下载地址：http://www.wireshark.org/download.html 简单介绍这个软件的一些常用按钮，因为本人也是接触这个软件不久，所以就简单的说下最常用的按钮好了，打开软件后，下面红框中的按钮从左到右依次是： 列表显示所有网卡的网络包情况，一般用的很少； 显示抓包选项，一般都是点这个按钮开始抓包； 开始新的抓包，一般用的也很少； 停止抓包，当你抓完包之后，就是点这个停止了； 清空当前已经抓到的数据包，可以防止抓包时间过长机器变卡； 而实际上，一般我们只要知道上面加粗部分的按钮功能，就可以完成抓包了，剩下的就是如何抓你想要的数据包，如何分析的问题了。 接下来说下抓包选项界面，也就是点第二个按钮出来的界面，同样，这里也只介绍最常用的几个功能，首先下图中最上面的红框是选择需要抓的网卡，选择好网卡后会在下面显示这个网卡的IP地址。 然后Capture Filter中就是要写抓包规则的地方，也叫做“过滤规则”，我们下面要说的很多规则都是要写到这个框里的，规则写好后，点下面的Start就开始抓包了。 当抓包结束之后，如果你需要把抓到的数据包找其他人分析，那么可以点菜单上的file，然后点Save As保存抓到的数据包，如下图： ok，到这里，基础的使用方法说完了，接下来步入很关键的内容。 使用Wireshark时最常见的问题当您使用默认设置时，会得到大量冗余信息，以至于很难找到自己需要的部分。这就是为什么过滤器会如此重要。它们可以帮助我们在庞杂的结果中迅速找到我们需要的信息。 过滤器的区别 捕捉过滤器（CaptureFilters）：用于决定将什么样的信息记录在捕捉结果中。需要在开始捕捉前设置。 显示过滤器（DisplayFilters）：在捕捉结果中进行详细查找。他们可以在得到捕捉结果后随意修改。那么我应该使用哪一种过滤器呢？ 两种过滤器的目的是不同的。 捕捉过滤器是数据经过的第一层过滤器，它用于控制捕捉数据的数量，以避免产生过大的日志文件。 显示过滤器是一种更为强大（复杂）的过滤器。它允许您在日志文件中迅速准确地找到所需要的记录。 两种过滤器使用的语法是完全不同的。 捕捉过滤器 Protocol（协议）:可能的值: ether, fddi, ip, arp, rarp, decnet, lat, sca, moprc, mopdl, tcp and udp.如果没有特别指明是什么协议，则默认使用所有支持的协议。 Direction（方向）:可能的值: src, dst, src and dst, src or dst如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字。例如，”host 10.2.2.2″与”src or dst host 10.2.2.2″是一样的。 Host(s):可能的值： net, port, host, portrange.如果没有指定此值，则默认使用”host”关键字。例如，”src 10.1.1.1″与”src host 10.1.1.1″相同。 Logical Operations（逻辑运算）:可能的值：not, and, or.否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。例如，“not tcp port 3128 and tcp port 23″与”(not tcp port 3128) and tcp port 23″相同。“not tcp port 3128 and tcp port 23″与”not (tcp port 3128 and tcp port 23)”不同。 例子：tcp dst port 3128 //捕捉目的TCP端口为3128的封包。 ip src host 10.1.1.1 //捕捉来源IP地址为10.1.1.1的封包 host 10.1.2.3 //捕捉目的或来源IP地址为10.1.2.3的封包。 ether host e0-05-c5-44-b1-3c //捕捉目的或来源MAC地址为e0-05-c5-44-b1-3c的封包。如果你想抓本机与所有外网通讯的数据包时，可以将这里的mac地址换成路由的mac地址即可。 src portrange 2000-2500 //捕捉来源为UDP或TCP，并且端口号在2000至2500范围内的封包。 not imcp //显示除了icmp以外的所有封包。（icmp通常被ping工具使用） src host 10.7.2.12 and not dst net 10.200.0.0/16 //显示来源IP地址为10.7.2.12，但目的地不是10.200.0.0/16的封包。 (src host 10.4.1.12 or src net 10.6.0.0/16) and tcp dst portrange 200-10000 and dst net 10.0.0.0/8 //捕捉来源IP为10.4.1.12或者来源网络为10.6.0.0/16，目的地TCP端口号在200至10000之间，并且目的位于网络 10.0.0.0/8内的所有封包。 src net 192.168.0.0/24src net 192.168.0.0 mask 255.255.255.0 //捕捉源地址为192.168.0.0网络内的所有封包。 注意事项：当使用关键字作为值时，需使用反斜杠“/”。“ether proto /ip” (与关键字”ip”相同).这样写将会以IP协议作为目标。 “ip proto /icmp” (与关键字”icmp”相同).这样写将会以ping工具常用的icmp作为目标。 可以在”ip”或”ether”后面使用”multicast”及”broadcast”关键字。 当您想排除广播请求时，”no broadcast”就会非常有用。 Protocol（协议）:您可以使用大量位于OSI模型第2至7层的协议。点击”Expression…”按钮后，您可以看到它们。比如：IP，TCP，DNS，SSH String1, String2 (可选项): 协议的子类。点击相关父类旁的”+”号，然后选择其子类。 例子：snmp || dns || icmp //显示SNMP或DNS或ICMP封包。 ip.addr == 10.1.1.1//显示来源或目的IP地址为10.1.1.1的封包。 ip.src != 10.1.2.3 or ip.dst != 10.4.5.6 //显示来源不为10.1.2.3或者目的不为10.4.5.6的封包。 换句话说，显示的封包将会为： 来源IP：除了10.1.2.3以外任意；目的IP：任意以及来源IP：任意；目的IP：除了10.4.5.6以外任意ip.src != 10.1.2.3 and ip.dst != 10.4.5.6 //显示来源不为10.1.2.3并且目的IP不为10.4.5.6的封包。 换句话说，显示的封包将会为： 来源IP：除了10.1.2.3以外任意；同时须满足，目的IP：除了10.4.5.6以外任意tcp.port == 25 //显示来源或目的TCP端口号为25的封包。tcp.dstport == 25 //显示目的TCP端口号为25的封包。tcp.flags //显示包含TCP标志的封包。tcp.flags.syn == 0×02 //显示包含TCP SYN标志的封包。 如果过滤器的语法是正确的，表达式的背景呈绿色。如果呈红色，说明表达式有误。 更为详细的说明请见：http://openmaniak.com/cn/wireshark_filters.php 以上只是抓包和简单的过滤，那么其实如果你要想达到能够分析这些网络包的要求时，还需要了解下一些数据包的标记，比如我们常说的TCP三次握手是怎么回事？ 三次握手Three-way Handshake一个虚拟连接的建立是通过三次握手来实现的 (Client) –&gt; [SYN] –&gt; (Server)假如Client和Server通讯. 当Client要和Server通信时，Client首先向Server发一个SYN (Synchronize) 标记的包，告诉Server请求建立连接.注意: 一个 SYN包就是仅SYN标记设为1的TCP包(参见TCP包头Resources). 认识到这点很重要，只有当Server收到Client发来的SYN包，才可建立连接，除此之外别无他法。因此，如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不 能让外部任何主机主动建立连接。 (Client) &lt;– [SYN/ACK] &lt;–(Server)接着，Server收到来自Client发来的SYN包后，会发一个对SYN包的确认包(SYN/ACK)给Client，表示对第一个SYN包的确认，并继续握手操作.注意: SYN/ACK包是仅SYN 和 ACK 标记为1的包. (Client) –&gt; [ACK] –&gt; (Server)Client收到来自Server的SYN/ACK 包,Client会再向Server发一个确认包(ACK)，通知Server连接已建立。至此，三次握手完成，一个TCP连接完成。Note: ACK包就是仅ACK 标记设为1的TCP包. 需要注意的是当三此握手完成、连接建立以后，TCP连接的每个包都会设置ACK位。 这就是为何连接跟踪很重要的原因了. 没有连接跟踪,防火墙将无法判断收到的ACK包是否属于一个已经建立的连接.一般的包过滤(Ipchains)收到ACK包时,会让它通过(这绝对不是个 好主意). 而当状态型防火墙收到此种包时，它会先在连接表中查找是否属于哪个已建连接，否则丢弃该包。 四次握手Four-way Handshake四次握手用来关闭已建立的TCP连接 (Client) –&gt; ACK/FIN –&gt; (Server) (Client) &lt;– ACK &lt;– (Server) (Client) &lt;– ACK/FIN &lt;– (Server) (Client) –&gt; ACK –&gt; (Server) 注意:由于TCP连接是双向连接, 因此关闭连接需要在两个方向上做。ACK/FIN 包(ACK 和FIN 标记设为1)通常被认为是FIN(终结)包.然而, 由于连接还没有关闭, FIN包总是打上ACK标记. 没有ACK标记而仅有FIN标记的包不是合法的包，并且通常被认为是恶意的。 连接复位Resetting a connection 四次握手不是关闭TCP连接的唯一方法. 有时,如果主机需要尽快关闭连接(或连接超时,端口或主机不可达),RST (Reset)包将被发送. 注意在，由于RST包不是TCP连接中的必须部分, 可以只发送RST包(即不带ACK标记). 但在正常的TCP连接中RST包可以带ACK确认标记 请注意RST包是可以不要收到方确认的? 无效的TCP标记Invalid TCP Flags 到目前为止，你已经看到了 SYN, ACK, FIN, 和RST 标记. 另外，还有PSH (Push) 和URG (Urgent)标记. 最常见的非法组合是SYN/FIN 包. 注意:由于 SYN包是用来初始化连接的, 它不可能和 FIN和RST标记一起出现. 这也是一个恶意攻击. 由于现在大多数防火墙已知 SYN/FIN 包, 别的一些组合,例如SYN/FIN/PSH, SYN/FIN/RST, SYN/FIN/RST/PSH。很明显，当网络中出现这种包时，很你的网络肯定受到攻击了。 别的已知的非法包有FIN (无ACK标记)和”NULL”包。如同早先讨论的，由于ACK/FIN包的出现是为了关闭一个TCP连接，那么正常的FIN包总是带有 ACK 标记。”NULL”包就是没有任何TCP标记的包(URG,ACK,PSH,RST,SYN,FIN都为0)。 到目前为止，正常的网络活动下，TCP协议栈不可能产生带有上面提到的任何一种标记组合的TCP包。当你发现这些不正常的包时，肯定有人对你的网络不怀好意。 UDP (用户数据包协议User Datagram Protocol) TCP是面向连接的，而UDP是非连接的协议。UDP没有对接受进行确认的标记和确认机制。对丢包的处理是在应用层来完成的。(or accidental arrival). 此处需要重点注意的事情是：在正常情况下，当UDP包到达一个关闭的端口时，会返回一个UDP复位包。由于UDP是非面向连接的, 因此没有任何确认信息来确认包是否正确到达目的地。因此如果你的防火墙丢弃UDP包，它会开放所有的UDP端口(?)。 由于Internet上正常情况下一些包将被丢弃，甚至某些发往已关闭端口(非防火墙的)的UDP包将不会到达目的，它们将返回一个复位UDP包。 因为这个原因，UDP端口扫描总是不精确、不可靠的。 看起来大UDP包的碎片是常见的DOS (Denial of Service)攻击的常见形式 (这里有个DOS攻击的例子，http://grc.com/dos/grcdos.htm ). ICMP (网间控制消息协议Internet Control Message Protocol) 如同名字一样， ICMP用来在主机/路由器之间传递控制信息的协议。 ICMP包可以包含诊断信息(ping, traceroute - 注意目前unix系统中的traceroute用UDP包而不是ICMP)，错误信息(网络/主机/端口 不可达 network/host/port unreachable), 信息(时间戳timestamp, 地址掩码address mask request, etc.)，或控制信息 (source quench, redirect, etc.) 。 你可以在http://www.iana.org/assignments/icmp-parameters 中找到ICMP包的类型。 尽管ICMP通常是无害的，还是有些类型的ICMP信息需要丢弃。 Redirect (5), Alternate Host Address (6), Router Advertisement (9) 能用来转发通讯。 Echo (8), Timestamp (13) and Address Mask Request (17) 能用来分别判断主机是否起来，本地时间 和地址掩码。注意它们是和返回的信息类别有关的。 它们自己本身是不能被利用的，但它们泄露出的信息对攻击者是有用的。 ICMP消息有时也被用来作为DOS攻击的一部分(例如：洪水ping flood ping,死 ping ?呵呵，有趣 ping of death)?/p&gt; 包碎片注意A Note About Packet Fragmentation 如果一个包的大小超过了TCP的最大段长度MSS (Maximum Segment Size) 或MTU (Maximum Transmission Unit)，能够把此包发往目的的唯一方法是把此包分片。由于包分片是正常的，它可以被利用来做恶意的攻击。 因为分片的包的第一个分片包含一个包头，若没有包分片的重组功能，包过滤器不可能检测附加的包分片。典型的攻击Typical attacks involve in overlapping the packet data in which packet header is 典型的攻击Typical attacks involve in overlapping the packet data in which packet header isnormal until is it overwritten with different destination IP (or port) thereby bypassing firewall rules。包分片能作为 DOS 攻击的一部分，它可以crash older IP stacks 或涨死CPU连接能力。 Netfilter/Iptables中的连接跟踪代码能自动做分片重组。它仍有弱点，可能受到饱和连接攻击，可以把CPU资源耗光。 OK，到此为止，关于Wireshark抓包工具的一些小教程已经写完了，而导致我想写这么一个纠结的教程的原因是，前几天通过这个抓包解决了梦幻西游在网维大师无盘上容易掉线的问题，当时捕捉到梦幻西游掉线时的数据包是这样的。注意下图中的红色数据，123.58.184.241是梦幻西游的服务器，而192.168.1.41是玩梦幻西游的客户机，在掉线时，发现是先有梦幻西游的服务器向客户机发送一个[FIN,ACK]数据包，根据上面的解释，FIN标记的数据包是代表要断开连接的意思，而接着客户机又回给服务器一个确认断开链接包。当看到这个抓包数据时，就意识到，大家说的在网维大师系统虚拟盘上梦幻爱掉线的问题，并非普通的网络问题，因为通过数据包的信息来看，是梦幻服务器主动要求断开链接，产生这个情况无非是以下几个原因：1、服务器发现客户端非法，比如有外挂什么的，踢掉了客户机；2、服务器压力大，踢掉了客户机；3、总之不是客户端问题导致的掉线； 那么既然结论是如此，为什么会有在网维大师系统虚拟盘上容易出现梦幻掉线问题呢？原因是由于网维大师系统虚拟盘是模拟真实硬盘方式来实现的，而在模拟过程中，将硬盘的序列号设置为固定过的OSDIY888了，而梦幻西游刚好后识别客户机硬盘信息，发现大量客户端的硬盘序列号都是一样的，就认为是作弊或者使用挂机外挂了，结果就导致随机被服务器踢下线的情况发生，后来我们将硬盘序列号设置为空，则没再出现该问题。这个问题在未来的新版本中会解决掉。 说这个案例的目的并不是为了说明抓包多有用，而是想说明一些解决问题的思路和方法，有些人是有思路，但是缺方法，比如不会用工具，而有些人收集了很多工具却不会用，而我其实就属于后者，几年前就收集了n多工具，但是用到的没几个。慢慢的学会用这些工具后，发现思维+工具，解决问题是效率暴增，接下来的几天里，会陆续介绍写小工具给大家，也希望大家有空学习下，有问题先百度，再自己摸索，而不是一味的求助，毕竟求人不如求己！自己能直接搞定，是皆大欢喜的事情~注意：由于某些系统为了防止ARP攻击，都免疫掉了一个Npptools.dll文件，这会导致该软件无法正常安装，打下这个补丁就可以了。]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记]]></title>
    <url>%2Fblog%2F41659.html</url>
    <content type="text"><![CDATA[Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。 spring只是一个框架想跟着 spring in action 4 系统的研究下spring，结果发现忘了怎么建一个spring项目。 关键是，不知道该建一个什么项目，Java项目？Maven项目（Java项目？Web项目）？ 一直以来都是直拿以前的项目配置修修改改，结果居然忘了spring的本质是什么，我是说，居然把spring当成web专属了。 颇有些提笔忘字的意思。 spring只是一个框架，第三方jar包，作用就是IoC、DI、AOP。 所以，spring与web没有必然关系，可以用在任何需要的项目中 — 它就一中介和监管机构！！！ 核心：加载配置文件applicationContext.xml，生成一个ApplicationContext对象，继而就可以提供被其代理的对象了！！！ 本质就是这么简单。 spring提供xml方式和注解方式配置bean。（可以认为bean就是我们需要spring创建的对象） 前者是在xml中配置bean，。 后者只需要在bean对应的类上@Component （或 @Repository ）即可。 需要注意的是，spring会根据配置或者注解生成对象，从而注入到需要的地方。 所以需要指定怎么生成对象，初始化参数是什么。 默认情况下，使用无参构造方法创建对象。 spring与web的结合： 在web.xml中启动spring即可！！！ spring与jdbc的结合： 在spring中配置连接所需信息，提供DataSource即可（也行还有事务）。 Spring事务：调用同一个类中的方法问题： 如果同一个类中有方法：methodA(); methodB()。methodA()没有开启事务，methodB()开启了事务 且methodA()会调用methodB()。 那么，methodA()调用methodB()时，不会开启事务！！！ 即：同一个类中，无事务的方法调用有事务的方法，结果就是没有事务！！！ 原因：点这里 解决办法：要么声明要事务，要么分开成两个类，要么直接在方法里使用编程式事务。 建议直接分成两个类。 Spring配置相关Spring容器中bean的id或name，都可以有多个，且第一个为标识符（Qualifier），其余皆为别名（Alias）。所以都可以通过applicationContext.getBean(“id or name”, Type.class)获取。 如果同时存在id和name，则name为别名！！！ Spring容器目前能对各种基本类型把配置的String参数转换为需要的类型。 注：Spring类型转换系统对于boolean类型进行了容错处理，除了可以使用“true/false”标准的Java值进行注入，还能使用“yes/no”、“on/off”、“1/0”来代表“真/假”，所以大家在学习或工作中遇到这种类似问题不要觉得是人家配置错了，而是Spring容错做的非常好。 12345678910// 测试类public class BooleanTestBean &#123; private boolean success; public void setSuccess(boolean success) &#123; this.success = success; &#125; public boolean isSuccess() &#123; return success; &#125;&#125; 12345678910111213// 配置文件（chapter3/booleanInject.xml）片段：&lt;!-- boolean参数值可以用on/off --&gt;&lt;bean id="bean2" class="cn.javass.spring.chapter3.bean.BooleanTestBean"&gt; &lt;property name="success" value="on"/&gt;&lt;/bean&gt;&lt;!-- boolean参数值可以用yes/no --&gt;&lt;bean id="bean3" class="cn.javass.spring.chapter3.bean.BooleanTestBean"&gt; &lt;property name="success" value="yes"/&gt;&lt;/bean&gt;&lt;!-- boolean参数值可以用1/0 --&gt;&lt;bean id="bean4" class="cn.javass.spring.chapter3.bean.BooleanTestBean"&gt; &lt;property name="success" value="1"/&gt;&lt;/bean&gt; Spring通过标签或value属性注入常量值，所有注入的数据都是字符串，那如何注入null值呢？ 通过“null”值吗？当然不是因为如果注入“null”则认为是字符串。Spring通过标签注入null值。 即可以采用如下配置方式： 1234&lt;bean class="..."&gt; &lt;property name="message"&gt;&lt;null&gt;&lt;/property&gt; ...&lt;/bean&gt; 使用context:annotation-config/标签来开启注解形式的依赖注入。 使用context:component-scan/标签来表示需要要自动注册Bean定义，而通过base-package属性指定扫描的类路径位置。 注意，context:component-scan/默认开启了annotation-config。 使用aop:aspectj-autoproxy/标签开启Spring对@AspectJ风格切面的支持。 @AspectJ风格的切面可以通过@Compenent注解标识其为Spring管理Bean，而@Aspect注解不能被Spring自动识别并注册为Bean，必须通过@Component注解来完成。 123456789101112package cn.javass.spring.chapter12.aop;//省略import@Component@Aspectpublic class TestAspect &#123; @Pointcut(value="execution(* *(..))") private void pointcut() &#123;&#125; @Before(value="pointcut()") public void before() &#123; System.out.println("=======before"); &#125;&#125; Spring 父子容器必须要说的是，父子容器是通过设置形成的关系。 容器实现了 ConfigurableApplicationContext 或 ConfigurableBeanFactory 接口，这两个接口中分别有setParent 及setParentBeanFactory 方法，可以将指定容器设置为当前容器的父容器。 首先，默认情况下，Spring + SpringMVC 框架的web项目，会先创建 WebApplicationContext（应用上下文环境，就是IoC容器啦），并以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE 为Key，将其存储到ServletContext 中 —这就是根容器。 然后，创建DispatcherServlet ，注意，这是个Servlet，而Servlet也是有ServletContext 的，而且，它也会创建自己的IoC上下文（IoC容器）。这个IoC容器会去ServletContext 中查找根容器，并将其设为自己的父容器！！！—小疑问，这个ServletContext 和 IoC容器 是否一个？？？待验证。。 简单的可以推知：子容器可以访问父容器中的bean，父容器则无法访问子容器中的内容！！！ 参考： spring的启动过程 Spring中父子容器的实现实例 Spring bean的初始化及销毁Spring bean的几个属性：scope、init-method、destroy-method、depends-on等。 Scope 在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。 scope分类：singleton, prototype, request, session, global session。 这里的singleton和设计模式里面的单例模式不一样，标记为singleton的bean是由容器来保证这种类型的bean在同一个容器内只存在一个共享实例，而单例模式则是保证在同一个Classloader中只存在一个这种类型的实例。 init-method 是指创建bean时调用的方法，注意，不是创建bean的方法。 destroy-method 是指销毁bean时调用的方法，同样，不是销毁bean的方法。 注意：scope为prototype的bean，容器会将创建好的对象实例返回给请求方，之后，容器就不再拥有其引用，请求方需要自己负责当前对象后继生命周期的管理工作，包括该对象的销毁。 所以：scope为singleton的bean的destroy方法则是在容器关闭时执行，而scope为prototype的bean是不会执行destroy方法的。 depends-on 用于指定bean初始化及销毁时的顺序。注意上面的结论。 123456&lt;bean id="helloApi" class="cn.javass.spring.chapter2.helloworld.HelloImpl"/&gt;&lt;bean id="decorator" class="cn.javass.spring.chapter3.bean.HelloApiDecorator" depends-on="helloApi"&gt;&lt;property name="helloApi"&gt;&lt;ref bean="helloApi"/&gt;&lt;/property&gt;&lt;/bean&gt; “decorator”指定了“depends-on”属性为“helloApi”，所以在“decorator”Bean初始化之前要先初始化“helloApi”，而在销毁“helloApi”之前先要销毁“decorator”，大家注意一下销毁顺序。 Spring 允许 Bean 在初始化完成后以及销毁前执行特定的操作。下面是常用的三种指定特定操作的方法： 通过实现 InitializingBean / DisposableBean 接口； 通过 元素的 init-method / destroy-method属性； 通过@PostConstruct或@PreDestroy注解。 Bean在实例化的过程中：Constructor &gt; @PostConstruct &gt;InitializingBean &gt; init-method Bean在销毁的过程中：@PreDestroy &gt; DisposableBean &gt; destroy-method 参考：Spring bean 的init-method和destroy-methodSpring容器中的Bean几种初始化方法和销毁方法的先后顺序Spring scope属性详解 可以和@Component一起使用的注解： @Lazy(true) – 延迟初始化 @DependsOn({“managedBean”}) – 初始化及销毁时的顺序 @Qualifier – 见 Spring 依赖注入（DI）的注解 @Primary – 当有多个候选时，被注解的bean作为首选项，否则异常。 Resource接口，及资源Resource介绍编码的时候，除了代码本身，我们还需要对外部的资源进行处理。例如：URL资源、URI资源、File资源、ClassPath相关资源、服务器相关资源（VFS等）等等。 而这些资源的处理是类似而繁琐的，如：打开资源、读取资源、关闭资源。 所以Spring提供了一个专门的接口Resource 用于统一这些底层资源的访问。 就是说，Spring的Resource接口代表底层外部资源，提供了对底层外部资源的一致性访问接口。 源码如下： 12345678910111213141516public interface InputStreamSource &#123; InputStream getInputStream() throws IOException;&#125;public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isReadable(); boolean isOpen(); URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource等。 ByteArrayResource代表byte[]数组资源，对于 getInputStream() 操作将返回一个ByteArrayInputStream。ByteArrayResource可多次读取数组资源，即 isOpen() 永远返回false。 InputStreamResource代表java.io.InputStream字节流，对于getInputStream() 操作将直接返回该字节流，因此只能读取一次该字节流，即 isOpen() 永远返回true。 FileSystemResource代表java.io.File资源，对于 getInputStream() 操作将返回底层文件的字节流，isOpen() 将永远返回false，从而表示可多次读取底层文件的字节流。 ClassPathResource代表classpath路径的资源，将使用ClassLoader进行加载资源。classpath 资源存在于类路径中的文件系统中或jar包里，且 isOpen() 永远返回false，表示可多次读取资源。 ClassPathResource加载资源替代了Class类和ClassLoader类的getResource(String name)和getResourceAsStream(String name)两个加载类路径资源方法，提供一致的访问方式。 ClassPathResource提供了三个构造器： public ClassPathResource(String path)：使用默认的ClassLoader加载“path”类路径资源； public ClassPathResource(String path, ClassLoader classLoader)：使用指定的ClassLoader加载“path”类路径资源； – 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/test1.properties”； public ClassPathResource(String path, Class&lt;?&gt; clazz)：使用指定的类加载“path”类路径资源，将加载相对于当前类的路径的资源； – 比如当前类路径是“cn.javass.spring.chapter4.ResourceTest”，而需要加载的资源路径是“cn/javass/spring/chapter4/test1.properties”，则将加载的资源在“cn/javass/spring/chapter4/cn/javass/spring/chapter4/test1.properties”； – 而如果需要 加载的资源路径为“test1.properties”，将加载的资源为“cn/javass/spring/chapter4/test1.properties”。 – 需要注意一定：资源查找顺序是先查找当前类路径的资源，再去查找jar包，而且，只要找到就会返回。 – 如果是在jar包中的资源，需要使用getURL()，而不是getFile()，因为资源不是存在于File系统，而是存在于jar包中！！！ UrlResource代表URL资源，用于简化URL资源访问。“isOpen”永远返回false，表示可多次读取资源。 UrlResource一般支持如下资源访问： http：通过标准的http协议访问web资源，如new UrlResource(“http://地址”)； ftp：通过ftp协议访问资源，如new UrlResource(“ftp://地址”)； file：通过file协议访问本地文件系统资源，如new UrlResource(“file:d:/test.txt”)； ServletContextResource代表web应用资源，用于简化servlet容器的ServletContext接口的getResource操作和getResourceAsStream操作； VfsResource代表Jboss 虚拟文件系统资源。 Resource访问ResourceLoader接口用于返回Resource对象；其实现可以看作是一个生产Resource的工厂类。 1234public interface ResourceLoader &#123; Resource getResource(String location); ClassLoader getClassLoader();&#125; getResource接口用于根据提供的location参数返回相应的Resource对象；而getClassLoader则返回加载这些Resource的ClassLoader。 Spring提供了一个适用于所有环境的DefaultResourceLoader实现，可以返回ClassPathResource、UrlResource； 还提供一个用于web环境的ServletContextResourceLoader，它继承了DefaultResourceLoader的所有功能，又额外提供了获取ServletContextResource的支持。 ResourceLoader在进行加载资源时需要使用前缀来指定需要加载：“classpath:path”表示返回ClasspathResource，“http://path”和“file:path”表示返回UrlResource资源；如果不加前缀则需要根据当前上下文来决定；另外，DefaultResourceLoader默认实现可以加载classpath资源。 目前所有的ApplicationContext都实现了ResourceLoader，因此可以使用其来加载资源。 ClassPathXmlApplicationContext：不指定前缀将返回默认的ClassPathResource资源，否则将根据前缀来加载资源； FileSystemXmlApplicationContext：不指定前缀将返回FileSystemResource，否则将根据前缀来加载资源； WebApplicationContext：不指定前缀将返回ServletContextResource，否则将根据前缀来加载资源； 其他：不指定前缀根据当前上下文返回Resource实现，否则将根据前缀来加载资源。 ResourceLoaderResourceLoaderAware是一个标记接口，用于通过ApplicationContext注入ResourceLoader。 注入Resource通过注入来获取ResourceLoader，再来访问资源，很麻烦！！！ Spring提供了ResourceEditor（这是一个PropertyEditor），用于在注入的字符串和Resource之间进行转换。 因此可以使用注入方式注入Resource。 1234567891011package cn.javass.spring.chapter4.bean;import org.springframework.core.io.Resource;public class ResourceBean3 &#123; private Resource resource; public Resource getResource() &#123; return resource; &#125; public void setResource(Resource resource) &#123; this.resource = resource; &#125;&#125; 123456&lt;bean id="resourceBean1" class="cn.javass.spring.chapter4.bean.ResourceBean3"&gt; &lt;property name="resource" value="cn/javass/spring/chapter4/test1.properties"/&gt;&lt;/bean&gt;&lt;bean id="resourceBean2" class="cn.javass.spring.chapter4.bean.ResourceBean3"&gt; &lt;property name="resource" value="classpath:cn/javass/spring/chapter4/test1.properties"/&gt;&lt;/bean&gt; 注意此处“resourceBean1”注入的路径没有前缀表示根据使用的ApplicationContext实现进行选择Resource实现。 Resource通配符路径Spring提供了一种更强大的Ant模式通配符匹配，能匹配一批资源。 1234Ant路径通配符支持“？”、“*”、“**”，注意通配符匹配不包括目录分隔符“/”： “?”：匹配一个字符，如“config?.xml”将匹配“config1.xml”； “*”：匹配零个或多个字符串，如“cn/*/config.xml”将匹配“cn/javass/config.xml”，但不匹配匹配“cn/config.xml”；而“cn/config-*.xml”将匹配“cn/config-dao.xml”； “**”：匹配路径中的零个或多个目录，如“cn/**/config.xml”将匹配“cn /config.xml”，也匹配“cn/javass/spring/config.xml”；而“cn/javass/config-**.xml”将匹配“cn/javass/config-dao.xml”，即把“**”当做两个“*”处理。 小结： ① Spring通过Resource接口统一访问外部资源，并提供了一堆实现类，可以分别访问File、classpath、URL、URI等等资源。 ② Spring通过ResourceLoader接口获取Resource。 ③ ApplicationContext都实现了ResourceLoader接口，所以可以直接加载资源！ ④ 实现ResourceLoaderAware接口，可以注入ResourceLoader。 ⑤ 注入Resource。 ⑥ Resource通配符路径。 Spring 依赖注入（DI）的注解Spring中想要使用注解进行依赖注入，需要进行如下配置： 12345678910&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; Spring自带依赖注入的注解@Required，该注解必须用是setter方法上面，目的是强制要求提供setter所需数据，否则报错。 例如，BeanA中的字段field，有一个setField( T field)方法。当在该方法上使用了@Required之后，在XML中创建BeanA时就必须给出设置field所需的数据。 如下所示： 12345678910111213141516package o1.bean;import org.springframework.beans.factory.annotation.Required;public class BeanA &#123; private String message; public String getMessage()&#123; return message; &#125; @Required //只能放在setter上,在XML配置BeanA时必须指定setter注入，否则在Spring容器启动时将抛出异常 public void setMessage(String message)&#123; this.message = message; &#125;&#125; 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--开启注解支持--&gt; &lt;context:annotation-config/&gt; &lt;bean class="o1.bean.BeanA"&gt; &lt;!--因为有了@Required，所以这里必须提供，否则报错--&gt; &lt;property name="message" ref="message"/&gt; &lt;/bean&gt; &lt;bean name="message" class="java.lang.String"&gt; &lt;constructor-arg index="0" value="hello world"/&gt; &lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617181920212223package o1;import o1.bean.BeanA;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class A &#123; private ApplicationContext applicationContext; @Before public void setUp()&#123; applicationContext=new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); &#125; @Test public void run1()&#123; BeanA bean = applicationContext.getBean(BeanA.class); System.out.println(bean.getMessage()); &#125;&#125; @Autowired(required=true)自动注入，required=true的作用与@Required相同。 可用于构造器、字段、方法。 默认根据参数类型自动装配，但必须只能有一个候选项（required=false则可以允许0个候选项）。 @Value(value=”SpEL”)可用于字段、方法（@Autowired method）。 如： 123456@Value(value="#&#123;message&#125;")private String message;@Autowiredpublic void initMessage(@Value(value = "#&#123;message&#125;") String message) &#123; this.message = message;&#125; @Qualifier(value=”限定标识符”)可用于方法、字段、参数。 配合@Autowired使用，可用于多个候选项的情况。 实例如下： 12345678910111213141516171819202122232425262728293031package o1.bean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import javax.sql.DataSource;public class BeanB &#123; private DataSource dataSourceA; private DataSource dataSourceB; public DataSource getDataSourceA()&#123; return dataSourceA; &#125; @Autowired public void initDataSource(@Qualifier( "mysqlDataSource2" ) DataSource dataSource)&#123; // this.dataSourceA =dataSource; &#125; public DataSource getDataSourceB()&#123; return dataSourceB; &#125; @Autowired public void setDataSourceB(@Qualifier( "mysqlDataSource1" ) DataSource dataSourceB)&#123; this.dataSourceB = dataSourceB; &#125;&#125; 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--开启注解支持--&gt; &lt;context:annotation-config/&gt; &lt;context:property-placeholder location="db.properties"/&gt; &lt;bean class="o1.bean.BeanB"/&gt; &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;qualifier type="org.springframework.beans.factory.annotation.Qualifier" value="mysqlDataSource1"/&gt; &lt;!--type可以省略--&gt; &lt;property name="driverClassName" value="$&#123;driverClass&#125;"/&gt; &lt;property name="url" value="$&#123;jdbcUrl_1&#125;"/&gt; &lt;property name="username" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/bean&gt; &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;qualifier type="org.springframework.beans.factory.annotation.Qualifier" value="mysqlDataSource2"/&gt; &lt;property name="driverClassName" value="$&#123;driverClass&#125;"/&gt; &lt;property name="url" value="$&#123;jdbcUrl_2&#125;"/&gt; &lt;property name="username" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021222324package o1;import o1.bean.BeanB;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class B &#123; private ApplicationContext applicationContext; @Before public void setUp()&#123; applicationContext=new ClassPathXmlApplicationContext("classpath:applicationContextB.xml"); &#125; @Test public void run1()&#123; BeanB bean = applicationContext.getBean(BeanB.class); System.out.println(bean.getDataSourceA()); System.out.println(bean.getDataSourceB()); &#125;&#125; db.properties 12345driverClass=com.mysql.jdbc.DriverjdbcUrl_1=jdbc\:mysql\://localhost\:3306/testdb1?useUnicode=true&amp;amp;characterEncoding=UTF8jdbcUrl_2=jdbc\:mysql\://localhost\:3306/testdb2?useUnicode=true&amp;amp;characterEncoding=UTF8user=rootpassword=root 如果有几个常用的DataSource，那么可以自定义注解来使用，而不必每次都是@Qualifier(“xx”)。如下： 自定义@MySQL和@Oracle 1234567891011121314package o1.customize_qualifier;import org.springframework.beans.factory.annotation.Qualifier;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target( &#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE&#125; )@Retention( RetentionPolicy.RUNTIME )@Qualifierpublic @interface MySQL &#123;&#125; 1234567891011121314package o1.customize_qualifier;import org.springframework.beans.factory.annotation.Qualifier;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target( &#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE&#125; )@Retention( RetentionPolicy.RUNTIME )@Qualifierpublic @interface Oracle &#123;&#125; 使用qualifier来限定需要注入的bean： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--开启注解支持--&gt; &lt;context:annotation-config/&gt; &lt;bean class="o1.bean.BeanC"/&gt; &lt;bean id="dataSource1" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;qualifier type="o1.customize_qualifier.MySQL" value="mysqlDataSource"/&gt;&lt;!--value可以省略！--&gt; &lt;/bean&gt; &lt;bean id="dataSource2" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;qualifier type="o1.customize_qualifier.Oracle" value="oracleDataSource"/&gt; &lt;/bean&gt;&lt;/beans&gt; 要被注入的bean： 12345678910111213141516171819202122232425262728package o1.bean;import o1.customize_qualifier.MySQL;import o1.customize_qualifier.Oracle;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import javax.sql.DataSource;public class BeanC &#123; private DataSource dataSourceA; private DataSource dataSourceB; @Autowired public void initDataSource(@MySQL DataSource dataSourceA, @Oracle DataSource dataSourceB)&#123; this.dataSourceA = dataSourceA; this.dataSourceB = dataSourceB; &#125; public DataSource getDataSourceA()&#123; return dataSourceA; &#125; public DataSource getDataSourceB()&#123; return dataSourceB; &#125;&#125; 测试： 123456789101112131415161718192021222324252627282930package o1;import o1.bean.BeanB;import o1.bean.BeanC;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.sql.DataSource;public class C &#123; private ApplicationContext applicationContext; @Before public void setUp()&#123; applicationContext=new ClassPathXmlApplicationContext("classpath:applicationContextC.xml"); &#125; @Test public void run1()&#123; BeanC bean = applicationContext.getBean(BeanC.class); DataSource dataSource1 = applicationContext.getBean("dataSource1", DataSource.class); DataSource dataSource2 = applicationContext.getBean("dataSource2", DataSource.class); Assert.assertEquals(dataSource1, bean.getDataSourceA()); Assert.assertEquals(dataSource2, bean.getDataSourceB()); &#125;&#125; 使用context:annotation-config/标签来开启注解形式的依赖注入。 使用context:component-scan/标签来表示需要要自动注册Bean定义，而通过base-package属性指定扫描的类路径位置。 注意，context:component-scan/默认开启了annotation-config。 使用aop:aspectj-autoproxy/标签开启Spring对@AspectJ风格切面的支持。 @AspectJ风格的切面可以通过@Compenent注解标识其为Spring管理Bean，而@Aspect注解不能被Spring自动识别并注册为Bean，必须通过@Component注解来完成。 Spring的p标签看Spring in action的时候看过p标签，可惜这东西不用就忘。 p标签是为了简化setter的注入而引入的。 用法： 12p:属性 = &quot;&#123;值&#125;&quot;p:属性-ref = &quot;&#123;引用bean的id&#125;&quot; 示例Bean： 1234567891011121314151617181920212223242526272829303132333435363738394041package o3.bean;import java.util.Date;public class Person &#123; private String name; private int age; private Date date; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125; public Date getDate()&#123; return date; &#125; public void setDate(Date date)&#123; this.date = date; &#125; @Override public String toString()&#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + ", date=" + date + '&#125;'; &#125;&#125; XML配置： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:component-scan base-package="o3.bean"/&gt; &lt;bean id="person" class="o3.bean.Person"&gt; &lt;property name="name" value="Kute"/&gt; &lt;property name="age" value="22"/&gt; &lt;property name="date" ref="date"/&gt; &lt;/bean&gt; &lt;bean id="date" class="java.util.Date" autowire="constructor"/&gt; &lt;bean id="person2" class="o3.bean.Person" p:name="Bill" p:age="23" p:date-ref="date" /&gt;&lt;/beans&gt; 测试代码： 123456789101112131415161718192021222324package o3;import o3.bean.Person;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class P &#123; private ApplicationContext ac; @Before public void setUp()&#123; ac=new ClassPathXmlApplicationContext("classpath:applicationContextPerson.xml"); &#125; @Test public void run1()&#123; Person person = ac.getBean("person", Person.class); Person person2 = ac.getBean("person2", Person.class); System.out.println(person); System.out.println(person2); &#125;&#125; 测试结果： 12Person&#123;name=&apos;Kute&apos;, age=22, date=Fri May 27 10:13:27 CST 2016&#125;Person&#123;name=&apos;Bill&apos;, age=23, date=Fri May 27 10:13:27 CST 2016&#125; Spring RestTemplate 小结关于RestTemplate 首先，你可以把它理解为一个发起请求并接收响应的工具类（功能类似浏览器）。 其次，它其实是一个壳，具体还是通过调用别的接口来实现（如jdk自带的连接，或者HttpClient之类的，需要设置）。 官方介绍Spring’s central class for synchronous client-side HTTP access.It simplifies communication with HTTP servers, and enforces RESTful principles.It handles HTTP connections, leaving application code to provide URLs (with possible template variables) and extract results. Note: by default the RestTemplate relies on standard JDK facilities to establish HTTP connections.You can switch to use a different HTTP library such as Apache HttpComponents, Netty, and OkHttpthrough the HttpAccessor.setRequestFactory(org.springframework.http.client.ClientHttpRequestFactory) property. 使用这个其实没什么说的，不外乎创建template，设置底层连接，然后增删改查。 请参考Spring REST和 RestTemplate实践 。 唯一需要注意的就是默认的jdk连接是不支持delete带请求体–解决办法见下面链接。 其他暂时不清楚使用RestTemplate和直接使用HttpClient有什么区别，感觉HttpClient足够用了–囧。 –突然想到的，RestTemplate可以配合MessageConverter等使用！！！也就是配合SpringMVC使用，而HttpClient则需要手动转换！ 杂： 1httpHeaders.add(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en;q=0.6&quot;); q是权重系数，范围 0 =&lt; q &lt;= 1，q 值越大，请求越倾向于获得其“;”之前的类型表示的内容，若没有指定 q 值，则默认为1，若被赋值为0，则用于提醒服务器哪些是浏览器不接受的内容类型。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目运维中常用SQL]]></title>
    <url>%2Fblog%2F54584.html</url>
    <content type="text"><![CDATA[结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 删除表空间12drop tablespace pt6 INCLUDING CONTENTS;drop tablespace mpm INCLUDING CONTENTS; drop tablespace sf INCLUDING CONTENTS;drop tablespace bt INCLUDING CONTENTS; 删除用户1234drop user pt6 CASCADE;drop user mpm CASCADE;drop user sf CASCADE;drop user bt CASCADE; 创建表空间当首次导入时创建表空间 （运行脚本时会提示输入 &amp;1 输入数据文件希望存放的物理地址 例如 D:\OracleData） 1create tablespace pt6 datafile '&amp;1\pt6.dbf'size 100m autoextend on next 10m;create tablespace mpm datafile '&amp;1\mpm.dbf'size 100m autoextend on next 10m; 创建用户1create user pt6 identified by cape default tablespace pt6;create user mpm identified by cape default tablespace mpm; 授权123grant dba to pt6;grant dba to mpm;grant all on dual to pt6 with grant option;grant all on dual to mpm with grant option; 数据库的备份：方法一：数据泵方式 导出： 1expdp pt6/cape@localhost:1521/bt dumpfile=ORCL_2014-08-18.EXPDP logfile=ORCL_2014-08-18.log schemas=(pt6,mpm,sf,bt) //如果是用数据泵倒入，把文件必须放在例：D:\app\rongda\admin\bt\dpdump(oracle的安装目录) 导入： 1impdp pt6/cape@localhost:1521/bt dumpfile=NEWBT_2015-03-16.EXPDP logfile =NEWBT_2015-03-16.log schemas=(pt6,mpm,sf,bt) 方法二： 导出： 1exp pt6/cape@localhost:1521/TEST file=c:\test_2014-04-02.dmp log=c:\test_2014-04-02.log owner=(pt6,mpm) 导入: 1imp pt6/cape@localhost:1521/orcl file=D:\app\rongda\oradata\orcl\20140704sf.dmp full=y log=c:\test_2014-04-02.log 1imp pt6/cape@localhost:1521/orcl file=D:\app\rongda\oradata\orcl\20140704sf.dmp fromuser=pt6 touser=pt6 fromuser=mpm touser=mpm log=c:\test_2014-04-02.log 说明：如果高版本的数据库导向低版本的数据库脚步，那么在导出的时候加上低版本号 version=11.1.0.7.0 版本号即可。导入不需要加入。10.1.0.2.0 例如： 1expdp pt6/cape@localhost:1521/TEST dumpfile=TEST_2014-04-02.EXPDP logfile=EXP_TEST_2014-04-02.log schemas=(pt6,mpm) version=11.1.0.7.0 1expdp pt6/cape@localhost:1521/TEST dumpfile=TEST_2014-04-02.EXPDP logfile=EXP_TEST_2014-04-02.log schemas=(pt6,mpm) version=10.1.0.2.0 1impdp pt6/cape@localhost:1521/TEST dumpfile=TEST_2014-04-02.EXPDP logfile=IMP_TEST_2014-04-02.log schemas=(pt6,mpm) 同义词创建：1create or replace synonym pt6.application_anplan for bt.application_anplan 表的恢复与表数据恢复对误删的表，只要没有使用 purge 永久删除选项，那么基本上是能从 flashback table 区恢复回来的。数据表和其中的数据都是可以恢复回来的，记得 flashback table 是从 Oralce 10g 提供的，一般步骤有： 从 flashback table 里查询被删除的数据表 1select*from recyclebin orderby droptime desc 执行表的恢复 1flashback table'需要恢复的表名'to before drop 删除表中数据有三种方法： delete（删除一条记录） drop或truncate删除表格中数据 delete误删除的解决方法原理：利用oracle提供的闪回方法: 如果在删除数据后还没做大量的操作（只要保证被删除数据的块没被覆写），就可以利用闪回方式直接找回删除的数据 具体步骤为： 确定删除数据的时间（在删除数据之前的时间就行，不过最好是删除数据的时间点) 用以下语句找出删除的数据： 1select * from 表名 as of timestamp to_timestamp('删除时间点','yyyy-mm-dd hh24:mi:ss'); 把删除的数据重新插入原表： 1insert into 表名 (select * from 表名 as of timestamp to_timestamp('删除时间点','yyyy-mm-dd hh24:mi:ss')); 注意要保证主键不重复。如果表结构没有发生改变，还可以直接使用闪回整个表的方式来恢复数据具体步骤为：表闪回要求用户必须要有flash any table权限 1alter table 表名 enable row movement ·flashback table 表名 to timestamp to_timestamp(删除时间点','yyyy-mm-dd hh24:mi:ss') drop误删除的解决方法原理： 由于oracle在删除表时，没有直接清空表所占的块,oracle把这些已删除的表的信息放到了一个虚拟容器“回收站”中，而只是对该表的数据块做了可以被覆写的标志，所以在块未被重新使用前还可以恢复 具体步骤：查询这个“回收站”或者查询user_table视图来查找已被删除的表: 1select table_name,dropped from user_tables · select object_name,original_name,type,droptime from user_recyclebin 在以上信息中，表名都是被重命名过的，字段table_name或者object_name就是删除后在回收站中的存放表名*如果还能记住表名，则可以用下面语句直接恢复： 1flashback table 原表名 to before drop 如果记不住了，也可以直接使用回收站的表名进行恢复，然后再重命名，参照以下语句： 1flashback table "回收站中的表名(如：Bin$DSbdfd4rdfdfdfegdfsf==$0)" to before drop rename to 新表名 oracle的闪回功能除了以上基本功能外，还可以闪回整个数据库：使用数据库闪回功能，可以使数据库回到过去某一状态, 语法如下： 1alter database flashback onSQL&gt;flashback database to scn SCNNO;SQL&gt;flashback database to timestamp to_timestamp('2007-2-12 12:00:00','yyyy-mm-dd hh24:mi:ss'); 总结：oracle提供以上机制保证了安全操作，但同时也代来了另外一个问题，就是空间占用，由于以上机制的运行，使用drop一个表或者delete数据后，空间不会自动回收，对于一些确定不使用的表，删除时要同时回收空间，可以有以下2种方式： 采用truncate方式进行截断。（但不能进行数据回恢复了） 在drop时加上purge选项：drop table 表名 purge 该选项还有以下用途： 通过删除recyclebin区域来永久性删除表 ,原始删除表 1drop table emp cascade constraints purge table emp; 删除当前用户的回收站: purge recyclebin; 删除全体用户在回收站的数据: purge dba_recyclebin]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN的使用]]></title>
    <url>%2Fblog%2F57755.html</url>
    <content type="text"><![CDATA[SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。 为什么要使用配置管理及时了解团队中其他成员的进度。 轻松比较不同版本间的细微差别； 记录每个文件成长的每步细节，利于成果的复用(reuse); 资料共享，避免以往靠邮件发送文件造成的版本混乱； 人人为我，我为人人。所有成员维护的实际是同一个版本库，无需专人维护所有文件的最新版本； 协同工作，大大提高团队工作效率，无论团队成员分布在天涯还是海角； Subversion/TortoiseSVN的版本控制系统Subversion：是一个开源的版本控制系统，拥有CVS的大部分特征，并在CVS的基础上有更强的扩展，用来代替 CVS 系统。 TortoiseSVN：SVN的客户端工具，和资源管理器完美集成，基于TortoiseCVS的代码开发，使用上与TortioseCVS极其相似; 配置库（ Repository ）SVN的核心是配置库，储存所有的数据，配置库按照文件树形式储存数据－包括文件和目录，任意数量的客户端可以连接到配置库，读写这些文件。通过写数据，别人可以看到这些信息；通过读数据，可以看到别人的修改。 最特别的是 Subversion 会记录配置库中的每一次更改，不仅针对文件也包括目录本身，包括增加、删除和重新组织文件和目录。 工作副本（WorkSpace）与位于中央配置库相对应的是每个人的工作空间，它是每个程序员工作的地方，程序员从配置库拿到源代码，放在本地作为工作副本，在工作副本上进行查看、修改、编译、运行、测试等操作，并把新版本的代码从这里提交回配置库库中。 SVN工作模式复制-修改-合并方案(Subversion默认的模式)在这种模型里，每一个客户读取项目配置库建立一个私有工作副本——版本库中文件和目录的本地映射。用户并行工作，修改各自的工作副本，最终，各个私有的复制合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。 锁定-修改-解锁方案在这样的模型里，在一个时间段里配置库的一个文件只允许被一个人修改。 此模式不适合软件开发这种工作。 SVN安装 安装完毕后，在“资源管理器”里点击右键，会有如下菜单出现： 目录结构 SVN使用流程 SVN使用图标说明 SVN CheckOut检出 SVN CheckOut检出注意事项 检出深度： 全递归(默认选择) 检出完整的目录树，包含所有的文件或子目录。 直接节点，包含目录 检出目录，包含其中的文件或子目录，但是不递归展开子目录。 仅文件子节点 检出指定目录，包含所有文件，但是不检出任何子目录。 仅此项。 只检出目录。不包含其中的文件或子目录。 省略外部引用：如果项目含有外部项目的引用，而这些引用我们不希望同时检出，请选中忽略外部项目复选框。如果选中了这个复选框，更新的时候要使用命令”更新至版本Update to Revision…” SVN Update更新作用：更新工作副本使其成为版本库中的最新版本 SVN将显示出更新的文件和更新的次数 SVN Commit提交对工作副本进行编辑后提交到SVN 在右键菜单中点击SVN Commit 提交前写好信息，点击确定 SVN 权限控制当进行提交文件操作的时候您将看到权限提示信息 输入您的用户名和密码 保存权限设置（见红圈） ，可以避免将来重复输入用户名和密码 SVN 如何删除认证数据 步骤：点击右键 —— 选择设置 —— 以保存数据 —— 清除认证数据 SVN Show log显示日志 SVN 日志信息填写规则好的日志信息和糟糕的日志信息 日志信息主要记录的是每次的修改内容。建议把一些重要数据、关键操作写到日志信息中。 注：修改人和提交时间由软件自动记录，无需人工写入日志信息 SVN 如何得到历史版本工作副本右键 - 显示日志 - 选择所需的版本号 - 保存版本至 SVN Revert(还原)作用：撤销本地所有未提交的修改 注意：还没有执行Commit操作之前执行此命令才可以，否则无效 SVN Add添加选中文件/文件夹（在新文件/文件夹所在父文件夹点击右键）， 在菜单中选择“添加Add”命令。不需要受SVN控制的文件请取消打钩。 SVN Add to Ignore List （忽略文件） 添加忽略文件 右键一个单独的未进入版本控制文件TortoiseSVN (加入忽略列表)Add to Ignore List，会出现一个子菜单允许你仅选择该文件，或者所有具有相同后缀的文件。 删除忽略文件： 如果你想从忽略列表中移除一个或多个条目，右击这些条目，选择TortoiseSVN → 从忽略列表删除。 已进入版本控制的文件或目录不能够忽略 SVN 版本分支这个版本历史分析图能够显示分支/标签从什么地方开始创建，以及什么时候删除。 版本分支图将显示以下内容: 增加文件/文件夹 已删除文件/文件夹 分支最新版本 一般的文件/文件夹 SVN 如何创建分支两种方式： 在版本库浏览器中创建分支 在工作副本创建分支 创建分支成功 SVN Switch切换 文件创建分支后，可通过Switch选择在主干工作或者在分支工作; 注意: 切换操作起来就象更新，因为它没有丢弃我们在本地做的修改。 在工作副本里，当我们进行切换的时候，任何没有提交过的修改都会被混合。 解决方法： 在切换前提交修改; 把工作副本恢复到一个已经提交过的版本(比如最新版本)。 SVN 合并假设我们在分支上进行修改：添加一条输出语句： System.out.println(“测试是否能将分支的修改合并到主干中!”) ;提交到配置库中，现在执行将分支合并到主干的操作 SVN 分支合并到主干右键- 主干的文件- 选择合并 SVN 合并时出现冲突 SVN 编辑冲突 SVN 冲突已解决 SVN 合并成功 SVN 什么是冲突团队协同工作时，当多位团队成员同时修改同一个文件，造成本地文件与SVN系统中的文件版本不一致，而导致文件无法提交的情况 SVN 冲突产生原因当团队协同工作的时候，多位团队成员同时操作一个文件。团队成员A操作完成后，将该文件提交到SVN上。此时，其他团队成员的本地文件与SVN上的文件版本不一致。当团队成员B操作完成并对文件进行提交操作时，就会产生冲突 SVN 冲突提示页面提交时产出冲突 SVN 冲突解决方案遇到冲突时，需要update该文件。我们将看到三个带问号的文件 filename.mine filename.rOLDREV filename.rNEWREV 面对文件冲突，我们可以选择以下两种方式解决冲突 使用工具解决冲突 用revert放弃所做的修改 SVN 使用工具解决冲突使用自带工具，如图所示 对比两个版本的文件，解决冲突 工具中会列出两个版本冲突的部分，并让我们选择使用哪个版本的内容 SVN 用revert放弃所做的修改选择SVN还原（revert） 放弃自己所做的修改 SVN 解决冲突之后通过上面所说的方法，解决冲突后要选择已解决的（resolved） 解决后，带问号的三个文件将自动删除 最后选择commit提交到SVN SVN 关于冲突的建议修改文件之前，先进行一次update操作 修改完成后，及时commit，不要在本地停留过长时间 在多位团队成员协作时，尽量修改自己撰写的部分，尽量不要修改不属于自己撰写的部分 出现冲突很正常，可以通过前面的方法解决，不要相互覆盖 SVN 其他SVN的功能 Export（导出） 导出你需要的文件，导出后不在受SVN控制；而checkout检出的文件仍受SVN控制； Import（导入） 将需要的文件导入到版本库中； Relocated（重新定位） 当服务器上的版本库目录已经改变，我们可以把工作复本重新定位； CleanUp（清理） 递归的清理工作副本，删除锁定和保留的未完成操作，如果你得到工作副本已经锁定的错误，运行这个命令删除无用的锁定，并将工作副本恢复到可用的状态； SVN Subclipse的安装步骤（Eclipse集成） 帮助 &gt; 软件更新 &gt;查找并安装 选择“要安装的新功能部件” 选项并点击Next。 点击“新站点”并且创建一远程站点， 名字:Subclipse URL:http://subclipse.tigris.org/update_1.2.x 在结果安装窗口中，把”Subeclipse in the Features” 选择到安装列表中，并且通过向导来开始安装插件。 完成这些之后，重新启动Eclipse。 SVN 在Eclipse下使用的图标 SVN Eclipse下使用的主要功能将版本库导入到SVN资源库 将新建项目导入到版本库 Eclipse中小组的使用]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荒原，我的国]]></title>
    <url>%2Fblog%2F12381.html</url>
    <content type="text"><![CDATA[自由在追寻自由的路上，像风一样掠过无数的山川，以及开满鲜花的旷野。山鹰在身后的气流中盘旋，只有它明白风的走向，又如何消失在无垠的大地。狼群在两侧高地似幽灵如影相随，它们希冀着远方有片肆意的江湖，来断一世恩仇。脚下野草按捺不住狂野的心，挣脱生于斯、死于斯的方寸之地，随风而往，在别处轮回生灭。一只迷途的蜜蜂轻落在湿润的额头，喃喃细语，无人知晓其意。只见前方瑰丽云霞，点燃了正欲黯淡下去的天宇。在冰与火的冷暖间，在明与暗相交的时光里，我一次次眺望，那云之落处的远方，是否有位美丽姑娘正在煎煮着热茶，准备好了我急于得知的一切答案。而有些答案，早已写在了故事的开头。 第一次踏入羌塘旷野，只是意识反复挣扎后的必然结果。 那是二〇〇九年，清晰记得狮泉河小镇的那个夜晚。三个朋友砸开了我的房门，惊恐之色令人诧异。他们魔怔般扯拉着我，劝说不要进入羌塘……那焦急、哀求、惊恐，伴着急泣的混乱场景让我心悸，犹如末世巨浪逼近头顶。原来他们在自己的慈善总结会议中，有一人开小差，恍见一副场景，大意是我进入羌塘荒原再也没有出来，直白的意思就是死在荒原里了。随后，他将这种不详预感分享众人。一粒微尘落入水中却惊起骇浪涟漪，他们居然严肃地认定为神启？先知警告？必定发生的凶兆？总之，他们在半夜闯进了我的小旅馆房间，演绎出了这么一幕劝生大剧。 我不想与他们的预感交锋，这个预感本身是否有意义，都不应热烈地去回应。我严厉地请他们离开房间，简单而粗暴地驱逐着他们的善心。又一番拉扯、苦劝后，我心生愤怒，劝留的起因对我来说只是个笑话，却被他们演绎成生离死别的闹剧。 我的愤怒最终平息了这场闹剧，或者说我进入羌塘的决绝让他们死心。但不得不承认，他们用夸张表情说出那个预感后，我着实起了一身鸡皮疙瘩，这分明是一个鬼故事嘛。并且，这个故事强有力的进入了我的心房，久踞盘旋。你可以吓唬我荒原里的气候有多么极端恶劣，豺狼虎豹又如何残忍，但是不能用一个鬼故事去诛我原本虚弱不堪的心。我的愤怒其实来源于虚弱。 朋友们走后，我无法抑制地陷入深深地恐慌中，虚弱内心最后一道庇护的城墙就这般无情地被摧毁了。没有人是绝对唯物的，这个世界有太多的未知。我理性分析着朋友们的言行，试图以摧毁他们的方式来重塑自己的内心。是的，他们都有强烈的宗教皈依感，在神山冈仁波齐山脚下的塔钦村时，他们夜夜入睡前均要抄讼一百遍《心经》，平日谈佛论道也是玄奥。虽然，日日礼佛念经，但在我眼中他们却不是真正的宗教皈依者，而是盲目的神秘主义追随者。正是这个世界没人能说的明白，而产生了许多能说明白的理论。正是每个人内心都虚弱的沉浮着，才有了那不顾一切的执信。我们塑造的神，只是我们极端存在的另一种形式。 我们的内心越虚弱与无助，我们塑造与信奉的神就越强大。力量的两个极端最终融为一体，达到完美的平衡之境。那个开会走神的朋友，当脑海里浮现我凶兆的景象时，或许只是他对羌塘荒原无力征服感的映射。这种映射以谎言的形式保护了虚弱的自我，巧妙地修复了人与神瞬间的失衡。此刻，神主宰了他的一切，可为与不可为都是一种命理注定。 我成功以否定别人的方式重塑了自己的内心，让他维系在一个脆弱却不至崩塌的状态。那个令人毛骨悚然的鬼故事，还是如幽灵般不时掠过心田，发出两声渗人的冷笑。 彼时，我对羌塘的认识只是反复臆想的摸样，我从未置身于如此广袤的一片旷野。犹如初恋，对于情人的幻想是甜美爱情的全部，当现实取代了幻想，爱情也就不复存在了。因而，进入羌塘的前夕，并没有太多体能、风险、未知与恐惧的困扰，幻想衍生出的淡淡欢愉始终萦绕着美丽的旅程。由于毫无骑行经验，大腿严重拉伤，瘸子可以进入羌塘吗？拉萨至阿里漫长的拉练骑行中，近三分之一路程是靠装可怜搭车前行的，意志力就像抽了大烟疲软无力。我没法和汽车同在一条路上，尤其当年还是土路的新藏线，当被包裹在汽车飞驰后的灰尘里时，骑行的心便顷刻间被瓦解了。所以，我深佩那些骑车进藏不搭车的人们，在诱惑中咬牙前行，无视身边飞驰而过的汽车，放弃高效的捷径抵达终点，埋首在自己的执着里，专注着心灵的移动。 为什么要去羌塘？我无法在我深爱的时候去缕析情人的本质，却对旧欢有着无比深刻的认识。〇七与〇八年交接的腊月，南方遭逢百年大雪，我带着一条充气船来到贵州那个魂牵梦萦的洞穴前。这是洞穴里的峡谷，在深暗的地下奔腾着湍急的水流，只有法国探洞联盟多年前成功漂流过。 显然，这不是一个适合漂流的天气，且我被当地政府盯上，只能在寒夜里悄然下水。我的两个助手是当地的苗族人，以往的经历已缔结了生死之谊。刚入洞口，我就被冲下了水，和法国探洞联盟初次漂流经历如同一辙。他们也因此放弃，直至三年后才完成此洞的漂流。我幸运的很快爬上一片巨石堆，浑身湿漉漉的，风从洞外呼啸的吹进来，越发浸入骨髓的湿冷。他俩从石缝里收集着被水流冲下来已干枯的木棍，在两块大石间生起火堆，然后把我像腊肉般架在上面烘烤。 许久缓过来，然后是长久的沉默。 这是一场儿戏之旅，偷偷摸摸，没有后援，山寨装备。回程逆水行舟，我们解决动力的办法居然是在竹竿上栓上铁钩，计划着勾拉洞壁回逆。这是一趟即便去得了也难回来的旅程。 我提出放弃，我难以承受捎带两人命运的旅程。正是我们在一起已经历了很多，让我对风险有了更为直面的清晰认识。他们最终闷声说道，继续。声音缺乏底气。他们远比我恐惧，但深知我，即便此刻糟糕的状态，也不足以动摇内心的执着。对于他们的选择，我沉默，唯有深深的无言的感动。他们为了成全我的梦想忽视了自我对死亡的恐惧。 漂流的艰险已成淡薄往事，唯有洞穴深处那片寂静，无法在光阴河流里轻易的散去。那是洞穴深处，死水之潭，弯曲促狭，世界仿佛停止了一切运作。蓦然，听见尖利的呼啸声，查明声源是气嘴漏气。船一直慢漏气，苦于一直找不到位置，此刻，他以这种嘶吼的方式倒数着自己的生命。接着，听见急促的擂鼓声，一支鼓，两支鼓，三支鼓。原来是三人的心跳声，此起彼伏的跳动着。再接着，听见水流奔腾的声音，可周遭的深潭死水一片，水流声从何而来？水流声从我们的身体深处而来，那是奔腾在血管里的鲜红血液。 我从未置身于如此安静的地方，肉身是世界里唯一的声源。那种感觉如同置身在躯体之外，看着那载了半生的皮囊不过是一台冷血机器，毫无感情与目的，他的存在就是维系自己的运转。时而，又会觉得自己被一台机器紧紧束缚着，你无法逃脱，只能与之共存亡。我前所未有的认识到承载自己的肉体是如此脆弱，与自己又是如此紧密相连、息息相关。世界就要消散，我极力挣脱，却又无能为力，这种矛盾如同用手捂住自己的鼻嘴窒息而亡。 这段特殊地形造就了至极安静，我不知和著名的奥菲尔德消音室相比哪个更安静？但我知道，没有人能单独待在奥菲尔德消音室里超过四十五分钟，否则，将会发疯。人无法在绝对安静的地方生存。在奥菲尔德消音室里，你无法忍受了可随时抽离。然而在这幽暗的地下深处，却无处可逃。 翌日中午，我们回逆到洞口，成功结束了漂流。当我站在洞外，被刺眼阳光包裹的瞬间，我仿佛看到明晃晃的眼前是一片广袤无边的旷野。 从那以后，我再也没有探过洞穴，甚至数年来再无踏足充满地穴的西南诸省，那是一片我不愿再回去的疆域。我希冀着被一块足够大的旷野承载，如风自由，往来无羁。我已被紧紧束缚在自己的躯体里，不愿自己的躯体再被无情的束缚。旷野，那自由的旷野，像天一样高远，像海一样辽阔，任由我盲目的游荡，无论朝哪个方向，都是没有边界的远方。 果真身临这片旷野时，他没有给我与现实接触必然的失落感，反而是更爱，深爱。羌塘，是我必定要经历的地方，彼此宿命中都残留着前世的印痕。进入荒原的第一次露营，是完美的夕阳，金色光芒抚慰着苍凉荒原，世间一切杂念与恶欲皆被抹去。白日的辛劳犹如迅速退去的海浪，前一秒是久远的过去，后一刻是无限的未来，时空凝滞在一片跳跃的金色中，温暖触手可及。 我长久凝视着自己斜长的影子，看着他一点点延伸，然后冷淡下去。怀念即刻心生，怀念那温暖的光，魔法般将烈日下枯燥乏味的荒原变成金色殿堂，怀念那由金到绛红直至冷却为幽蓝的色彩，怀念微风披着光羽在大地上自由的奔跑，怀念那通透的远方不再是残忍的诱惑，怀念一朵云被点燃及熄灭的时光。怀念应该是对一件久远的事物在记忆上的复苏。然而，在羌塘的第一夜，我就无可救药地迷恋上了那夕阳下欢颜的旷野。在透彻温暖的光中，随着镀金的野草欢快的跳跃，荒原上是一望无际的火焰。燃烧吧，我们一同燃烧，尽情把握短暂的欢愉，直至成为静谧且幽蓝的灰烬，然后一同在冷夜里怀念彼此曾经的辉煌，期待下一次重生的曙光。 生命短至一日，轮回却无止境，每一天即是消亡也是重生。这便是我初入羌塘，与之暗合的节奏。 这是一条穿越羌塘西部的路线，完全由鲜亮的梦规划。我用笔在地图上把心仪的山谷、河流、雪山、湖泊连成一条线，这便是我的旅程了。随着旅行的深入，时间的流逝，这片荒原总是适时地在我激情消退之际，变出新的戏法。陷在沙地里万分沮丧之时，他派来一只萌到翻的小藏羚羊，我有什么理由拒绝此番鼓励？当我被冰雹砸得抱头卷缩后，一道彩虹悬挂在触手可及的身旁，我有什么理由拒绝欣赏此番盛景？陡峭的山梁之后是万顷碧蓝的波涛，我有什么理由拒绝登高？粘稠陷人的湿地里，同时也开满鲜艳的野花，在这荒凉的无人高原，我有什么理由不心心相惜、心生爱慕？ 当我被一条河流迂回阻截，数十次淌着刺骨的水流周旋两岸后，我看到了一群群数目庞大的藏羚羊群，在河谷中欢快的列队奔跑着。那低闷密集的蹄声让我恍惚置身于《动物世界》里的非洲草原。又时而穿越到上世纪西方探险家对羌塘那如潮水般野生动物的描述中。虽然，山野中漂泊多年，但如此恣意奔放的盛景从未有过。藏羚羊们并不十分惧我，但绝不会过度热情的亲近我。我坐在一块干燥的石头上，凝视着他们矫健的身影，长久之后，忽然意识到他们从哪里来？这贫瘠、酷寒的高原，野花只是点缀，水草需要费力的寻觅，他们何以为生，以此为家？ 这是一片奇幻的旷野，野生动物不真实的存在着，从你身边缓缓走过，在远处山头凝望你，黑夜里徘徊在帐篷周围……他们又以如此真切的方式证明自己的存在，和对这片旷野所有权的宣示。 在这条充满狂风、冰雹、湿地遍布的河谷里，我踽踽前行了五天。每天都有数量庞大的藏羚羊群擦身而过。后来，我知道了，这条山谷是羌塘西部藏羚羊一条非常重要的迁徙通道。早年，夏勒博士想探寻此道无功而返。若干年后，两个美国旅行家向北寻找这条迁徙通道，收获甚微。而在九月份，向外界关上大门独自狂欢的泥泞羌塘，却被我无意的闯进了这条河谷。那时，以我对羌塘浅薄的了解，并没有闯进土豪晚宴的喜悦，而只是，对这片荒原，对身处大自然中的我，都充满了难以言喻的敬意。 随后，穿过一条羌塘西部几大山脉交错的边缘山系后，我进入一个宽阔的湖盆地带。这里又完全是另一幅景象，雪山，湖泊，草地，自由的生灵，他们在夕阳下为我搭建了一个完美的梦幻场景。 我恍惚，那年寒冷的冬天，我从地下深处走出来看见阳光下明晃晃摇曳的旷野，就是此时脚下的这片大地。我的躯体不再被束缚，而我也难觉察到我被躯体束缚着，一切是那么的淡然，随意江湖。 我醉了，醉在无边的旷野里。 我些许颤抖，那样的美，纯净空灵。 我心生妄念，以此为家，安度余生。 人群的拥挤，不过是个体随波逐流相互碰撞的表象。每个人都试图逃离着，在璀璨夜里独自盘算着自己的远方。远方是什么地方？没有人能清晰告知我们，但他一定有别当下被裹挟的疲惫生活。 多年前的我，希望远方是一个像乌金贝隆一样的地方。我并不在意牛奶河、糌粑山，我憧憬那是一个没有争议与烦恼的世界，那里的人生活在和谐的精神秩序里，相互爱慕，恬静淡泊。 多年前的我，很年轻，因而尚有逃离的热情与力量。我在西南偏远的山区，游历在闭塞的村寨之间。那里的人如同那里的山水一样清澈，我只要坐在吊脚楼下发一会呆，就会有人把你领回家给你可口的食物和温暖的夜。我陶醉在质朴的人心里，万物以安静平和轨迹悄然运转着，每个人的脸上都绽放着幸福的花朵。城市的嚣泄与设防如同西山落日，且坠入黑暗深渊后再无轮回。 是的，我一直憧憬平和的岁月与人。人群不再拥挤，人们的眼神不再空洞茫然，相互的碰撞应是温暖的传递。但已知的几千年来，我们都试图相互远离，那是避免彼此伤害唯一的方式。是的，年轻的我充满了违背我们特质的憧憬，希冀一个与世无争的山谷只能是欧洲人厌倦战乱臆想出的香格里拉。当我在一个寨子待上三日后，能用肢体语言和拙劣的第六感与人交流后，发现他们也在意邻家的猪偷吃了我家的菜，谁家的姑娘轻薄的与少年郎微笑，慈祥的老奶奶也有愁眉解不开的心结，喝酒的热烈汉子麻痹着一颗火辣的心……更不消说，我以为的那些外面世界的垃圾其实是他们一直渴望尝试的。 当我在一个美丽寨子待上三个月后，自己便成了打破和谐秩序的最大因由。人们像商量好了一样琢磨出对你的三个判断，前提你只是一个没有任何背景符号的旅人。一，失恋的。从情感上判断一个人，佐证了八卦是人们不可或缺的生活要素。二，淘宝的。这十分符合一个男人对世俗的终极追求，即女人和财富。当上述两个判断都不成立时，你就只好委屈的成为第三个可能，逃犯！ 世俗的逻辑竟如此一致，对于一个男人而言，你不为钱和女人，就一定是为了钱和女人犯了事。 我坐上竹筏顺流而下，离开山峦深围的美丽村寨，有人在岸边哭泣，有人在行囊里塞了一双绣花鞋垫，更多人目光空洞不知所然。我离开了，并非我是一个逃犯，而是乌金贝隆又一次必定的破碎了。那温和的表面涌动着深不可测的鬼魅，随时成为一幅令人厌恶的面孔，我们在厌弃他人时也被他人厌弃，我们就这么悲哀与孤独的活着。无论走到哪里，我们都在人群里相互拥挤。 最终，我明白，那些我有意、无意逃避的事物，并不存在于理想国之乌金贝隆里。因为，乌金贝隆从不存在，他只是我对这个世界以及自我最终的幻想。眼前景象，在某个瞬间，让我游离到一个曾被我否定的叫乌金贝隆的圣境。一只狼的出现适时打破这一幻幕，让我走出稚嫩少年才有的心境。 荒原自有他的游戏规则，以此为家的生灵一样拥有无常生灭。每一个生灵生存的基础都是建立在其他生灵毁灭之上。野草吸食着大地的养分，牛羊咀嚼着鲜美的野草，豺狼在一旁窥视着自己丰盛的晚餐，最终，凶狠的豺狼也会被病魔或时光之剑杀死，腐烂成富饶的大地。生命在循环中创造无数悲剧，这才是荒原最真实本质的一面。生命最终都会消亡，生亦灭，虽已注定，但存在于每个生灵体内的自私与智慧，让其不甘俯首命运而勇于抗争。生亦灭，我们无从选择，但之间的长度却有可能被有限的延长。 第一次，面对狼，就这么猝不及防的来了。 之前，我的意识里，狼更多是一个传说中的符号。我曾赋予这个符号为自由。多年前，曾写过一本小说，大意是随着人类对自然的掠夺，原本狼自由栖息的草原日渐萎缩。一只被猎人捕获的小狼崽，被包装成宠物贩卖到繁华的城市。狼变成了狼狗，开始了他从未想过的只需依靠献媚就能获得丰富物质的宠物生活。对于放弃自由的代价，他似乎默认了，并从中尝到了甜头。随着时间的推移，草原在他内心深处慢慢复苏，他最终鼓起勇气抛弃繁华，一路艰辛回到那已不复存在的草原。 那时年轻的我，写完这本寓言式的小说后不久，便选择了一直在路上的生活，寻找着我心中的那片草原。而今，我真的遇见了狼，在一片真正的广袤的草原之上。我略有恐惧，那是本能必然的应激。我的理性告诉我，其实你并不了解狼，一切关于狼的知识只是那些文人意淫的。或是人类对自我缺陷的转移，似乎一个人欺负了姑娘只是狼附体而已。同时，对狼的负面幻想也无限放大，他是否会一跃扑向我咬断我的喉咙？或者像猫捉老鼠一样，尾随我几天之后再无玩耍兴致，便一口吃掉精疲力尽的我？不管哪种结局，他都不会为我捕获一只兔子，烤熟后以讨好我那忍够了辣椒和糌粑的肠胃。事实上，他对于我的不了解和我对他的不了解一样多。 我们就这样对视着，风中无语，亦无过激的提放，彼此都充满了好奇。然后，他走了。然后，我继续往前。此次短暂的相遇，我并不能确定有多么的了解狼了，但内心不再有盲目无知的恐惧。 我希冀着，能再次遇见这只狼，我们熟识为友了，一同坐在草地上聊天，彼此讲述初遇的感念。我希冀着，有一天，我和草原上每一个生灵都能做到：在路上，你看着我，我也看着你，一个眼神就能明了，彼此的困顿与幸福。 当我决定游历羌塘前，已然思量如何避免介入荒原上的厮杀。我有我的宿命，但绝对不是在荒原弱肉强食的链条中轮回。一位试图穿越羌塘的人曾短信说，做了一张弩，箭头涂有毒汁……还有一位则认真欲讨论猎捕鼠兔作为有效补给。我屏蔽了此些人，异常反感此般论调。人类总是因为恐惧而先发夺人，或者将自己塑造成食物链的顶端，其实，我们什么也主宰不了。 对于荒原，我们只是过客，而他们生于斯、死于斯。 作为客人，我们应是卑微的姿态和感恩的情怀。遇到友善主人，我们报以诚挚的微笑，遇到刁蛮主人，我们时刻隐忍与耐心沟通。带着刀和充满戾气的心，征服不了那早已不再属于我们的荒原。 我的一把随身小刀只是切大蒜和酥油，我的鞭炮从未试图点燃，我的防狼喷雾剂时常忘记放在了哪个口袋里。在末进入荒原前，我并不确定带着一颗过客的心是否能畅通无阻，是否过度理想化了我与荒原的关系？ 之前一路，我都认为过客的身份得到了荒原生灵的认同。不仅传说中的狼对我友善有加，就连食物链顶端的棕熊也认可了。第一次与熊是个偶遇，我在山坡上，他在山坡下，冷不丁一个转角彼此对上了眼神。他极度敏感的直立站起，两只前腿怕打着胸脯，嘴里嗷嗷吼着同时摇摆着憨厚的大脑袋。他站起来足够高大，和一个篮球中锋并无差异。面对此状，我居然禁不住笑起来，他完全和想象中的不一样。我坐在地上，悠然的点燃一根烟，看着他一番耍宝。他很快自觉无趣，仓皇逃向另一侧山坡。当我来到他原先待着的地方时，他居然躲在不远处的一块石头后。其实我没有看见他，他以为我看见了他，从石头后再度仓皇地逃离。我不禁又傻乐起来，这棕熊肥大的屁股扭起来真是性感。 过客不仅是我在荒原里的身份标签，也是我人世间游历的法则。无论我们与谁相遇，相伴多远，在浩渺的时光洪流里都不过是短暂的邂逅，终将生离亦或死别。那些纠缠的恩怨情仇，不过是虚无中凭空生成的嗔怨。不要执着于彼此的关系，我们会被人辜负，也会辜负别人，但我们始终会别离，再无关联。遗憾的是，人世间过客的身份难以获得单纯的对待，我们总是在彼此辜负中互生怨艾，甚者诅咒，路遇拔剑，生死不往。什么样的怨恨使我们即便相互远离也无济于事？什么样的怨恨伴随灵魂在轮回中不灭？我所秉持的人世间那份过客的淡然，难以持久的维系，最终成为人群之外的旁观者，看人群与浮云的流动，在地平线上起伏连绵。那么，我凭什么执信荒原里就存在简单的彼此，就认定最好的防卫是颔首微笑？世间，有没有一片旷野，广袤无垠，自由的跋涉。不去伤害，不被伤害，我们的轨迹即便交错，也只是温暖的传递。 我深爱上了这片荒原，其实，我只是深爱上了行走在荒原中的我。 曾经，我也经过很多高山，但视野终要回到逼仄谷地。那种对顶点愉悦的深刻怀念，不过是为下一次重复，酝酿心智而已。起伏的旅程最终在失去与得到的反复拉扯下，成为一条铺满无奈与哀伤的直线。 曾经，我也走过密密山林，满树繁花与翠绿确实赏心悦目，但不免格局有限。我更喜冬日里萧瑟的树木，繁华虽已落尽，却是通透开阔，直抵人心。曾经，我也深入幽暗地下，迷恋着手中光亮开启永恒黑暗，我与所见景致均是生命中第一次相遇。创世般的惊喜在时间尺度上极为微小，却足以温暖整个艰辛的旅程。然而，持久的黑暗才是那些景致的本质，一次次转身光灭的瞬间，最终叠加成一个毫无色彩的记忆片段，我在黑暗中照亮的只是自我。曾经，我遇到过很多人，他们怀着各自缘由陪伴我进出险恶之地，不论我们曾有怎样的分歧，最终，我们将力量汇聚一处，所向披靡。我们在风景里，我们本身也是风景，这是我极力却也是无力摆脱的困境。 曾经，我去过很多地方，他们成为经历的组成要素。我不能否定他们曾带给我的快乐与虚荣，但我总是在善变中寻找新的可能。我要去的不是某个地方，而是那个地方有我的存在。这不是轻易的事情，若干年前的同一时刻，是否还记得身在何处，内心涌动着至今难以消退的触动？回首，过往，多是淡薄的苍白了一片的琐碎。记忆是唯一能证明曾经的存在，没有记忆的时刻，我在何处游离失所？ 羌塘，位于高原北部的无人之地，我处心积虑地走了进来，看似两个老友随意约定。但我深晓他不仅缺乏绕指柔情的表象，本质上也是冷酷、荒凉、死亡的内核。很多人尝试走进他，左右徘徊不得法门。更多人只是远远地瞥了一眼，便明了无法驾驭他的深邃。他在物欲横流的当下，依然持有着本真面目令人陌生的伫立在极遥的远方。 我不知，羌塘何时将成为靠记忆拼凑的过往。那年，那时，初遇的淡然，让我感受到了某种可能，彼此一番纠缠难以轻易了结。 至少五年过去了，我们一直相互依恋。 初次进入羌塘，那近似完美的旅程一度让我不知所措。没有体能困扰，没有单调食物难忍之心，没有冷酷风雪中的倦意，没有孤单至深的恐慌，没有野兽堤防之意，没有方向错乱之惑，反而，这一切都成为了完美的注脚。对于这片传说中恐怖色彩笼罩的荒原，进入的能力与技巧，我居然不费心机的掌握。我对荒原的恐惧一个个湮灭，行走的脚步越发愉悦。这种愉悦不同以往旅行，他更似一种深谙气流的飞翔，在客观世界无法摆脱的诸多阻力中，以最轻盈的姿态无拘无束的游历。 直到一个夜晚，月影憧憧，难以无眠，我在帐篷里辗转反侧。忽然，那个心中的鬼故事悄然浮现脑海。不同以往，他清晰的面容难以用最强硬的手段使之沉入海底。就那么无奈的，在月光铺洒的静谧海岸，我跪立在礁石上，与那张漂浮在水面上惨白面孔相互凝视。他的眼睛空洞黑暗，深不见底。我好奇隐藏着什么，俯下身去，凑近他的眼睛看个究竟……蓦然，所有惊悚的记忆从那个被我凝视的黑洞里涌了出来……我极力对每出现的一幕场景加以理性的解读，却让自己更深陷一场无法自拔的泥淖。我想呼救，可无人应答。我想逃离，却无处可逃。我暗自憎恨阿里的三个朋友，为何在深夜闯入我的房间，用惊恐的表情和夸张的肢体语言为我讲述了他们的预感。现在，好了，他们在人群中相互取暖，可曾想旷寂荒原中无法沉睡的我，将如何面对这未知的世界？克制与隐忍达到一个边界，无力阻挡鬼魅在黑夜里潮水般的入侵。我钻出帐篷，在它不远的周围徜徉着，试图用夜的寒凉让自己清醒与理智。远处群岚围合着清凄的月夜，我难觅明日将要行往的方向，我只能等待曙光的来临，将大地透彻的展现在眼前，从而判断与决策。之前，我所能做的便是学会如何将这个无眠的夜晚抛弃。如果我失忆，这个世界是否记得我曾经存在？ 我没有宗教皈依，我无神可倚。 我总是执信自己有足够力量把握自己，而不是将自己的失与得归咎于冥冥中的上帝之手。无情的是，面对未知的世界，我们谁也无法坚定的持有此般执念。万物回逆必有一个起点，总有一个力量无视逻辑与规律，在我们连意识都无法抵达的远方负责无中生有。因而，在内心极度虚弱的时候，我可以不信赖我们塑造出的各路神仙，以及种种无法被检验的理论，但我无法回避我的存在本身就表明了，确有一股力量在我之前就已然存在。 内心深处，我并不能轻易的接受，神的确以某种形式存在。或者说，我只是在神和自己之间选择了自己。我选择自己，安排自己，独立成完整的我。我的命运，我在人世间获得的不公与幸福与他无关。我只是单纯的我而已，或许平凡，或许闪光，或许沉沦，那都是完全属于自己的经历，而非某种被注定的无法挣脱的轨迹。这同样不是一件轻而易举的事情，这需要自我有足够的力量和心智与之抗衡。在这场不明意义的长久拉锯中，我和我的神各有胜负，至少我是这么自负的认为着。显然，这次，我输了，输得极其惨烈。 在完成羌塘西部的穿越旅行后，我应与边区牧点相隔一百公里平行，然后在预设的牧点获得补给后掉头继续深入荒原。正是在那个鬼故事的干扰下，我偏离预设轨迹近二十公里，与牧点更为接近的平行。只为那个鬼故事果真灵验后，我可以迅速逃离。实际上，偏离二十公里在客观上毫无意义，他只是满足了虚弱的内心，让自己看起来比之前强壮一些罢了。 没有预料的是，我对边区牧点的判断完全错误，我所偏离的二十公里与他们撞个满怀。那是敏感地带与敏感时节，我被牧民热情的扣留了。良久，我都没有缓过神来。我已然身处于拥挤的人群中，而我的心还在那片自由的荒原里独自跋涉。 牧民将我的证件送我乡政府，以便确定我的去留，那是离无人区最近的一个行政点，即便如此，他们往返了三天。因而，我在牧点魂不守舍的居住了三天。这是一个在物理空间上更为闭塞，更类似于我曾希冀的如乌金贝隆的地方。三顶帐篷聚在一个土坡环绕的谷地，十来个牧民与世隔绝的相依共存，与一群牛羊终年重复着简单的生活。帐篷是由牦牛毛编制而成的黑帐篷，这种原始帐篷已并不多见了。最初收纳我的帐篷，过于拥挤，一个年轻的孩子不得不与露天的羊群相拥而睡。 他们对我极为友善，每天吃不完的炖羊肉和至纯的酸奶，以及廉价却对我诱惑十足的烟草。他们对我并无提放，其实，我也无处可去，对于他们而言，这偌大的荒原便是最好的牢笼。我参与着他们的劳作，放牧，剪牛毛，挤羊奶，揉皮，在大雪覆盖的清晨拍打掉帐篷上的积雪。我享受着田园般恬静无争的生活，暂忘那无法应变的明天。我所能回报他们的便是一本地藏王菩萨经书，他们对菩萨有着与生俱来的虔诚与恭敬，十分满意我的礼物。经书是阿里朋友赠送的，他们劝留不了我，并将地藏王菩萨经书赠与我，佑护我在荒原里的旅行。地藏王菩萨曾有誓言，地狱不空，誓不成佛。他不仅度芸芸众生，也度地狱饿鬼，慈悲心境舍我其谁。朋友之意显然，在我生死渺茫的荒原旅行中，无论何方神圣都在地藏王菩萨的感召下为我让路开道。 初始，我对经书这样的礼物十分为难，沉重的行囊着实不愿再多加这样无用的东西。且不能被随便挤压，玷污，毁损，我得把他像宝贝一样收置好。对于艰苦的旅行，无形中增添了我小小的负担。现在，终于解脱了，我将崭新如初的经书转赠于更需要的人。 他们并不执意我的去留，尤其在我能念诵莲花生心咒之后，只碍于一人最初的强硬，他是牧民点唯一的党员。我刻意靠近这个强硬的人，彼此熟识后，他像了换了一副面孔，极为温和友善的待我，神情中不时有些许逃避，一定是愧疚自己的行为导致了我夭折的旅行。其实，他们并无恶意，他们即使身处荒原深处，也摆脱不了在人群中的随波逐流。 三天后，乡长开着车将我带回了乡政府驻地。即将离开牧点时，所有人向我挥手告别，不舍之情，无言以表。几天的相处，我无时无刻不在表明远行的执着，然而，我们都被卷入了一场无法把握的激流中。他们辜负了我，他们有所负疚，他们对我的依依不舍，更像是对自我的某种忏悔。我强忍感怀，看着他们逐渐消失在视野，最终融化在无边的荒原中。就这样，我离开了荒原，沉默不语的离开。但我并没有放弃，我臆想着在乡政府能把自己的行为解释清楚，然后休整几日，继续北上找寻那荒原中还在踽踽独行的我。 五天后，我又被县上警车带走。当我坐上车时，依然没法面对即将远离荒原的事实。随着车后的乡村也如那牧点一点点的消失在视野，直至完全融化在无边的狂风中，我才意识到，完美的旅行彻底终结了。非常难以理解的事情，我的身体随之剧烈的变化，一股股恶臭从身体里涌出来，不停的闷屁与打嗝，类似一种腐烂鸡蛋的怪味。车上人被熏得难以忍受，询问我驮包里是否有腐烂的肉食？我佯作什么也没闻到，事事与我无关的神情，随着颠簸的车厢面无表情的打嗝、闷屁。每一阵过后，他人便要打开车窗透气，任凭冷风吹打着抖索的身体。如此无奈的一幕反复演绎，让我有种复仇的快感。远离荒原，我的身体也似腐烂了，再无生气。 忧伤与怀念主宰了我离开荒原后的心情。有过类似心境，对一个难以抵达的地方有着备受折磨的思念。我不断反思，那偏离二十公里的轨迹，缘何就变成了前往相反方向的岔口？ 人生有多少时刻，是被这微小的力量毫无知觉的改变。我一边追索这种改变的每一个错误细节，修正他，完善他，一边积蓄力量重新开始。 起点，我们皆为一致，在生命起源的混沌中走向明晰，在人类文明的洪流中相互裹挟，在无穷轮回的时光里生生灭灭。远古，我们手揣石器孤独地在旷野里游荡，不知方向，不记来路。生命如同浮云，散聚无常，脆弱不堪。但我们从容，不惧命运。如同山鹰深谙气流的走势，藉以在广袤的天地里自由飞翔。生命的意义不值得追寻，就如这无涯的旷野，方向没有实际存在的意义。生命的终结只是另一个生命的站起，我们累了，便随意躺在一片野花丛中，安静的沉睡，只待春日里的曙光将我们温柔的唤醒。 春日迟迟不来，野草爬上了额头。最终，未知与恐惧，使我们从四面八方聚集一起，建立弱小城邦抵御不可知的自然。自由天性使我们的相聚充满了争斗，为了不被相互伤害，自由被约束，每个人都必须将部分自由交给彼此都信赖的人掌管，他是巫师，亦或王。我们在共同约定的守则下生息、繁衍，集聚众人之力获得与自然对抗的力量。我们像狼群一样在旷野里结伴而行，试图触摸它的边界，挑战他的威严。最终，我们遍及旷野里的每一个角落，却悲哀的发现，我们已成为旷野的主体。 我们再无处可去，只能相互拥挤，像蜂群一样建立起一座座巨大的蜂巢，那昔日弱小的城邦最终发育成偌大的都城。我们已然成为一个被同质化的庞大群体，制造出了一台喂养我们的机器，我们存在的意义与目的便是保证这台机器的正常运转。然而，在不灭的夜里，每一盏灯火都是孤立的，那看似璀璨的都城，不过是所有孤立的灵魂集合的表象罢了。无论我们拥有怎样空虚的内心，都要在曙光中无奈地飞出巢穴，为维系息息相关的生存机器辛勤劳作，在一个由我们共同创造的循环结构中冷漠的疲于奔命。 行走荒原最大的障碍，其实是我们自己。 喜欢深度旅行难以抵达的秘境，享受着难得一见的自然与生活。在他眼中，旅行是一种单纯的生活状态。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北方的空地，孤身穿越大羌塘无人区]]></title>
    <url>%2Fblog%2F52480.html</url>
    <content type="text"><![CDATA[藏语“羌塘”，意为北方的空地，狭义指藏北无人区，实则是所有北方未知的土地。大羌塘包含藏北无人区、可可西里无人区、阿尔金无人区、昆仑山无人区，这四个无人区连片在一起，构成了世界上独有的超级无人荒原。由于可可西里的概念被炒热，以至于大家一度用“可可西里”代替了这片广袤的荒原。实际上，可可西里不论行政疆域还是地理疆域都只是大羌塘这片荒原的一小部分。大羌塘，自由最后追逐之地。北方的空地相信，荒原彼端，云之落处远，方是永远到达不了的地方。 此次穿越的路线前无古人，被誉为历史上最伟大的探险旅程。 北方的空地作者以自己孤身穿越这片最后自由之地的经历为出发，用生动的文字、富于冲击力的照片，用满含的激情与深邃的思考，为读者真实再现了这片神奇而瑰丽的土地，每一段文字，读来都让人有身临其境的感觉，而每一章照片，都是那样恰到好处的精美，记录着羌塘的美丽、神秘和朴实。让读者阅读之后，不仅为大自然的雄奇瑰丽而深深震撼，满足潜藏在每个人内心深处的远足梦想，更能让心灵受到涤荡。” 序言行走荒原，放逐心灵 羌塘之行，头戴英雄桂冠，只是迎合了世人幻梦，头顶依旧是被电脑辐射得越来越稀的毛发，那才是真实的自我。 回眸荒原，那个孤寂身影不再，而荒原依故。有人默默走过，有人轰然倒下，有人留恋舞台。荒原不会为任何人改变，改变的只是行者的心，抑或世人的目光。不论谁，对于荒原而言，都不过光阴驹隙里的过客。行走荒原，并不需要多么高超的技巧，它远比人世间的游历轻松。那些笑对生活困顿的人，才是真正的强者。行走荒原，也不会使人有多么高尚，它仅仅是一种生活方式，没有什么可值得炫耀。如果爱，就去，不知不觉转到另一条路上，只说明还不够爱。不要轻易给自己冠冕堂皇的借口，滑动的人生并不会有更丰富的体验，那只是一种随波逐流的状态，在不断反悔与更替的价值观中游弋。你可能属于每一个经历过的时代，但没一个是属于自己的美好时代。若说行走荒原所需的品质，就羌塘而言，无疑是坚持、隐忍和乐观。坚持可以让扫地的成为少林寺高僧，可以让唐僧轻易摆脱女儿国的纠缠。没了坚持，生命中只剩无穷诱惑，就会轻信看漫画书也能练就如来神掌。没有什么事能轻轻松松成功，走路还有嘴啃泥的时候。隐忍则抑制着复杂多变的情绪，以客观姿态旁观自己的行为。谁都能在别人骂街的时候充当一个优秀的老娘舅，当自己身处骂街角色中，观音姐姐来劝都不顶事。很多事情真没什么大不了，不就是搞不清谁踩谁一脚嘛。现实又是残酷的，有些事不是那么好轻易接受，所以需要乐观，它可以将任何苦难变成一出事不关己的舞台剧，既饱含泪水，更充满啼笑皆非的趣事。荒原在哪里？它可以是一片广袤的无人区，也可以是小区里夜深人静的花园，甚至是野草滋长的内心。荒原真正的含义，是一片心灵自由放逐之地。那里有久违星空，只随意地仰望一眼，就知自己的位置，既没想象的那么高尚，也没想象的那么卑微。那里有单纯，模糊的道德边缘是分外明晰的善恶边界。那里有安静，可以毫无顾忌地打量自己，只有独我的时候，才无视那些形形色色的标签。 人是群体动物，但心灵是孤独的。 不时去荒原，摒弃繁华，看看真实的自己，想要什么，不想要什么，也可什么都不想。不要怕迷路，世间本就无路，迷失才可怕，走在正确的路上都觉得行往错误的方向。祈愿每一个尘世中的孤寂旅人，都能找到属于自己的安宁之地。 自序第二次穿越大羌塘无人区已过三月，期间不少志同道合者询问事宜，今儿便呈一贴，简叙过往。 此次穿越从青藏高原的西端至高点界山大阪开始，时间4月20日，一路向东经邦达错、羊湖、若拉错、岗扎日，横穿整个藏北无人区后改由北上进入阿尔金无人区，经可可西里山脉、昆仑山脉、鲸鱼湖……在阿奇克库勒湖遇人，再三天车程至花土沟镇，时间七月五号，总历时77天。在离开界山大阪至阿奇克库勒湖的74天里独处无人区，此间行程1400公里左右，跨度四个月。大羌塘藏语“羌塘”意为北方的空地，狭义指藏北无人区，实则是所有北方未知的土地。大羌塘包含藏北无人区、可可西里无人区、阿尔金无人区、昆仑山无人区，这四个无人区连片在一起，构成了世界上独有的超级无人荒原。由于可可西里的概念被炒热，以至于大家一度用可可西里代替了这片广袤的荒原，实际上，可可西里不论是行政疆域还是地理疆域都只是大羌塘这片土地的一小部分。大羌塘，他是自由最后追逐之地…… 穿越路线图： 前戏三月初入藏，一路烦心事。原装插头居然正负极接反，驮包铆钉再而三的轻易断裂，多个设备共用的充电器损坏……骑车前往阿里，作为前期体能拉练，一路上丢三拉四，先是遗了背包捡回，后失了相机包再寻回，第三次在警察林立的江孜县街头丢了一个大驮包，衣物、太阳能板等尽失。无奈，重返拉萨调整，整顿装备。随后与友人去了林芝赏桃花、泡温泉以求转运，更享得“十凤一龙浴”的传奇，想必晦气已散，再返拉萨，做着去阿里的准备。没想到又遇江湖客忽悠，失了小钱又耽搁一周，不得已自己找车速到阿里。谁料自行车竟在途中被颠掉了后轮快拆杆，一时在偏远的阿里无所适从，即便拉萨有零件走邮政快递也得十天不定。多啦同学凭借巧嘴托一司机将快拆杆从拉萨捎来。以为最后一遭，不曾想一次未用的新油炉又断了喷嘴。翌日到处寻焊接，一连三家皆无铜焊，第四家倒是可以，老板事先说明，“如果焊好给十块，坏了可别怨我。”我应下。只见电光闪烁，不消一分钟喷嘴便彻底毁了，无语。又是多亏多啦同学，将自用的MSR油炉及丁丁的睡袋托志鹏捎回了阿里。时间已4月16日了，我已没有多少时间再耽搁，翌日便找车前往界山大阪。 雅江上的漫天黄沙 雅江大峡谷的桃花，遗世独立 山野中的原生态温泉，边酒边歌（此张友人拍） D1（4-20），16K，宿营5192M这是一辆装满废铁的卡车，到达界山大阪凌晨六点。夜黑酷寒中，司机冷得都不愿露头，我独自攀上废铁将自行车取下，慌乱中将跟随多年的鸭嘴兽水袋刺破。好在多带了个友人赠送的MSR水袋，否则我将再度功亏一篑。猛烈的寒风中第一次搭建新帐篷，若不是单层一体结构（1.5层），是搭不起来的。极冷，温度在–15℃下，把头钻进睡袋，却被呛了出来，丁丁睡袋的那个味可不一般。中午十一点醒来，大风依旧，全靠身体压着帐篷。烧水吃饭，忽四个边防官兵走近，他们诧异一个人竟在此季宿营界山大阪。我是万分紧张，生怕是堵我的人，去年便是被从无人区“押”了出来，有此一遭更是疑神疑鬼。好在四个边防官兵不知我的去向，嘘寒问暖，不断叮嘱小心小心。官兵走后，我随即打包装车走向无人区的深处，恐再有变。车子沉重，车把难以掌握，途中一个小坡居然要拆掉驮包才能推上来。这对我打击很大，现在硬路且如此，后路漫无边际的荒原如何可行。此次从界山大阪进入荒原竟连一个人也没见着，而去年九月时无人区边缘游牧甚多，可想此时大风低温天气还不是放牧季节。十六公里处有一间羊圈，在龙木错东端，去年也经过，到了此地后再无力推行，决定宿营，好好整理下思绪。安顿好后便去了山谷中寻找湿地，去年多啦和流虻经过时发现，而我竟一无所知，所以这次要寻个明白。湿地中泉眼众多，是恒温的地下水，所以外面世界一片冰冻，水里却春意盎然，水草，游鱼……这是我在海拔5200米高原唯一见此的独特地貌。 谷地里的积雪被大风吹成尖锥装 此湿地由多啦和流虻发现，附近矿上的人也不知，我去年也是错过 地下水恒温，所以外面世界冰天雪地，水中一幅春意盎然，有鱼有草 D2（4-21），0K，宿营5192M一夜狂风，海啸般此起彼伏。第二日没有往前，而是在羊圈里思前顾后。的确，前事诸多不顺，体能尚未拉练，负重到了极限，咳嗽不见好转，寒风低温甚烈……我并不认为这是一场精心准备好了的旅行，身体和心理上都存有巨大的阴影。何去何往，一直纠结着。心里没底的还有装备，能否承受的住，还没怎么着，驮包铆钉又断了一个，前货架松脱。下午把所有驮包的铆钉撬掉换上准备好的螺丝，效果非常好，整个行程再无有过一次故障。前货架重新调整，由于没有带匹配的扳手，我并不认为一劳永逸了。晚上下定决心，继续往前，其实这个决定一点也不意外。 幽兰水草 遍布湿地的小泉眼，水质清冽 泉水流出不久便上了薄冰 羊圈，睡袋下是门板，没有挪动过，和去年一样，感觉昨日 黄昏中的湿地 黄昏中的龙木错，如果图片有声音，可以听见排山倒海的风声 D3（4-22），52.4K，宿营5145M早起，东西竟塞不进包里，无奈扔掉了三碗糌粑、护肘、冰爪才得以顺利装包。顺着铅锌矿的路找到进入荒原的岔路，岔路在河床上，很难发现，去年就错过，后回头直接插进去的，所以今年寻的特别仔细。接着便是翻越大丘陵，坡顶海拔5275米，也是此程最高点。下午两点过了去窝尔巴错的“岔路”，至此全新的旅程开始，前方的路不再是熟悉的了。随后吃了一块压缩饼干，冻得硬邦邦，用铁锹砸碎。到了下午六点，边推边骑走了32公里，如果轻装的话速度至少能提高一倍。风越来越大，我打开“伞帆”测试了一下，利用风能的效果远大于预期，一路飞驰。八点后开始留意路边水源准备随时宿营，地图上显示路边有连续泉水并聚集成沟，但我高估了此季的水资源，山谷里一边荒芜，滴水不见。随着天色黯淡，不免有些紧张，“伞帆”被吹断了三个辐条，当天便彻毁，并不可惜，只是个试验（被风直接吹了20公里，今后大有利用价值）。到了九点半，渐黑透，只好放下自行车，先去了北侧山谷里找水。这是一片宽阔的沙地，连条沟也没有，再远点的地方什么也看不见。我回头取了GPS查看等高线，发现南侧沙地离山势较近便寻去。终于在一条沟壑里发现一块冰，用铁锹砸了20升，冰块很浅，还夹杂着羊粪。回程时逆风，把眼睛给吹坏了，两天里都半眯着。等把帐篷搭好，已经快23点了，融冰又用了40分钟，倦的不想吃东西，喝了点牛奶。没想到，这么快就开始缺水，如此狼狈。 途中的溪流，冰层触底 此河汇入马头湖，而湖的北侧有个卫星湖，绝好的溜冰场 夜深融冰，需要40分钟 D4（4-23），31K，宿营5028M一整天阴霾，大风不断，不时有冰雹云从身后袭来，又忽而一晴。沙土极重，基本推行。下午3点到了鲁形湖，此处有一间土房，是最后一处人类固定建筑。去年，多啦和流虻曾在土屋里住了三天，无人。今年似乎也如此，但房子前一辆卡车不免让人浮想联翩。我先去羊圈侦查了一番，只有几次小羊羔，它们见了我后就一直跟在身后，心中平添不少暖意。用望远镜查看四周，不见人与羊群，确定无人后用螺丝刀拧开门栓。屋子里很干净，地上有两箱饮料，里屋挂了一串风干的羊腿。炉子上有壶水，微热，说明主人并未远去。我把水袋灌满后出来，将门栓螺丝再拧上，不留一丝有人潜入的痕迹。然后在卡车的工具箱里顺走一把匹配的扳手，解决了最后一个装备上的障碍。前货架每两个小时就松脱一次，组合钳子根本拧不紧，如果没有匹配扳手是迟早要回头的。即便有了扳手，前货架依然每天都要松脱，驮包太重了，所以每天晚上把前货架拧紧成了例行工作。快速离开土房子，有了去年一遭，牧民成了我最不想见的人。离开土房子数百米后车辙骤然变的稀疏，沙重的下坡也推不动车子。从路的角度来看，过了鲁形湖才是真正的进入无人区。很多天以后，常怀念起屋子里的羊肉，可惜那时食物充足，车子太重，恨不得多扔掉些东西。 早晨继续融冰，光线好，羊粪都被捡了出去 营地，面对的小山就是昨夜取冰处 鲁形湖边的土房子，无人，最后的人类建筑 D5（4-24），19.8K，宿营4951M十点半出发，天气依旧。可能此段路从界山大阪开始是台地风口，所以风难止歇。风速通常保持在六级，瞬间风速到九级。沙土依然很重，双手适应了沉重的车头，前日被风吹坏的右眼疼痛加剧。下午三点，瞥见右侧山头上有一截凸起物，貌似天线，于是爬上去细瞧，原来是一个铁塔（大地三角点）。上世纪71年，三大军区联合对羌塘做了初步测绘，留下大量三角点和水准点，今天终于得以见识实物。傍晚来到邦达错附近的一处泉眼，泉水流进冰封湖区，冰面上黄斑遍布，是风携来的黄沙与尘土。近湖冰面有很多裂口，我推测下面有泉眼，而非冰层融化所至。邦达错西侧便是通往克里雅山口的岔路，越野车可以直接开到山口，我一路留意，却没有发现车辙。阴霾天空终于呼啦啦飘下雪来，我不慌不忙搭好帐篷，附近有如此一口清冽的泉水，便再也没什么大不了的事了。 71年三大军区联合测绘羌塘时竖立的大地三角点 邦达错冰层上的空隙，推测下有泉眼 伏地风暴团，扫过时天昏地暗 邦达错一片冰封，野鸭更显旷寂，他也是藏西北四大错之一 风雪说来就来，这个季节天气不应该频繁的阴霾 D6（4-25），4.3K，宿营5002M此处风化地貌丰富，充满气泡的火山石随处可见。推车转过小山是一条大冰河，此河是饮水河，从窝尔巴错流出汇进邦达错，去年走过上游，它也是一条动物迁徙通道。饮水河下游极为宽阔，冰层厚有一米，中间是未冰封的主河道，很深。河岸边有很多泉眼，水质极好。今天只推行了四公里多，却走了二十多公里探路，主河道是过不去的，北侧邦达错更别想，只能向南寻路找一处浅滩，谁知南侧是更大一片湿地，一直把路逼向西方，彻底南辕北辙，令人琢磨不透。花了四五个小时不得过河的路径。下午横下心一直沿着湿地走，直到山脚下，湿地才止住得以东寻。此处火山地貌丰富，还发现了游牧痕迹，和用火山石垒起的玛尼堆。此处也是最后一处游牧痕迹，想必是一个夏季牧场，再之后的路，荒原彻底与人类社会断绝了关联。寻路一直到天黑，确定了明天行进的方向。 此处类似雅丹地貌很多，同时又是火山地貌带 从窝尔巴错流出的饮水河 河边泉水众多，平添一丝绿意 主河道很深，下午碧水间夹杂着黄水带，那是融化的冰雪携带的泥沙 冰层很厚，冰面呈凹陷状，是风吹所至 此图才是饮水河南来主道，分叉无数，其右侧是大片泉水滋养的湿地 绕路东寻探路，发现游牧痕迹，这是火山石堆砌的玛尼堆 营地，从上图中可看见遥对的此山 D7（4-26），11K，宿营5009M朝着昨天探路的方向前进，绕过湿地转向东方。下午两点再度遇到曲折的饮水河，这次是躲不过去了。河面近700米宽，覆冰，冰面由外至里呈现不同形态。岸边有悬冰、褶皱冰、堆积冰、冰窝、冰凌等。见此情形我断定河水会在傍晚时分消融，所以才造就了如此多的冰形。换上拖鞋探到主河道时发现主河道至少有三条，冰面厚薄不一，水深至膝。我长吁，如过了此河便无法回头了。有很多路都是如此，只能走一次，第二次便没了胆。推车强渡，有些冰软，卡着轮胎，得用脚破冰，有些冰厚，底部且半融彻底陷住车子，有些冰水下面是软沙，寸步难行。最后一段冰河拆了驮包才得以过去。整整用了四个小时才过河，腿上被冰块划了数道血口。六点钟时，冰面基本化尽，水面大涨，混沌一片，恰时狂风卷着冰雹袭来。我想，若迟疑一刻，赶上此时怎么也横不下心过河的。河岸沙重的超乎想象，且垂直，又卸了一次驮包才推上去。到了日落时分，天气又出奇的好起来，霞光，蓝宇，明月……喜欢这样颜色的羌塘，喜欢这样颜色下的营地。 这类冰薄而悬空，远离主河道 冰面硬，下而半融，最怕下面还有一层软沙 这种情况下车轮会被卡的很死，很难弄出来 卸包过河，很是繁琐 转瞬，河水混沌，冰雹袭来 终于找到曾经的羌塘，金色的黄昏，暖冷色调相间 D8（4-27），14.6K，宿营5112M昨夜忘了收码表，冻坏，之后路程远近靠GPS数据。双路温度计探头冻坏，内置探头到了–10℃就乱码，只能用水银温度计临时采集数据。夜间温度基本在–15℃—–20℃之间，帐篷内温度在–10℃左右。一体式单人帐的好处就是限制了空气流动易于保温，缺点同样大，就是结露现象严重，每天早晨帐篷里的冰霜有半升之多，穿衣服时先把连衣帽戴上，不然冰块呼啦啦的往脖子里掉。另外，羌塘的风终于回到了我之前预测的规律上，早晨无风，或极小的风，下午两点后风起逐渐加大，傍晚八点左右风逐渐小，这个规律准确率达到80%。今天路况很糟糕，下午在一条古河床的软沙里艰难前行，需拼得全力才前一步，然后停下大喘，速度也就可以在蜗牛面前吹。挣扎了五个小时后，当我看到草岸时，眼睛蓦地湿润一下，终离苦海了。 清冷的早晨 内帐结露严重，每天都清理出近半升的冰霜 这样的朝阳预示着今天的天气依旧阴霾为主 D9（4-28），18K，宿营5072M上午又进入一段重沙路，苦不堪言。GPS专用的太阳能板短路，查修是二极管坏了，好在备了零件。由于采用了最新的三结非晶硅太阳能板单独给GPS供电，使得GPS高耗电成了历史，七十多天里只因故障换过一次电池，节省了需携带的大量碱性电池。同时备了一块功率5.4W的太阳能板，专给7.4V的相机、DV及其他数码设备供电，路上没缺过电只缺水。下午七点抵达普尔错，此湖冰面怪异非常，岸边的冰卷扬上翘，湖岸裂开，推测是大风推冰拱岸所至。冰体夹杂的黄色，应是碱渍。湖对面有很多野牦牛，及两头闪烁不定的棕熊。湖东面是一座深入湖心的半岛，我与之犄角之势扎营。晚上砸开岸边的冰取水，碱味很大，只采了冰回去。第一次煮麦片，第一次带麦片旅行，只因在阿里装包时发现还有一点空间，就买了包两斤的麦片。很不好吃，还是碱水味太重？反正是倒掉一半，其实还是负重的阴影，能轻点就轻点。 早晨晒装备必不可少 普尔错黯淡的黄昏 被冰拱起的堤岸，再加上羌塘强大的风化力，便如拉链般敞开 不断挤压的冰面 取水处，踏过冰锥有一薄冰处 日落前一刻，一道金光照在普洱错上，一切变了模样 D10（4-29），16K，宿营5141M上午绕行普尔错北面，岸边是此起彼伏的大坡，稀疏的草地生出嫩黄，野牦牛多三两结伴各霸一处。忽然有五头结群的野牦牛向我冲来，一时尘土飞扬，雷霆万钧之势，非常有震撼力，对野牦牛脾性不熟悉的人定会被惊吓一番。结群的野牦牛并不会伤人，冲人只是在表述领地，在离人近时会突然九十度转向，绝尘远去，然后停在一处高地远远的观察你。身躯重达一吨的野牦牛其实是荒原中生性最胆小的动物，他们遇人最初的反应是尾巴翘起，前蹄磨地，犄角向前，双眼发红，披身长毛不时抖动，一副不干死你就不叫牛魔王的凶狠劲头（示警）。这种举动是内心恐惧的反馈，期望用凶狠的表情吓退外来之物，你只要壮着胆子不去理睬，当靠近野牦牛群时，他们会突然溃败转身逃去，和先前狠劲截然相反，情势转变之快令人错愕。只有胆大的野牦牛群才会短暂的冲向人，但绝对不会真有胆量查看你的护照。野牦牛群的数量越少，这种恐惧的反馈机制越明显。在羌塘，有经验的司机是不会从两三头野牦牛前经过的，远远的就避开了，实在绕不过去，就点上一根烟等牛吃饱草自然走开。因为野牦牛是会真的顶车，而非流言，能把越野车轻而易举的顶翻。我曾向他们求疑，为什么我推着自行车没遭到过一次恐怖袭击？老师傅给我的答案是我的车太小，牛看不上!离群或发情的孤牛的恐惧反馈机制就更大了，我路过它们时也是心里没底的，那种对峙令人窒息。我个人经验是极慢速度靠近，不要对视牛的眼睛，不要在乎他做什么凶恨的动作，但只要他的前蹄往前迈一步，那怕一小步的挪动，就要利马停下来，给对方一个缓气调整心态的时间。如此反复前行。若逼急了，野牦牛将是地球上最具杀伤力的动物，没有什么能够阻挡，一般的子弹打在它的皮上根本穿不透，顶多一个小眼。以往，无人区附近的牧民会把捕获到的野牦牛皮切下来做菜板，几十年都剁不坏。中午时候，夹在背包外侧的360度遮阳帽丢了，还未用一次，没有回去捡，导致以后的日子里一顶抓绒帽白天黑夜里戴到底。好在皮粗肉糙，否则对脸部的伤害是致命的。一点半的时候发现一辆废弃的吉普车，翻了个身，有十几年的历史了，推测是盗猎车。如今，羌塘的野生动物保护的特别好，至少藏羚羊的盗猎极罕有了，但盗猎野牦牛的却应孕而生。盗猎者把野牦牛的头割下弃之，然后扒皮，再把肉剁碎，拉出去当家养牦牛肉买。因为没有硕大的头骨且肉剁烂，难以检查其肉家养野生，这让盗猎者赚了空子。盗杀一头野牦牛肉的利润在万元左右，铤而走险的人不少。盗猎者通常冷季进入无人区，活动直径两百公里左右，所以无人区深处的野牦牛对人的恐惧心里要比外缘的低很多。在阿尔金无人区曾发生过一起野牦牛报复盗猎者的行为，母牦牛寻到前日打死小牛犊的盗猎者，钢刀般的犄角穿过那人胸膛，顶在头上，十几天不放下来。母子之情，撼动人心。三点左右出了普洱错盆地，下一坐标是红山大阪，然后下到土则岗日的月牙湖。此时，发现了一条南北纵向的车辙，探了半天路不知走向。我带上地图、GPS、指南针爬上一座小山测算红山大阪方位。山势浑圆，山口难寻，确定大阪位置后抄直线前行。经过一片烂草地时，不想看见的一幕来了，草地上零散着百个劈开的野牦牛头，无疑是盗猎现场。之后是漫长的古河床，软沙铺地，缓上至山脚。 野牦牛舌头上长有一层肉齿，可以做梳子，俗称肉梳，牧人用他一头青丝梳到银发 废弃的车子，疑是N年前盗猎者遗下 被宰杀的野牦牛，头被割下，硕大，可比车圈，有的头骨被劈开，不知因何，难道是取舌做肉梳子？ 大阪下的营地，夕阳金辉，明日还是个好天气 D11（4-30），20.4K，宿营5120M上红山达坂的地面很硬，碎石为主，加上下了一个大坡，今天推行距离在过鲁形湖后首次超过20公里。山口平坦，似一条宽阔山脊，海拔最高5256米。上了平坦山口，海拔6356米土则岗日便映入眼帘了，山顶浑圆，丝毫没有一座雪山的筋骨。羌塘深处的雪山大多如此，在经过数次夷平地质运动后不再有鲜明的棱角。谷地里藏羚羊很多，多是十几只成群。自去年在某河谷里看见迁徙的绵延不绝的超大藏羚羊种群后（可能是近年发现的最大种群），便对这种小型羊群完全没了兴趣。羌塘的食草动物种群恢复的极快，例如野牦牛、藏羚羊、原羚、鼠兔、旱獭等。深入羌塘深处，你绝不会对突然出现在眼前的藏羚羊感到惊喜，因为太平常了。此季藏羚羊已经公母分群，路上多见带孕的母藏羚羊，公藏羚羊不知迁往何处出了。近年研究，藏羚羊繁育中心不仅只有卓乃湖，整个大羌塘无人区有四个藏羚羊繁育中心，一是卓乃湖，二是兔子湖，三是黑石北湖，还有一个记不清了。我认为，藏羚羊的繁育中心远不止四个，多数种群并没有不可想象的长途迁徙。他们的生育性迁徙大致南北走向，南到中央山脉附近，北到横亘天际的昆仑山脉。藏羚羊看似胆小，其实对外界事物充满了好奇。羌塘深处的藏羚羊并不十分怕人，最近距离可至30米。它们会安静的看着你，揣测着你是什么玩意，为何走的这么慢。它们会在你的前方来回穿插，时而佯作一副胆小的神情踌躇不定，实则逗你玩。性格决定命运也适用动物，藏羚羊就是典型代表，它跑的快，身姿矫健，最厉害的是头顶一对长角，其硬度和锋利是数一数二的。如果它们转了性，三头藏羚羊戳死一头狼是很简单的事情。可它们倒好，这对角是在发情时和竞争对手玩命用的，一剑封喉啊！下达坂有段路陡直，试着骑车顺坡溜一段，却被厚重的沙土绊了大跟头，前货架松脱，一驮包直接飞到沟壑里。至山下就是土则岗日脚下的月牙湖，湖面冰封，近岸稍融，依然是个重矿水湖。月牙泉岸边有许多露头的岩石，风化的极为厉害，一道道的排列，有如城墙，有如房舍，因此也使得我数次停下侦测。心里是明白的，只是那些风化的岩石造型太拟物了。其中一人形石头还折腾我躲到一沟里用望远镜看了许久，太逼真了。湖岸散落的黑色火山石也很多，总之这一处地貌非常奇特。过了月牙湖进入一片不见边际的古湖床，我的GPS地图显示这一带是一个触须般的大湖，如今放眼望去，四周一片荒芜，不见一水一冰。粗略测算，这片古河床将近1200平方公里。羌塘是一个没有大比例地形图的地方，也没有过大比例尺度的地面实测，地图上的有些地标往往只是一种记忆，比如脚下这片古湖床，几十年前或许还碧波荡漾着。推行在古湖床平坦的沙砾中，极易混淆方向，心理也是，仿佛这就是一片没有方向的疆域。 借用去年拍的一张动物迁徙的照片 上达坂的路，碎石地面，硬，已经非常理想的推行地貌了 土则冈日下的月牙湖，雪山浑圆，没有山骨，一瞥之间有时难以分清山和云 古湖床，地上的白渍是盐碱，常会和冰雪混淆46# 豆豆它爸2老范好。横走的话绝对无人区的天数和线路太长，是双湖至阿尔金的三倍，油料？另外车辙比较少，多是高原寒漠土、古湖盆沙地，表层非常软，因为不懂摩托车，不知轮胎和动力能否克服？去年流虻和多啦在鲁形湖遇到的骑摩托车跑山人吹嘘自己去过很多地方，我是不信的，挺多也就是在昆仑山南麓和藏西北四大错之间转，地貌环境不允许啊。老范，摩托车你专业，也许改装下（三轮模式什么的）在冬季走是可行的。关于野生动物（上）申明：个人体会，非书本，仅参考。对于在荒原中行走的旅人，野兽是亘古不灭的话题。以羌塘为例，野兽主要有两种，一是狼，二是棕熊。还有两个替补野兽，分别是野牦牛和乌鸦，把他们列入残忍一类随后解释。如何防范野兽伤害，首先自己不要有害它之心，人与动物在本能上的情感是一样的。【狼】此次遇狼七次，其中五次是对狼。狼现在的基本社会属性是神雕侠侣模式，至于集团军似的狼群很罕见了。闲扯一句羌塘的生态问题，现在不是藏羚羊等少了，而是位于食物链顶端的野兽一直没有恢复，导致荒原生态另类失衡。尤其是失去天敌的鼠兔、旱獭把荒原折腾的够呛，直接显现结果就是草原沙化。早在上世纪中叶，狼还是这片荒原的主宰，他们为非作歹，无恶不作，然后政府决定号召牧民打狼除害，就变成现在这副情形了。最近一次关于狼群袭人的有效记录是七几年的一次科考，在巴毛穷宗遇到狼群围困，队员们开枪射狼，而狼前仆后继，饿的以为子弹真是花生米。如今，狼绝对是孤独的。我此次第一次遇狼是对狼，一只在前面佯攻，一只在后面守着，这种一前一后是基本战略。首先不要紧张，野兽是能嗅到人的恐惧气息，其次不要后退，后退就等于承认自己是猎物，不要做过大的肢体语言，觉得安全时拍个照片没问题，然后凝视对方的眼睛僵持着。僵持时间少则几分钟，多则半小时，当狼搞不懂你后且不觉得你有什么危险，就会汇集一处从山坡后溜走。要知道，狼不缺食物，搞定一只鼠兔比搞定一个比自己身形大的人要轻松的多。即使他饥饿，他首先也要评估自己能不能搞定你。而你要传达给狼的信息就是我对你没兴趣，也不怕你，更不会给你看身份证。至于狼群？真的，好多年没听见过了，如果遇上，且他们只有你这一块肉的话，就看造化了。事实上，这么多年来，鲜有狼伤人的事件。但这么多年来，恐狼的流言依旧漫天飞，尤其是新藏线上。 此行与狼最近的一次，小沟遭遇，无一点过激反应【棕熊】这家伙伤人是真的，每年在昆仑山北麓的新疆地区和藏北草原上，都会发生几起熊伤人甚至致死事件。不仅如此，熊还会袭击你家房子，用板砖拍碎你家玻璃，偷吃你家羊……以至于，在藏北有些县区有种补贴，就是熊给牧民造成的破坏政府买单，不允许你致命反击，除非人身危险了。曾经有一个牧民教我防熊术，就是捡一根棍子给熊吃，熊以为是你的手，咬了一口棍子觉得不好吃就走了。听完我笑的把糌粑喷出来，即使此计可行，在藏北荒原上找根棍子的难度比中彩票都高。熊是杂食动物，对人肉是不感兴趣的，很多熊致人死伤事件中并没发现肉被吃了，纯一个开瓢玩。那熊为什么伤人了？答案是生态冲突，牧民侵犯了熊的生存领地，长期摩擦导致。另外熊的智商很高，他也可能认为偷吃羊圈里的羊比抓鼠兔轻松多了。此次旅行遇熊五次，有两次距离特别近，其中还和一只同走了一段路，就像约好了散步似的，没有想象的那么可怕。与遇狼一样不要后退、不要恐惧。把熊惹火了，他的冲刺时速是40公里，你能在海拔5000米的高原跑过他吗？但另外一种情形就很危险，就是遭遇战，被恐惧激活的绝地反击是停不住的，不是你死就是我活。去年有次急转山谷，忽然撞见前面一头熊，他也吓一跳，竟直立起来双手挥舞口中嗷嗷。我坐在地上不理他，不回应，他嗷几下就跑了。羌塘深阔，绝对不会发生贴面遭遇战，假使了，看造化。（熊的嗅觉极为灵敏，所以个人比较坚定的认为至少在深阔羌塘是不会贴面遭遇的。） 此行与熊最近的一次，他后来混入野牦牛群中不见了，还找了他一会，奇怪 关于野生动物（下）申明：个人体会，非书本，仅参考。【野牦牛】鉴于他以往业绩，把他列为替补野兽。对他的描述“D10”天帖子里有，不再叨叨。 此行与孤牛相持最滑稽的一次，遭遇型，他无警示动作，我坐下他就坐，我往前他就站，不知脑子里琢磨啥【乌鸦】把乌鸦列为替补野兽是因为当你昏倒在荒原中的时候，第一个吃你肉的绝对是他。羌塘里的乌鸦不似内地，它们体型如鹰，飞过头顶时似乌云掠过。它们是食腐动物，但更渴望鲜肉，曾有牧区婴儿被它残忍叼死过，而葬送它嘴下的羊羔不计其数。曾有牧民问我索要鞭炮，目的就是要吓走偷吃羊羔的乌鸦。（神鸟，不能搞死。）防范乌鸦很简单，永远保持自己的斗志，不要在荒原里倒下。 去年照片，一次小憩，乌鸦就落在旁边守着，打错算盘了【此行防范措施】在界山达坂遇到官兵时，他们就用野兽吓唬我，并问我是否带了电击器？若知道我一个人进无人区估计得搜身有无带枪。我的防卫装备只带了鞭炮和辣椒水，实际使用情况是一次也没用。鞭炮过河时打湿了仍了，辣椒水都没打开过。（注：不到万不得已不要使用辣椒水防卫，因为野兽大多靠嗅觉搏生，嗅觉毁了就等于要他命了。）晚上宿营没考虑过防范，觉得实在没有必要。白天遇野兽连贴身小刀也没摸过，徒步探路时基本无防范。羌塘真的很大，有什么东西早发现了。另外，离发情期的野兽越远越好，发情期的兔子都咬人。如果棕熊、野牦牛之类的攻击你恐怕带枪也不行，所以说心态最重要。闲扯一句，比野兽厉害的是狗，被藏狗追过，被发情狗扑过，被十来条土狗围了一晚上……防范狗更实用些。再申明：上述经验只限于羌塘环境。防范野兽越周全越好，不能逞强斗勇。 D12（5-01），23.8K，宿营5117M今天是五一劳动节，一直走在地图上已消失的湖区。湖盆平坦而坚硬，所以今天推行距离超过了20公里，算是羌塘对我五一节的奖励吧。十二点过后天空阴沉起来，大风随行。自昨天过了月牙湖，之后一直到羊湖，期间路上再无大湖（将从碱水湖和拜惹布错中间走），连轻度的盐碱水都没了，所以特别留意寻水，随时补充水袋。途中倒是有几个很小的海子，均是盐碱水洼地，水极浅，淹不过半指，上面托着一层盐冰混合状的硬壳，走近可明显闻到一股腐臭的味道，毒水也。此类型海子的岸边是一片软泥，很难接近，没有丝毫冻土形象。将近六点半才在一条土沟里发现一处雪锥，也是今天唯一可利用的水源。雪锥附近地表融有一层薄水，薄水不仅捞不起来且被地面盐碱渍严重污染。雪锥是未化厚雪，在大风的吹打下呈尖锥状，雪质干硬，充满小孔隙，貌似冰。碾碎了几根雪锥装进水袋，今晚的饮用水解决了。此处雪锥是今天荒原中的唯一，它未消融的原因是下方土壤里含有大量地下水凝结成的冰块，起到了冰箱效果。晚上大风，帐篷抖动的巨响让人受不了。小型单人帐的好处就是只要帐内有人就不会被吹走，但搭帐篷时要极小心，每个步骤都不能大意，先前搭帐时一不注意，大风将帐篷吹走，似个大灯笼在地面滚动……把帐篷追回来时，那个累。靠帐钉完全固定帐篷是不可能的，小帐篷的地钉在大风天气里只是一种摆设。23点开始下雪，先伴着呼啸的西风，后只有安静的雪花纷落在帐篷上，终于可以安静的睡去。 平坦的古湖盆，为今天行距超二十公里立下汗马功劳 途中洼处的小海子，超重矿，极毒水 雪锥，今天唯一可利用的水源 D13（5-02），0K，宿营5117M早晨醒来，掀开帐篷一看，这雪大的完全是羌塘强迫我五一节休假。睡了个小懒觉便出去踏雪寻踪，一些羚羊群映入眼帘，他们很容易发现，在雪地里似一条黑线分外明显。取了相机追拍去了，无奈他们始终和我保持着相当长的距离，是一群受孕的母藏羚羊，本能防护吧。水是不缺了，雪水是极品，问题是非常耗费汽油。此行带了8.6升93号汽油，油炉是多啦的MSR耳语，大锅1.5升，主要是烧水用，经过几天下来的实测，烧水需时如下：液体水，早晨要用16分钟烧开，晚上则快些，14-15钟的样子。化冰35-40分钟左右，化雪耗时最长，45-50分钟。化雪极耗汽油，所以在雪和轻度盐碱水同存的情况下，我多数会选择后者作为水源。躺在帐篷里听歌，边抽着烟，边注视着经过帐篷外的越来越多的藏羚羊群。因为天气很冷，所以进羌塘以来一直都是穿着鞋子进出帐篷，趁着好天气晒了下郁闷的脚丫子。手上出现了三个裂口，脚掌上有一个，裂口有四厘米长，看着很恐怖，其实一点感觉都没有。脚趾有一半磨透皮了，有针痛感。取出药品袋发现只带了四片创可贴，严重失误。手指关节处的裂口自有了后就再也没有愈合过，直到出了无人区，几十天里总觉得手指随时会掉下来。其余的裂开不知不觉就好了，然后其他地方新裂口出来，周而复始。裂口产生和干冷天气、缺少维生素有关。雪消失的很快，这是此季羌塘特有的现象，由于湿度低，太阳辐射高，雪会很快被蒸发，蒸发的速度远大于雪自身融化的速度，所以雪消失后的地面还是干透透的。（这也是羌塘雪线特别高的原因。）一般情况下，雪会在下午两三点后蒸发的只剩下2/5了，小块地面路出，到了第二天就完全可以行路了，第三天只有些阴坡、沟壑、潜冰上会存有些小块雪。所以，一场大雪可以维持三天饮用水。一个后驮包裂开了，DEUTER最贵的一款防水驮包，关于驮包的问题日后详说。 大雪覆地，今天是走不了了 听着音乐，抽着小烟，暂且还有愉悦的心情 迁徙的母藏羚羊，估计是去黑石北湖方向集中生育 雪水是极品，但太消耗汽油 天气尚很冷，一直穿着鞋子进出帐篷 逐渐被蒸发的大雪 防水驮包这么快就不防水了，更担心的是他彻底脱线 最坚持的裂口之一，两个来月不愈（DV拍）谢谢骑士追贴，月华与你。由于单人所以自己的照片很少。带了线控和遥控，线控拍星轨用，遥控自拍，两个都没用过一次，白带了。用DV自拍了些。上了张“裂口”照片，有人背景，勉强入眼。今天估计不更新了，写字挺累，还消耗香烟。关于食物装备总重在200斤左右，包含车子本身。其中食物总计100斤左右，分列如下。主食：糌粑50斤（丢弃一斤），压缩饼干25斤。辅食：大蒜4.5斤（腐烂半斤），酥油4斤，花生米4斤，盐2斤，麦片2斤（丢弃一斤），紫菜1.5斤，辣椒粉1.5斤，奶粉1斤，白糖1斤，茶叶1斤，巧克力0.5斤，虾皮0.5斤，调料包0.5斤。食物以糌粑和压缩饼干为主，零食可忽略不计。在羌塘大体力环境下，每日摄取热量至少应在5000大卡，显然食物携带量要达到这一指标是不可能的。上世纪早期以斯文赫定为代表的西方人首次触及这片神秘疆域，虽然他们带了大批活羊鸡什么的，但捕猎还是非常重要的补给手段，那时野生动物太多了，也没有现在的动物保护观念。能坚持就不要打动物的主意，再则一个人在没有机动装备情况下猎杀动物是非常难的，没有想的那么浪漫。言归正传，本次旅行每天摄取食物热量有如下四个阶段。一、克制期，前45天里每天摄取热量在1400大卡左右，大致4两糌粑和2.5两压缩饼干，一些汤料为辅。摄取热量属于中度饥俄状态，下午四点以后基本就无力了。此阶段食物控制的极为严格，以至于45天里消耗的主食才30斤（另有三天意外补给，后文详述）。二、提升期，由于前期食物控制非常成功，所以总行程过3/5，食物却消耗2/5，因此每日口粮提升至5两糌粑和3.75两压缩饼干。但仅一周后，食物就完全失控了。三、失控期，从第52天开始，食物完全失控，原因既有生理上的需求，也有精神上的欲望，每天夜不能寐，脑海中总是一幅山珍海味的蜃景。控制力低下时，干吃糌粑粉都能吃掉半斤，如零食般。四、超控期，第64天开始至74天遇人救助，每天食物热量摄取不足800大卡，少于身体基本代谢量。从食物种类上可以看出，为了控制负重，食物以热量转换效率高的碳水化合物为主。零食基本没有，花生米都觉得不该带，因为后期会控制不住，花生米会被当做美食很快消耗掉。全程无肉，吃过一次蔬菜，微量元素靠金施尔康。没有动物脂肪的缺点是，抗寒力和身体耐力会下降，例如生活在北极圈的爱斯基摩人，不吃肉是没法长久活下去的。水，始终是个大问题，期间断水多次。后期虽雨季水多，河系泛滥，但水质多混杂不堪，时而无奈。纵观全程，饮用清洁地表水的天数约占20%，融雪和矿水（包括轻度盐碱水、泥沙水等）各占40%。可见若无雪则命不保，当然轻度盐碱水喝多了麻烦是非常大的，后文详述。 标准早晚餐，糌粑+辣椒+大蒜（借用去年照片） 自制辣椒酱，不带成品辣椒酱进无人区，重量大，辣椒粉自制重量比高（借用去年照片） D14（5-03），25.2K，宿营5118M通过坐标确定了今天日出时间，八点十分（时差比北京时间晚两个小时左右，前期日出在八点左右，后期稳定在七点四十分左右），目地就是要感受下清晨低温，羌塘一天气温最低时刻是日出前半小时内。自离开硬路每天均速才16公里，而我必须要达到均速20公里才有可能完成计划中的旅行，否则……加上大雪封路、地况特糟、生病、洪水、偷懒睡大觉等突发事件，所以每天行距尽量超过20公里才行。根据去年经验，均速20公里是很难达到的，推行不仅比徒步慢的多，还对地况严苛。唯一解决的办法就是早起，在冻土最甚的时候多赶些路。羌塘早起是很痛苦的事情，蚁力神，谁吃谁知道。前几天都是等太阳先起我才起，然后烧水、晾装备、收拾打包等琐碎，实际上路时间都十点多了。帐内温度－11℃，外面－16℃，无风，没有想象的冷。一番折腾后9.37分正式上路。虽只比以往早走半小时多些，但地面感觉却好的太多，加上今天红土居多、大雪湿气，地面冻的更硬，仅三个小时，推行距离就有12公里，将近当天一半路程。羌塘日照时间长，剩下的一半路就是慢慢耗，能走多少是多少，一般耗到下午八点左右扎营。当天8.49分扎营，行距25.2公里，等于后面八个多小时耗十三公里。重装推行是徒步者难以感同身受的。我也有过多次极限徒步经历，那种煎熬远没法跟推车比（大负重除外）。早起痛苦最大表现在呼吸道上，大运动大呼吸量，使得更多冷空气进入体腔，有如一根冰凌直接插进气管直触胃部，鼻涕哗啦啦的。口罩？有经验者会明白为什么不戴口罩，不多说。下午六点进入稀疏的草地，彻底绕出湖盆，部分地面稍融，大雪还是有些影响，地面看似干燥，但轮胎一过就沾满泥沙，卡死轮胎。最后选择一处坡地扎营，因为这里的野生动物很多，藏羚羊、野驴、野牦牛都有，人多热闹。 羌塘一天温度最低时刻在日出前一秒 早行半小时，地面的硬度就有明显的差距 今天藏羚羊很多，却很难发现，片雪白云混淆，动物草色相近 稀疏的草地，土质很粘，看似干燥 轮胎时被卡死，沙土并不烂，却是粘性十足 当天宿营地，附近野生动物多，热闹，近九点的光景，相当于北京时间七点 帐篷坡顶慢悠悠掠过的羚羊，好奇的会瞥上一眼 D15（5-04），26.2K，宿营5011M今天是个小节点，之后日子只要天气不特殊，早起时间都将比太阳公公早半小时，尽量早行，充分利用冻土硬度。因此晾装备也取消了，好在丁丁的防水睡袋非常好，但里面的湿气却没了时间排除，明显重了一些。因为今行又比昨日提前半小时多，那地面硬的居然可以小骑一段，小骑绝对指下坡，丘陵地貌，但前货架在颠簸下会松脱。最郁闷的是清水鼻涕，如滔滔江水绵延不绝，黏在胸襟上不久即冰。当下午开始留意片雪时竟无发现，茫茫大地真绝情。一直推行太阳快下山才在一处坡顶发现一米见方的积雪，缘分。扎营时间常态下不会在太阳下山以后，太冷，光线也不利于观察地貌。今天比较累，时间长，翻了不知几个大坡，铲雪融水也折腾了一番。晚上第一次用了湿巾，擦脚，脚是荒原旅行的命根子。 中途一处特殊地貌，山坡上突兀着众多城垛模样的沙石堆，查看确是自然形成 前日大雪融的难见踪迹，茫茫荒原真绝情 光线作画，绚烂的黄昏，绚烂的大地 营地不远的坡上有一片小积雪 烧水空隙，掀开帐篷，拍了这张火烧云 D16（5-05），19.5K，宿营5033M今天起的更早，这两天十分干冷，帐内都在－10℃上，怕赖床，定了两个闹钟。今天按地图线路指示从碱水湖和拜惹布错之间插到羊湖方向。实测地形才知两湖由此起彼伏的山坡阻隔。通往两湖之间的路极为荒凉，死寂，动物不见一个，少见。地软，今天在路上耗了十三个小时居然差0.5公里到20，略郁闷。下午三四点的样子在左手山坡上又发现个大地三角点，决定爬上去瞧瞧。爬山俨然是种休息方式，挣脱桎梏的鸟儿，桎梏就是看一眼仇恨一眼的自行车。铁塔下零散着许多罐头皮，烧得黑黑，里面充满沙土，或许是当年架铁塔的解放军留下的。铁架顶端有个大鸟窝，毫无疑问是乌鸦的闺房。在羌塘，荒芜是主题，却时时有如幻境，那些野生动物不真实的存在着。尤其有一种叫“哦哦”的小鸟，近乎每天都能听见他们在帐篷外叫床，只两个旋律，“哦-哦”，“哦哦”比麻雀还小，多成双成对。所以，当看见这个鸟窝时我就想起“哦哦”，他们如何在恶劣的羌塘生存，晚上又栖息何处？要知道，羌塘没有一棵树，超过膝盖的草也找不出几根。“哦哦”带给了我太多的感悟，每天听着他们的叫声，开始着一天的旅行。虽从两湖之间经过，却不见真容，在铁塔坡上北望才勉强看见白乎乎的碱水湖。而失落的是水，一路连个雪影都不见，倒是白色的盐碱骗的我几次枉寻一番。到了天黑才扎营，水袋里还剩一点水，没喝没吃，留着明天早晨用。昏暗的光线中，忽然发现对面半坡上有一只健壮的藏羚羊，且是此行首见的公藏羚羊，所以格外注意。他威武的伫立着，一动不动的注视着我，心理素质之强在羚羊界少有的。相视一会，两只母藏羚羊出现在公的身后，稍有不安的游移，公藏羚羊依旧，气势逼人。我似有明白，这是发情期的羚羊在保护爱妾。刚想入睡，大风四起，夹杂着雪花，雪不大，难以估算落到够我融雪的厚度需要几时。没去理睬，抽了根烟，最后一根烟，抽到很细心，然后在呼啸的风中沉眠。 位于碱水湖和拜惹布错之间的三角点，顶端有一个大鸟窝 坡顶北望碱水湖，隐约白乎乎 入睡前风雪起，但要积到融水的厚度尚早，今夜无水无食，抽掉最后一支烟 D17（5-06），28.9K，宿营5003M早晨，雪还是极薄一层，用纸片轻轻的掠，好歹扫出一小堆雪，加上剩水够一顿饭用的了。查看地图时才注意，此点居然是我第二条备用逃命路线。第一条是克里雅山口，早过了。在已知的仅靠自力穿越记录中，没有人能超过此点，因为前方是更广阔的大羌塘无人区核心，前退都很尴尬。其北面的昆仑山脉有一条著名的库亚克大裂沟，约十五天时间可到达新疆的最近居民点。2002年美国人瑞克·瑞吉韦等四人便是遵循此路线进入新疆。所以这个点是道坎，过了这个点后最近的逃生点也得一个月以上。我自省一番，觉得状态不上不下，很中庸，就像平日的某个清晨，毫无思绪的开始无聊一天。算是尚可吧，继续往前，就这么不小心人类第一次靠自力横穿羌塘。横穿路径一直贴着新疆和西藏的分界线，巍巍昆仑一直横亘在北方天际。过了碱水湖，昆仑山北弧，此后再难相见。晨温比昨天高三度，地很硬，出门就是一个大下坡，两小时追掉十公里，超爽，然后进入一片边际难寻的古湖床。十一点的时候来到“陷车点”坐标，这是一条连接碱水湖和拜惹布错之间的河，2003年由一支记者组成的汽车穿越队陷在此河，通过卫星电话向新疆军区求援，后被西藏方面救出。此时，宽阔河道近乎干涸，只有东侧边缘有一条三米宽的水道支撑着。水质很差，强碱水，味如漂白水，连冰也是苦涩不已。奇迹在一条浅埂上，居然有一片积雪，在水袋里先装了一点碱水，然后装雪，让之一点点融化。继续湖床，平坦而坚硬，阳光炙烤，迷迷糊糊的推车，速度竟也极快，类似一种催眠状态。下午云会从西方天际涌起，向东方漂移，一朵朵的偶尔遮蔽。云遮时，拉上拉链，云过时，打开拉链，羌塘的温度变化一朵云都能极大的左右。下午发现一块“大地水准点”，依旧是当年测绘兵所留。七点才走出湖床，上了稀疏的沙草地，一片野草豁然眼前，终于再见生的气息。 过河小麻烦，内有沟壑，软沙陷住， 漫无边际的平坦湖床，一种催眠状态推行 水准点，向当年的测绘兵致敬 终见生的气息，虽然沙草地极难行走 D18（5-07），25.7K，宿营4974M今天翻越碎石山，海拔不高，山势少有极陡处，碎石铺地，路面较硬，近二十公里上坡，下午六点抵达山口，用了九小时，后急速下山六公里。在山口北眺可见昆仑山系，已是极远了，之后日子难再见昆仑。后驮包又涨开一大口，用帐篷胶布勉强粘了下，再用4毫米登山辅绳捆束，否则驮包命不久矣。另两个DEUTER驮包一个背板被货架磨破，一个横杆处裂开。还有一个廉价的DOITE驮包，车友用的比较多，去年走羌塘用的，补了今年丢失的DEUTER驮包。DOITE驮包多天前就断了一个卡扣，一直用绳子挂在货架上，全程再无故障。不得不提DOITE驮包，除了卡口外，质量非常好，其实比昂贵的防水驮包更适于恶劣的羌塘环境。苦恼还是水，以为碎石山上沟壑里会有些残冰，却是碎石一片，燥风猎猎。六点在山口放眼前方，天空阴霾，风暴云游荡，山脚不远处有一个白色的湖泊，便锁定方位，抄直线下山奔去，看似咫尺，遥不可及。干涸的河道里发现一丝水痕，薄的用嘴也吸不起来，且是极碱水。又是一个奇迹，居然捡到两瓶矿泉水，生产日期3.15号，我怀疑是不是早前有探矿的深入羊湖一带，至少不会是近18天留下的，一路独我，又或许是方向一致路线有别绕到了我的前面？顾不得想那么多了。八点半大风，且风向乱了，西方急转东风，黑云压顶。赶紧扎帐，手忙脚乱，地钉被吹起的帐篷弹走一根，此时才发现没有一根多余的了（好像总共有10/11根地钉，记不清了），这些天都被吹走了，竟无留心。只好一番细找，把先前吹走的地钉找到，一共就剩七根了，少一根都无法基本稳住帐篷。此后，这七根地钉宝贝似的，就是被风吹到天涯海角也要找回。再前后陆续，帐篷袋、地钉袋、帐杆袋、地布皆被风挟至荒野，消失的了无踪迹。此说HW1.5层单人帐，由于设计问题市面上基本买不到，然而却是最适用羌塘穿越的，这个结果是考察了所有国外国内品牌单人帐中偶然发现的，700（或是670，记不清了）银子进货，物美价廉。另说，今天营地4974米，十八天来首次下海拔5000米。想念山上看见的湖，明天上午就可到达。 载物太重，驮包撑开 北眺昆仑，隐约一道雪山便是，与他越行越远 碎石山典型地貌 山顶平缓，小坡连绵，难以确定主山口 放眼前方，风云四起为什么称这张龙卷风照片罕见，因为是一种龙吸水模式，顶端盘旋着不断壮大的云团。很幸运，遇上。羌塘，气候的变化有时是超越想象的。羌塘腹地我是难以到达了，看了丁丁的穿越日记，对比楼主前17日的行程，可以对羌塘简单遐想一下。羌塘西部由于高寒干燥，植被稀少，野生动物也相对较少，而羌塘与可可西里接壤的东段植被以及动植物都较丰富（从丁丁他们如此频繁与熊、野牦牛遭遇可见一斑），对否，望楼主指正！！羌塘东西南北野生动物都是多的，没有孰轻孰重，只有人进动物则退的区别，唯有中间一块稍微少些，因深受西风环流带影响，印度洋和太平洋暖湿气流也皆难到达，所以常年寒旱，被地质学家称为“亚洲寒旱中心”。但羌塘又是幻觉的，“寒旱中心”仅四五日动物罕见外还是很多，尤其狼。明日就见了一群规模较大的迁徙藏羚羊种群。前十七日动物还是非常多，经常和羚羊野牦牛头碰头，只是见多不怪了，不再描述。同时，遇见野生动物也是机遇，阿尔金路线也涉及，我却没一天见六熊。相比较来说，野生动物最密集的地方是若拉错，多到有如牧场，这与季节也有关系，春天来了，山上的下来了，躲在被窝里的出来了。闲扯，中国对羌塘的长期深入考察是极其缺乏的，更别说什么动物专项了，科学家的深入还没有盗猎者的零头多，包括此行也是走马观花，见到的成了数据，没见到的便是零，不能成为体系，只是个人感受而已。 D19（5-08），23.5K，宿营4942M昨天下午在碎石山上看见了日冕，晨起果然大风，下午五点，狂劲北风夹杂着小冰雹把左脸都快要打烂了。风暴持续一个小时后停歇，风没了先前的张狂，蓝色天空也显露不少。推行不久便在一条沟里遇狼，先是一只狼从前方沿着土埂小跑。又觉得眼花，田埂后有一黑物闪烁，果然也是只狼，便盯着隐狼看他去向。隐狼完全现身一会后又不见了，再看前狼朝我直奔而来。我靠着车子密切注视，他开始时而横切时而直行时而扑腾，慢慢接近。心里略有紧张，或许是激动，此行首次遇狼。回头查看退路，以便紧急之需。却见另只狼像尊罗汉似的蹲着，没有理睬他，他的行动受前狼操控，只要和前狼关系搞好即可。僵持了十多分钟，前狼也没再敢靠近，左右徘徊着。受缺水影响，又这么僵持着，心里极郁闷，朝狼呵斥起来，什么两块肉过来啊，爷正缺吃的之类的。前狼一顿，后退两步，随后和后狼汇合从土埂后面远去了。相比狗，喜欢狼，不干你时绝不吭声，干你时绝对血盆大口，哪像狗，汪汪个不停，虚张声势。下午一点才到昨日看见的湖，不看不知道，一看气死人，这水毒的远离水域就扑鼻一股恶臭，令人窒息，白色部分也非冰雪。奇在湖边生长着一些腌菜似的植物，也是臭气弥漫。再远些的干燥地方布满鼠洞，地面点缀着稀疏的针茅草，还二度发现甲虫。这种不可思议的生态关系令人费解。下午一场大风暴停了不久发现一根木桩，估计下面埋着水准点，木桩是地面标记。水，水，水，一天不见。 狼，欣赏，不乱叫，一叫定血腥 来到昨日山口看见的白湖,腐臭扑鼻而来 甲虫 鼠洞，白色是盐碱，很难想象这是一种怎样生态关系 水准点上木桩标记 D20（5-09），35.5K，宿营4905M八点出头就出发，急需找水，所以使足力气快行。途中被白色盐碱骗了多次，最郁闷下了一条大沟，回途纠结，受侥幸心理驱使的频率过高了。 九点半的时候遇见一群规模较大的藏羚羊群，雌性，可能是前往昆仑山某个未知湖泊集中生育。羊群不怎么怕人，慢悠悠在前面横切，避免打扰，我放倒车子让他们先行。近十二点，发现一块平滑的黄地，干硬了得，如岩石般，其小沟壑里居然藏有一层薄雪，喜出望外。雪薄，选些稍厚的用手指轻掠。雪的密度很低，又非冰体，所以扒遍沟壑约取了一升的水，解了燃眉之急。因一路下坡至羊湖湖盆，便想再拼一天多赶些路，早遇水。水不见一滴，天色却大变，近八点扎营。吃了一块压缩饼干，喝了点水底子，浑身无力。天黑时风雪四起，把帐篷吹的稀里哗啦，我也懒得等雪，便睡下。约十点，忽然听见有人唤“英雄……”疑似幻觉，风声作祟，可“英雄……”越发明晰。扭过头看见一丝微光，打开帐篷，天啊，居然一辆越野车停在外面……司机透过车窗兴奋的说，在饮水河迷路，然后回铅锌矿问路，矿上人说有一人骑车进了羌塘，不知去哪里了，他便跟着我的车印子一路追踪至此。而他们进入羌塘是因为一辆大车坏在前面，去修车的……由于风雪飘摇，寒风刺骨，简单交流了两分钟，他们便赶路去，说明天能遇上。临走前我讨了瓶矿泉水，一口气喝完。然后半夜难眠，既兴奋，明天可遇人，说不定能吃顿热饭，又紧张，不知他们是什么人……但至少不是坏人，又觉梦幻，看看矿泉水瓶确实无疑。另一说，矿上人说看见我，还劝我不要前行是胡诌的。估计第一天在羊圈休息时，夜晚开车经过看见我靠在外面的自行车，随后又发现车印拐向深处，才确定有人进去了。去年我和流虻、多啦两伙皆遇矿人，他们俩甚至错路骑到矿上，因此矿人有了前事可签。 途中所遇一群较大的羚羊群，通常，百只就是大群 经过一硬地，沟壑中发现今日之水，左下可不是兽迹 D21（5-10），20.6K，宿营4809M大早起，奔向热饭。昨夜雪不厚，中午即化的差不多了，再则也顾不了这么多了。一路下坡，页岩地面，虽对昨夜之人不甚了解，但在这无人区深处遇人总是梦幻之事，脑海里也早已勾勒出一幅豪华营地、肉香汤热的美景，所以趁坡势强行骑车，一不留神车被片岩爆胎。近五点来到传说中的英雄地，这是上世纪七十年代三大军区联合测绘会师的地方，因而取名英雄地。八十年代，中科院考察队曾横穿至此，因前路恶劣折返，直到本世纪初，中科院与商业联姻，才对羌塘进行了连续三年的大规模科考，羊湖便是最后一条科考线路。近七点到达羊湖西侧，风暴中终于看见昨夜之车缓缓开来，后一辆卡车，共四人。昨夜说话之人李哥随即给我一杯预备好的热咖啡，感动。大风，冷，车下寒暄片刻便挤上大车。他们极为热情，又狐疑满腹，说没见过这么玩法的，说我一个人肯定带了卫星电话，还检查了证件……而我只想着蹭些补给。大餐不见，豪华营地没有，总得有些香烟。他们也是麻烦一堆，补给不多，最后给了大约三天食物，些许蔬菜和水果，散烟合两包，馕等，见此，觉得自己从未如此富过。这就是前文所说，在前45天食物克制期里意外获得的三天补给。双方都很激动，但只聊了一会，他们便要赶路从界山大阪出无人区，临走再问“真不要跟车回去？”二十天来，奇迹遇人一小时，获三天补给，下次再遇奇迹是53天后了。恍然如梦，那夜羌塘风雪听见“英雄”的呼唤，今生难以忘却。就地扎营，水果狠吃一半，缓过神来，决定休息一天，太累了。 一夜风雪将帐篷吹的稀里哗啦 首爆胎 传说中的英雄地，会师情景，可以想象，他们才是英雄，后人按图索骥 D22（5-11），0K，宿营4809M有了额外三天补给，休息一天并不觉浪费了。两棵小卷心菜、两根小葫芦瓜，若干西红柿，个头还挺大，74天里唯一蔬菜，算上后期，将近80天了。依河，依湖，以为水不缺了，没想盐碱味甚重，可怜了蔬菜。更糟糕的是靠近水源是稀烂泥地，取水提心吊胆，而稍微洁净的冰又远离岸边。闲扯一句，盐水的冰是淡是咸？很多人困惑这个问题，答案是即不是淡水也不是咸水。冰是单晶体，理论上，一旦结冰就盐水分离了，但在实际中，冰体中含有大量盐泡及混杂物，所以他不咸不淡。下午准备把脏袜子洗掉，找水却是大问题，因为近不了水，稀烂，陷人，后找到远离水域的沟壑之水，同样稀烂不已，悲愤。下午做针线活，缝补裤子、羽绒服，裤子裂大口，是材料在恶劣气候下老化所致，后期更是溃烂的连犀利哥也不会瞧一眼。但还是得一针一线，不能马虎，为了减轻负重，我没带一条备用裤，连轻薄快干裤也没，包括鞋。现在回想，不可思议。湖边转了不少地方，但都不远，羊湖东面的独尖山清晰可见，他是羊湖的标志，谋杀了不少快门。晚上又狠吃一顿，撑得弯不了腰，幸福的再点支小烟。晚上变天，狂风大雪，估计明天走不了了。并不急，趁势好好休息。为了快速穿越寒旱带，多天来起得比太阳早，一天推行超过十二小时，休息时间超过五分钟就觉得是犯罪，再不缓口气迟早会跨的。身上已多处不适，尤其右腿，血痂已和内衣相连。上陡坡停顿时全靠右腿抵住脚踏不至下滑，久之便斑斑，刚结痂又被抵破，反反复复。而意外补给给了我一个难得喘息时刻，感恩。 比彩票概率还低的蔬菜，感恩 眺望羊湖东侧独尖山，羊湖标志，看山跑死马，还是很远 腿是陡坡的主力刹车，但不耐磨损 洗袜子的沟壑，岸边碱渍，貌似干硬，依然稀泥 这就是取水、洗袜子……遇水的代价，还不是好水 风雪再起，羌塘换了规律，夜必风雪 D23（5-12），0K，宿营4809M睡了懒觉，掀开帐篷，一片白茫茫，分不清湖与地，今天终于不需喝羊湖的水了。纠结的是，雪融，沙土粘性十足，一抬脚两斤泥，这不是一个好兆头。羌塘的年温差不大，日温差大，顷刻可冰雪，顷刻也可晒的人皮开肉绽。白天的绝对温度高，意味着冻土消融将提前。温度也不仅是温度表里的，他是一个多因素，受空气温度、湿度、光辐射、风速，四大因素结合才是一个真实的温度，体感温度，还得加上运动量。今天闲暇，做了个简单对比。下午两点时，测得帐篷里的温度居然高达32℃，裸浴都行，但到了有风的帐外还是得穿羽绒服。然后趁天气还不错，取了扳手弄货架，转瞬一朵大云遮天蔽日，风速加快，五分钟大概，我的手就冻麻木了，一不小心还伤了手，赶紧丢下扳手，跑到帐篷里避寒。纵观整个旅程，这种温度的体感差异就更大了，有时间再细说。 融雪，稀泥，水 也是错觉的地面，很是泥泞 风暴开始酝酿，半小时候，天色全变 D24（5-13），28.1K，宿营4805M八点半就出发，天寒地冻，原本想多赶些路，谁知在河湾里绕了四个小时才出来。早晨沿着地图上的河界走，尽头是一片湖滩挡道，四处探路，无法通行，逼近十一点，地面有些融化，一想起昨天一脚两斤泥的画面，头皮发酥。赶紧往回绕，选了一处稍硬河床强行推到对面山脚。山脚土质不似湖畔泥泞，却十分松软，一直耗到下午三点钟，才推行十公里。后面十八公里是个奇迹，源于羊湖北岸异常平整坚硬，多数可小骑。在羊湖岸边骑车的感觉非常美妙，湖水波澜，远山淡淡，风也知趣，此行最难忘的一段骑行。6.40分就停下了，一番游玩，登上了竖有铁塔的山坡，还发现了中科院考察队前几年竖立的“金字塔”。初见山坡上有道金光时，蓦地想起一位朋友，曾问我为何喜欢羌塘，我说火山多，有宝石，有金子……越近山顶，金光越闪，心想，莫非真是金子？果真带块金子回去，看你以后还敢说我吹牛。晚上扎营在湖边，全天吃馕，之后，再度自力更生。入黑，又如昨日狂风大雪，加固帐篷，这可是咫尺湖畔，好比玩火自焚。进入五月中旬，季风交替，羌塘深处或多或少受到影响，天气越发没了规律，已连续四个晚上风暴起。 羊湖北侧眺望羊湖标志 暮色羊湖 耸立羊湖岸边小山上的三角点 中科队的“金字塔”，只放字面，上有赞助单位，鼓励 D25（5-14），22.3K，宿营4867M破冰，水袋里打点盐水底，然后把雪压实一点点装入。雪装水袋个人体会，雪一定要压实，手指捏成团，要有挤出水的感觉。新雪、风化雪、粉雪密度皆很低，只有水的十几分之一，若不压实，即便水袋装满，小口水矣。苦的是手，压实两升雪就会冻僵，但值得。二是水袋里打点液体水做底，会利于雪融化。若是轻度盐碱水，被冰雪稀释后也会好很多，另外盐碱水冰点低，比净水更利于冰雪融。三是就寝前将水袋放在头部垫子下，既做了枕头，也保温了，否则翌日定是冰坨一块，浪费汽油还不算，问题是根本倒不出冰来。今天直奔独尖山，那年科考志愿者称之鹰嘴山，地图上，独尖山。据说山顶确有鹰窝，或者鸦居？天气差，大风，时而冰雹。又是傍晚时分，风速骤然增剧，密集雪子遮蔽视野，能见度数米。此般天气，皆顺风放倒自行车，蜷缩在包后。趁风雪小了些，赶紧扎营，生怕更猛烈的下一波。果然如此，搭好帐篷，按了两下快门，这天就完全黑压压起来，连续第五天风暴。 晨，冰雪羊湖 近瞧独尖山 趁风暴暂缓，赶紧扎营，地上非雪，是冰雹，雪的前奏 D26（5-15），31.3K，宿营4903M今天的状态超常，大雪涌进帐篷，雪漫四处。路硬，红土面，抖抖鞋子里的雪就穿上走人，也没吃饭，准备待到土软之后才吃。时间就是效率，适用于羌塘。雪一直到下午两点才化掉大半，路也神奇的这才干软，一点不湿，雪留无痕，极不真实，数小时前还是一片白茫茫。草地上残雪与白云恍惚，美，却极易视觉疲劳，迷了天空与大地。吃饭时选择一处羚羊多的地方，边吃边看，藏羚羊初始有些羞怯，慢慢的也就放松警惕，认为我不是披着羊皮的狼，靠得近了些。公藏羚羊终于回归草原，还夹杂着母藏羚羊。此季尚是生育季节，母藏羚羊应在别处做月子，为何公母混群了？这点，看的有些不明白。或者，羊们也有羊的私生活，人类并不知晓全部秘密。还疑惑的是，羊湖东侧与西侧地域环境雷同，为何野生动物一夜间冒出似的，星星点点在草原随处。或许，节气就差那么一天，局面就大不相同，或许，巧合，缘分。下一坐标，耸峙岭雪山，凡向雪山行，皆有沟槽循。天高云阔，望山而去，意识似乎先行到达了。 风雪涌进帐篷，无暇顾及，抖掉鞋子里雪，饭也不吃，去响应时间就是效率 残雪与低矮白云，时常混淆 天高云阔，意识似已先行到达了 公藏羚羊回归草原，其实先前也是在草原 D27（5-16），23.8K，宿营5145M通往耸峙岭雪山，缓上缓下，是一片稀疏的草地丘陵。耸峙岭海拔6370米，是重要的地理分界点，他便是可可西里山脉西部源头。是的，同学们，我们进入了可可西里，欢呼吧。行政上的可可西里保护区只是可可西里的一小部分，人为的划分。国家在划分这片广袤荒原时以省界为界，分为了西藏羌塘保护区、新疆阿尔金山保护区、新疆昆仑山保护区、青海可可西里保护区。实际上，长达四百余公里的可可西里山脉绝大部分在西藏境内，包括主峰岗扎日。同时，耸峙岭雪山也是此行的一个重要里程碑，前27天依偎昆仑山脉一路向东，后27天则依偎可可西里山脉一路向东，直至到主峰岗扎日后转向北方，再二十多天纵向翻越可可西里山脉与昆仑山脉……“可可西里”是蒙语，意为“青色山梁”，过几日后，可可西里山梁之态才会完全显露，青色则因人而异了。下午六点多上到耸峙岭雪山下的一片雪原，硬雪壳，块状分布，间隙生有凄凄黄草，冷。雪壳很难推行，他无冰的硬度却有冰的分层特质，所以轮胎很容易压碎雪壳，再一点点破雪推行。几度欲放弃，待到明日晨行，想必雪壳会硬很多。探路过程中却有了惊人发现，在一条宽阔的河床里居然有一条清冽溪水，天啊，这是二十一天来首次见到的可直接饮用的地表水，简直乐疯了，想着今天无论如何也得把自行车推此扎营。先前，就确定了会经过雪山下面的伏沙河和降龙河，但并不认为能遇水。一路行来，地图上标示的河流此季中无一不干涸。实际上，明后天的伏沙河和降龙河确实无水，却没想到在一条地图上无标示的河里居然有溪水。搭好帐篷去打水，溪流表面已结了薄冰，破之取水，格外酷寒，水杯捞起转瞬间杯壁上便结了冰。手冷的不行，几秒就冻僵，换只手取水，反复。一边烧着清冽的溪水，一边欣赏着金色夕阳，一地碎金，铺垫在荒原上，这种金色不是形容词。遗憾的是，我们永远无法拍出金色的赐予者太阳，在羌塘，即便太阳落得只剩一个边角，依然刺眼的不会与众生对视。 耸峙岭雪山下的雪原，上一层硬雪壳 终见洁水，举国欢庆 金色夕阳，羌塘的颜色，碎金一地 在羌塘，即便太阳落得只剩一个边角，依然刺眼的不会与众生对视 D28（5-17），0K，宿营5145M耸峙岭雪山有太多含义，他不仅是地理界点，里程碑，水圣地，同时也是我生理上一个转折点。昨夜，沿袭往日，入夜后不久风雪袭来。深夜，风雪停了，而我糟糕的身体感觉却愈发加剧。大约凌晨三点，实在无法控制，披上衣服钻出帐篷，蹲在雪地里一通狂拉，瑟瑟仰望，也是此行第一次欣赏羌塘星空。要知道，羌塘的夜有多寒，晚上钻进帐篷后打死也是不会出来的，所以原本带了个线控拍星轨，不仅一次未用，就连星空也不多见。纵观全程，若不是三次因恙夜起，羌塘星空哪能相见。星空我划为三等，一是黯淡星空，世界大多地方可见。二是灿烂星空，只有偏僻荒野可见。三是水波星空，星辰点缀在片片光芒中，如水波荡漾，在极高山巅可见，高域羌塘却是寻常。晨醒，身体依然难受的不行，胃绞，无力，恶心，反酸，臭屁。实在起不来，病躺一天。这种症状即不是拉肚子也不是胃病和发热，我也只得过一次，便是去年羌塘之旅。所不同的是，去年是即出羌塘所得，很快调理了过来。而此次症状居然一连50天（除了断水两天），直至出了无人区就蓦然好了，不打针不吃药。症状后续平缓下来的反应是：每天平均拉三次肚子，饭后十分钟后定是反胃，一股股酸味，然后放屁不断，也是酸味，不怕笑话，一天数百屁算是少的。身体其他方面倒无大碍，偶尔胃难受一会。所以，之后，在羌塘里一连拉了50天肚子，出来即好，兴奋的发短息给一个朋友说“昨天终于硬了”。心情很是沮丧，又耽搁一天，我已经停不下来了，原地踏步是一种煎熬。好在下午一对狼探望，依旧，一只在帐篷前面，一只在帐篷后面，前面的狼折腾一番后，居然匍匐在地，用下巴蹭着地面玩，翻滚，耍泼，再静坐……如此一小时，后汇聚走向耸峙岭雪山深处。 抽空，晾装备，电池充电…… 荒野来宾，相互守望谢谢各位，备受鼓舞。 D29（5-18），27.8K，宿营5020M昨夜，沿袭，连续十天夜风雪。身体还有些不适，今天反而行得早，无暇顾及。为了控制腹泻，晨晚皆没吃，全天靠中午两块压缩饼干，居然走了近三十公里，当天日记写下了个“牛”，自我鼓励。全程下坡为主，顺干硬河床，天气极好，我需要的干冷，羌塘很体恤民情。鞋面一处裂开，好在干雪难以快速渗透，抖抖即掉，但想着以后春暖花开……实在不敢想，得过且过。藏羚羊很多，已经分群，多十来只拉帮结伙，全公是黑社会，有母有幼是四世同堂。又遇狼，猥琐，想象着同一片草地上，狼和羊会演绎怎样的惊心动魄。是拔刀亮剑拼得你死我活，还是“嗨”一声，各奔前程？我的答案是后者情况居多，狼的速度比羚羊稍慢，好比夏利追QQ，这比搞只鼠兔来说难太多了。当下羌塘，的确是那些野兽的黄金时代，不愁吃不愁穿。太多了也不好，不够吃就相互残杀，高级灵长类动物已做了表率。十九点多，看见一座“城堡”，便想着那处扎营，赶了一个半小时，他只大了一点点，无力扎营。羌塘的距离很难测算，一是过于平面化，二是缺乏地标物，三是地貌变化小。会导致你把一个很近白色塑料桶看成遥远蒙古包，更会把一座山看成几根烟的功夫。更为麻烦的是地面辐射导致的光线抖动，视场紊乱（空气密度也会不同，光线折射），尤其烈阳下，稍远处的石头便会强烈抖动。白色盐碱辐射微波就更大了，即便用望远镜拉近也难以分辨，所以导致多次误冰雪跑冤枉路（某些时候是非常严重的后果，甚至致命的，D38天遭遇）。想体验这种辐射很简单，太阳最辣的中午，找一栋大楼，眼睛贴着墙壁，向上望去。所以，望远镜是羌塘旅行的重要装备，但使用他是个苦力活。我的是望远镜规格10×25，要端稳望远镜分辨出怀疑物是非常难的，长焦抖动，平面空间更被压缩，抖动中的抖动，这需要平抑呼吸，持稳，耳水平衡，心率……三五秒便会有头晕眼黑恶心的反应。即便如此，望远镜使用频率每天也要十几、几十次，谁知道土堆不是一处外星人古迹，谁又知道那块黑石不是撇大条的熊。 晨起（个人很喜欢的一张营地照） 上午雪，薄，密度高，很适宜推行 藏羚羊开始分群了，但似乎又早了些 D30（5-19），27.2K，宿营4972M夜风雪暂告段落，羌塘恢复规律。早起，跨上车，沿着冷透透、干硬硬、平缓缓的河床一路下溜，爽的脸都抽筋了，冷的。约八公里才到昨天看见的“城堡”，是一处风化土山。今天一路许多这种逼真拟物的风化地貌，有似房舍，有似羊圈……对于非专业人来说，把楼兰古城的残垣与之对比，绝对后者更牛更实体。下午，进入苦不堪言的沙草地，天气变的恶劣，狂风大作，沙尘四起，眼前一片昏黄，视野近零。是的，就是沙尘暴。测量，瞬间最高风速达到了27.8 m/s，接近十一级。不过，羌塘的沙尘暴不会持续太久，很快平息，只猎猎大风七级左右。顺风顺路，趁势推行，我负责扶稳车把掌握方向，风负责后面做苦力推车，瞬间大风时还会踉跄。口念金刚经，诸神佑我啊。另说羌塘风，常年大风，八级风天至少占全年天数1/4强。但风速不等于风压，风压通俗点说就是风的破坏力。风压受诸多因素左右，风速，温度、湿度、重力……但最大的因素是空气密度。所以，同等风速下，羌塘的风虽大，但实际破坏力是小的，八级大风简单换算下只相当于内地六级左右。若羌塘大风相当于内地大风，那草是长不出来的。再另说珠峰顶部大风也是如此，风的实际破坏力更小。踉跄，GPS支架摔断，晚上修理。水是冰，吃完饭，反完胃，然后拉完肚子才钻进睡袋，这寒夜，谁敢起来。 昨日看见的“城堡” 又一处风化地貌，羌塘很多，但今天密了些 很像围墙房舍，确实不是，我也希望发现石器时代的痕迹（那时羌塘温和，有祖先来过） 修理时间，各等螺丝 D31（5-20），16.5K，宿营4935M今天，极重的沙草地，一直大风，阴沉发灰的云，跟江南梅雨季似的。空气通透度极差，雾霭霭。下午五点后，大风忽然停歇，很奇异的感觉，荒野中静的只有呼吸和推车声，而云层却是越发浓稠暗灰。羌塘降雨主要受印度洋暖湿气流控制，加上先前东南风，让我觉得羌塘在酝酿一场强烈而持久的风雪。所以，短暂的静默期过后，大风冰雹席卷而来，我便以最快速度扎营，这可不是西风带控制的短暂风暴。判断错误，这风雪也就张扬了半个来小时就没了，之后的灰云也慢慢消隐。适才发现前方突兀着四座火山，前往探寻。有种行在素描画的感觉，天空是铅笔灰，雪一缕缕，再点缀着一些凄凄黄，着实是一幅彩笔素描画。是泥火山，高度在五十米左右，土质甚红。这种规模庞大的泥火山是很罕见的，其泥火山在地球上也是罕有的。泥火山不是通常意义的火山，高度一般不超过十米，小个子，只喷出泥浆和气体，没有岩浆管道。到底是不是泥火山？我个人分析是百分百。一是如此庞大的尖锥型孤立土丘在地质运动中很难形成，二是此处是青藏高原一条重要的构造带（高原有过四次隆起运动，印度洋板块不是一次性撞出珠峰的，所以羌塘荒原中的火山遗迹遍布），三是在火山顶部发现了类似喷口封土，四是未来几天将遇到更多的泥火山群，特征也将更明显。显然，这是剧烈地质运动下特有的泥火山地貌带。泥火山风化严重，NN年前了，有的火山充满孔隙洞穴，我还臆想有否藏宝？选择一个好的角度观察，他又会呈现别样形态，我便发现了一只羌塘之鹰。（不是地质专家，关于是否是沉寂的泥火山，待我更新完未来几天的照片后，相关专业网友可给出科学结论，以正视听。） 典型沙草地，试着装上一百五十斤大米在沙滩上推上十公里就知感觉了 风雪袭来，误判，很快就停了 雾霭散去，帐篷前惊现一处火山群 有如彩色铅笔素描画 爬了两座玩，放眼，是一幅更大的彩色铅笔素描画 左下角，疑似喷口封土 天色渐晴，一只羌塘雄鹰 D32（5-21），27K，宿营4880M今天，格外漫长……今天，天气也是格外好。上午穿过一段泥火山地貌，依旧未到此行最震撼的。一路踏雪，前方的胜利湖盆雪厚许多，直到中午才化去，好在此前搏命赶路。十二点半，车子被粘土卡死轮胎，甚至把后轮给顶了出去，可见土粘，可见我急于摆脱的发力。苦等了一个小时，地面才在午后烈阳下干了些许。下午三点遇到胜利湖北侧的胜景河，碱水，泥沼型，探了无数次路过不去，泥沼太陷，也很冷。每次在泥沼里探路不会超过三分钟，否则会冻的失去知觉，一辈子就这么被陷住了。我放弃了，决定等明天早晨看能否上冻些。有些分心，此点是我第三组逃生路线，一是北上经可可西里山、巴杂钦山、昆仑山进入位于新疆境内的土啦牧场，二是南下经绥加日、藏色冈日、措尼、玛尔果察卡找到无人区最近的荣玛乡，一南一北两条逃生路线距离相等，都约需二十天时间。再度反省一番，不上不下，状态尚可，那么就继续往前吧。恒了心，恐多变，咬牙过了河，断后路，其艰辛不表。过河后是绵延的寒漠土丘陵，属于非常难行级地貌。由于错判前方会有大量水资源，所以上午没有融雪，下午没灌盐碱水。实际情况一片极度荒芜。渴的厉害，又误判前方有水，疯了般推车，一直到太阳下山前一刻才发现一个湖泊，就是照片中那个。放下车，第一时间去打水，才发现这个湖居然是盐湖，薄薄一片水，水下是不知多厚的一层盐粒。此水自是不能喝，活不过当夜。光线已无，我绕了盐湖一圈，心存侥幸。这段记忆很深刻，有种在暮色荒原中没有归宿的感觉。当夜无一滴水，但还是吃了一块压缩饼干，因为明天还得继续，往前，找水，没力气可不行。 上午，穿过火山地貌，很多 远眺胜利湖，背景是玛岗喀日雪山 轮胎被卡死，后轮被顶出 胜景河，碱性泥沼河 白色是盐碱，泥沼很冷，每次探路不会超过三分钟 太阳下山前一刻终于看见一个湖，却是一个大盐缸，今夜无水 关于探险当今，没有探险，地上宝马，头顶波音，还有GE。撕了脸面，上网恶炒，全世界也都会瞬间知道。地球不再是旧石器时代，逐猎而生，不问方向。地球也不再是哥伦布时代，手持圣经发现上帝遗弃之地。所以，没了探险。羌塘，走的人多了，有科学家，有测绘兵，有探矿的，有开车探险的，有盗猎的，有淘金的，有外国探索者，虽然我暂时走的更深些，在无人区里待的最久些，但依然只是一次艰苦的旅行，还上升不到探险高度。若较真地球上再找一个探险之地，那便是地下世界。中国占世界喀斯特地貌三分之一，无数的洞穴。但探索者寥寥无几，因为地下世界没有第一，你今天发现了最大地宫，可能明天就被取代。没有第一的游戏是没人玩的，所以都挤上珠峰，因为全世界都能瞧见身影。当今，没有探险，但不能失去探索精神。依旧羌塘，某年，某个俄罗斯人带了几个伙伴，经克里雅山口来到昆仑山玉龙河上游漂流，死了几个，他活着，后被军区直升机救出。去年见一新闻，说是俄罗斯人在昆仑山遇大雪，危急，又被军区直升机救出，查名字，还是那哥们。这就是俄罗斯人的探索精神，不顾规则，不论成败，管几斤几两，计划好了就去做。或许鲁莽，但墨守成规是做不出事的。所以，没有探险，只有探索，对自然，对自我。 D33（5-22），18.9K，宿营4986M天气，好周期。继续东进，寻找绥加日山的风翎垭口，准备进入朝阳湖盆区。晨，没吃。上午近十点发现一个湖泊，微碱性，可适量饮用，利马取冰融水，此行唯一一次途中生火烧水吃饭，有些虚脱。喝饱未吃饱，已经好很多，赶路。十二点上一个大坡蓦然眼前的是，一个宽大的盆地里居然有几十上百个泥火山，锥形特征更明显，恍然异星球。这使我更加坚信两日来所见的是泥火山。一片闪闪银光吸引我，初以为是露头水晶，近处才知是云母片，一层层相叠，似一本厚书，可轻易剥开，稍有韧性，易碎，手指一捏便咔嚓。半透明，似熬成片状的糖浆，很美。不知此种云母石和泥火山成因是否有关联，但此处露头云母太多了，风化的也厉害。有专业人士可以再结合这云母判断一下，以正视听。可惜未拍一张云母照片，遗憾。另说，盆地东侧小山上有一大地三角点，这至少说明了当年测绘兵来过，至于科学工作者是否来过未知。羌塘地质资料中确无发现沉寂泥火山相关内容，所以，泥火山是否还是存疑。穿过火山盆地，东侧地貌呈现盆地戈壁，风化石极多，很拟物，上了一张骆驼石，大家可以看像不像。有几次误判，终于确定一条通往垭口的河道，人品不好，干硬河床很快变成软沙底，推得我十分的十分的忧郁。途中看见一只硕大的死乌鸦，原本想拔根羽毛随身带着，因为有个朋友不相信有这么的大的乌鸦，他看了这长达40厘米的主羽一定会心服口服。还是忧郁，顿了一下，瞥了一眼，走过。河道开始有了新特点，纵深，两岸陡直，走在里面感觉既像甬道也似迷宫。八点钟，遇河道分叉的开阔处，再无一丝力气，扎营，然后又轻松的徒步探路半个小时，把河道走向搞了清楚，确定明天方向。水是上午灌的碱水及冰，捂了一天后味道甚重，已经习惯，但今天却不知怎么惦记起最后一点白砂糖。一斤白砂糖吃到现在再也留不住了。是半夜，迷迷糊糊的醒了，一直想着最后一点白砂糖，真的很馋，于是挣扎起来，把睡袋里的水壶掏出，将最后的白砂糖冲了。味道？很不好，就行骨头汤里放糖一样。这是一个非常危险的信号，从精神层面上开始动摇了对食物的控制。 晨起，才清晰昨夜地貌 遇水，途中唯一烧水吃饭，有些虚脱了 盆地里的火山，再结合周边的云母片，专业的看判断下，以正视听 盆地东侧的戈壁地貌，风化石多 骆驼？狮身人面？ 河道通常是优先选择的推行地貌，但人品不好时很痛苦-宿营，本想山坡下，避免风头，没力了 D34（5-23），16.2K，宿营5212M好天气周期继续。今天吃了四块压缩饼干，是平日两倍，实在无力推向垭口，只能在食物上给自己找借口。全天就拍了两张照片，一是下午遇见的狼，拍他是因为自相遇后他就蹿上坡脊一路跟了我半个多小时。那狼在山坡上，映着蓝天白云的感觉勾起了感悟，江湖是孤独的，在于内心。另一张照片是雪袋里混杂糌粑粉。还是欲望，对食物的失控，弄了些糌粑粉搅在装雪的袋子里，做起“糌粑冰沙”。创意无限，食物有限，不可取。另说水源是山坡附近一块积雪，海拔高，过了5200米，冷，风大，铲雪时帐篷被吹翻了，好在防风绳拴在自行车上。那一刻，坐在雪地旁，看着暮色中翻腾的帐篷，想象着帐篷果真跌落山谷我将如何。所以，晚上除了“糌粑冰沙”，还把最后一点牛奶给消灭了，算是补偿帐篷。从精神上再次为自己开脱，补偿帐篷我喝牛奶是什么逻辑。一斤牛奶也是挺到现在，终于完成了他的使命。用自行车驮物穿越羌塘是国外探索者最先采用的，确实也是目前长线穿越羌塘最有效工具。但绝对无人区的天数都很难超过五十天，除了体力、心理，食物也是主要原因之一，所以一直都是纵穿，羌塘东中西三条线他们都走了，有兴趣的可以查下网络，就那几个人。纵穿是因为线路相对较短，而且两边都有牧民深入，容易紧急情况下得到求助。我的逃生路线也是如此，皆是南北方向。同纬度横行，永远都处在纵行的中间点上。我的食物重量已是所能承受的极限，即便半饱走完全程都是不可能的，这就需要极力控制，控制生理上的需要和心理上的欲望，只要不饿死怎么都行。去年就曾尝试横行，设计了“V”和“W”型两条路线，就是反复斜插，途中寻找一到两个牧民点获得补给。却在斜插完羌塘西部无人区时被牧民揪住了，随后就是各级政府尽职尽责。这也是当地公安局仅在无人区里抓住的两次人之一（仅指旅行者），上一次是那三个国外探索者走的中线。此前，可信的单人模式穿越羌塘最长记录的人是Martin，纵穿最难的中线，耗时35天，其中完全没有遇人19天，有粮食剩余。Martin也是穿越羌塘次数最多的人，彪悍，狂野。 江湖是孤独的 糌粑冰沙，创意无限，食物有限 D35（5-24），29.5K，宿营4965M很早起来，趁天寒地冻，迅速翻越风翎垭口。海拔5200米的山口不算高，但此地是个风口，清水鼻涕稀里哗啦，乱甩。下山时，寻了一条硬干沟，碎石很多，也不顾，一直溜到山脚下，几头野牦牛吓得抱头鼠窜。最有意思是一大群藏羚羊，被我冲的七零八落，有点像被炒家的劲头。乱石沟里溜坡确实奇妙，靠的不是技术，是感觉，一种身体和心理完全打开的感觉。仅有一次遇挫，一个坑，没留神，屁股和手都被颠起，车子就这么从身下独自溜了下去。我坐摔在地上，车子撞石倒下，还好当时没有牛羊，否则定是幸灾乐祸的狂笑。今天人品不错，下山后干沟变成干硬河床，有一段跟水泥地似的，骑得我兴奋的发颤。行距早已达到预期，便鼓足精神又翻了常雾岭小山口，下山口迎面就是可可西里山脉，他终于完整的呈现出山梁之态。（明天是雪染可可西里山，所以今天的可可西里照片就不发了。）随后几天都在可可西里山脉与常雾岭、玉帽雪山之间狭长的盆谷里一路东进，直杀布若错。水源是一个水坑，周边满是动物脚印，水质尚可，微生物多。灌好水后准备就地扎营，却看见几只羊在不远处的小土堆后闪闪躲躲。原来霸了他们的水源，于是又沿着河床往下推了数百米，直面可可西里山脉扎营。晚上分析地图，种种因素都表明了未来几天，甚至今后的日子水源将一直丰富。说近期，一是我的前面就有条春雨沟，瞧这名字多好听，而两边雪山下也有多条河流汇集在狭长的盆谷里，朝阳湖也在前面直线距离30公里的地方……一切都显得那么美好，实际上…… 途中一群藏羚羊挡道，我吆喝了一声，一同将屁股对准我，无语 营地，旷远 D36（5-25），14.8K，宿营4873M夜风雪，雪小，风大，气温干冷，帐内温度低于-10℃。可可西里山脉点缀着稀拉雪，像是染上去的，地面被吹的一条条模样，可见风之大。早晨赶了一段硬路后就全是重沙草地了，推到下午5点没力，扎营。另说中午吃了三块饼干，比计划的又多了一块。晚上又琢磨着饼干烧成糊糊的味道，尝试了下，不错，又多消耗了两块饼干，对食物的探索精神貌似超过了旅行本身。所谓的河，无水，深沟壑极多，垂直，松土，自行车推上推下就像推土机在搞基建。水是一个小海子，湖畔淤泥，经验多了，看一眼便能大致断定水的品质。非常疲倦的感觉，有过经历的人就知道，每天近二十公里的速度是怎么来的。除了极少的路可小骑过个小瘾，其余路况很少能一次推一百米不停下喘两口气的。硬草地一般推个五十米喘口气，寒漠土二十米喘口气，沙土路十米喘口气，重沙地三五米喘口气，陡坡半个轮圈喘口气。这羌塘就是这么一口口气喘过来的。呼吸很重要，学会呼吸就可控制心率，控制心率是为了减少血液循环，减少血液循环代谢就少，代谢少了就能节约热量，节约热量就能省食物。呼吸和食物之间的关系便如此，体力减少更不必说。如果一个小时休息十分钟，不如学会一个小时休息六十次，每次十秒，使你的心率永远控制在低频。（仅指羌塘推行，因人因线路而异控制休息次数和时间，徒步控制心率更容易些。）我的体格并不强健，中等，除了探路外每天长休息三次左右，每次不超过十分钟，其他时间推一会，喘口气，控制心率。提高推行频率，比太阳起得早，速度就是这么来的，尽量不做无氧运动（过多使用爆发力）。另外，胡思乱想、多愁善感、吟诗作画、悲天悯人也都会消耗体力（尤其拍照）。有网友问心情变化，大部分时间里是没心情的，有心情时也要控制成一个平滑的状态，套句网络语就是“蛋定”。 可可西里山脉，呈现“山梁”之态 藏羚羊越发不惧人了，尤其慢似蜗牛者 乌鸦，终于拍下很猥琐的表情 水源，一个很美的小海子 取水的代价 D37（5-26），19.8K，宿营4775M从宿营海拔可见一直下坡，但速度提不上，主要原因就是重沙地。今天肚子过闹，不知是否和前天水有关。今天小苍蝇很多，不粘人。一路无水源，用存水。太累了，那天没什么记忆，日记字数也少，估计又是大部分时间都是催眠状态。弄的当下也没什么心情，凑合着写了几个字把今天内容应付。 重沙草地，这些天频繁了些-营地，天高云阔，却无水源 D38（5-27），18.5K，宿营4764M今天话多，因为漫长。用最后一点水泡了糌粑，不急。找了条沟推行，沟窄，如地道战。地表过于平坦，沟壑很难发现，方向一致更要检验人品。今天发现这沟，归功于“拉肚子”。硬沟缓上，到了坡顶后是一片开阔草地，动物很多，却没发现水源。春雨沟和峡丹沟相向汇合，再九十度南下与朝阳湖相连，再无水源天理不容，所以，身上无水不急不急，一直朝那汇河推去。上午十点，终见此河，一道波光粼粼，望远镜中看去，更是水波荡漾，岸边耸立奇特小山。绝美景象，便想着推到河边休息半日，把疲惫的状态调整下。到了近处，一个霹雷，这河居然是一片干涸盐碱地，先前看见的波光粼粼是地辐造成的视场紊乱。更麻烦的是，盐碱看似干透，实则陷人无比，走不到三米便得丢盔弃甲，一时不知如何是好。有客来，一只高原沙蜥，还有三头驴在河坡上看笑话。思量，沿河往朝阳湖方向推去，动物白骨极多，半沙淹没，衬着死寂河滩，有股死亡味道。烈日也炎炎，脱得只剩抓绒，还开了拉链。一个半小时候后，寻到一处便宜处过河，又是错觉，那龟裂河床不过是个幌子，不到五米，粘土卡死轮胎。这土奇异，粘性十足，似胶。放下车子，往前寻了几步，人都过不去了。那三头驴居然一路跟来，在山坡上，发呆的样子，心里定想，小样，看你怎牛。无奈，继续往下游方向走，几经探寻，过了盐碱河滩。接着便是火星一样的沙漠，燥热，更渴了，嗓子冒烟。沙漠是古湖床，红沙，其间点缀怪异小山，左边古湖床边缘也是怪异山，稍高，只是不孤立，重重叠叠，类似喀斯特地貌的峰丛。望远镜找水，不见水，转向玉帽雪山方位推行。到雪山是不可能，雪山西侧有座狮子岭，山地草原，定有水。一直推到八点，进入一条沟壑，放下车子，探路边找水。渴的失常，忘了带背包、GPS等。走啊走，先沟壑而上，翻上沟壑，再下沟壑……就这么一个小时过去了，不见水，只有稍湿润的盐碱渍。九点往回走，发现迷途，一条条并行的沟壑，一道道无尽的山梁……风景却是罕见的美，绚烂黄昏，月出东山，一边晚霞似火，一边月华静谧，可惜没带相机。寻啊寻，越发迷失，即便找到停车的沟壑，也不知身在沟壑那端。西边景致全无，只剩东方皓月当空。坐在一处山梁顶端，沐浴晚风，努力使自己平静下来。困顿显然，身无一物，幸有月光，但在月光下找到自行车更是渺茫。我做好了最坏打算，在哪个土堆后猫一晚上，明天日头下便一目了然。有了最坏打算，那么心情便可平静，心平静了，便可尝试再一次找寻。策略是走向沙漠，方位简单，地貌特征明显，易寻。然后在沙地边缘找到车印，有点难，需要细心。顺着车印进入山地，虽没了车印，但记忆有了逻辑可循，坡，沟，右行，坡，沟，左行，直上……运气好，判断正确，十点多，在如水月华中找到了自行车。漫长的一天，筋疲力尽，这才又想起渴来，无食无水。半夜醒了几次，风沙打在帐篷上，以为是雪花。我祈祷着，下一场雪吧，给你一百块钱。 沟壑也是首先推行地貌，但方位要判断好 汇合河，虚妄的幻觉-岸边的小山重重叠叠，很似喀斯特地貌的峰丛 风化胀缩泥河床 高原沙蜥，身下是根草，以为身体一部分，罕见新品或基因突变什么的 问朋友，说不会是草吧，写今天文字时在硬盘里找了近影，确实是根草 看似龟裂盐碱滩，十分粘土，似胶 红色沙漠，其间点缀怪异小山，火星地貌？ 寻到月色中的自行车，淡定 D39（5-28），5.8K，宿营4768M今天，推车五公里，徒步找水二十二公里。观测前方，狮子岭一带无水痕迹，推车前往也是艰辛，便掉头直奔朝阳湖，哪怕盐水也罢。不过五公里，便无力，于是装上所有水具，徒步去找水。还带了糌粑、油炉、锅，遇水得先造一顿，补充体能，也是节约一顿做饭的水，然后再背水回来。望远镜里，朝阳湖烟波浩渺，心旷神怡。先是古湖床的沙子，再是爆裂缩胀的泥床，再是一块块呈现几何图案的盐田，很沮丧，前方却依然一片烟波浩渺。此时，望远镜已没用途，挺多放大烟波浩渺，甚至出现了芦苇丛……光折射、抖动太厉害了，蜃景。查看三份地图，对比，朝阳湖不仅有水，还极有可能是淡水。干盐湖不好走，上是一层硬壳，有空隙，下面不知几米厚的盐，一踩即碎，再拔脚，难行度和齐膝深的雪相当。地图显示已进入湖区，可还是盐田，有些领悟，GE卫星图显示这片湖畔的大片白色，非冰，而是盐。热，极热，干，极干，盐湖似无尽头，但前方烟波浩渺无限。人有些撑不住了，高原的太阳辐射之狠去过藏地的人知晓，再加上盐体的放大效应，有如烤炉。终于晃到盐湖中间的一座小孤岛，爬上，四周寻望，不是盐田就是沙漠，孤岛无依，我比孤岛更无依。侥幸着深入盐湖，多少会有些水，便选了一条面对常雾岭的直线穿越湖区，即便湖区无水，在湖的西侧也有河流与湖泊。体力下降极快，行在盐田，如行尸走肉般……临近岸，是一个个盐窝，从未见过如此景象。（一般徒步探路、找水不带相机，否则今天的盐窝大家就看不见了。）盐窝内陷，是盐泽，盐壁干硬，可行脚，要小心，掉进盐窝里便成了腌肉。锁定直线，在盐壁上绕的头晕，不知又走了多久，盐窝变成了盐锅巴，终可直线。上了岸，看地图，已经横切了湖区。放弃湖区寻水，找西侧的河，无水，白色盐碱渍却是不少，很迷惑人。最迷惑的是常雾岭半山上有片白，盐碱而已，却是那么诱惑，再三观察，思量，放弃侥幸心理。若爬上山，非雪也，估计人就下不了山了，身体已经很糟糕。又去找西南侧的另一个小湖，还是杯具，盐湖。再朝朝阳湖南侧湖区寻去，希望盐湖里有些液体水，也可利用，研究过以色列的海水淡化技术，所以随身带了一段导管和喷雾瓶。依然一片盐场，更宽阔，坐在地上，脑袋一片空白。缓了会后，爬上一山坡，用望远镜四处瞭望，皆是蜃景，就连回路方向都是一片烟波浩渺。拒绝诱惑，但还是又奔着寻了一程……下午五点进入一片沙漠特质的古湖床，彻底不行了，口腔溃烂，黏在一起，人也迷糊。一泡尿液进了杯子，用尿液漱口，口腔才好了些。虽有些尿液会进入喉咙，但绝非主观意愿，喝尿救生是不科学的，不多说。尿液是很好的消毒剂，但慎用，非绝对杀毒，尿液里也含有害成分，加速伤口感染，只紧急情况下润喉、消毒。用衣服遮住头部在沙地里躺了会，好很多。六点往回走，晕一脚，眼睛腿断一根，找到车，搭帐，喝尿润喉，睡觉。 回首 渐变的地貌。沙，土，盐 辐射高，难行，煎锅似 登上孤岛，比孤岛无依 奇异的盐窝，小心，陷，成腌肉 边缘，逐渐衰落的盐窝，似一口口大锅巴 所有地图中湖，皆盐湖(拼接图） 眼镜腿断了一根，半稳架在鼻子上居然也走了好几天，只是滑稽些 D40（5-29），5.8K，宿营4764M早晨醒来，看见干透透的帐篷非常惊诧，甚至有些恐慌，此行唯一帐内没有结露现象，甚至连湿的痕迹都无一丝。这说明了空气的湿度有多低，侧面也反映出呼吸中的水分也少的可怜。尿了一泡，润口腔，吃饼干，今天还得继续找水，所以压缩饼干必须吃些。如果有直升机投水来，我一定会躺着不动，不吃一点东西。但眼下情形必须要有体力去寻水，自我拯救。眼镜腿断了一根，但还能半稳架在鼻子上。拍了今天唯一张照片，就是留言纸条，“我是旅行者，去找水了，如果有神人路过，请不要随意动东西。请留下些补给给我，最好有大量的水。”将纸条夹在拖鞋里。我了然，这是火星撞地球的概率，但还是留了纸条，或许潜意识里……随后，带上半壶存尿，水具，DV去寻水了，又给自己拍了唯一段视频，“今天早晨很美，如果今天再找不到水，马克思就要找我去开会了，所以今天一定要找到水。”其后不表，过于琐碎，不时用尿液润口腔找水而已，遗憾的是，没有找到水，庆幸的是，马克思还没找我去开会……睡前，尿液，吃饼干，明天还得要有体力。祈祷，下场雪吧，爱下不下！ 今日唯一照片 今日唯一视频（镜头太近，其实很帅，汗）十二点上一个大坡蓦然眼前的是，一个宽大的盆地里居然有几十上百个泥火山，锥形特征更明显，恍然异星球。这使我更加坚信两日来所见的是泥火山。一片闪闪银光吸引我，初以为是露头水晶，近处才知是云母片，一层层相叠，似一本厚书，可轻易剥开，稍有韧性，易碎，手指一捏便咔嚓。半透明，似熬成片状的糖浆，很美。不知此种云母石和泥火山成因是否有关联，但此处露头云母太多了，风化的也厉害。有专业人士可以再结合这云母判断一下，以正视听。可惜未拍一张云母照片，遗憾。另说，盆地东侧小山上有一大地三角点，这至少说明了当年测绘兵来过，至于科学工作者是否来过未知。羌塘地质资料中确无发现沉寂泥火山相关内容，所以，泥火山是否还是存疑。 应该还是剥蚀地貌，此处风化严重，早晚温差大，且大风、气候变化多样，易于物理风化。至于为什么形成那么多的土堆，很可能是土堆下面及附近有较周围不易风化的物质，比如说一些坚硬的基岩，由于该处的隆起，表面又土化，故而形成土堆。那些云母片儿，照楼主的描述可能是类似于绢云母千枚岩或是石英片岩之类的变质岩，变质程度低等-中等，那些土堆下面很可能是变质砂岩一类较硬的基岩。这个地区整体覆盖较厚，上面是一层冻土，下面的砂砾石或许能看出一二，但此间的信息能透露这么多，已经是非常难能可贵的了。谢谢指教，以正视听。我觉得你分析是对的，我只是粗陋凭借地貌揣测，且缺乏相关专业背景，大的理论还能嚼些，分枝就远不能胜任了。 D41（5-30），0K，宿营4764M夜里醒多次，口腔黏在一起，喉咙也仿佛合拢了，喘不过气来，嚼口唾液撕裂的痛。担心早晨醒来口腔会张不开，最后，用一个长尾夹放在嘴里，既是物理隔绝也是刺激唾液分泌，再用一根红绳子栓在长尾夹上，以免不小心吞咽。迷迷糊糊听见帐篷沙沙声，以为又是风沙作祟，微明，掀开帐篷一角，见是雪子，再看了眼天际，灰云铺顶。不喜不悲，因为羌塘白天是很难下大雪的，更难积蓄。心中也并无打算今天如何找水，身体透支太多，再难强打精神，也无祈祷，该怎样怎样。无视，继续睡去。天色放亮，雪越下越大，才清醒些，认为是生机。然后三两分钟掀帐看下雪情，待到有些积淀，便赶紧扒了些雪融水，生怕云散雪化。终于喝了水，这才感触颇多（可能诸神也喜欢看帖J）。写今天文字时翻看当天DV，有一段自拍，很是矫情，眼有泪花，觉得做作。人的一生不可能踏入同一条河流两次，此时彼时，我再也无法感同身受了。趁雪未停，继续化，没想这雪越来越大，鹅毛之势，傍晚才歇，这是此行唯一一次，在羌塘也是鲜见的。不停取雪化水，把所有水袋装满，人也喝得饱，整整7L，唱歌，尿液亮晶晶，兴奋。除了控制粮食，水也是受控的，是为节省汽油，水再多，一天两锅水，3L，所有食物用和饮用，显然此环境下也是不够的，尿液一直淡黄。今天，终于见白，闪着亮光，耀武扬威。吃饱喝足，外面风雪，困在帐篷里听音乐，如果再有根烟，我情愿再喝尿一天。果有根烟，我还能等到明天吗？客观的回想，是不能了。 见雪稍有积攒，便速融了水 可能诸神也喜欢看贴J赏了口水喝 傍晚，雪才停下，这在羌塘时鲜见的 D42（5-31），0K，宿营4764M昨夜，又一次半夜雪地欣赏水波星空，要来的不请自到。（当夜，非常糟糕，不表。）这老天爷要么渴死我，要么淹死我，昨儿一整天大雪封了大地，只能再休息一天。无聊，很容易乱心智，手机里的音乐听得不再觉得经典，就像燕窝吃多了跟粉丝无异。稳定心智的唯一办法就是吃，用一种代价换另一种代价。做了糌粑冰沙，做了糌粑泥人，做了糌粑烤饼，最后让他们在胃里团聚。哦哦鸟格外的频繁，就那三两只，围着帐篷转，“哦-哦”，估计是食物吸引了他们，便洒了些糌粑粉在稍远的雪地上，反而，他们跑了。有乌鸦，闷闷的扇翅声，要早两天看见他一定恨死。午后，日冕，踏雪上山，遥望四野，一切显得那么久远。继续无聊，找事情打发。修了GPS，线路老化，想着老无所依可以做电工；缝了裤子，材料老化，想着老无所依娶个裁缝老婆；然后写日记，拍照片，觉得做卡梅隆其实也不错，当然，首先要华谊兄弟鼎力支持……又想了一堆乱七八糟，改换压缩饼干镇压一切妄念。 修理时间 裤子频繁轻易破损，与气候悬殊，盐碱腐蚀都有关联 踏雪四野，一切显得如此久远 坠入地下的夕阳，依然无法见真容 D43（6-1），24.8K，宿营4837M昨夜两次起，第一次水波星空，第二次月华铺地，真是奇妙，肚子和某处压力各闹一次。温度开始提升，-6.4℃，想起今天是儿童节，阳光定要灿烂。地只冻了一小时就软了，白天记忆很是模糊，追赶流逝的时间，一直无视风景。其实，也无风景，羌塘即没那么美了，也没那么糟了，种种幻想也变得实际，走一步算一步，挣扎是所有情感的总和，新鲜感一过，剩余的只有时间在流淌。荒芜永远是羌塘的背景，偶尔的奇异地貌和掠过眼前的动物只是衬托了荒芜。很晚才拍了一张照片，然后进入一条河床，发现几个破损的大油桶，历史怎么也十年上了。滚了一个回来，在帐篷前挡风，第二天，被风吹跑了。夜里有过一场虚惊，有人窜门，似咚咚的敲门声。用手扑打了两下帐篷，声音消失一会又起，起身，用电筒巡视一番，没有什么发现，躺下，咚咚声又起……以往，根本不担心有动物骚扰，开门迎客便是，但这声音着实诡异，加上前几日的折腾，神经有些敏感。又起身一次，原来破损的油桶里有只鼠兔，不知怎么进来的，想逃出去又不敢弄出大响声惊扰未知怪物。没有理睬，放心睡去，迷迷糊糊风起，很大，帐篷哗啦啦的响。翌日起来便不见了油桶，估计被风吹到了河床下游去了，或鼠兔练就了如来神掌，粉碎了油桶跑了。 斜阳下的羌塘，化平凡为神奇-挡风的破油桶，第二天，跑了 D44（6-2），24.8K，宿营5014M又是追时间一天，将翻越可可西里山、横云山、玉帽山相交地带。预估会很难，地质复杂，实际出奇的好，一条条干硬河床及沟壑相互交错，如同网络。先前说过，干涸河道、沟壑都是首选推行地貌，原因是坚实的沉积物多，方向也好掌握。若是山地貌，就一定有硬沟可循，若是湖盆区，那一定有干河道可依。确定河道沟壑的最有效方式是GE地图，这也是GE地图唯一有实用价值的地方。羌塘广袤，GE细节无法呈现，但一条条沟壑却是清晰，将设计好的路线转成KML格式，同时再在周围多设些参考坐标，最后将GE地图打出，便能快速的寻找沟壑以及确定方位，速度和精准性极高。如果有支持位图的GPS手持机就更容易操作了。另随身携带一个传统指南针，电子罗盘不可靠，（电磁干扰大，有巨大风险隐患，）GPS算出方位角，用指南针定位。体能下降越来越快，到了十一点就惦着压缩饼干了。很难判断，是馋食物了，还是生理需求到了底限。应该两者都有，交织在一起，结成一对恶棍。眼镜很麻烦，大点颠簸就半搭着，袜子也不够穿了，必须将脏的洗掉，肚子闹的有些厉害，头发打结严重，内衣也够呛……这一切让我急于寻个完美营地休整一天。完美营地必须满足三个条件，一是有硬岸的清河或湖泊，二是适合扎营的土质，三是天高云阔的好天气，后者简单，前两者是大问题。硬岸清河自不必说，适合扎营的土质同样也难。草地不平，沙地扎不稳帐篷，石砾地帐钉无力，漠土浮尘太厚……完美营地，应再加上遗世独立的风景，这又可遇不可求。大蒜开始发绿，变软，腐烂，只能将坏的部分咬掉食用。先前将大蒜分几袋密封，隔绝氧气，避免发芽，但随着白天温度升高，大蒜也有被捂烂的风险。大蒜是数着瓣数买的，每顿几瓣严格控制，人算不如天算。辣椒粉也是超出预期，估计也挺不了多久。如果没了这些敷料，馋嘴的欲望将更难控制，转而向主食寻找慰藉，后期，的确也这样了。 形单影只，一路相携 大蒜开始损坏，咬掉坏的部分仍可食用 D45（6-3），14.2K，宿营4988M丰富的一天，天气，水文，个人生活。晨，雪原茫茫，暧昧雾气，风无一丝，静的诡异。所有的游戏规则仿佛都被抹去了，包括荒原的规则。一片静谧的暧昧白，却无迷失感，最大程度的自我。十一点就“饿”了，吃了路餐，然后在深陡的红土沟壑里翻上翻下，几度不支，最终进入可可西里山与玉帽雪山之间的宽阔台地。雪难觅踪迹了，风却猎猎起。下午两点，发现一个小海子，便打算休整，可惜不是一个完美营地，海子周围一片烂泥。下午四点半，经过玉帽雪山脚下的一条沙质河床，其间有一条溪水，沙重，但不至浑浊不堪。恰无一丝风，烈日当头，且视野开阔，可可西里雪山和玉帽雪山皆在视野，南北相对，勉强算个完美营地，便急速扎营，调整。先洗头，此行唯一一次，头发打结，再不处理，便成鸟窝。溪水太浅，水道中挖了一深坑，才蓄住水。然后洗脏袜子、内裤，挂在帐篷上晾晒。换了一套内衣，带两套，脏的一套扔弃。照镜子，很陌生的面孔，其实连声线也变了很多。清点食物，辅料消耗极快，主食控制的很好，于是决定增量，其实也由不得自己了，生理和心理都很难再支撑。修眼镜，用绳子串起，回想蛮可笑，一只腿的眼镜居然在鼻子上架了好几天。为何？应是一种麻木，半稳的眼镜不值得小题大做，它被更艰辛的旅行给埋没了。开始享受生活，自制酥油茶。一般藏人在野外的酥油茶非混合的，简单的油汤，我也如此。今天探索了下，把酥油和茶水装在杯子里，上下猛摇50次，左右猛摇50此，前后猛摇50次……就像调酒杯，油茶完全混合，味道绝对比所谓的知名藏餐厅要好，因为他们不可能用好酥油调制。一边喝着香喷喷的酥油茶，一边远眺着可可西里雪山，对前途满是憧憬。忽听见帐篷外有流水声，出来瞧，发现河床上遍布分叉的河流，这离先前挖坑的单溪不过两小时。这是一个重要的河流节点，随着温度升高，雪山加速了融化，季节河开始苏醒。不想再挪动帐篷，便用铁锹将切过帐篷边缘的一条浅沟堵住。事必，发现先前因水沙太多没有补水，这下只能打些泥水沉淀明天用了。 一片静谧的暧昧白，却无迷失感 途遇海子，周边烂泥，非完美营地 自制混合型酥油茶，享受生活 眼镜折腾好，很潮 晾晒衣服，此时浊水未起 傍晚，水漫河床，突兀 一夜间，季节河苏醒了，这既非好消息也非坏消息 D46（6-4），24.6K，宿营4937M天气，整天都很糟糕，唯有晚霞亦真亦幻。河流苏醒，浊水在宽阔河床上四溢，上午过了无数小河岔，皆不深，不难逾越。到了下游，河床再度干涸，上游的水还没下来。中午太阳出来一会，正休息吃饼干，闻滔滔声，见一股浊流顺着沟槽涌下，急忙起身推行，黄色浪头基本追着脚后跟，有黄河之势，却无黄河之实，很有趣。直到一处开阔地，水流被分散，适才喘口气。用不了多久，河床将会被融水彻底打通。有些河汇入盆谷低处的湖泊，有些则满溢在开阔的空地上，形成吃人沼泽。随后，大雪风天，湿脚极冷。再随后，对流天气，一会东风压倒西风，一会西风压倒东风，两股妖风纠缠过程中，惊雷四起。此行第一次，之后是常态。惊雷是雨季的号角，我并未从中听出惊悚意味。对羌塘的雨季早有提放，没有人能在雨季穿越羌塘，机动车更不行了，所以，雨季里的羌塘才是真正的无人区，没有盗猎的，探矿的，游荡的，出风头的。原计划四月初进入羌塘，只压雨季十来天的时间，后因背运晚了二十天进入。当下还感觉不出这晚二十天有什么严重后果，如果早知，那些设计的逃生路线就会派上用场了。下午到达旭光湖，一个超强风暴团正从身后涌起，风暴前锋蔚为壮观，只见玉帽雪山被一点点吞噬。仔细观察，风暴前锋离我尚远，且风向东南，我非挡道，便拿上水袋准备去湖畔打水。走了不过十来米，不放心，回头一瞥，只见一团白色急速涌来，心想不好，奔到自行车处，刚掏出救生毯，这风暴便夹着冰雹昏天黑地了，十分恐怖。救生毯，十元钱，就是塑料布涂上一层锡箔。此行第一次用（总共用两次），当时见风暴来，就觉非同寻常，掏冲锋衣肯定来不及了，顺手取了夹在背包外侧的救生毯。十元钱，效果好，昏天黑地中不觉一丝冷意，但明显感觉自行车被推动了，人用脚撑住地面才能稳住，勉强测了风速，瞬间十一级。风暴掠过后去打水，旭光湖被搅得一片混沌。傍晚进入一条纵深河谷，三头驴子带路，在河道中央，走一段等我一段，我只能断定此驴非常驴，心智过高了。约半个小时候，三驴跃上山坡不见了。我查看地图，正好是横切至烈马河的标点处。推上两河之间的草地，天色渐暗，打算宿营，却发现周边有许多小土坡，因昨夜有梦，和土坟有关，心有阴影，便又往前推了数百米，并将帐门面对亦真亦幻的晚霞。 夜风雪，湿软，赶路无视 季节河苏醒，破鞋子，很纠结 可可西里山脉，青色山梁 魔幻色彩，羌塘夕阳 D47（6-5），27.8K，宿营4868M上午漫河滩，过水难以计数，鞋湿透，脚泡白，冻僵。水多从鞋子烂口处渗进，很担心之后的日子。中午摆脱水域，进入干谷。谷地中有一块孤雪堆，呈冰性，高约两米，尘染，有些时日了，周围是一圈动物脚印。不解，首先干谷里此处唯一，即无冰川推至的可能，也无地泉喷塑的迹象，更无积雪不化的因素。不解二，一圈动物足迹，却无靠近，仿佛是一场围绕篝火的晚会。此景随后两日又各见一次，同样状况。下午进入另条一纵深河道，闹肚子，半响才注意，右首一只野牦牛虎视眈眈，左首三只藏羚羊好奇张望。好不尴尬，他们一定在想，这玩意蹲在地上作甚？河道探路，确定走向，是一百八十度后正转，回程从山梁上直插，由于没带GPS，无法准确判断停车之处，犹疑之际，见先前观我闹肚子的三只藏羚羊背对我往河谷下张望。我一个恶作剧，吓的羚羊惊慌逃窜。走到羚羊先前处往下一望，见是自行车。原来三只藏羚羊尾随了一个多小时，非要把我研究个透彻。的确，这里野生动物如同人类，对未知充满好奇。今天罕见的吃了六块压缩饼干，先早早吃了两块饼干，下午吃一块饼干，找了个太累的借口又吃了一块饼干。傍晚时分为庆祝即将抵达若拉错又吃了两块饼干。最初，一天两块饼干，分两次食用，支撑着漫长的白昼，那样的豪情万丈再也不复，只剩下一副被欲望填充的皮囊。七点就扎营，天气不好，浑身也湿乎乎的，又来了几头野驴在山坡上盯着帐篷良久，我希望他们能给我驮些压缩饼干出来。大声问可否？他们吓跑了。 水漫河床，但下游尚未贯通 野驴和藏羚羊混合群，有意思 守望帐篷，却不愿为我驮些美味来本来今晚无暇更新，但网友们的热情感动了DZY、GWY，特命我怎么的也要更新一天内容，节后必须正常更新，增加内容。在此，深表歉意，并祝大家国庆快乐。 D48（6-6），23.8K，宿营4871M照例，顺着一条浊水四溢的河床来到若拉错湖畔，这里是动物坟场，白骨累累。老死病死的野牦牛随处可见，尸体被野兽撕的散落。伴随死亡的是生命，此处的野生动物繁盛有如牧场，这与湖畔大片的硬草地及温湿小气候有关。沿着湖畔走，很少见的硬岸，蓦然发现一条“车印”，只有单道，约二十多公分宽，十公分深，起初怀疑是牧民的独轮车，后想想不现实，此地无人区腹地，人力独轮车即便能到也无法压出如此厚实的“车印”。有一点可以肯定，不是机动车所为。之后的日子里，常见到此种“车印”，一直到阿尔金白石山下。很大谜团，不解，后期深入雨季有所悟，“车印”是野牦牛的安全通道。它们同样惧怕冻土消融和沼泽，巨型身材比人更容易陷落，所以一条坚实可信的通道是生存必须。有些“车印”里充满牦牛脚印，有些“车印”则被踩实脚印难留。最后的疑惑，牦牛可以在二十多公分宽的通道里行走嘛？事实上是可以的。这是野牦牛在无人区腹地生活习性的一个重要发现。之后的日子里，有相当长的一段路是压着野牦牛通道走的，的确安全可靠。午后，湖畔一场风暴过后，空气中弥漫着泥土芬芳。“泥土芬芳”不是形容词，他是暴雨过后泥土中的植物孢子被释放而产生的怡人气味，这是春天到来的显著标志。想必很多人有过类似经历，某个午后，雨后浓烈的泥土气息扑面而来。下午来了一场更猛烈的风暴，平均风速达到十级，风中夹杂着硬雪子，若迎风的话一分钟就能把脸打烂。我躲在一条深沟里，见风暴时间太长，便琢磨利用下势能。先探了几十米的路，人不稳，回程倒着走，花样脸可不能毁了。确定前方地貌后便跃出深沟，那风瞬间就推着人急速向前，甚时，我得小跑才能追上自行车的步伐。雪子从耳畔呼啸而过，前方一片昏暗，没有视野，却也无阻挡，如此晕头转向的被风推了几公里，实在奇妙。风暴渐歇，忽见遍地的小花，多到难以下脚，紫黄两色，粘着风雪，楚楚可怜。羌塘，冬天与春天并存。蒙蒙中，前方一头小野驴，像是迷路，游荡着，伴我行了一程。雾霭散去，一群野驴围着我绕圈奔跑，时而一列绕圈，时而分成两列相迎绕圈，持续良久，他们难道特地为我表演“驴术”？若论羌塘最爱的动物，一是野牦牛，二就是野驴了。前者外表狂野、内心温和，后者外表温和、内心狂野。为人处事，更欣赏后者，但凡不惹事，逼急了一个驴后腿，不是常说嘛，脑袋被驴踢了。 刚老死的野牦牛，他们社会形态是老者自动离开族群，寂寞死去 尸体很快被野兽撕裂，累积的白骨更是遍野 风暴肆虐，湖面呈现汪洋的气魄 若拉错湖畔的野牦牛 再一场风暴后，春天蓦然眼前，冬天与春天并存 野驴很热情，为远客表演着精彩驴术，并让我代祝全国驴友国庆快乐 D49（6-7），24.9K，宿营4943M目标，翻越若拉冈日与可可西里山之间的台地，进入多格错仁强错盆区。路线好寻，若拉冈日一条山脊向北延伸，尾端有一座独山，锁定即可。台地缓上，需横切多条雪山下的山涧，有水则只一条。山涧充满浑圆巨石，这在羌塘河流地貌中少见的。其中一条山涧两岸陡峭，土质，河道里却是无数有棱碎石，应是冰川造就。此河难逾，思量之际，三头野牦牛从远处山坡上直冲下来，逼近二十米才转向，冲刺时间、路程之长罕见，我也着实心里没底一回。过了独山垭口是一片高山草甸，厚，块状，也是羌塘少见，一地牦牛粪，牦牛四处散居，貌似牧场。海拔6035的若拉冈日雪山一直在右首近处，相对高度低，浑圆无势，总有上去溜一圈的冲动。左首则是锯齿状的可可西里山脉，宛如一把钥匙，若是，一定是打开羌塘宝藏的钥匙。傍晚寻路，走了数公里，遇一奇景，斜阳下的金光透过云层打下几束，照在草地上的牛群，看得忘乎所以，用眼睛代替相机拍下。今天发生一件很糟糕的事情，就是炉头坏了。炉头坏了，无疑等于慢性自杀，所以国外探索者一般此长线，多会备一个炉头。早晨从六点半修到十点半，晚上从九点修到凌晨一点，全天修理时间八个小时。此前，炉头多次修理，多是分火盘和喷嘴积炭，清理便好，而今天似乎没这么简单了。早晨，炉子反复拆多次，总算折腾出些小火苗，烧了热水上路。晚上，又把炉子拆得七零八碎，能拆的都拆了，不能拆的硬拆。话说炉头是借朋友的，肯定比主人分解的厉害，因为没他那么爱惜。发现症状，是油管和喷嘴连接处的细管堵塞，内部，垂直，针眼般小，根本没法疏通。不知拆了多少遍，折腾了多少次，很焦心，依然无法打通淤积，倒是把汽油弄得四处。一次点火中，帐篷里火焰腾起，以最快速度将油炉扔到帐篷外，然后扑灭帐篷里的火苗，万幸，无大碍，只是防潮垫烧黑一块（帐篷等都是防火材料，只融不燃，速度快可避免杯具）。若迟疑一秒，后果不堪设想。实在无法，我已接受现实，炉子彻底废了，一路冷水泡糌粑何妨？客观说，这个打击是非常巨大的，在羌塘，如果连基本的热水都无法保证，确是和慢性自杀等同。至于烧牦牛粪，那是过度的浪漫主义，不现实。正因此，我又侥幸的一试再试，把喷嘴拆下，当废品折腾，直烧油管。忽然，“嘭”一声，火焰蹿升，烈焰熊熊，又是连忙把炉子仍到帐外。心里却是兴奋，炉子被烧通了？等火焰熄灭后，再次试验，果然，炉子正常了，真是死马当做活马医的一次典型案例。爱迪生试验灯泡，最后一刻，世界亮了。 右首若拉岗日相对高度低，浑圆无势，总有上去溜一圈的冲动 左首可可西里山脉，呈现钥匙形态，玩味 稀有的厚草甸，牛粪随地，远处黑点是牛不是粪 这个拍照姿势有点像芙蓉 D50（6-8），23.9K，宿营4833M整五十天了，却是迄今最狼狈的一天，究其原因，雪的节点。一天无照片，艰难前行。天空阴沉，大风裹挟冰雹时起。前路缓下且平铺，视野模糊也无妨，心里多少有些迷失感，全靠回望车轮印判断直行。唯一陡坡上演完美前空翻，顺坡溜一段，刹车早已真亦假，速度快，见一个沙坑，心想不妙，少顷前轮陷死，人被甩到空中。意识清晰，想着摔在沙土上没什么大不了。随即三百六十度前空翻落地，没有一丝卡带，就势爬起返身扶起自行车继续推行。稍后，才想起先前的流畅，一番自嘲，真是帅呆。下午七点过一条宽河，不再是小河小沟，四条主道，十多条小河岔，先探路到对岸，确定河底软硬分布。回程中，大风夹着鹅毛大雪扑面而来。恐怖的序幕终于拉开，雪不再干硬，而是着物即化的湿雪，衣物快速湿透，有如水捞。羌塘，不怕下雪，不怕刮风，可一旦进入雨季，雪变得又湿又软，加上大风裹挟着湿空气，挺不了几分钟就会把人体温抽尽。另外，湿雪也直接影响到地表变化，那就是沼泽和烂泥回归了。淌在回程的水中，挣扎着，是先扎营休息，等天气好转再过河？还是趁摸清了水道长痛不如短痛？答案是选择短痛。下身是水，一片冰寒，上身湿透，前方那鹅毛大雪封了视野，完全靠先前的GPS轨迹过河。半途便不支，浑身发颤，强忍着在水中推行。过河，即刻扎营，脱下湿衣，钻进睡袋，然后首次在内外帐之间生火烧水，来回三趟，一点五公里，体温低到极限。若论羌塘冻死，唯雨季风险最大，因为来不及防范，就可能在一场猛烈的冻雨湿雪中丧失体温。今日，天气的渐变，雪的节点，超轻羽绒服彻底进入了历史，换上劣质冲锋衣（此前50天只穿过一次），着装开始以防水为主。关于着装和气温变化单独简说了一段，后见文。 完美营地，西羌塘清澈湖一带（今日无片，借用去年） 野生动物乐园，和谐共处（今日无片，借用去年） 关于着装和气候【气候与体感】混沌但有逻辑，照顾好自己。此行羌塘横行高纬，只有节气变化，跨度4-7月份，海拔高于羌塘平均水平，世界屋脊之屋脊，地势西高东低，落差在400米左右。（不算阿尔金）。相同节气，东部雨水比西部多。小型风暴团频繁，区域性气候主因，夹杂冰雹，一天经历五个也不算多。从羌塘夜间温度来看，常年寒冬，从白天温度来看，四季皆有。通过近十年周边县市气象资料分析，推测羌塘腹地四月份夜间温度在－10℃-－25℃间，白天温度则受外界因素影响大，常态均在0℃上，天气受冷高压控制，季风猛烈，湿度低，沙尘大，降雨为固态。羌塘后期进入雨季，受印度洋暖湿气流影响大，对流天气频繁，固态降雨变成湿雪、雪球、冻雨等半固态模式，夜间温度在0℃-－10℃，极端可达－15℃以下，白天温度同样变化大，最高可达25℃。之前预测的温度变化通过实测是完全正确的，理性的，不夹杂超低温流言。今年，羌塘雨水偏多，温度偏暖，雪融性洪水和降雨共同引发河流失控。事后得知，昆仑山全线洪水，东侧格尔木市险些被上游水库冲决，西侧玉龙喀什河将淘金者围困，和田河也多年罕有的全程贯通塔克拉玛干大沙漠，至于昆仑山中段则亲身经历了。羌塘温度一日最低点在日出前半小时，最高温度通常在下午四点至八点。这种温度的高低分布与高原大气密度和地貌引发的辐射变量有关。体感温度则富于戏剧性，最高体感在上午十点左右，即便前期四月份，多次可只穿抓绒。最低体感通常在下午，如此倒置跟风力变化有关，风寒效应是体感变化的主要因素。纵观全程，前期低温体感并无显著不适，后期高温反而有多次全天冻僵，原因很复杂，即有后期的湿度、河水、装备溃烂的影响，也有身体摄取热量过少有关。如果各用一个字来表达羌塘前后期的体感，分别是“冻”和“冷”，前期“冻”得手脚麻木、脸歪嘴斜，但没危机感，后期“冷”得浑身发颤，体温似被抽尽，随时呜呼。【着衣】实用唯上，素色更好。此行着装很大胆，从专业角度来看很菜。也的确因减少负重而没带备用，吃了苦头。服装标准是按白天－5℃+八级风寒效应装备的，体感大致在－30℃左右，都为精品。可惜衣物在江孜县尽失，只剩身上所穿，随后极简（但并未脱离气温因素），在拉萨买了一套极星抓绒和非户外的超轻羽绒服御寒。夜间由睡袋和密封帐篷限制了空气对流，风寒效应指数小，比较容易掌握体感。前五十天着装：超轻羽绒服+极星抓绒套装+普通冲锋裤+普通内衣+GOX登山鞋+冲锋衣和救生毯各用一次。五十天后着装：劣质冲锋衣+极星抓绒套装+普通冲锋裤+普通内衣+GOX登山鞋+救生毯用一次。 可见，前期着装并不多，原因是运动状态，身体自身热量大，一旦静止时间超过五分钟，体感温度会明显下降，超过十分钟，那还是赶紧起来锻炼身体吧，好在休息时间都很短。衣物具体如下：超轻羽绒服：非户外，忘了什么杂牌，充绒90几克，春季款，非防水防风面料，前50天主穿，实际效果好，冲锋衣只套过一次，堪称奇迹。破洞多，用透明胶粘贴，第50天湿透后再没穿过，第58天丢掉。假THE NORTH FACE冲锋衣：不到三百块，前50天只穿一次，套在羽绒服外，50天后主穿。携带劣质冲锋衣是考虑磨损因素，只当雨衣就行，岂知太假，失算。探路者普通冲锋裤：轻便型，兼顾热天，全程穿，第18天开始裂缝，后期连犀利哥也不会瞧一眼，原因与气候恶劣、盐碱腐蚀有关，材料明显老化，防水贴条最先脱落。极星抓绒一套：普通加厚型，全程穿，感觉不错。普通内衣：天气总体干冷，对排汗要求并不高，带两套，扔一套。探路者GEX登山鞋：有过四个月使用历史，很舒服，轻便，质量不错，全程穿。第27天鞋面裂缝，后期破的连犀利哥也不会瞧一眼。主要原因是没带备用鞋，过于单一磨损，加之盐碱腐蚀，牛皮面老化。正因破鞋破裤破衣，后期惨遭雨季蹂躏，险些废脚。有条件，要买最好的登山鞋，脚是命根子。洞洞鞋：轻便，质优，第58天过河时先后被冲走，因公殉职，默哀。袜子：一双普通厚袜，四双迪卡侬徒步袜，后期磨损严重，基本是光脚走出无人区。手套：一双薄抓绒，一双军厚，一双极星专卖店买的杂牌，五双白纱。9.9块的薄抓绒是最冷季的主力手套，杂牌（还是最贵的）保暖性还比不上薄抓绒，军厚手套后期为主。出无人区时，就只剩一支军厚。雪套：没用一次，雪大戴雪套也走不了，雪小戴雪套累赘，过河戴雪套还不如赤脚，陆续扔。迪卡侬抓绒帽：全程穿，昼夜穿，劳苦功高，现仅存的羌塘遗物之一（后期弃车逃命，装备基本全扔），可拍卖换烟。360度遮阳帽：未用一次，第10天遗失，望捡到者拾金不昧。护膝：超市普通型，棉制，很好。护腕：一双连指型，全程穿，一双魔术贴型，未用一次，均该他用。救生毯：十元，效果好，用两次，不耐用，一场大风就把锡箔打得差不多了。魔术头巾：多用做汗巾。简易冰爪和护肘：第一天就扔。此行衣物最大杯具是衣物尽失，后期极简弥补，最大失误是没带双备用军胶、外裤，冲锋衣失算，袜子太少。如果驾驶越野车深入羌塘，自身热量少，衣服要加厚，不然会冷的骂娘。 关于装备装备永远是消耗品，不要被装备玩。装备体现对旅行计划的实施，很繁琐，仅束缚类就有6MM登山辅力绳、4MM登山辅力绳、1.5M魔术贴捆扎带、1M魔术贴捆扎带、20CM魔术贴捆扎带、硅胶弹力带、普通松紧绳、红头风筝绳、凯夫拉鱼线、两色缝补线、5号铁丝、2号铁丝、大号长尾夹、小号长尾夹、橡皮筋、别针、小快扣、主锁。所以只介绍部分装备，以供参考。美利达公爵自行车：入门级山地车，如果不是竞速竞技，足够好了。尼康D80相机：几年来的出生入死，更加证明了经典。至于镜头，利用好了，只发帖和杂志使用，和牛头之间并没有不可想象的差距。如果你想大幅输出展览，特殊摄影，镜头越牛越好，最好全幅CCD。佳能HF100DV：再昂贵的家用高清始终是鸡肋。GARMIN60CSX：困于GPS技术，后续产品往娱乐化发展，其核心技术未变，荒原旅行GARMIN60CSX仍是不可替代的经典。MSR耳语者油炉：省油，轻便，易维修，经典。HW1.5层单人帐：专为特殊环境设计，缺点自然也明显，就是结露严重，每天与冰同眠。质量超乎想象，全程帐杆无弯曲，帐布无破损，但防水胶条皆松脱，好在羌塘无液体雨，无渗透现象，相比价格，国外品牌也未必做的到。Ontrip防水睡袋：朋友的，质量好，同HW1.5层单人帐使用是绝配，否则麻烦大了。DEUTER防水驮包：防水面料皆易在低温下脆化，廉价的DOITE驮包稍加改装足以胜任羌塘恶劣环境，包括DOITE车首包。太阳能板：尽量自己组装，减少功率损耗，至于推荐，因物而异，但至少要有点基础电工知识，不然四处请教也是雾里看花。熊猫10×25MM望远镜：国产正牌就够了，除非军事侦察。又鉴于其重要性，带个好货更好，注意镜头畸变、边缘成像、通光量、倍数、分辨率、视场等。Nalgene水杯：一个好的水杯比水袋还重要，特殊环境下，广口比窄口好，透明比非透明好。Therm-a-rest防潮垫：从来不用好防潮垫，把它当做绝对消耗品。这次是借朋友的，效果好，质量优，但从舒适性和保暖性上来说并未有很大感触。但一个好防潮垫最大的问题是，质量太好了，一次艰苦的旅行结束后舍不得丢弃轻装行。fenix LD20手电：体积小，营地照明省电，三防，强弱光兼备，照明防身兼备。从实用角度看，一个好手电要比一个好头灯重要。Turning铲子：强力推荐，这款铲子找了很久，只有五百多克，钢口好，可当刀斧，紧急情况下有效防身，重要的是可通过安检。缺点是铲面小，煎鸡蛋都得小心，只适合土木工程不大的旅行。LED打火机：两块钱的那种，从性价比、功能性角度来说，它都是无敌的。尽量在高海拔县城购买，要磨轮的，此行带了八个，剩两个出来，送一个给朋友，他一听说是从羌塘里带出来的，利马还给了我。360度遮阳帽：虽然在着衣一文里提过，虽然遗失未戴一次，但还是要再说一遍，目的是为不要因大意，或为证明自己去过高原、走过艰苦路线而把皮肤晒黑，事实上得不偿失，隐患很多。此行即便天再热，也绝不会脱手套、卷裤腿、露胳膊，忍点热是超值的。迪卡侬指南针：任何情况下都要带个传统指南针，电子罗盘不可靠。6MM登山辅力绳加主锁：在减轻负重前提下，一根6MM登山辅力绳足以保障你的安全，若懂些绳索知识，仅配合一把主锁，会让弱者变成强者。在减负前提下，绳索最适宜配置应是8MM+6MM登山绳。（绳索使用谨慎。）墨镜夹片：羌塘紫外线高，保护眼睛很重要。有可能多备一副，我的眼镜、墨镜都被冰雹打花的不成样子了。组合钳：必带。尽量优化修理工具，很多功能都是重复的，重量自然也重复了。12V电压表头：现代电子产品都是集成芯片，坏了就坏了，要么就是线路问题，一个电压表头足以排查线路，如果和太阳能配合，电池充满了一测就知道，省去大量充电电路管理。各种小仪器：尽量采集些气候、水文等信息，带着问题旅行会学到很多新东西。暂时想到这些，随意简说。装备跟个人习惯、线路有关，仅供参考。一分价格一分货自然不错，但大多旅行远未达到装备精益求精的地步，实用就好。对装备要有包容，没有什么装备能让人变成超人。有必要，就稍加改装，也没有什么装备是特意为每个旅行量身定做的。多和别人交流，但不能迷信经验，要以自我为中心。注：特殊领域必须专业装备，知名品牌质量更好。 D51（6-9），0K，宿营4833M天气未见好转，阴沉，冷风，身体还未缓过来，蜷缩到十点钟起来，依然裹在睡袋里烧水热身。烧水过程中，又吃起糌粑粉，已然成了常态，糌粑粉成了无法抗拒的零食。无需水，满嘴粉末，如果不加限制，可以连续吃掉二两，竟也不觉得口干舌燥。下午一点，多云，太阳时闪，裤子干了，鞋子阴湿，羽绒服还在滴水，穿上拖鞋，披上正式上岗的冲锋衣在周边溜达。原本只是溜达，稍微探下前路，没想越走越远……先是登上河边一座沙山，瞭望前方见是一片沼泽，于是下山往北查看有无硬土通往高地，以便绕过沼泽。下山，干河道，草地，小海子，河滩……大约走了三公里终于确定可借高地绕过沼泽。回程中，土坑里窜出一只狼，闪电逃遁，因为连脸都没看清，此类遭遇均未归入猛禽数据里，或许是只狐狸什么的。但被狼这么一闪，居然迷路了。上了沙山，沿山脊边行边往下张望，可怎么也找不到帐篷。由于昨日阴霾天气没有显著坐标，对岸一片稀疏草地不分彼此，营地附近地标物更没留心，导致俯瞰山下河道基本一个摸样。一会儿觉得帐篷在东，恒下心往东寻，觉得不对，又恒下心往西寻……如此反复数次仍没发现帐篷。又开始认为帐篷被沟壑土坎挡住，于是下到半山东西搜寻，即有视野又少阻挡，未果。又沿着河边滩涂东西搜寻，总能找到昨天过河车印吧，未果。真是见鬼了，心态有点失衡，胡思乱想着。如此一段短程，且有河道可循，怎么帐篷会找不到呢？糟糕的是，午后的小风暴团生成，那边一团，这边一团，雷声此起彼伏。再找不到帐篷会很纠结，睡袋、衣服都在帐外晾晒，更纠结帐篷会被风刮走，临走之前未有任何加固，溜达嘛。一片冰雹已经扫到了我，顾不得，再恒心，告诉自己，不能再疑神疑鬼、犹豫不决，一直走到河西端一个小冰湖，冰湖之上是一片沼泽，这说明，帐篷必在相反一端，但又不能百分百确定，纠结啊。再恒心一直往东，一直走，不管内心忐忑，反正见鬼了就见到底吧……六点多终于看见帐篷，真激动，那可是家，荒原里的归宿。好在没哪个小风暴团扫到帐篷，正庆幸，一股大风将睡袋吹了数米，离水咫尺，真险。折腾的够呛，甩掉拖鞋上的泥，躺在帐篷里一边干吃糌粑一边反省，到底缘何？至今仍无答案，在谜一样的河流边茫然徘徊数个小时。 上午还未完全缓过来，依旧裹着睡袋烧水暖身 D52（6-10），18K，宿营4824M早行，推过沼泽边缘进入山地，眺望，真是英明决策，冬布勒山（东西转南北走向，孕育了若拉冈日、冈盖日等众多雪山）和五泉河之间的开阔地带皆是融化沼泽。山地遍布黑色火山石，点缀在浮土稀草间，土质干燥，底部干硬，发现多条野牦牛通道，追随一段。有段地貌类似连绵不绝的火山锥，确实不是，但遭遇那头搞笑野牦牛就在此处。牦牛堵在前面，我走就站，我坐就坐，我绕行就横堵，却无任何示警动作。我乐得顺带休息，他也惬意的继续晒太阳。通过外貌简单判断是一头衰老母牛，其诡异行为难以揣度。相持许久，见牦牛毫无让路的意思，便哄闹一番，这才懒洋洋的远去。丘陵缓上缓下，土质湿软，有局部陷土。今天状态一直不好，无力感，迷迷糊糊的，早晨就忘了装水，余水不多，过了中午就开始留意水源。五点多发现小河，近前却是泥浆水，又寻了相邻一条小河，还是泥浆水，所汇和所源的两处洼地皆如此。无奈灌了一壶水，想着一夜沉淀，晨用。灌好水不久，强对流天气袭来，三个大型风暴团相互拉锯。环顾周遭，一圈闪电，见此景便急速扎营，这般厉害的对流天气并不常见。刚顺风搭好帐篷，风向便猛烈掉头，夹着冰雹，骤然增大，帐钉瞬间便被弹飞，若不是手快抓住帐篷，被吹走就不会有往次好运气了。手根本抓不稳帐篷，身体倒进帐篷里压住，脚踩手按，帐篷变形，根本无暇顾及头顶滚雷是否会击中。如此靠身体压帐二十分钟才平息，作为帐篷，这是他经历的最大一场风暴。作为一款超轻单人帐，它要比我在这恶劣的荒原中承受的更多，当下，防水贴条已基本脱落，幸在无妨。 绕过沼泽上高地，即纠结也很危险 冬布勒山下的消融沼泽，若从中穿越，会成茶几 山地遍布黑石火山石，土质干燥，浮土厚 搞笑的牦牛，我走他站，我坐他坐，我绕行他横堵 破烂的鞋子，还不是最糟状态，却让人已经很纠结了 从高地上遥看冬布勒山，他由多座六千米雪山组成，都差不多高，难辨主峰 强对流天气，用身体压住帐篷 帐篷连接处的防水贴条基本脱落，帐篷比我承受的更多 D53（6-11），17.3K，宿营4830M昨日风暴过后小雪稀拉，晨，铺了薄薄一层。泥水沉淀一夜后好很多，烧水过程中翻起一股土腥味，倒掉，掠了一堆薄雪重新烧水。今天的路很难熬，以为小雪，可越往前走雪越深，有些厚达二十厘米。偌小范围内降雪就如此不匀，可见昨日那场强对流天气的乖张。脚受累，湿雪变湿脚，冷的不行。丘陵之间的谷地充斥着沼泽，由于雪覆盖，很难分辨，最长的一段沼泽初探时还是大雪全封，刚探完路便融了很多，水溢，泥沙也软下来。不再是湿脚，而是鞋子灌水泡脚了。过了沼泽后绕自行车跑了几分钟，把脚找回来。自前天湿雪开始，灌水鞋泡脚就一直延续到出无人区，中间只有几天幸免，最初还倒倒水拧拧袜子抖掉泥沙，到最后就麻木了。整天都这样水路，一遍遍的无用功罢了，却为后期脚疾早早埋下了祸根。小风暴团一天几个，无视，应付不过来。但大风暴团就不行了，尤其临近晚上的风暴团，基本就地扎营，否则浑身湿透晚上很难熬。下午四点进入一片平坦湖床，经历了一个超强风暴团，先是天空黑如夜色，闪电闷雷不断，随后风头夹着冰雹涌来。第二次用救生毯把自己裹起来蜷缩在车子后面。没法测风速，太大了，冰雹密度也是罕见。找词汇形容当时的场景很难，那种感受只有亲历才能明白，真是天地间鬼哭狼嚎。很担心头顶滚过的闷雷击中自行车殃及自己，但实在没地方躲，也来不及躲，手都伸不出来。虽没测风速，但体感上绝对是最大的一次。十多分钟结束，雷声远去，此时地面被冰雹完全覆盖，真疯狂。不久离开平坦湖区，进入草地，冰雹稀落不堪，估计那场风暴团里的冰雹大部分都砸在我头上了。离风暴团四十分钟后遇见一头棕熊，非常有意思，近处才发现，对方似乎也如此，双方都有点催眠状态。棕熊慢腾腾的斜插一会，然后径直朝我走来，停车致敬，那熊便走到车前面，晃悠悠的，我也没绕行，前方不远就是双湖至阿尔金的南北线，便跟在后面慢慢推。那熊走一段回头等我一段，我默契的与之保持一定距离。那熊忽在坡顶停下，用脚掌拍鼠洞玩，我趁势休息。过了一会，熊不见了，我推到坡顶后发现他还趴在地上候着，却没了继续往前走的意思。没有理睬，但也万不敢超越他，便放倒车子，斜插向前方去找南北线，不过百米，就发现了南北方向的深车印。再看那熊，慢腾腾的起身走了。这几天怪事多，谜一般的迷路，搞不懂的牦牛，光砸我脑袋的冰雹，带路的熊。算下来，我和这头熊前后同行了近半个小时。以前就听人说过，熊会给人带路脱离险境，估计也就是这种夸张放大的巧合。到了南北线需要做一个很大的抉择，就是该往哪里走？当下，不存在什么逃生路线了，北上，南下，东进都差不多，只剩下选择。顺着南北线各探了几公里路（探路过程中一直担心那熊会把干粮给偷吃了），车印很清晰，至于前往何方难以决断，因素太多，轻重难辨。晚上想了很久，也没明白，反而乱了心智，就这么迷迷糊糊睡去。 过这片沼泽折腾死 破鞋子成了最大的障碍，那种灌水后的湿冷难以忍受，鞋子的轻便性更无存了 小冰雹团很多，在荒野四处游荡 一场超强风暴团，想测风速，手伸不出来，同时也担心会成为引雷体 很玩味的棕熊，彼此相见时都有点催眠状态 见他径直走来，一紧张，手一抖，跑焦了 D54（6-12），0K，宿营4830M昨夜迷迷糊糊睡去，中途迷迷糊糊被闷醒多次，胸口如压巨石，喘不过气来。再次被闷醒时，见天亮了，但帐篷上明下黑，用手一推才知被大雪埋了。这是此行遭遇的最大一场雪，深度三十至四十厘米，帐篷周边更深些。后怕，帐篷下面被大雪完全封死，内部只有一个小透气窗，半掩着，冰雪又封了一些。简单计算，夜里帐内氧气含量比珠峰峰顶还低，这还不算二氧化碳的致命影响。半夜被闷醒多次居然浑然不觉大雪，熊都不理我，若被闷死这可怎么跟自己交代。上午都被困在帐篷里，远处有牦牛在雪里扒草，这过得什么日子。下午往东探了一段路，然后回来仔细研究，最终确定了行往何方，答案是南下。且听三个方向当时的分析，一是东进，计划沿沱沱河从唐古拉乡出来，直线340公里，直线150公里可能有牧民，200公里可确定有牧民，就算解脱了，然后顺大路出去。二是南下至双湖，直线250公里，由于南北线南端牧民非常深入，所以直线90公里就可确定遇到牧民，算是解脱了。三是北上阿尔金，没研究，只有两个模糊的信息，有硬路和在直线200公里的阿奇克库勒湖可能会有个“小饭店”。（以上均直线距离，和实际行路有差别，仅是技术分析，当下方位多格错仁强错西北角。）不选东进，是因为要穿越多格错仁强错和可可西里山脉最高峰岗扎日之间的泽水地带，（注意多格错仁强和多格错仁强错是两个不同的湖，一南一北，相距90公里），之后还有一片相连的低洼湖区，此季可以想象一片沼泽，如果遭阻没有方向可遁只能退回，这就需要足够的食物做保障，以及心态和装备状况，显然做不到了。不选北上，是因为对阿尔金没多大兴趣，就像罗布泊，觉得过分热闹了。阿尔金资讯很丰富，探矿的，捞卤虫的，自驾穿越的，后勤保障徒步的，包括丁丁和老苟去年的首次羌塘穿越……因压根就没想到会从阿尔金出来，所以即没做这方面功课，也没设计线路。两个有用信息，一个硬路早知，二是阿奇克库勒湖可能会有个小饭店，丁丁游记中记载。（实际上“小饭店”是风尘口大阪下面的回民帐篷，为淘金探矿人服务的，一直以为在阿奇克库勒湖附近。）选南下，因为一周左右就能遇到牧民，获得补给，然后从设计的长峡河路线翻过冬布勒山沿沱沱河出来。即便外星人把所有牧民掠走了，也可相对轻松的从双湖出无人区。从三个方向分析可知，南下安全容易，伸展性大，北上未知风险多线路长，东进季节因素影响太大，没有回旋余地。最终结果，大家已知，是走了最纠结的北上路线出来。人生，往往最后走的路都是最不想选择的路。 夜里大雪差点闷死，太不光荣了 下午天气依旧不稳定 这就是可可西里山脉最高峰冈扎日，也是西藏和青海的行政分界 D55（6-13），6K，宿营4803M晨，穿上湿鞋子，需要一点勇气。决定南下前往多格错仁强寻找牧民，除了想获得补给，还希望能搞件裤子和一双鞋子。大雪还封着路，困难的不是雪，而是薄雪下的冰水，所以每一步都很揪心，水直接渗进鞋子里。脚冷的厉害，身体也是，整天微颤颤的。小沼泽遍布，有些露头，有些被薄雪完全覆盖，所以确定前路非常重要，尽量控制鞋子在渗水状态，若是灌一鞋水，便是最煎熬的体感。天气阴冷，下午五点坚持不住，扫了一片雪地扎营。吃糌粑粉，拼命的吃，把最后几瓣大蒜消灭掉，撑得人很难受。多天来都是这样，无法控制，一直撑到人弯不了腰。早期糌粑的吃法是做成糌粑粥，目的是可撑大肚子，减少饥饿感，流食也易于消化，另外，热腾腾的加了辣子的糌粑粥，能给身体快速提供额外热量。现在不行了，不仅得有热粥，得有货真价实的干货，还得有填补欲望的零食。 稍低洼处便成了积水沼泽 雪地推车，冰雪会粘住制动，但要比软泥好清理 薄雪下是层冰水，每一步都很揪心 五点便难支撑，扎营暖身 最后几瓣大蒜，留影纪念 D56（6-14），6.5K，宿营4805M上午，一片泽国，以及一条条不知何时冒出的小河，走的很艰辛，下午两点多进入多格错仁强错东岸的草地，状况才稍微缓解些，大车印也重新出现。回望来路，河水中央有一条红带，是刚被冲入河湖中的红泥水。彼岸岗扎日左侧的三座奇特山峰清晰可见，分别是天台山，白象山，还有一座火山残骸，没有名字，但自从三天前初见到八天后都一直围着它绕圈，缘分颇深。这三座山就是北上阿尔金的必经之路，也是可可西里山脉最典型的一段火山地貌。顺着车印沿湖南下，途中被一头牦牛尾随，也是难以揣度，不细说。没多久就被宽阔的五泉河挡住了去路，车印戛然止住。河畔有许多未开封的矿泉水，对岸隐约有几个油桶，用望远镜还能看见水中有一个红色车顶，推测是东风六驱卡车，行话叫“炮车”。四月份一定有越野车队穿越双湖至阿尔金，事后得知，的确有两支越野车队分别对穿了双湖至阿尔金。这条羌塘东部的南北线所谓第一次汽车穿越是2005年，两支队伍，也是对穿，一支民间队，由北向南，旗帜“人类首次无后援穿越中国四大无人区”，一支中科队（CCTV全程媒体），由南向北，旗帜“人类首次穿越可可西里核心地带”。这就撞车了，两支队伍同时对穿可可西里核心地带，谁是第一了？自然是拥有话语权的，当然民间的也可以申请吉尼斯（民间队的确先到达双湖完成穿越）。闲说瑞典人Corax 和Nadine早在2003年就用自行车的方式穿越了此线，47天，37天无人，美国国家地理频道为此做了个纪录片，名字叫《太累了》。2009年，丁丁和老苟作为中国人首次用自行车方式穿越此线，36天，18天无人，获得当年《户外探险》金犀牛奖。这条线之所以走的人多，因为相对易，还能戴上若干无人区的帽子。我最初也是设计此线，见热闹了就放弃。沿五泉河往西寻找早期地图上的过河点，一路泥泞，旱獭和鼠兔却是四处乱窜，多如牛毛，从未见过如此景象，可能是被大雪憋了两天全出来晒太阳了。到了地图上的过河点，水的深度和宽度不足以推车泅渡，更重要的是河底冻土化开，两脚陷人。再往西探了一段，是河湖沼泽，更难逾越。当时没带丁丁去年的穿越轨迹，不知他们怎么过河的，事后查看，他们就是从之前的过河点通过的，日子只比我早23天而已。更恨了耽搁二十天进羌塘。被淹没车顶的车子于四月五号遇难，那时河面还是厚冰，只是运气不够好。晚上考量许久，两天来只推行了十多公里，这路没法走。眼前又是条大河，如果豁命也不是没有过去的可能，但是过去之后了？至少还要横切汇入多格错仁强措的三条大河以及大片的湖盆沼泽。除非弃车徒步（当日探路就走了二十公里，徒步通过性要强很多），当时还非底限，便很快打消这个念头。不过雨季羌塘的确超出预测，加上今年雨水多，更是一副吃人面孔。最后决定掉头北上，从阿尔金出去，这是最后一个选择，没法拒绝。从地理上分析，或许北上是条出路，因为要翻越数道山脉，属山地貌，沼泽大河会少很多。 喜欢这种小冰雹云，也是荒原游荡，随意江湖 没有名字的火山残骸，和它缘分颇深，半个月绕它240度。 白象山，一块突兀的岩石体，很美 没法逾越的五泉河 东眺多格错仁强错，冷暖色调相宜 车印旁扎营，做起拦路收费的营生 D57（6-15），15.2K，宿营4860M掉头北上，再无选择，所以定下心，再难都得坚持下去，时间也禁不起反复折腾了。轻车熟路，很快进入天台河谷，眼前景象，大吃一惊，宽阔的河床充斥泥水，而四天前到此探路时还是清水山涧，河岔跳脚就可逾越。之后四个小时，在泛滥的河床里只推行了两公里，看来北上也被理想化了，甚至更糟。还是心存幻想，顺着天台河翻上可可西里山脉就好了，如此继续坚持。过河的主要问题是无法看清河底面貌，只能用脚一步步踩，从而确定是稀泥、软沙、石砾。河道中间的滩涂同样无法凭借外貌分辨软硬，有些看似石砾硬底，却是比稀泥还软，有些看似漫水稀泥，却是硬如水泥，当然，有时又和外貌完全吻合。一切没了逻辑和规律，每步都要用脚踩探。泥似胶水，粘性大，车子被陷几次，把驮包卸了都很难把轮胎从陷泥里拔出。宝贝似的拖鞋先后殉职，一次过大河道，水急，脚一抬，鞋子被冲走了。一次陷在稀泥里，脚一拨鞋子留在原地，顾不得，赶紧把车给弄出去，回来捞鞋子，连影都摸不着。拖鞋丢了，对过河打击是非常大的，这才刚开始。 前轮陷死，驮包取下都难拔出来 没有逻辑和规律，这稀泥状硬如水泥 河谷往上变窄 D58（6-16），6K，宿营4872M河道满溢，无法通行，只能推上山依河而行。山顶俯瞰河道一片红色血腥，传说中的正宗红泥河，想要过此河，首选要克服半米厚的淤积泥沙。当时，已经意识到途径错误，（地图和地貌都有误导），应该在河道左侧前行，所以一直寻找河道窄处过河（窄，水流大，淤泥少）。就像某个朋友看照片时说，水没有想象的大。高处俯瞰的视野的确容易迷惑人，我也因此从山上两下河道，皆有被骗之感。第一次下山，近七十度推下，很爽。用光脚探河，深度，河底面貌。探河又出现几个新问题，一是狭道里的水流更急，河水皆雪水融化很冷，急水如风寒效应放大了水的冷度，每次探河也就几分钟必须上岸暖脚。有过惨痛教训，某些淘金者过浅河，因脚冻麻无法站立，竟被过膝的水活活淹死。二是光脚在石砾河底无法发力，跟碎玻璃似的，这也是拖鞋非常重要的作用。三是“混凝土”，一旦陷到膝盖深就很难拔出来了，等着被冷水终结吧。《可可西里》中流沙是被艺术化的，可怕的是那种泥沙混合体，类似混凝土，轮胎陷20厘米就很难拔，更何况人。并未探到对岸，水至大腿基本就无法站稳，失温更快。尝试一次性推车过河，很冒险，豁出去，被水流冲翻，十来米，脚踩到硬底赶紧上岸，宣告失败。然后再七十度推上山，寻找下一个两山之间的窄道。第二次下山，又是被迷惑，到了河道近处看了一眼就觉得胜算不大。探了半个小时河，没有通路，光人都过不去。最后一次还是冒险策略，推车强渡，豁出去，也许就成功。一直循着先前探路的轨迹过河，撑到离对岸几米的地方，接着水底是一道沟壑，自行车瞬间失控，侧翻，人被斜压着，一脚一脚的撑，撑到硬地，赶紧上岸暖身，宣告失败。接着再上山，难度最大的一次，局部八十坡度，推到三十米高处垂直无法再上，也不想回绕山顶，便横切山坡到缓处。横切前，休息了很长时间，心中不断默念，小心，万分小心。近八十度，坡面是一层松散的片岩碎石，脚下几十米即是河了，若一失脚基本就控制不住了，所以小心，万分小心。横切最难的一段后，好很多，连着切过两座山，下到另一谷底。河道非常窄，试探一下还是过不了河，心情很糟糕，身上冷，天气坏下来，天色也渐晚，便扎营，等着明天早晨低水位时再过河。很累，找水很尴尬，身依大河却不能饮用，太浑浊。滩涂上找到一洼水，清澈，估计是积水沉淀，烧开后竟是碱水，苦涩不已。推测洼地原本就盐碱渍沉积，水被污染，于是又找了一处洼地，淡水，却有些混。晚上吃很多，积蓄力量明晨过河，谁知…… 眺望天台河谷，血腥一片，远处就是天台山，很像千层雪雪糕 与此山平视了，由南向北，很远就能看见这座山，朝他走，进入河谷，翻越可可西里山脉 白象山近影，很优雅 两座喜欢的山的合影 D59（6-17），0K，宿营4872M晨醒，听见帐外一片流水声，出来一看，大惊，昨天的窄道不复，扎营的滩涂被洪水围困，赶紧收拾装备推出水域。这个打击太意外了，河道在一夜间扩宽四倍，还险些把帐篷冲走。让晨水位低时过河的想法见鬼去吧。天气倒是很好，把驮包里湿透的东西拿出来晾晒，也是盘点。辣椒酱彻底没了，茶叶剩两小块，盐也剩一小把了，其余的紫菜什么的早就没了，（搞不明白，怎么一下子消耗这么快。）压缩饼干剩五包（2.5斤），可恨当天又吃掉两包。闲说这压缩饼干很有故事，2006年6月20号生产，保质期4年，意味着3天后饼干就过期了。先前就发现这个问题，找老板，他说阿里干燥，饼干没事，我也就没再纠缠。快过期，饼干确实没事，但结块严重，有些需要用铲子才能砸碎吃，有些漏气，稍许变味，总体来说，没出多大乱子。下午携带GPS、地图轻装上山前往天台河上游探路。地图很有意思，天台河上游有个近九十度的拐弯，直行是条季节河百流河。到了两河交叉处才发现，所谓的长流河天台河很小，季节河百流河则一片宽阔滩涂，望而生畏。先前判断是正确的，百流河是岗扎日等数座高大雪山的汇流，怎么可能会小于可可西里山脉为源的天台河了。但此时已经更难过河了，顺着天台河翻越可可西里山脉。（地势上，对岸草坝，此岸山地死角。）从百流河源头绕过又绝无可能。在山顶上坐了很久，这才深刻意识到此时的羌塘才是绝对无人区，没有探矿的，自驾穿越的，淘金的，盗猎的，出风头的……回到营地，继续不停的吃糌粑粉，虽然食物如此匮乏了，但还是控制不住内心的欲望。往往打自己一巴掌后没多久又忍不住抓出半碗糌粑粉舔吃，此时的状态接近本能，就是吃，像猪一样的思维。至于过河，我还是幻想着明天水位会退去，这是唯一的选择，便是等待。 晾晒饼干，当天又吃了两包 晾晒茶叶，最后两小坨 辣椒粉（酱）彻底没了，很怀念辣的味道 纠结，烂裤子和倒数第二双袜子 红河水，刺痛感 水位标示，每一小时更新，最后逃脱和详细的水文记录有很大关系 D60（6-18），0K，宿营4872M水未退，反而又涨很多，典型的雪融性洪水，跟降雨无关。等待，继续等待，谁也不知要等到何时，非常煎熬，那种感觉就是日记上的N个感叹号。为了抵挡食物的诱惑，时而爬上山顶睡觉，晒太阳，走神，眺望，听歌。有时也会走远些，没有目标，只有让自己动起来，才能分化低落的情绪。天气总体好，但几场冰雹还是难免。能平地活动的地方就是半个足球场大小的峡谷死角，铺垫着很多火山石，有许多土红色的，还有些硬草根，对植物了解不多，但藏北很多牧民会用它引火。 背倚可可西里最高峰岗扎日，至山脚直线距离约25公里。 红色的火山石，块头比黑色的都稍大 夕阳漫步，顺着河水一趟又一趟 被冲刷下没多久的沙尘 D61（6-19），0K，宿营4872M第四天了，堵在峡谷死角里。等待就像抽烟，让人难以在恰当的时候放手。如果有足够的食物和香烟，这或许是一场不错的度假。如果可随意的抽身，旅行也许就没那么深刻了。的确，对前路失去信心，觉得走不出去了，但在生死存亡的问题上从未动摇。很矛盾，即觉得走不出去了，又不认为会消亡于荒野，那是一种什么状态了？就是混吃等死。（本来想形而上的描述这段心理，觉得又把简单的东西复杂化了，就是混吃等死、胡思乱想而已。在搞不明白宇宙边界和量子空间前，我们总是会将世界复杂化。）下午开始为突围做准备，将世界简单化，就是此岸到彼岸。将车子调整一番，清理掉两个驮包，使之轻便快键。在清理其中一个驮包时，居然在夹板里发现一块德芙巧克力，哦的神啊，吃完巧克力，又把包装纸给舔了个遍，那“牛奶香浓，丝般感受”原来是有前提的。肚子闹得厉害，再次欣赏水波星空，然后整夜失眠，胡思乱想，很危险的情绪。 从山坡眺望帐篷，每天N次随意溜达 清理掉两个驮包，简装准备 如果不在山上和河边，那一定在帐篷里舔食糌粑粉 黄昏中河流，只涨不落 壮观云柱 D62（6-20），5.4K，宿营4891M河水一直未退，已不抱希望，这样的等，逐渐失去了意义。必须有所行动，不然真混吃等死了。有了几天的水文资料，虽然水一直在涨，但有其自身的小规律，就是下午5点钟左右是水位最低期。这似乎不符合逻辑，但事实大于臆测。中午开始在下游的一段河道里踩探，首先沿河每隔一米左右距离放块石头，目的是要确定河水中的位置，岸边石头就像经度，而维度靠相邻步数记录，确定河流硬底、水旋、沟槽、软泥的准确位置非常重要，光靠记忆是不行的，也是致命的。岸边再置一锚点，身系绳子，顺流斜切。到下午四点左右，终于像下跳棋似的到了对岸，极度狂兴奋，太不容易了。赶紧打包装备过河，这时发现自行车爆胎了，见鬼，这几天根本就没用过车。顾不得，先将驮包一一渡河，最后推自行车时还是被水冲翻，好在有惊无险。未先补胎，换上备用的，谁知走了不到百米又爆了。只好补胎，再查看外胎，发现触地的地方有一道四厘米的裂口，没带备用外胎（有点不可思议），只好用那副不曾用过的护腕加铁丝包扎外胎，勉强能用。装上轮胎，没走多远，又漏气了……先前极度亢奋的心情再难寻觅，臆想着羌塘真要留人啊。之前的62天里就补过一次胎，两个裂口，而今天两个小时内补了四次胎，六个漏气点。这才刚开始，自行车轮胎正步入崩溃的边缘。晚上，终于来到天台河通往可可西里山脉的谷地入口，累得没心思想明天，但情绪不再低落，总算动起来了，只要上山就好走了。 轮胎步入崩溃的边缘 没有备用外胎，如此外科包扎 D63（6-21），14.5K，宿营5013M早晨切过天台河沿右首走，左岸是沙漠化地貌。没多久下起大雪，湿雪，一大早的，没法理会，只希望下午能有好天气，只要扎营时不浑身湿漉漉就行。深入河谷，堆砌着密密的黑色火山石，棱角尖利，随处积水，主河道又把谷地割成一段段，因此只能推上山坡前行。路烂雪湿，一片蒙蒙，遭遇几只棕熊，都是在逃窜时发现，包括野牦牛。很有意思，视野模糊，动物混杂在黑色的火山石中，随着我的脚步临近，冷不丁的，东一头西一头逃窜，怪猥琐的样子。到了山嘴尽头，转下河谷切到对岸，过了数次河道，淤泥少，水急，不深，乱石河底，扎脚。赤脚探路很纠结，表面凹凸的火山石和稀疏的针茅草与人为难，天气又十分的糟糕。过了下午四点，天气才好起来，上游河谷大涨，只能沿岸湿地推行，沼泽坑遍布，期间淌过N条小河，很杯具的发现，只要是条沟，就一定大水泛滥，这些沟只算是次流的次流。轮胎又慢漏气，补了几次胎，心情沉重。六点半，撑不住，趁太阳大好扎营晒鞋。 晨，切过天台河 迷雾般的推行在河谷湿雪烂泥中 铺满黑色火山石的河谷 到处山涧，只要是条沟，就一定凶水 六点半就扎营暖身 D64（6-22），0.8K，宿营5020M凌晨大雪，一直到早晨九点停，百般聊赖，很难控制情绪。趁太阳出来，又去处理轮胎，刚补好一个，另一个地方又漏气了……差点崩溃。这是没有想到的，轮胎老化的如此严重，瞬间似的走向衰亡。只带了十三四片补胎片，三天时间就剩最后一片了，补胎胶水也危在旦夕。解决的办法就是轮胎充一点点气，只要不干瘪就行，生怕又触及轮胎脆弱的神经。中午把最后一块压缩饼干吃了，坚守了四年，只过期两天，吃的时候笑出来。决定继续往前，不能再这样耗着。一路冰水，比多格错仁强错湖盆区的严重多了，坚持了不到一公里又遇大河阻挡。此河是天台河上游和一条支系的汇合处，堵得人哪里也去不了。赤脚探河数小时，上上下下，主河次河，太急了，水底大石多，到大腿就没法站稳，水寒的也厉害。到了六点钟，停止折腾，抓绒裤湿的厉害，随便一绞两碗水。躺在帐篷里状态不好，担心又似前几日，水只会一天天的涨，所谓的晨时水位低的想法彻底见鬼。查看轨迹，离十天前扎营的地方直线距离只有24公里。反而清醒了，这是场持久战，像高手对决，活得长的人才是最终胜利者。再次清点粮食，只剩下五斤左右糌粑，比乒乓球体积还少的盐巴，一点茶叶，三两左右的酥油。计划吃十天，撑到鲸鱼湖，想象着那里游人如织，牧民如星，牛奶做成的湖，糌粑堆成的山。十天到底能走多远？真的没底，但心态忽然好的过分了，走一天是一天，实在不行就弃装备。现在回顾，那天是个很重要的心态转折，破罐子摔到底的耍泼。 大雪，大雪，大雪，虎，虎，虎 处理自行车，差点崩溃，人 不到一公里又遇洪水，纠结 沿岸来回探河，脚印相逢 D65（6-23），10.6K，宿营5024M昨夜，身体非常不适，熬到凌晨两点入睡。醒得较晚，八点，见大地冻得非常硬，令人无法相信的是河水退去的只剩底子，青石裸露，溪水潺潺，冰凌充斥，轻松踮脚就可以过河，神助。没吃饭，趁着水退地硬赶路。走在硬邦邦的河床上，对比过去几日，太不可思议了。硬地坚持一个多小时就开化了，前两小时走了3.5公里，剩下6公里耗到晚上，一直跟沼泽挣扎。中午到了可可西里山脉“山口”？连绵的大丘陵，杀机四伏。见过烂地，没见过如此烂的，那种烂不在视觉上，而在每一次落脚之后。看似正常的地面，一脚下去就像踩在豆腐渣里。这难道就是传说中的冻土消融？见过，但没见过这种。整片大地都是外焦里嫩的豆腐渣，野生动物也仿佛瞬间消失，不见一个，很恐怖的感觉。经验归纳，表面有碎石的沙砾地最陷，反而看上去水汪汪的稀草地是硬底，如果遇上表面有龟裂的红土就得小心了，它可能是妆术高明的稠性泥沼，陷过膝盖就难以逃脱了。过冻土消融地带，必须先用脚探，太软的不行，稠性大的反而有过去的可能，以前山地经验发挥了作用，就是短距离冲刺，飘脚，胆大心细。重点是控制距离和身体瞬间的平衡性，如果一口气没冲过去，不好意思，有的折腾了。（无路绕的情况下尝试，有危险。）有个案例，羌塘之前和朋友去林芝，一道浸水沼泽，四米左右吧，我在前轻松过去，鞋面都未沾泥，并告诫后来者要快，不要思前想后的。一个朋友很勇敢的做了反面教材，陷在沼泽里，人拉不出，后被木板搭出。这个案例说明什么？沼泽里没有支点，低头找下脚点是大忌，挑来挑去都一样，时间稍长就加速了重力下陷，再一挣扎，完了，形成重力怪圈，两脚越陷越深。车子屡次被陷，说严重的一次，纠结到底。绕陷地，见一块干硬的平坦地表，迅速把车推过去，完了，一脚陷脚踝，二脚陷半小腿，三脚弃车撤人，粘性太大了，再不撤来不及了。随后试着靠近拖车，无效，反而把地越踩越烂，地下水都踩了出来。再试着靠近自行车连边都摸不上了，周边也被踩得走样。折腾够呛，都考虑弃车了。但装备要弄出来，找了那十块钱的救生毯和两个防雨罩铺在地上，一番折腾，好歹把包弄出来了。再看垫脚物早没影了，光救生毯铺开就两平方。这时，自行车远远的就不能靠近了，放驮包的地方踩了几脚后也无法立足。转移驮包后，用铁丝套上绳子圈在自行车上，拉拽，车子移动了，后轮却被拖出……总算把自行车弄出来。遇到大面积深度沼泽就没办法了，没有技巧可言。途中两次大洼地，都对自己说过不去了，等明天上冻再走吧。经过反复试探，还是稀里糊涂过去了。遇过几次险，总之一陷到膝盖，利马倒地匍匐出来。这种沼泽是典型的冻土消融加雪水浸泡，其冻土表层融化，深处依然是常年冻土，所以那种《可可西里》流沙性质的很难存在，但一样致命，陷过膝盖就不要挣扎了，伏地出来。过了五点开始下山，真正到了可可西里山脉另一端，依然是条混浊的河，岸边、山野极度陷人，顺着一条野牦牛安全通道才下来。天色晚了，扎营地难觅，地太软太烂，不经踩。 大折腾，弄出自行车，还能发现之前的垫脚物吗？ D66（6-24），18.7K，宿营4886M收拾好东西，帐篷下是一个窝，地软人压。上午阴雪，下午四点钟后天气全面转好。上午唯一半小时太阳很神奇，那是顺着一条漫河进入一个山谷，此谷名曰兔子沟，兔子未见，却是小花绿草硬地，河水清澈，山石有型，非典型羌塘地貌，是一段难以忘却的行路。太阳也神奇的露出来，似乎在补偿上午的水泽蹂躏。快捷而舒畅的出了山谷，进入向阳湖的领地。北上阿尔金就是翻越数道山脉和其间的湖盆区，先后是可可西里山，向阳湖区，红泥岗，围山湖区，长蛇岭，桃湖区，昆仑山，从而进入阿尔金鲸鱼湖区。从向阳湖西侧环绕，路不再是想象的软烂，除去探路行程差一点就到20公里，很久没有这个速度了。湖西侧是水坑类型的沼泽地，边缘很硬，但难绕圈，方位需要把握的很准。很多旱獭，冷不丁的从土窝里窜出，也有狼，或许狐狸，均没看清脸，速度太快。湖西北侧通往围山湖的方向，再度出现大量的黑色火山石地貌，其中发生一件趣事，在一片火山石窝里，蓦然看见一只奇异动物，第一反应是火鸟，火鸡，总之是鸟类，再仔细一看，是只直立站着的肥大灰兔，吓他一下，玩什么COSPLAY扮鸟。顺着一条清水河进入宽阔谷地，一个完美营地，帐篷正对岗扎日背面，终于逃脱他的雪融洪水，可惬意观瞻了。本想以庆祝的借口舔点糌粑粉，被控制住。中午路餐自昨天被取消后，的确更加力不从心，整天就靠不到八百大卡的糌粑热量维系。控制的代价就是晚上开始失眠，满脑袋都是美食，想的流口水，想的凌晨前必然无法安然入睡。 记忆深刻的一段行路，非典型羌塘地貌 战争与和平，车轮与野花 回望可可西里山脉和向阳湖 逃脱岗扎日的雪融洪水，终可惬意观瞻 D67（6-25），10.5K，宿营4958M天气和昨天一样，上午阴雪，下午大晴，如果掉个个会很痛苦。今天行路就做了一件事，捷径，翻个大土坡。冻土消融状态好很多，还是有了可可西里山脉做参考，就没谁敢称霸了？中午又补了三次胎，其中，从另一个轮胎上撕下两片旧的补胎片。后来补胎液彻底没了，所以就连撕旧补胎片救急都不行了。没过多久，两条轮胎都没气了，打气，气筒断了。对于自行车而言，真真的穷途末路了。压着钢圈推车很费力，便尝试改装成一辆独轮车，减少轮阻。独轮车，就是前轮+车把+前叉。拆车挺麻烦，此生第一次补胎和拆车等等都是在无人区里完成的，我的车龄两年，第一次玩车羌塘，第二次玩车羌塘，所以对车的经验并不多，都是实践中学习。当下，独轮车装好后发现车把不灵光，这才发现车把套前叉的两端都有转盘。独轮车弄好了，看似不错，未等欣赏够，一阵大风将地上散物吹走，此行最麻烦的一次，主要是睡袋和防潮垫同在行列，奔跑着先找块石头把睡袋压住，接着追防潮垫，那家伙轻，追了近一公里，回程揍了防潮垫几拳。右脚在这次奔跑中恶化，肌肉劳损什么的变成了筋拉伤，脚踝不能垂直地面，歪着走才行。又丢弃一些装备，把两个驮包捆绑在前轮两侧货架上，还有相机包，背包，睡垫什么的，试着推两步，不爽，拉两步，还是不爽，样子也很滑稽，主要问题是重心无法掌握，独轮车拉杆必须从轮轴延伸才行，显然我的独轮车过于浪漫主义了。还是坚持着，推了三百多米，猛然把车一摞，骂了句，还真以为我是玩杂技的啊！然后回头去找拆散的车架。把车拼好，能拆的零件都拆掉，剩链条搞不掂，又回头找拆炼器，第一次用，兴奋，以为很精密很技术，很快捷的把链条拆了。这时又发现，后货架一侧断了，其实也没什么大不了的了。6MM钢筋，在螺丝间都加了橡胶垫片，避免硬连接的金属疲劳，极端的环境下还是不行。前货架也是用6MM钢筋焊接的，除了绣，一切都好，负重不多了，驮包置前，轻物置后，够用了。今天，是自行车的崩溃之日，最具崩溃代表性的不是轮胎或钢货架，而是脚撑。很有故事，道来。因为去年羌塘之行深刻意识到拍照很辛苦，原因之一就是要把自行车放倒、再扶起，看似简单，却极耗体力精力，流失很多拍照机会。一般的单脚撑基本上瞬间弯，钢制的无法保持大负重的自行车平衡，所以特地寻了一款类似摩托车的双叉中架脚撑，试验很不错，可羌塘实际地貌是不适合的，地太软，脚撑难以平衡，所以一次未用，但又拆不下来，（由于其固定结构很顽固，又没带匹配大扳手，尝试无数次无用）。每每看着这脚撑，觉得委屈，两斤多重的无用货，早知换成备用鞋。也是在今天，奇迹发生，脚撑松动，两端螺丝用手就拎开了，终于卸了这负担。晚上又失眠，除了想吃的流口水外，还想着脚撑的重量可以换些什么好吃的带。 把车子拆散架 传说中的独轮车，需要杂技演员才能推稳或拉稳，有点恶搞了 后货架断了，能拆的拆了，最后配置 D68（6-26），19K，宿营4898M依旧上午，阴冷，湿雪横飞，中午天气短暂好，下午是频繁的冰雹团，七点撑不住扎营，除去探路轨迹重叠，离实际推行至20公里还差那么一点。几个插曲简说，一是近距离遇狼，很近，河沟遭遇，蓦然撞上，双方都诧异了那么一会儿便各自淡定，各走各的。掏出相机，一通猛拍，很爽，超近。到近处，狼的眼神有点飘，可能觉得我的第三只眼太大（镜头），又死盯着他。交汇不到三米时，收起相机，提高警惕，狼也是。我们四目对视为中心点，错肩，头颅转动，这个距离太近，彼此都很提防。感觉有点像江湖仇人陌路相逢，却又不知对方几年来的身手，不敢贸然行事。狼转到身后面对站立，我也是，谁也不敢轻易相背直行，恐遭背后黑手。相持那么一会，狼忽然伏地，用下巴蹭土，打转，矫情似宠物，这才放心推车直行。过了转弯，倒车探路，见狼还在自顾玩，但眼神始终瞟我。无视，探路回来，狼不见了，觉得有点寂寞。十二点，来到到围山湖东侧的烂泥河，看了一眼，便又对自己说，过不去了。此泥河宽约一公里，烂泥泽，其间夹杂着十几道河叉，看一眼就头晕。查看地图，此烂泥河长约三十公里，并行于红泥岗，绕过去不可能。最后花了几个小时还是过去了。记忆真是不多，就是不断挣扎、探路，事后翻照片发现在河中拍了两张，往前按下快门，朝后按下快门。有点要说，就是这种宽阔河床，视野角度很重要，平视根本无法辨析河叉和滩涂分布，必须高处俯瞰。思维也得像只鸟，翱翔高空，指引前行，这或许就是直觉。过河后天气就转坏，过水难以计数，又两次较大的阻隔，一段粘泥滩，一条沼泽沟壑。话说轮胎干瘪，压钢圈阻力大，但过软地却不那么陷了，可能胎面宽幅了吧，就是体力多耗些。七点不到扎营，晾鞋子，只要不滴水就成，抖泥沙。尤其裤子，夹层里像是沙绑腿。风大，依一条河扎营，睡袋被吹，慌忙中赤脚追，扎脚，疼得够呛。晚上又失眠很晚，想吃的，已经无法摆脱这种情绪了。想着回拉萨吃多拉同学的菜，这丫天生厨艺细胞，又是川人，说好，回拉萨三个喜欢的菜管够，一是清炖羊肉，二是西红柿炒蛋，三是凉拌莴笋，当下又加了两个，青菜炖豆腐和回锅肉。如此，五碟菜像魔咒似地在脑袋里转个不停。实然，这也是一种巨大的幸福感，若每天晚上想着四万一平米的内环房子，一定是极其痛苦感的，但只要走出去，那几个菜就一定能够满足，从而成就了巨大的幸福感。真正的幸福感，是触手可及的，真实的。 挑两张狼猥琐的样子，后一张勉强有威势 泥沼河中间，前拍一张 泥沼河中间，后拍一张独轮车用后轮也许会好些？刚回北京两天就受凉发烧了，躺在床上一天一夜，产生各种幻觉，有人要杀我。。。在那种恶劣天气下生病的概率会不会更大些？ 这个你有考虑过么？一旦生病，可能耽误行程，体力，信心，自持力。。。 甚至性命？后轮和前叉不匹配。人没有想象的脆弱，都是工业化惹得祸，把本能丢了。 D69（6-27），19K，宿营4976M从路的角度上说，今天不错，天气的角度就极其糟糕。一整天冻得手脚发麻，脸斜嘴歪，就拍了一张照片。早晨，壮观的天象，东方天际一束红彤彤的光柱斜射出来，背景是暗黑的云，从未见过此景，可惜脑子犯浑，钻进帐篷准备取相机时却收起了睡袋，美景不得分享。顺着似无边际的沙滩进入逼仄河谷，两岸怪石非常有特点。激流充溢，基本泡在水里推行，好在河底硬沙砾，否则够喝一壶。过了山口照例顺河而下，同时接受大风和冰雹的洗礼，时间尚早，就一直撑着，到了五点看不行了，冰雹变成漫天飞雪，再也撑不到太阳出来暖身，赶紧扎营。失温太多，帐篷弄了半天才搭好，再次裹在睡袋里烧水热身。果真，雪越下越大，那个冷，牙打牙，睡袋也湿乎乎的，还一堆泥沙。 很冷，今天就拍了这张营地照 D70（6-28），16.7K，宿营4890M昨天按了一下快门，今天则一张照片都没，太冷，脚疼，泡水，所以放了一段前期吃饼干和缝补的视频，娱乐下，算是弥补当日无片。今天的目标是下到桃湖，过了桃湖就是翻昆仑了，肥羊正在大锅旁等着我往下跳。雪一直飘到上午八点，昨天的衣服还湿漉漉的，要命的是鞋子，没勇气再穿。想着多啦同学的炖羊肉已端上了桌，咬牙穿鞋走人。（现代人多没吃过食物的苦，再怎么琢磨也无法切身感受。）顺条大河而下，河滩被割成一段段，今天立下个目标，就是鞋不灌水，遇水就脱鞋。脚再被沙水蹂躏就真的要废了。但没过多久，过条小河叉时推车没跳过去，还是鞋子灌水了，于是改了目标，尽量少灌水。下午很晚的时候拐上一个山坡，发现结实的大车印，许多小车印都汇了进来，更可喜是硬草地，车印也硬，加之下坡，便尝试着顺坡溜一段，没了刹车，摔一跤，乖乖推到山下。桃湖风景极美，草茂湖绿，臆想着的应该会有牧民。如果没有牧民，等我老了，就来此放牧，霸了这地盘。身体出现新问题，小腿起满红斑，龟裂，肿胀，刺痛感，碰着内衣都剧痛，估计冰水泡的。脚也肿的厉害，脱不下鞋子，最后一咬牙脱了鞋子，有点像电影里点燃火药消毒伤口。感觉脚冷飕飕的，低头一看，还有半截袜子留在鞋子里。身体状态没法细说，但心态尚可。最糟糕的两个阶段已经过去，一次是进羌塘前，压力大，任何一个环节出现问题都是致命的，每天脑袋里就是上百个问题转圈，是不是真的没问题了？怎么可能会没问题，这或许就是旅行的乐趣，尽自己的能力周全，去面对未知。第二次就是被堵在天台河的几天，类似禁闭。西方有句名言，已经最糟了，还能怎么糟？再套句葛优的台词，看未来。再闲扯三个问题，第一是关于人的问题，现代人越发依赖机器，这不是什么坏事，却丢了很多本能。人的本能足以让一个健康的成年人完成无数艰苦的旅行，我们的祖先不就是这样吗，最近也不过几千年前石器时代的事。一时抛弃不了社会属性、羁绊太多也没关系，一场艰苦的旅行也证明不了什么，只要尽兴就好，在别的领域一样是探索，毕竟时代不同了。第二个问题，装备。装备很重要，但不能保证一场旅行的顺利，就羌塘而言，谁也不知道装备最后会溃败到什么程度，也不可能准备的让装备不出问题，除非有后援车。羌塘腹地的雨季又是怎样骇颜，没有多少资料可以参考应对。问题是有没有做好最坏的打算（不是生死问题，这种问题想多了，哪里也去不了），做到了心理坦然，而非临场马后炮满腹怨艾。最后一个问题，心态。很对人对此关心，我想说的是心态是很个人化的东西，没有答案，也没有借鉴意义，比如有些人不敢看贞子，有些人还觉得不够恐怖，没法衡量。至于我最基本的旅行心态是，不过度标榜，不吓唬没去过的人，不区分强弱，人与人区别并不大，只是生活的方向不一样。预告：今天琐碎多，更新少，剩下内容两天更完。抱歉，视频搞不定，看原址吧：http://v.youku.com/v_show/id_XMjE0NDAyNDky.htmlD3天吃饼干，有点像阿甘的巧克力，永远不知道下一块饼干是漏气的还是结块的。购买地址，狮泉河红绿灯劳保店，小心过期。 抱歉，视频搞不定，看原址吧：http://v.youku.com/v_show/id_XMjE0NDAzMzIw.htmlD21天左右，缝补衣服，很贤惠，娱乐下 D71（6-29），16.7K，宿营4916M顺着车印进入峡谷，逆水而上，车印都被冲了或在水底沉寂着。终于开始翻越昆仑山，没有想象的高伟，最高海拔也5016M，山口也是浑圆，过了山口也不知。昆仑山西陡东缓，克里雅山口是西昆仑山进入羌塘的一个重要通道，也是老外最早用自行车方式穿越，特别说的是国内杜一，带了几个馕九天时间就翻过了克里雅山口，体能和气魄都令人惊羡，这也是国内最早用自行车方式穿越羌塘。另说克里雅山口也是我十分向往的地方，那里有羌塘仅存的活火山，（上世纪中叶冒过烟，最早的新藏线因此被迫改道。）昆仑山北坡，峡谷里的水增大，过河遇到些麻烦，但比预想的好很多，水也不是那么浑浊。天气越发糟糕，迎面，密集的雪子和大风，不支，扎帐篷。到了下午八点，天气神奇的晴朗，昆仑山完全是另一副模样了。回首来处，感叹进入阿尔金地界了。如果运气非常好的话，明天就能到达阿尔金最大的湖——鲸鱼湖，在当时的臆想中，那里可能会遇到人，过去几天所有的动力都来源于此。即便遇不到人，也会有传说中的硬路。糌粑就剩一斤左右，为最后的冲刺多吃了点，又多加了些盐。在荒原中控制食物，的确很难，尤其四五十天后，那种食物的欲望非常折磨人。所以前期控制非常重要，是为了留给失控期一个较大的空间。如何控制食物？最简单、最重要的就是知道自己每顿吃多少，这靠记忆和感觉是不行的。有个舀糌粑的碗，能装多少糌粑精准到克数，大蒜按瓣数买，盐按每天十多克的标准配，酥油用刀划线……所有的食物是按理论极限80天配置的，（最大携带量，提供基本热量）。虽然未达到理论值，但也非常满意了，算是一次有益的尝试。（每个人的食物理论值都不一样，仅供参考。）为什么没有达到食物的理论极限值？关键就在于节奏乱了，若非深入羌塘雨季，若每天都保持有节奏的运动状态，那么对食物的消耗会少很多。节奏看似作用于身体，其实是对心态的控制，这就像在打游戏的最紧张关头，忽然被贾君鹏妈妈喊回家吃饭，你说恼不恼。动了气，乱心智，没过关，下次打游戏一定要找家贾妈妈找不到的网吧。再延伸，一次艰苦的旅行前，越少人知道越好，否则随便被谁过度关心下，在心态上都可能有微妙的变化，失去了勇往直前的节奏。很多被赞助登山遇难的就如此，条件不允许上，可后面有眼睛盯着，再则失败了以后赞助商也不好找了……一想到这些，完了，节奏没了，脱离了旅行的心态，那注定难以维持在旅行的路上。 翻越昆仑，一天都很糟糕的天气，黄昏，天气蓦然转好 D72（6-30），32K，宿营4816M晨，大地冻得真硬，喜出望外，昆仑山就是昆仑山。打好装备就过河，记忆深刻，不过三四米宽，脚冻得想骂人，这是此行从未有的。一直沿着平缓河谷，为了绕河时而要上软草地，有些周折。快出河谷时一次探路，发现前面溪水中有一块大牛粪，有这么大的吗？再仔细看，牛粪会微微晃动，这就更奇了，走近……忽然牛粪一转身，是头熊。他很淡定，瞥了我一眼继续泡屁股。我赶紧跑回车处取相机，创作欲望空前。再到溪边，端起相机，熊起身，不敢造次，避免惹怒。和熊隔着溪水并行了一段路，他见我死跟着便直行去了，终于让熊给我让路了。我没直追上去，曲线救国，绕了一段溪水去找它，见熊混进一群牦牛，再找，彻底不见了，熊混牛群、熊不见，两者都很诡异。出了河谷，再也不受水流困扰，沿着潜出河水的大车印朝鲸鱼湖推去。心情格外好，对面小崖顶三头牦牛吃草，向他们不停招手看其反应，他们很迷茫，很不淡定。天气好，路好，心情好，随后两件趣事。一是看见了祥云，科学解释是光折射，但还是过于奇妙，不免唯心起来，无非神佛之类的臆想。总之好兆头，终于结束了，祥云迎之。二是……远远见一条蓝带，鲸鱼湖是也，上世纪五十年代才被飞机发现，是阿尔金最核心区域。不时用望远镜搜寻牧民痕迹，很失望。又见一黑点，用望远镜看之，端稳，光线抖得厉害，只见……吓得我差点扔掉望远镜，心率倍增。整个行程只有两次惊吓，一次噩梦，不表，一次就这了。同学们，我看到了ET！！！正朝我走来！！！缓了口气，冷静下来，再仔细观察，原来是一头直面的野驴，太不淡定了，哈哈。遇到鲸鱼湖西侧一条汇河，原来的大车印早早被淹了，路烂的连水边都近不了。绕上游数百米，过河，心想，这是最后一次过大河了。过河后戈壁路，好走，虽没遇牧民，但毕竟硬路，迟早遇车。当日超三十公里，非常鼓舞人心，有点昏头了。开始矛盾的设想，如果遇人，是先讨烟还是先讨吃的？ 出昆仑，海阔天空 泡屁股的熊，很有绅士风度 熊混进这群野牦牛中消失，诡异 祥云？一通唯心主义乱想 鲸鱼湖西侧汇河 D73（7-1），33K，宿营4715M晨醒，雪，头大。推了半小时三百米，决定弃车，这路一天最多走十多公里。背挡风雪，匆忙收拾必带品，睡袋、帐篷、炉子……尽量极简，大概十五斤。没背负是最大问题，背包，斜挎睡袋，腰夹GPS、DV、望远镜，像个先锋队员去革命世界。为什么这才弃车？有很多问题，最重要三个原因，一是压根没想从阿尔金出来，功课全无，前途未知，光靠臆想不行。二是没一个好的背负系统，这需要舍弃很多基础装备，万一遇到紧急状况，风险太大。三是还未到底线，不到万不得已不能最后一搏，要向武林高手似地，被人砍了N刀，最后一刻出其不意甩个暗器。此时，弃车机缘到了，不得不弃。我已完全从昨日梦中醒来，这路哪会有车进来，见鬼。那祥云？浮云，浮云，都是浮云。最后一个目标，阿其克库勒湖，丁丁游记中的“饭店”，代替了鲸鱼湖成为新的精神寄托。路比预测的还烂，昨日之路不是常态，特殊地质而已，就像后天的白石山之路，他们是被沼泽烂地遗忘的一段，却迷惑人。眼下路，连炮车也进不来。走了小段路，扔了望远镜，走了小段路，扔了水袋，然后调整节奏不停的走。到了下午，腿脚随步伐巨痛，腿伸不直，膝盖不能弯曲，脚尖不能超前，脚板不能平展，可能是长期不良推车姿势，猛然变成正步加速了肌腱损伤。以往徒步中，膝盖容易受伤，但整条腿都似肌腱损伤还真第一次。腿部的皮肤红斑更重，随步伐摩擦着衣服火辣般，至于鞋子问题导致的摩擦痛基本被掩盖了。此时，保持节奏很重要，包括与痛感的磨合，不停的走，慢而有频率。下午三点半，经遇一条河，车印方向和纸质地图脱节。（只有一张西藏地图的边角，有部分阿尔金区域，上面路线多是象征意义，但大方向值得参考。）所以，生怕跟进一个无人矿就糟糕了。查看GPS，这条车印似乎通往贝勒克湖，湖被昆仑山分支阿尔喀山围堵，等高线显示其中有些平缓的小山口，加之阿其克库勒湖至祁曼塔格乡之间有条路（完全被边角地图误导），这条车印是不是前去交汇的？如果不是，翻过阿尔喀山右转也比GPS线路近。（根据早期地图描了一条鲸鱼湖到土拉牧场的线，经过阿其克库勒湖，也是阿尔金区域唯一触及的设计路线。）因此决定跟着车印进山。一半误判，一半准确，误打误撞走了最正确的一条线，差之毫厘都将是极其严重的后果，后说。见一群盘旋乌鸦，走过去，是一头死藏羚羊，刚腐烂没多久，恶臭，眼睛被乌鸦啄了，下身被撕开，很想弄块稍干净的羊腿吃。想想，自己真到食腐动物的份上了吗？坚定的回答，否。下午七点半遇贝勒克湖东北侧的河，再也折腾不起脱鞋过河，决定扎营。查看轨迹，走了33公里，整九个小时，基本无休。弃车是对的，否则这路要推两三天。晚上空腹，未脱鞋，脱不下来。想吃的难受，忽然想起下午看见的那头被啄了眼珠的死羊，莫名悲伤起来。他“羊”，我也杨，小时候就抄过一篇作文，叫《绵绵羊》，“我姓杨，同学们都叫我绵绵羊……”有种同病相怜的宿命感，非常的感伤。 晨雪，头大 推了几百米后决定弃车，告别公爵，他没过过几天好日子 阿尔金的荒原，他仍是青藏高原的一部分 贝勒克湖，湖边貌似牧场，一般地图上找不到这个湖 宿营地，除了地上的和手中相机，最后徒步之物另补充：当天下午看见飞机往返，唉。 阿尔金，唯一纸质地图，西藏地图的边角，给了很大的误导 被乌鸦啄去的眼睛的死藏羚羊 D74（7-2），36K，宿营4288M很早起来，上午翻越阿尔喀山口，先前昆仑山未留一影，此昆仑分支多拍了几张（后才知此昆仑分支是阿尔喀山，地图上就是昆仑山脉）。简说下昆仑走势，西源帕米尔高原，巍巍壮观，东至阿尔金时开始分支，形似龙爪，南支延伸为巴彦喀拉山脉，最终与横断山脉并行。北支延伸为祁连山脉和秦岭，成为中国南北气候分界线。昆仑的含义对中国人不必多说，但古人的昆仑不是无人区里绵延两千公里的山峦，而是秦岭或祁连山。下了山口进入峡谷，再度找到被雪覆盖的车印，然后一直顺河走，进入一片宽阔的扇形冲击河床。两侧是典型的喀斯特地貌，这便是绵延200公里的白石山。若论什么景致才是阿尔金无人区的标志？官方民间都是鲸鱼湖，我觉得喀斯特地貌的白石山更具张力。随后一段走得很纠结，宽阔河床比可可西里山脉那段路还糟糕，皆是泡水严重的沙粒，尤其中途一场大雪，极度迷失感。再次庆幸，如果推车，完了。出河床，是烂草地，混水坑，回归的车印则成了泥浆河，一直到了六点，路才稍微好些。晚上扎营在深车印里，一场冻雨袭来，雨水汇在低洼的车印，好在帐篷坚强，否则再无法忍受。一天没吃，最后一棒糌粑要留在最后时刻，这是猎人传授的经验，一定要把最后一口粮食藏在饿死之前的一刻才能记起的地方。没有脱鞋，脚肿得有些呻吟了，腿放直痛，弯着痛，反正怎么搁都痛。看地图，明天赶不到阿其克库勒湖的“饭店”了。今天走了11小时，36公里，比昨天多走两小时，距离则只多3公里。36公里，看来是此般身体状态、路况下的极限了。而离阿其克库勒湖的“饭店”还有四十公里左右，它真的存在吗？ 走向昆仑山口，好寻，坡缓路短 地图上也是昆仑山脉，是其分支 山口俯瞰，进入峡谷 最窄一段峡谷，过后一片坦荡 右侧有型山 左侧有型山，但还未到最喀斯特的一段，明天路上 D75（7-3），30+XK，宿营4792M八点半出发，没法走，用了半个多小时磨合最佳痛感。脚心窝着，单侧受力，膝盖直，大腿右撇，有点像范伟的卖拐，但没那么夸张。没过一会，左腿也弯不了，脚掌无法平展受力，走路姿势右瘸一下左撑一下。话说睡袋，湿气太多，重，斜跨在左侧，时间长了勒肩，便左手挽抱，貌似上了年纪的阿婆挽着一篓鸡蛋赶集。早晨曾考虑丢弃睡袋，当下必须集中所有能量赶到“饭店”。可想想，睡袋是朋友的，好借好还，要是自己的就扔了。路好，天气好，一直并行白石山。最后十几天只摄取相当高度饥饿程度的热量，最近两三天基本没吃，但并无强烈的饥饿感，再加上“饭店”的诱惑，心态还算坦然，但这脚令我万分担心，这样走下去，明天还能不能动是个问题。如果脚废了，一切都完了。过了中午，难再支撑，休息次数略多，坐下、站起，腿都没法打弯。风景一直很美，手解脱了，倒是拍了不少照片。除此之外，一种类似深度催眠的状态行走，风景和疼痛，飘渺且不真实。下午出现幻觉，或许只是眼花，看见前方有两辆摩托车快速移动，很快不见，便急切的吹起哨子，吹啊吹，不见摩托车。到了坡顶，也不见有岔路，之前看见的是什么？然后坏天气，然后天晴，然后上了一段大长坡，坐下休息，看GPS，走了三十一公里，时间四点半，想着至少还能撑好几公里，但肯定赶不到“饭店”，便想好，明天一大早什么也不带轻装徒步找饭店，然后找辆摩托车回头取随身物品。休息时间较长，起身没走几步，蓦然回头（不知道为什么要回头），见一辆越野车在身后十几米处，极缓慢的速度，没有一点声音。以为这下真幻觉了，休息这么长时间难道发现不了车接近？再看，果真是车，跑上去，敲车窗，要吃的。从司机黄哥角度看这场相遇：路中间有头牦牛，放慢车速，渐渐觉得牦牛没这么小，便是狗熊，再近，怎么狗熊还会弯腰捡东西？再近，是人！不可能啊……车上四个人，很明显都紧张了一会，车门没打开迹象。我说从西藏过来的，车丢在鲸鱼湖，旅行的……他们以为“车”是汽车，最后才明白是一个人推辆自行车在荒原里晃了70多天。赶紧开车门给了一袋方便面和一瓶矿泉水。交流中得知，所谓的“饭店”子虚乌有，现在除了他们一家矿（还在中探阶段），再无其他人，淘金者也都在白水河一带，遇见他们真是命大。而我们相叠的路段只有几公里，早一点不遇，晚一点分道扬镳，他们往风尘口大坂，我往阿其克库勒湖找“饭店”，所以，一直称黄哥为救命恩人。按他的玩笑话，此生就是为了此刻此地等我。当然没回头找弃车，此季没有车能过阿尔喀山，深入鲸鱼湖一带，黄哥在阿尔喀山北侧探矿，是此季唯一还在阿尔金腹地的单位。他们一行四人，三个工人，其中一老者，昨天下山，当夜陷沼泽，下午遇我。三天一百公里的徒步逃生结束，上了车后以为解脱，干吃方便面和抽烟，但故事并未结束。过了白石山好路后，就开始频繁陷车，一路挖车，推车，三个工人很辛苦。晚上陷在一泥坑里，只能等明天上冻脱困，和他们昨夜深陷沼泽一样。晚上，和黄哥聊得很晚，很兴奋，似乎我的经历勾起了他的江湖漂泊梦。对于他这种有无人区工作经历的人来说，我的旅行更加具有梦幻性。聊天中还得知，他们没有多少补给，就带了一箱方便面和矿泉水就匆匆下山，也没想到路这么烂，但想着随后矿上有炮车下来就没回头，希望能冲过风尘口大坂，到达山脚下的回民帐篷，（平时半天时间到回民帐篷），随后就是大路了。这才明白，为淘金者和探矿人提供服务的回民帐篷就是丁丁游记中的“饭店”，如果步行还需三天，还得保证不走错路，显然，我对风尘口一带无半点了解。黄哥敢单车下山，也是因为后有炮车，如果出现问题可以救援，这是他的底线。 两张白石山近景 两张白石山远景 遇人，拍照，先前坏天气，镜头有水，便这样了 拍了几张挖车照，后面再无拍过，越来越糟糕，麻木 D76/77（7-4/5）整天，汽车走了九公里。上冻，车子冲出泥坑，人徒步，车子轻装冲向山口。路太烂了，坐过墨脱的车，那是小巫（有季节因素）。一小时后候车陷死，随后用了十个小时，靠人力将车移动了八百米——难以回首的八百米。三个工人一直淌在水里挖车，挖路，我没法再吃这种苦了，只在稠密的烂泥里推车，那也是够呛。看不下去了，也撑不住了，只想安静地待在车上，等待炮车，客观上，仅凭我们几个人也没法将车弄出去，就一直劝黄哥，别折腾了。中午方便面就快没了，所谓的炮车一直不见，所以黄哥有些着急，希望车能撑过山口下到回民帐篷，所以对我的建议充耳不闻。老头失控，对我态度极差，老是用话戳我，说不能把包扔在车上就当大爷了，说没眼力不会找活，说抽这么多烟，说好吃懒做……这点承认，一直吃方便面调料包，都是没人吃的，都知道是TM味精+胡椒粉，可对我来说是天上美味了。老头不时把铁锹扔给我去挖车，没办法，被说的也不好意思，偷懒，随便挖几下。没法挖，手连铁锹都握不紧，问题是要穿鞋跳进水里挖，工人们至少还有双鞋换，我的鞋已经两天脱不下来了，没法再跳进水里。重要的是心态变了，都遇人得救了，再吃不了这苦。一瘸一拐的姿态，并未从老头那里获得同情。话说黄哥一直照顾我，这也可能让他很不舒服，的确，太艰辛了，五个人就三个人挖车，老板不敢支使，就只好我了。下午，有辆淘金车经过，从附近白水河撤出来，他们有一辆炮车，但要钱才帮忙拖车。600元，黄哥还价400元，价格淡不拢。主要是黄哥掷气，不在乎几百块钱，他们矿上车不知救助了多少淘金客。（淘金客大都XX，名声不好，确实不该在这种环境谈钱，虽然知道我们可能有后援）。当时，我很想掏那600元钱，就像有网友说的，几十天没用钱了，憋得难受，只要晚上能吃口热的，不要说600，1800也给（身上现金数），但是，这场交易演变成不是钱的问题，而是立场，所以忍了，还忍了搭乘淘金者车出去的想法。毕竟一辆车上的人了，如果不是他们，我现在可能精神崩溃，那有什么“饭店”，荒原里只有浮云。老头对我态度越发差，我不乏乞色说，这种路我走了几十天，真的不行了，脚痛，连铁锹都握不住。老头一句话：你脑袋里有虫！激得我拿起铁锹就往泥浆水里跳，挖挖挖。“脑袋里有虫”，随后成为我们的语录，拿它开心。一直快到天黑，两个年轻工人中体力最好的垮下来，头发热，昏睡。天气也差，飘着阴雪，冷风，只好在车上再熬一夜。非常冷，没吃的，继续吃调料包，老头又看不惯，（弄得我吃调料包都偷偷摸摸的）。一会儿又用身体挤我，一会儿说我踩了他脚，淡定，淡定！！！心里真是抓狂啊。很理解，这种环境下人都很脆弱，他们虽在无人区里探矿，但毕竟每天有白馍肉蔬菜，有人交流，有工作时间，除了海拔不同，和一般内地工人并无太大区别。十一点多，有灯光从后面打来，炮车终于来了。准备拖车，大家都不想下车系钢缆，推辞中不知怎么把那昏睡的工人给弄下去了。系好钢缆，车动，问题是那工人没上车，我们车又没喇叭，无法和前面大车交流，就这样把工人丢在夜色中。气氛非常凝重，十分钟后，有人敲车门，原来那工人一直跟在车后追，很难想象，那十足烂路，那恶劣天气，那漆黑麻乌的，工人追车的心态。杯具的是，他敲得那扇车门是坏的，打不开，车窗也摇不下来，车里车外无法交流，只见工人边跑边敲窗。随后，他又消失在茫茫夜色里，几分钟后，工人又出现，在我这侧车门，拉上车，之后一直昏睡。话说，炮车来了，司机给了我们两张饼，一包烟。那饼摆在面前真想吃啊，老头以大家还没吃的借口不让我吃，而他们显然远未达到猪的吃食状态。老头一直用眼睛盯着我，像防贼，有一刻，真想冲过去一口把饼吞了，要打要骂随你老头。抽烟吧，第二根又被老头骂，说是只有司机能抽……坡陡路烂，拖车危险，解除牵引，但陷车依然频繁，三人下车推（那个昏睡工人至少当夜彻底没劳动力了），也管不了脚下是泥浆还是河，头上是风还是雪。数次过后，大车上的人实在看不下去了，顾不得危险，一直系上钢缆将车拖下山至回民帐篷处，此时，凌晨两点左右。回民帐篷前一道浅滩，漫水，淌水过去。见黄哥一直在众人面前吹嘘我，这才看清大车上至少有七人。此后，他们都对我非常照顾，尤其司机，没事就围着我聊天，还把最后一根烟给我，然后自己去讨烟。用他的话说，自己每进一次山都觉得掉层皮，无法想象一个人从那边怎么过来的。有了商业，我就可以用钱势轰老头，抢着买单，谁怕谁啊。的确，老头自此后对我态度好很多。简单吃碗面条赶夜路，临走前，问老板，去年是不是有两个逃犯也推车从里面出来？老板半听懂似的，恩恩，一个坐车走了，一个骑车走了。算是为那莫须有的“饭店”解气了，实则是我没做功课。随后，大路，连夜赶往花土沟，睡觉。路上还有很多杯具故事，但相比之前，已无味了，不表。下午四点到达石棉矿，抄近路，从矿区里走，更加显露生存的悲哀，如果让我在此处工作，我情愿在羌塘里永不出来。（去过石棉矿的人都知道，生存环境的问题。）进入家属区吃饭，跟着路人翻院墙方便，是所学校，不知是不是怕被学生撞见，很紧张，几经挣扎，才知硬了，还秘……我想，这才是旅行的彻底终结。随后油路花土沟，找了家宾馆，脱鞋，带出几片碎布，剩下的袜子成泥沙了。一瘸一拐的去买换洗衣服，生活用品，徐福记系零食，吃饭，回宾馆洗澡，躺在干净的床上吃零食。手无力撕开食品塑料袋，一一用牙齿咬开。吃了N多零食，喝了两升果汁，睡去。翌日开机，报平安。请救命恩人吃饭，开始挤兑老头脑袋里有虫。很多追贴的朋友关心身体状况，简说下后面行程。D1-3，请恩人吃饭，理发，打电话，寄还友人物品。D4-8，庸医说脚养一月，不得下地，随即前往新疆找羊肉吃。D9-20，舟车劳顿，新疆小玩，身上已难寻羌塘印记。先是巴音布鲁克草原，被蚊子追咬，与一家四口挤睡敖包，逃跑，去吐鲁番热死，敦煌一瞥，辗转回拉萨。第十天朋友角度描述，“气色不佳，略微浮肿，笑容淡定，思绪游移。”D22-35，坐车，陪朋友下林芝，上珠峰大本营，挤雪顿节。其间，一直想借道拉萨去克里雅山口看火山，谁知出羌塘舟车未停过，说真的，心很累，很想找个安静地方小憩几天，坐火车离开拉萨，打道回府。舟车劳顿中，第十一天恢复走姿，但赶路快走会有抽筋感。内器官只夜间呼吸重，胸口压迫感，出拉萨好。豁出去了，老脸游街，附出羌塘后第一张照片，第十九天车上，窥斑知豹以度身体状态。另外，实际生活中很不淡定，那样多无趣。生命是一条贯通的河流，一切皆是没有开始的复始。我们所期望的终点并不存在。更完。 出羌塘最近照，第十九天要表明的熟识的朋友希望我更新完毕做个总结，不知说什么。或许每个人心中都有一个江湖梦，像侠一样自在漂泊。若此贴暗合了内心，心绪飘荡，那么我想有必要再表明下观点，以免误导，传递错误的信息。【装备】此行装备看似简陋，但够用了，事后发生的事不能推翻前面，就像孙子不可以穿越时光杀死爷爷。但，这只是我个人的装备习惯，不想给朋友们一个错误的信号。譬如，当我第一次三个月时间穿坏一双进口登山鞋时就明白，有些路注定是消耗品，所以在一千块鞋子和提升了5%性能的三千块鞋子之间，我选前者。如果，我只是偶尔出来旅行，三年穿不坏一双鞋子，那我选择后者。这年头赚钱不容易，还是省着点。另外，基础装备和技术装备有着本质区别，红军可以穿草鞋过雪山，但绝无可能在没有冰镐的帮助下攀上雪壁。【本能】旅行即不是奥林匹克，也非奥数，他不能说明体能与智力的问题。不要过度迷信道听途说，不要被小说似的探险故事吓着，从未有过游泳经历的人，经过训练，虽然超不过菲利普斯，但至少能狗刨。从漫步陆地到畅游水里的巨大飞跃，不是潜能的问题，而是本能。所以，只要不是极限之地，大部分人都能去，没什么大不了。有种高反，不是生理上的，是心理上的。随时保持清醒，知道极限和本能之间的界限，可以在海拔五千米的地方走上一辈子，但在海拔一万米的地方活不过五分钟。【成长】即使对比去年的旅行，我对生活的态度也有了新的体悟。如果再回逆十年，差异性就更大了，即便翻阅不久前的文字，都觉得无法入目，当初为何有那样的想法？所以尽量不要标榜，不要给自己贴标签，我们随时都在成长，都有新的认知，只需一个记录就行，反思和展望。【如果准备尝试一次艰苦的旅行】不会吓唬没有去过的人，这样会抹杀探索精神，但并不说明因冲动就可以踏上旅程，那是冒险，不是旅行。所以，尝试一次艰苦的旅行前，首先要问自己几个问题。一、为什么？如果热爱那就去，如果想证明什么那还是好自为之。二、准备好了没有？如果买了一堆昂贵的装备只能说明你有钱或有赞助，如果你花很多时间了解那片热爱的土地，装备配置才会有实际意义，一根水泥钉或许都是最强装备之一。三、艰苦的定义？如果宅了十年，第一次就走羌塘显然是不现实的。从未有长途骑行经历的人，走了青藏线就是蓝波湾，爬三楼都喘的人爬了黄山，那是超蓝波湾。不要和人比较，每个人的艰苦旅行都不一样，只要超越了自己，超越了当下，就是当之无愧的蓝波湾。四、有完美吗？没有完美的装备，完美的计划，完美的旅行，要有包容，对人对事。五、一定要去探索吗？旅行不是生活的全部，还得养家糊口、求学就业、升官发财，做科学家也是探索，玩高难度杂技也是探索，抑制房价也是探索，讨暗恋女生欢心也是探索。不要羡慕无氧登珠峰的人，坐在大本营看他们上跳下窜也很幸福，尽兴就好。一切问题都解决了，最后才是意志力和运气的问题，说不清，但很真实，这才是探索的开始。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于word合并、分割、转换问题]]></title>
    <url>%2Fblog%2F51428.html</url>
    <content type="text"><![CDATA[最近项目中有个这样的需求：要把word 按章节(大纲)拆分多个word,然后再将这些word能合并成一个整体。看到这个需要，其实也是头疼，100个程序员中应该100位都没有做过类似的开发，最多的就是poi 读取、生成word,那么接下来，我会将最近研究的word切割、转换、合并以笔记的形式记录，也算做为积累吧！ word 分割 ： word 分割，使用的 poi，这个还真有点难，如果不是同事给国帮助，分割这块，还是很难搞定，不过合并用的第三方插件，很快就搞定了，上代码吧：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297package com.sysware.soft603.util.backUp; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.util.ArrayList;import java.util.List; import org.apache.poi.xwpf.usermodel.BodyElementType;import org.apache.poi.xwpf.usermodel.IBodyElement;import org.apache.poi.xwpf.usermodel.XWPFDocument;import org.apache.poi.xwpf.usermodel.XWPFParagraph;import org.apache.poi.xwpf.usermodel.XWPFRun;import org.apache.poi.xwpf.usermodel.XWPFStyles;import org.dom4j.Element;import org.dom4j.io.OutputFormat;import org.dom4j.io.SAXReader;import org.dom4j.io.XMLWriter; import com.sysware.fai.entity.BookMarkInfo; public class POItest1 &#123; public static void main(String[] args) throws IOException &#123; splitWord(); &#125; private static void splitWord() &#123; String path = "d:\\GJB 1362A-2007 军工产品定型程序和要求.docx"; InputStream is = null; List&lt;BookMarkInfo&gt; bookMarkInfos = new ArrayList&lt;BookMarkInfo&gt;(); try &#123; is = new FileInputStream(path); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; XWPFDocument doc = null; try &#123; doc = new XWPFDocument(is); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // 获取段落 List&lt;XWPFParagraph&gt; paras = doc.getParagraphs(); // 获取bodyElements List&lt;IBodyElement&gt; bodyElements = doc.getBodyElements(); // 获取doc样式 XWPFStyles styles = doc.getStyles(); int j = 0; // /切割成的word 文件存储位置 String patha = "d:\\poi\\"; // 根据大纲定义分割成的段落 ArrayList&lt;Integer&gt; al_duanLuo = new ArrayList&lt;Integer&gt;(); // 大纲名称 ArrayList al2_name = new ArrayList&lt;&gt;(); // 大纲级别 ArrayList&lt;Integer&gt; al3_jiBie = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; al5 = new ArrayList&lt;Integer&gt;(); // 存放生成wordId ArrayList&lt;String&gt; al6_wordId = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; bodyElements.size(); i++) &#123; IBodyElement bodyElement = bodyElements.get(i); try &#123; if (j == 0) &#123; al_duanLuo.add(i); j++; al2_name.add("首页"); al3_jiBie.add(1); // al5.add(1); al6_wordId.add(java.util.UUID.randomUUID().toString()); &#125; if (bodyElement.getElementType() == BodyElementType.PARAGRAPH) &#123; XWPFParagraph para = (XWPFParagraph) bodyElement; if (styles.getStyle(para.getStyle()).getCTStyle().getName() .getVal().contains("heading")) &#123; // 以标题创建第一个文件 al_duanLuo.add(i); j++; al2_name.add(para.getParagraphText()); // System.out.println(al2); String temps = styles.getStyle(para.getStyle()) .getCTStyle().getName().getVal() .split("heading")[1].trim(); al3_jiBie.add(Integer.parseInt(temps)); // al5.add(Integer.parseInt(para.getStyleID())); al6_wordId.add(java.util.UUID.randomUUID().toString()); // System.out.println("a2======" + al2_name); // System.out.println("a3======" + al3_jiBie); // System.out.println("al======" + al_duanLuo); // System.out.println("a5======" + al5); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; // 定义存放父新id ArrayList al4_parentId = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; al_duanLuo.size(); i++) &#123; if (al3_jiBie.get(i) &gt; 1) &#123; int k; for (k = i; k &gt;= 0; k--) &#123; if ((int) al3_jiBie.get(k) &lt; (int) al3_jiBie.get(i)) &#123; break; &#125; &#125; al4_parentId.add(al6_wordId.get(k)); &#125; else &#123; al4_parentId.add(" "); &#125; &#125; // for (int i = 0; i &lt; al_duanLuo.size(); i++) &#123; // System.out.println("==================="); // System.out.println("al2=" + al2_name.get(i)); // System.out.println("al3=" + al3_jiBie.get(i)); // System.out.println("all4=" + al4_parentId.get(i)); // System.out.println("==================="); // // 根据关系创建拼接组装xml文件 // &#125; System.out.println("al_duanLuo" + al_duanLuo); System.out.println("al2_name=" + al2_name); System.out.println("al3_jiBie=" + al3_jiBie); // System.out.println(al6_wordId); System.out.println("al4_parentId=" + al4_parentId); XWPFDocument newDoc = doc; int max = 0; max = bodyElements.size() - 1; al_duanLuo.add(max); try &#123; for (int k = 0; k &lt; al_duanLuo.size() - 1; k++) &#123; path = "d:\\GJB 1362A-2007 军工产品定型程序和要求.docx"; is = null; try &#123; is = new FileInputStream(path); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; doc = null; try &#123; doc = new XWPFDocument(is); // 移除多级列表，移除前面的编号，这里分割后是有编号的，不过这里如果你不移除的话，直接把代码注释掉即可 if (k != 0) &#123; XWPFParagraph para1 = (XWPFParagraph) doc .getBodyElements().get(al_duanLuo.get(k)); String str1 = para1.getStyleID(); doc.getStyles().getStyle(str1).getCTStyle().getPPr() .unsetNumPr(); &#125; &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // 移除前0－－14， int temp = al_duanLuo.get(k); int tempCount = al_duanLuo.get(k + 1); for (int u = max; u &gt; tempCount - 1; u--) &#123; doc.removeBodyElement(u); &#125; // 进行移除之前 for (int l = temp - 1; l &gt;= 0; l--) &#123; doc.removeBodyElement(l); &#125; // XWPFParagraph tempDuan = paras.get(temp); // paras.get(7).setStyle(paras.get(1).getStyle()); // XWPFRun run = paras.get(7).insertNewRun(0); // run.setText("10086"); OutputStream out = null; out = new FileOutputStream("d:\\poi\\" + al6_wordId.get(k) + ".docx"); BookMarkInfo bookMarkInfo = new BookMarkInfo(); bookMarkInfo.setId(al6_wordId.get(k)); bookMarkInfo.setPid(al4_parentId.get(k).toString()); bookMarkInfo.setName(al2_name.get(k).toString()); bookMarkInfo.setLevel(al3_jiBie.get(k)); bookMarkInfos.add(bookMarkInfo); try &#123; doc.write(out); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("over"); CreateXml(bookMarkInfos); //遍历xml文件 &#125; public static void CreateXml(List&lt;BookMarkInfo&gt; bookMarkInfos) &#123; String target = "d:/MyXml.xml"; SAXReader reader = new SAXReader(); try &#123; org.dom4j.Document document = reader.read(new File(target)); Element root = document.getRootElement(); List&lt;Element&gt; list = root.elements(); for (Element element : list) &#123; root.remove(element); &#125; //给xml加上标号, int j=0; for (int i=0;i&lt; bookMarkInfos.size();i++) &#123; BookMarkInfo bookMarkInfo =bookMarkInfos.get(i); //判断是否为第一级 if(bookMarkInfo.getLevel()==1)&#123; //为了是第一个不用加编号 if(i!=0)&#123; j++ ; &#125; &#125; if (bookMarkInfo.getLevel() == 1) &#123; Element element = root.addElement("item"); element.addAttribute("id", bookMarkInfo.getId()); //加上编号 if(j==0)&#123; element.addAttribute("name", bookMarkInfo.getName()); &#125;else&#123; element.addAttribute("name", j+bookMarkInfo.getName()); &#125; element.addAttribute("filename", bookMarkInfo.getId() + ".docx"); GetXElement(element, bookMarkInfo, bookMarkInfos,j+"",0); &#125; &#125; saveXml(target, document); //遍历xml &#125; catch (org.dom4j.DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void saveXml(String target, org.dom4j.Document document) &#123; try &#123; OutputFormat outputFormat = OutputFormat.createPrettyPrint(); outputFormat.setLineSeparator("\r\n"); OutputStreamWriter outputStreamWriter = new OutputStreamWriter( new FileOutputStream(target), "UTF-8"); XMLWriter xmlWriter = new XMLWriter(outputStreamWriter, outputFormat); xmlWriter.write(document); xmlWriter.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void GetXElement(Element parent, BookMarkInfo item, List&lt;BookMarkInfo&gt; bookMarkInfos,String j,int k) &#123; k=0; for (BookMarkInfo bookMarkInfo : bookMarkInfos) &#123; if (bookMarkInfo.getLevel() == item.getLevel() + 1 &amp;&amp; bookMarkInfo.getPid() == item.getId()) &#123; k++ ; Element element = parent.addElement("item"); element.addAttribute("id", bookMarkInfo.getId()); element.addAttribute("name", j+"."+k+bookMarkInfo.getName()); element.addAttribute("filename", bookMarkInfo.getId() + ".docx"); GetXElement(element, bookMarkInfo, bookMarkInfos,j+"."+k,k); &#125; &#125; &#125;&#125; 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;item id="1" name="1" filename="a.docx" author="杨稳" publishtime="2017-02-03" keywords="关键词" abstract="摘要" journal="" issn="" Implementation="2017-04-01" groupname="国标" phase="研制阶段" content="内容分类"&gt; &lt;!-- id=编号（标准规范）,name=名称,filename=文件名称,author=作者,publishtime="发表时间",keywords="关键词",abstract="摘要",journal="所属期刊",issn=ISSN,Implementation="实施日期",groupname="国标",phase="研制阶段",content="内容分类"--&gt; &lt;item id="1.1" name="1.1" filename="a.docx"/&gt; &lt;item id="1.2" name="1.2" filename="a.docx"&gt; &lt;item id="1.2.1" name="1.2.1" filename="a.docx"/&gt; &lt;item id="1.2.2" name="1.2.2" filename="a.docx"/&gt; &lt;/item&gt; &lt;item id="1.3" name="1.3" filename="a.docx"&gt; &lt;item id="1.3.1" name="1.3.1" filename="a.docx"/&gt; &lt;/item&gt; &lt;item id="1.4" name="1.4" filename="a.docx"/&gt;&lt;/item&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;item id="1" name="1" filename="a.docx" author="杨稳" publishtime="2017-02-03" keywords="关键词" abstract="摘要" journal="" issn="" Implementation="2017-04-01" groupname="国标" phase="研制阶段" content="内容分类"&gt; &lt;!-- id=编号（标准规范）,name=名称,filename=文件名称,author=作者,publishtime="发表时间",keywords="关键词",abstract="摘要",journal="所属期刊",issn=ISSN,Implementation="实施日期",groupname="国标",phase="研制阶段",content="内容分类"--&gt; &lt;item id="cdc88f18-a024-4e88-9ba1-3d5c5a7a0c58" name="首页" filename="cdc88f18-a024-4e88-9ba1-3d5c5a7a0c58.docx"/&gt; &lt;item id="d6cd51f4-b16f-4d25-860f-d102d01f4d79" name="1范围" filename="d6cd51f4-b16f-4d25-860f-d102d01f4d79.docx"/&gt; &lt;item id="250b91c9-986e-4ad8-ad21-2008331d07ec" name="2引用文件" filename="250b91c9-986e-4ad8-ad21-2008331d07ec.docx"/&gt; &lt;item id="7e54f054-3880-4087-bde6-ec423bc0a3ad" name="3术语和定义" filename="7e54f054-3880-4087-bde6-ec423bc0a3ad.docx"&gt; &lt;item id="0b9dfec5-a484-4092-a8a3-0f1c0c4caeae" name="3.1一级定委 first-class committee for finalization of military products" filename="0b9dfec5-a484-4092-a8a3-0f1c0c4caeae.docx"/&gt; &lt;item id="0192d8d5-fdc7-4f8d-8a6e-bb88a53f5395" name="3.2二级定委 second-class committee for finalization of military products" filename="0192d8d5-fdc7-4f8d-8a6e-bb88a53f5395.docx"/&gt; &lt;item id="1e172285-5b97-4da0-98be-60a90bd245b8" name="3.3军工产品 military products" filename="1e172285-5b97-4da0-98be-60a90bd245b8.docx"/&gt; &lt;item id="a255bca2-9380-485c-8c43-43bfb6c19a62" name="3.4军工产品定型 finalization of military products" filename="a255bca2-9380-485c-8c43-43bfb6c19a62.docx"/&gt; &lt;item id="d1df3277-4895-4282-b1b1-52cf9fe48a3c" name="3.5设计定型 design finalization of military products" filename="d1df3277-4895-4282-b1b1-52cf9fe48a3c.docx"/&gt; &lt;item id="70709984-ba90-40cc-b4ad-e29a025cb9ab" name="3.6生产定型 manufacture finalization of military products" filename="70709984-ba90-40cc-b4ad-e29a025cb9ab.docx"/&gt; &lt;item id="f27b646b-bdf6-4fa9-aa78-c9dab72450ce" name="3.7一级军工产品 first-class military products" filename="f27b646b-bdf6-4fa9-aa78-c9dab72450ce.docx"/&gt; &lt;item id="d80e9425-6502-46db-9251-43a06fa8a164" name="3.8二级军工产品 second-class military products" filename="d80e9425-6502-46db-9251-43a06fa8a164.docx"/&gt; &lt;item id="6d217bdf-a7c6-4751-8a64-0a16026d6e52" name="3.9军工产品鉴定 assessment of military products" filename="6d217bdf-a7c6-4751-8a64-0a16026d6e52.docx"/&gt; &lt;/item&gt; &lt;item id="bd43a101-a948-4efc-ab33-cdb1bf324a6b" name="4总则" filename="bd43a101-a948-4efc-ab33-cdb1bf324a6b.docx"&gt; &lt;item id="43463950-f7f8-459c-9a62-65ef8021027a" name="4.1定型工作的依据" filename="43463950-f7f8-459c-9a62-65ef8021027a.docx"/&gt; &lt;item id="fd4614c6-c00e-4244-ae25-0d9fdb3c5e51" name="4.2定型分类" filename="fd4614c6-c00e-4244-ae25-0d9fdb3c5e51.docx"/&gt; &lt;item id="2ccfe33a-c864-41ac-89af-91a05075eda1" name="4.3定型原则" filename="2ccfe33a-c864-41ac-89af-91a05075eda1.docx"/&gt; &lt;item id="b58bb7c0-cebf-45f6-8c86-30658ec89ca4" name="4.4定型分级" filename="b58bb7c0-cebf-45f6-8c86-30658ec89ca4.docx"/&gt; &lt;/item&gt; &lt;item id="afc9af0e-9074-4dc6-be3b-6632f20135b8" name="5设计定型" filename="afc9af0e-9074-4dc6-be3b-6632f20135b8.docx"&gt; &lt;item id="0ed6ad9a-34f1-427a-bf7e-70e1ec8717e0" name="5.1设计定型程序" filename="0ed6ad9a-34f1-427a-bf7e-70e1ec8717e0.docx"/&gt; &lt;item id="8634212f-0ec7-45b8-9596-69e7e6b3db78" name="5.2申请设计定型试验的条件" filename="8634212f-0ec7-45b8-9596-69e7e6b3db78.docx"/&gt; &lt;item id="f1ab75a0-def4-4058-ab36-df14ee4081d6" name="5.3申请设计定型试验" filename="f1ab75a0-def4-4058-ab36-df14ee4081d6.docx"/&gt; &lt;item id="d205e3ac-aa79-414f-8817-0bf693cb950c" name="5.4制定设计定型试验大纲" filename="d205e3ac-aa79-414f-8817-0bf693cb950c.docx"&gt; &lt;item id="7659923a-d274-4ae2-b882-dbce090457cc" name="5.4.1试验大纲的制定" filename="7659923a-d274-4ae2-b882-dbce090457cc.docx"/&gt; &lt;item id="7d3ca588-771d-4b93-b3d9-fbaa7b60066a" name="5.4.2试验大纲内容和要求" filename="7d3ca588-771d-4b93-b3d9-fbaa7b60066a.docx"/&gt; &lt;item id="3fb7579f-23b0-47e5-95fb-02115726d4cb" name="5.4.3试验大纲编制说明" filename="3fb7579f-23b0-47e5-95fb-02115726d4cb.docx"/&gt; &lt;item id="a864a195-3fcc-40c8-8854-8521603144a3" name="5.4.4试验大纲变更" filename="a864a195-3fcc-40c8-8854-8521603144a3.docx"/&gt; &lt;/item&gt; &lt;item id="67b5e4c2-16ac-4023-a215-d650f86d2d06" name="5.5组织设计定型试验" filename="67b5e4c2-16ac-4023-a215-d650f86d2d06.docx"&gt; &lt;item id="fb17fdd6-def8-4219-b780-bdcb8fcf34f5" name="5.5.1试验要求" filename="fb17fdd6-def8-4219-b780-bdcb8fcf34f5.docx"/&gt; &lt;item id="fff01927-27c5-4e27-bfd9-8356846c64a9" name="5.5.2试验组织实施" filename="fff01927-27c5-4e27-bfd9-8356846c64a9.docx"/&gt; &lt;item id="e02e40c4-c1a9-42da-bf91-923e46f49ca3" name="5.5.3试验顺序" filename="e02e40c4-c1a9-42da-bf91-923e46f49ca3.docx"/&gt; &lt;item id="8428ba02-bda0-43f3-898a-cb61a0bffebb" name="5.5.4试验中断处理" filename="8428ba02-bda0-43f3-898a-cb61a0bffebb.docx"/&gt; &lt;item id="0f8ee823-1b3b-4357-9821-5b6c23bb1c9e" name="5.5.5试验恢复处理" filename="0f8ee823-1b3b-4357-9821-5b6c23bb1c9e.docx"/&gt; &lt;item id="008c1546-45d5-4bfd-96c5-d4150054d547" name="5.5.6承研承制单位的责任" filename="008c1546-45d5-4bfd-96c5-d4150054d547.docx"/&gt; &lt;item id="f19db0de-1e2f-47dd-b82f-173ae5a7acab" name="5.5.7试验记录" filename="f19db0de-1e2f-47dd-b82f-173ae5a7acab.docx"/&gt; &lt;item id="2c6df7ba-53ec-45c5-95f7-4be37e5b7406" name="5.5.8试验报告" filename="2c6df7ba-53ec-45c5-95f7-4be37e5b7406.docx"/&gt; &lt;/item&gt; &lt;item id="8262e0da-b543-45da-b289-380cf43fab59" name="5.6申请设计定型" filename="8262e0da-b543-45da-b289-380cf43fab59.docx"&gt; &lt;item id="ded722e3-4c04-4fe3-a8e4-bf30b73bcda2" name="5.6.1提出申请报告" filename="ded722e3-4c04-4fe3-a8e4-bf30b73bcda2.docx"/&gt; &lt;item id="45d1a9ed-01ed-46c5-a81a-1a0822627833" name="5.6.2申请报告内容" filename="45d1a9ed-01ed-46c5-a81a-1a0822627833.docx"/&gt; &lt;item id="3038774c-ddd7-440a-b172-ab758192dd8a" name="5.6.3申请报告附件" filename="3038774c-ddd7-440a-b172-ab758192dd8a.docx"/&gt; &lt;item id="ec05b70d-07c6-4f21-b5b0-f61fa08db313" name="5.6.4产品模型" filename="ec05b70d-07c6-4f21-b5b0-f61fa08db313.docx"/&gt; &lt;/item&gt; &lt;item id="a9c7cf2a-48be-46c5-aef4-8c93e138db00" name="5.7设计定型审查" filename="a9c7cf2a-48be-46c5-aef4-8c93e138db00.docx"&gt; &lt;item id="ea6c4556-a3fe-4177-a24b-d05ecc8b9054" name="5.7.1设计定型审查组和检查组" filename="ea6c4556-a3fe-4177-a24b-d05ecc8b9054.docx"/&gt; &lt;item id="b448feb3-4731-4344-bf27-a29309b4dded" name="5.7.2设计定型标准和要求" filename="b448feb3-4731-4344-bf27-a29309b4dded.docx"/&gt; &lt;item id="72e2b383-83ad-4699-ad07-23b6c29da944" name="5.7.3审查意见书" filename="72e2b383-83ad-4699-ad07-23b6c29da944.docx"/&gt; &lt;/item&gt; &lt;item id="8f480f8a-cee6-4bb0-8a82-23c01b368f7c" name="5.8审批设计定型" filename="8f480f8a-cee6-4bb0-8a82-23c01b368f7c.docx"&gt; &lt;item id="b5c7d912-9f6f-4660-beb3-57e19f5d4e95" name="5.8.1审批一级军工产品设计定型" filename="b5c7d912-9f6f-4660-beb3-57e19f5d4e95.docx"&gt; &lt;item id="89fc14e1-09af-4537-915a-3fca40f7aa1d" name="5.8.1.1二级定委根据产品设计定型审查意见，审议一级军工产品设计定型有关事宜，符合设计定型标准和要求的，向一级定委呈报批准设计定型的请示；不符合设计定型标准和要求的，提出处理意见，连同原提交的军工产品设计定型申请文件一并退回申请单位。" filename="89fc14e1-09af-4537-915a-3fca40f7aa1d.docx"/&gt; &lt;item id="b47935da-32fd-4ff7-b1a2-8ffa74d69dba" name="5.8.1.2一级定委专家咨询委员会对二级定委报送的军工产品设计定型请示进行审核，审核后向一级定委提出定型咨询意见。专家咨询一委员会可参加二级定委组织的试验试用大纲评审、试验试用、定型审查等活动。" filename="b47935da-32fd-4ff7-b1a2-8ffa74d69dba.docx"/&gt; &lt;item id="1d7edc11-e6f2-4513-8268-ccf2de55e1ba" name="5.8.1.3一级定委对符合规定标准和要求的产品，按照规定的权限批准设计定型或报国务院、中央军委审批，下发批复；对不符合规定标准和要求的产品，提出处理意见，连同原报送的有关文件一并退回报送的二级定委。" filename="1d7edc11-e6f2-4513-8268-ccf2de55e1ba.docx"/&gt; &lt;item id="dd662740-de4a-4dee-9b05-afe92b3a020a" name="5.8.1.4产品批准设计定型后，由一级定委颁发产品设计定型证书，由二级定委对有关设计定型文件加盖设计定型专用章。" filename="dd662740-de4a-4dee-9b05-afe92b3a020a.docx"/&gt; &lt;/item&gt; &lt;item id="e3da11b1-6637-4e06-adfd-191614132859" name="5.8.2审批二级军工产品设计定型" filename="e3da11b1-6637-4e06-adfd-191614132859.docx"/&gt; &lt;/item&gt; &lt;/item&gt; &lt;item id="248e1e89-f829-4e89-b4d7-9420dacc13b8" name="6生产定型" filename="248e1e89-f829-4e89-b4d7-9420dacc13b8.docx"&gt; &lt;item id="90f82375-bf17-4d44-86b5-581bcce5ec2d" name="6.1生产定型条件和时间" filename="90f82375-bf17-4d44-86b5-581bcce5ec2d.docx"/&gt; &lt;item id="7a197dae-20e4-4ba7-abce-86d6ce6ced72" name="6.2生产定型程序" filename="7a197dae-20e4-4ba7-abce-86d6ce6ced72.docx"/&gt; &lt;item id="21da9766-d333-41cf-abc9-933006b59799" name="6.3部队试用产品与生产定型试验产品" filename="21da9766-d333-41cf-abc9-933006b59799.docx"&gt; &lt;item id="2c96287b-3f41-4fb5-9ee5-71a4b3a763ee" name="6.3.1部队试用产品" filename="2c96287b-3f41-4fb5-9ee5-71a4b3a763ee.docx"/&gt; &lt;item id="f96c66e4-6279-4bd5-a52a-2948e7ec580e" name="6.3.2生产定型试验产品" filename="f96c66e4-6279-4bd5-a52a-2948e7ec580e.docx"/&gt; &lt;/item&gt; &lt;item id="5f252b0e-7785-4d08-9d74-a85081c9dc5f" name="6.4组织工艺和生产条件考核" filename="5f252b0e-7785-4d08-9d74-a85081c9dc5f.docx"/&gt; &lt;item id="6ff6d59f-1711-42a1-beb9-cf8c96208049" name="6.5申请部队试用" filename="6ff6d59f-1711-42a1-beb9-cf8c96208049.docx"/&gt; &lt;item id="5fb9ca65-9ed9-426c-adb0-82c3c8a42d9f" name="6.6制定部队试用大纲" filename="5fb9ca65-9ed9-426c-adb0-82c3c8a42d9f.docx"/&gt; &lt;item id="7017ddc5-456f-470c-a73b-284704415106" name="6.7组织部队试用" filename="7017ddc5-456f-470c-a73b-284704415106.docx"&gt; &lt;item id="d2b30828-a09a-4534-bdcd-4eda8aba8e90" name="6.7.1部队试用的实施" filename="d2b30828-a09a-4534-bdcd-4eda8aba8e90.docx"/&gt; &lt;item id="2d83ebef-af67-4ff7-8b2c-d61bcface34e" name="6.7.2部队试用报告" filename="2d83ebef-af67-4ff7-8b2c-d61bcface34e.docx"/&gt; &lt;/item&gt; &lt;item id="eedd399f-0d47-42c0-b954-20b532a05340" name="6.8申请生产定型试验" filename="eedd399f-0d47-42c0-b954-20b532a05340.docx"/&gt; &lt;item id="a2f3b8ab-5fdf-44cd-8694-a020dbed6fe2" name="6.9制定生产定型试验大纲" filename="a2f3b8ab-5fdf-44cd-8694-a020dbed6fe2.docx"/&gt; &lt;item id="c35fa5ab-ba11-451a-bbf5-043add4496c1" name="6.10组织生产定型试验" filename="c35fa5ab-ba11-451a-bbf5-043add4496c1.docx"/&gt; &lt;item id="f5ad80a9-fdc2-4bab-a460-2da497dfca68" name="6.11申请生产定型" filename="f5ad80a9-fdc2-4bab-a460-2da497dfca68.docx"&gt; &lt;item id="25783469-78ff-4400-b39c-795e72ed33b0" name="6.11.1提出申请报告" filename="25783469-78ff-4400-b39c-795e72ed33b0.docx"/&gt; &lt;item id="0344cbf0-1595-4124-b030-20a9ace0941c" name="6.11.2申请报告内容" filename="0344cbf0-1595-4124-b030-20a9ace0941c.docx"/&gt; &lt;item id="6862ca2d-b646-4eba-af5c-150de9055301" name="6.11.3申请报告附件" filename="6862ca2d-b646-4eba-af5c-150de9055301.docx"/&gt; &lt;/item&gt; &lt;item id="a12aaeb2-2615-437a-aeb4-2ce7fc172657" name="6.12组织生产定型审查" filename="a12aaeb2-2615-437a-aeb4-2ce7fc172657.docx"&gt; &lt;item id="e5987e7d-5a37-4906-961e-6ee839dfc743" name="6.12.1生产定型审查组 " filename="e5987e7d-5a37-4906-961e-6ee839dfc743.docx"/&gt; &lt;item id="b9c74941-650a-4f8f-a92c-8578e60c072b" name="6.12.2生产定型标准和要求" filename="b9c74941-650a-4f8f-a92c-8578e60c072b.docx"/&gt; &lt;item id="fa286bb9-27e0-4d50-ac57-78773dfbded3" name="6.12.3审查意见书" filename="fa286bb9-27e0-4d50-ac57-78773dfbded3.docx"/&gt; &lt;/item&gt; &lt;item id="0346afa0-ca37-46e8-89c5-eaaec86a8898" name="6.13审批生产定型" filename="0346afa0-ca37-46e8-89c5-eaaec86a8898.docx"/&gt; &lt;/item&gt; &lt;item id="6472b4ba-fbf8-4b8b-bf3a-7d0412edade2" name="7定型文件" filename="6472b4ba-fbf8-4b8b-bf3a-7d0412edade2.docx"&gt; &lt;item id="f79e1d11-fb56-45cb-8529-fba7eac33185" name="7.1定型文件种类" filename="f79e1d11-fb56-45cb-8529-fba7eac33185.docx"/&gt; &lt;item id="07fce1f4-d186-42f1-ab89-1f9db5d65e0b" name="7.2定型文件清单" filename="07fce1f4-d186-42f1-ab89-1f9db5d65e0b.docx"&gt; &lt;item id="cece5585-cf2f-4891-a4df-e1e5c2e57508" name="7.2.1设计定型文件" filename="cece5585-cf2f-4891-a4df-e1e5c2e57508.docx"/&gt; &lt;item id="45350173-17a8-4357-bb2c-540e5184c6b5" name="7.2.2生产定型文件" filename="45350173-17a8-4357-bb2c-540e5184c6b5.docx"/&gt; &lt;/item&gt; &lt;item id="9d8ebba1-513a-4eea-ade1-8629e3d5ea60" name="7.3定型文件制作要求" filename="9d8ebba1-513a-4eea-ade1-8629e3d5ea60.docx"&gt; &lt;item id="2ea2bd5a-fb02-4ffa-b219-4261f8232b42" name="7.3.1技术文件格式" filename="2ea2bd5a-fb02-4ffa-b219-4261f8232b42.docx"/&gt; &lt;item id="a6d486b7-c3ae-4109-adf7-54270879bdb8" name="7.3.2产品图样绘制" filename="a6d486b7-c3ae-4109-adf7-54270879bdb8.docx"/&gt; &lt;item id="1a9b9795-7469-4fd6-92be-ff43c9cf454e" name="7.3.3产品照片和录像片" filename="1a9b9795-7469-4fd6-92be-ff43c9cf454e.docx"/&gt; &lt;item id="ba1e384c-e16e-4b3a-a125-0575f38d3a1e" name="7.3.4文件整理" filename="ba1e384c-e16e-4b3a-a125-0575f38d3a1e.docx"/&gt; &lt;/item&gt; &lt;item id="50c13504-32c3-4a6d-ae96-f9a35cfd6c9e" name="7.4定型文件汇总上报" filename="50c13504-32c3-4a6d-ae96-f9a35cfd6c9e.docx"/&gt; &lt;item id="3cca6d6b-13a2-495b-ba9d-bd21b8584917" name="7.5定型文件盖章" filename="3cca6d6b-13a2-495b-ba9d-bd21b8584917.docx"/&gt; &lt;item id="a7381eb0-fc6a-48f0-8fe1-236d63401a41" name="7.6定型文件的使用" filename="a7381eb0-fc6a-48f0-8fe1-236d63401a41.docx"/&gt; &lt;item id="a77fbb37-dc8d-489e-a29f-0fe414ee4c43" name="7.7定型文件的修改" filename="a77fbb37-dc8d-489e-a29f-0fe414ee4c43.docx"/&gt; &lt;/item&gt;&lt;/item&gt; 不过poi 分割.docx没问题，但是分割.doc 文件就会有问题 所以中间如果是.doc 文件的话，所以中间还得进行转换，这里我使用的技术是aspose for java,这个特别简单只要把jar 包引入即可两步，不过这个玩艺是收费的，所以有点扯，不过，最后在csdn花了10分，下载了一个license.xml(破解)： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.sysware.soft603.util.backUp;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import com.aspose.words.Document;import com.aspose.words.License;public class WordToPDF &#123; public static boolean getLicense() &#123; boolean result = false; try &#123; // InputStream is = // Test.class.getClassLoader().getResourceAsStream("\\license.xml"); InputStream is = Test.class.getClassLoader().getResourceAsStream( "com\\sysware\\soft603\\util\\backUp\\license.xml"); // InputStream is = // Test.class.getClassLoader().getResourceAsStream("testpackage/license2.xml"); // InputStream is = // Test.class.getClassLoader().getResourceAsStream("subpackage/license3.xml"); License aposeLic = new License(); aposeLic.setLicense(is); result = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; public static void main(String[] args) &#123; // 验证License if (!getLicense()) &#123; return; &#125; String path = "d:\\GJB 1362A-2007 军工产品定型程序和要求.doc"; InputStream is = null; try &#123; is = new FileInputStream(path); Document doc = new Document(is); doc.save("d:\\1028.pdf");//转pdf、docx都可以 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 以下是合并的代码：使用的是docx4j 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282package com.sysware.soft603.util.backUp;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.apache.commons.io.IOUtils;import org.apache.poi.xwpf.usermodel.BodyElementType;import org.apache.poi.xwpf.usermodel.IBodyElement;import org.apache.poi.xwpf.usermodel.XWPFDocument;import org.apache.poi.xwpf.usermodel.XWPFParagraph;import org.apache.poi.xwpf.usermodel.XWPFStyles;import org.docx4j.jaxb.Context;import org.docx4j.openpackaging.exceptions.Docx4JException;import org.docx4j.openpackaging.packages.WordprocessingMLPackage;import org.docx4j.openpackaging.parts.PartName;import org.docx4j.openpackaging.parts.WordprocessingML.AlternativeFormatInputPart;import org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart;import org.docx4j.relationships.Relationship;import org.docx4j.wml.CTAltChunk;public class MargeDoc &#123; public void mergeDocx(List&lt;String&gt; list, String path) &#123; List&lt;InputStream&gt; inList = new ArrayList&lt;InputStream&gt;(); for (int i = 0; i &lt; list.size(); i++) try &#123; inList.add(new FileInputStream(list.get(i))); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; InputStream inputStream = mergeDocx(inList); saveTemplate(inputStream, path); &#125; catch (Docx4JException | IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public InputStream mergeDocx(final List&lt;InputStream&gt; streams) throws Docx4JException, IOException &#123; WordprocessingMLPackage target = null; final File generated = File.createTempFile("generated", ".docx"); int chunkId = 0; Iterator&lt;InputStream&gt; it = streams.iterator(); while (it.hasNext()) &#123; InputStream is = it.next(); if (is != null) &#123; if (target == null) &#123; // Copy first (master) document OutputStream os = new FileOutputStream(generated); os.write(IOUtils.toByteArray(is)); os.close(); target = WordprocessingMLPackage.load(generated); &#125; else &#123; // Attach the others (Alternative input parts) insertDocx(target.getMainDocumentPart(), IOUtils.toByteArray(is), chunkId++); &#125; &#125; &#125; if (target != null) &#123; target.save(generated); return new FileInputStream(generated); &#125; else &#123; return null; &#125; &#125; // 鎻掑叆鏂囨。 private void insertDocx(MainDocumentPart main, byte[] bytes, int chunkId) &#123; try &#123; AlternativeFormatInputPart afiPart = new AlternativeFormatInputPart( new PartName("/part" + chunkId + ".docx")); // afiPart.setContentType(new ContentType(CONTENT_TYPE)); afiPart.setBinaryData(bytes); Relationship altChunkRel = main.addTargetPart(afiPart); CTAltChunk chunk = Context.getWmlObjectFactory().createCTAltChunk(); chunk.setId(altChunkRel.getId()); main.addObject(chunk); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void saveTemplate(InputStream fis, String toDocPath) &#123; FileOutputStream fos; int bytesum = 0; int byteread = 0; try &#123; fos = new FileOutputStream(toDocPath); byte[] buffer = new byte[1444]; while ((byteread = fis.read(buffer)) != -1) &#123; bytesum += byteread; // 瀛楄妭鏁� 鏂囦欢澶у皬 fos.write(buffer, 0, byteread); &#125; fis.close(); fos.close(); &#125; catch (FileNotFoundException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Docx4JException, IOException &#123; MargeDoc wordUtil = new MargeDoc(); String template = "D:/poinew"; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(template + "/0.docx"); list.add(template + "/1.docx"); list.add(template + "/2.docx"); list.add(template + "/3.docx"); list.add(template + "/3.1.docx"); list.add(template + "/3.2.docx"); list.add(template + "/3.3.docx"); list.add(template + "/3.4.docx"); list.add(template + "/3.5.docx"); list.add(template + "/3.6.docx"); list.add(template + "/3.7.docx"); list.add(template + "/3.8.docx"); list.add(template + "/3.9.docx"); list.add(template + "/4.docx"); list.add(template + "/4.1.docx"); list.add(template + "/4.2.docx"); list.add(template + "/4.3.docx"); list.add(template + "/4.4.docx"); list.add(template + "/5.docx"); list.add(template + "/5.1.docx"); list.add(template + "/5.2.docx"); list.add(template + "/5.3.docx"); list.add(template + "/5.4.docx"); list.add(template + "/5.4.1.docx"); list.add(template + "/5.4.2.docx"); list.add(template + "/5.4.3.docx"); list.add(template + "/5.4.4.docx"); list.add(template + "/5.5.docx"); list.add(template + "/5.5.1.docx"); list.add(template + "/5.5.2.docx"); list.add(template + "/5.5.3.docx"); list.add(template + "/5.5.4.docx"); list.add(template + "/5.5.5.docx"); list.add(template + "/5.5.6.docx"); list.add(template + "/5.5.7.docx"); list.add(template + "/5.5.8.docx"); list.add(template + "/5.6.docx"); list.add(template + "/5.6.1.docx"); list.add(template + "/5.6.2.docx"); list.add(template + "/5.6.3.docx"); list.add(template + "/5.6.4.docx"); list.add(template + "/5.7.docx"); list.add(template + "/5.7.1.docx"); list.add(template + "/5.7.2.docx"); list.add(template + "/5.7.3.docx"); list.add(template + "/5.8.docx"); list.add(template + "/5.8.1.docx"); list.add(template + "/5.8.1.1.docx"); list.add(template + "/5.8.1.2.docx"); list.add(template + "/5.8.1.3.docx"); list.add(template + "/5.8.1.4.docx"); list.add(template + "/5.8.2.docx"); list.add(template + "/6.docx"); list.add(template + "/6.1.docx"); list.add(template + "/6.2.docx"); list.add(template + "/6.3.docx"); list.add(template + "/6.3.1.docx"); list.add(template + "/6.3.2.docx"); list.add(template + "/6.4.docx"); list.add(template + "/6.5.docx"); list.add(template + "/6.6.docx"); list.add(template + "/6.7.docx"); list.add(template + "/6.7.1.docx"); list.add(template + "/6.7.2.docx"); list.add(template + "/6.8.docx"); list.add(template + "/6.9.docx"); list.add(template + "/6.10.docx"); list.add(template + "/6.11.docx"); list.add(template + "/6.11.1.docx"); list.add(template + "/6.11.2.docx"); list.add(template + "/6.11.3.docx"); list.add(template + "/6.12.docx"); list.add(template + "/6.12.1.docx"); list.add(template + "/6.12.2.docx"); list.add(template + "/6.12.3.docx"); list.add(template + "/6.13.docx"); list.add(template + "/7.docx"); list.add(template + "/7.1.docx"); list.add(template + "/7.2.docx"); list.add(template + "/7.2.1.docx"); list.add(template + "/7.2.2.docx"); list.add(template + "/7.3.docx"); list.add(template + "/7.3.1.docx"); list.add(template + "/7.3.2.docx"); list.add(template + "/7.3.3.docx"); list.add(template + "/7.3.4.docx"); list.add(template + "/7.4.docx"); list.add(template + "/7.5.docx"); list.add(template + "/7.6.docx"); list.add(template + "/7.7.docx"); wordUtil.mergeDocx(list, template + "/out.docx"); //splitWord(); &#125; private static void splitWord() &#123; String path = "d:\\poinew\\out.docx"; InputStream is = null; try &#123; is = new FileInputStream(path); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; XWPFDocument doc = null; try &#123; doc = new XWPFDocument(is); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // 获取bodyElements List&lt;IBodyElement&gt; bodyElements = doc.getBodyElements(); // 获取doc样式 XWPFStyles styles = doc.getStyles(); System.out.println(doc.getParagraphs().size()); for (int i = 0; i &lt; bodyElements.size(); i++) &#123; IBodyElement bodyElement = bodyElements.get(i); try &#123; if (bodyElement.getElementType() == BodyElementType.PARAGRAPH) &#123; XWPFParagraph para = (XWPFParagraph) bodyElement; System.out.println(styles.getStyle(para.getStyle()).getCTStyle().getName().getVal()); System.out.println(para.getText()); if (styles.getStyle(para.getStyle()).getCTStyle().getName().getVal().contains("heading")) &#123; XWPFParagraph para1 = (XWPFParagraph) doc.getBodyElements().get(i); String str1 = para1.getStyleID(); doc.getStyles().getStyle(str1).getCTStyle().getPPr().unsetNumPr(); System.out.println("test"); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; XWPFDocument newDoc = doc; int max = 0; path = "d:\\poinew\\out.docx"; OutputStream out = null; try &#123; out = new FileOutputStream("d:\\poinew\\newOut.docx"); try &#123; doc.write(out); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("over"); &#125;&#125; 使用jacob合并多个word为单个word1导入jar 包,我使用的是1.7,dil文件一定要和jar包匹配 使用前操作 1、把dll文件放在%JAVA_HOME%\bin下（注意系统是32位还是64位）， 也可以放在C:\Windows\System32下，如果是64位应该放在C:\Windows\SysWOW64 下。建议放在jdk的bin目录下 2、如果是在eclipse下开发，需要重新引入jdk（Preference/Java/Installed JREs） 3、开发时将jacab.jar包放在项目lib下并add到liabraries中即可。 测试用例: 我在我两台电脑上都部署了,但不知为啥,一台运行出现异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.dyz.test; import java.util.ArrayList;import java.util.List; import com.jacob.activeX.ActiveXComponent;import com.jacob.com.Dispatch;import com.jacob.com.Variant; public class TestWord &#123; public static void main(String[] args) &#123; List list = new ArrayList(); String file1 = "D:\\file1.doc"; String file2 = "D:\\file2.doc"; //String file3 = "D:\\file3.doc"; list.add(file1); list.add(file2); //list.add(file3); // System.out.println(System.getProperty("java.library.path")); uniteDoc(list, "d:\\file.doc"); &#125; public static void uniteDoc(List fileList, String savepaths) &#123; if (fileList.size() == 0 || fileList == null) &#123; return; &#125; // 打开word ActiveXComponent app = new ActiveXComponent("Word.Application");// 启动word try &#123; // 设置word不可见 app.setProperty("Visible", new Variant(false)); // 获得documents对象 Object docs = app.getProperty("Documents").toDispatch(); // 打开第一个文件 Object doc = Dispatch .invoke((Dispatch) docs, "Open", Dispatch.Method, new Object[] &#123; (String) fileList.get(0), new Variant(false), new Variant(true) &#125;, new int[3]).toDispatch(); // 追加文件 for (int i = 1; i &lt; fileList.size(); i++) &#123; Dispatch.invoke(app.getProperty("Selection").toDispatch(), "insertFile", Dispatch.Method, new Object[] &#123; (String) fileList.get(i), "", new Variant(false), new Variant(false), new Variant(false) &#125;, new int[3]); &#125; // 保存新的word文件 Dispatch.invoke((Dispatch) doc, "SaveAs", Dispatch.Method, new Object[] &#123; savepaths, new Variant(1) &#125;, new int[3]); Variant f = new Variant(false); Dispatch.call((Dispatch) doc, "Close", f); &#125; catch (Exception e) &#123; throw new RuntimeException("合并word文件出错.原因:" + e); &#125; finally &#123; app.invoke("Quit", new Variant[] &#123;&#125;); &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>poi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要自称为程序员]]></title>
    <url>%2Fblog%2F34625.html</url>
    <content type="text"><![CDATA[每年都有无数年轻程序员，加入软件行业。 他们在学校里学过编程，但是对这个行业的现实一无所知。Patrick McKenzie 是美国一家小软件公司的老板，他写了一篇长文，介绍这个行业的一些实际情况。我看了以后很感慨，有些地方很受启发。我选择了一部分，翻译如下。 一、90%的编程工作来自内部软件计算机专业的学生，可能有一种印象，觉得大部分程序员，都在编写公开出售的软件或者通用软件。 这种看法是不对的。大部分程序员，实际上编写的是不公开的企业内部软件，比如追踪费用的软件、优化装运成本的软件、帮助记账的软件、设计新部件的软件、计算保单价格的软件、识别恶意订单的软件等等。各种各样的商业公司，开发内部软件，解决它们自己的问题。市场上对程序员的大部分需求来源于此，只有极少数程序员直接编写面向外部顾客的软件。 内部软件的开发，通常非常乏味，令人厌倦。因为它们的技术复杂性低、技术决策非常保守、预算很少、缺乏长远考虑。但是，世界上大部分编程工作都是这种。 二、别人雇你的目的，是让你创造利润，不是让你编程商业公司最关心的（或者说唯一在乎的）事情，就是增加收入、降低成本。因此，它们实际上需要的不是程序员，而是能够帮助它们增加收入、降低成本的人。 开发优美的软件，解决技术难题，编写没有 bug 的代码，这些都不是商业公司的目的。它们雇佣你，是为了让你帮它们完成某个可以增加收入、降低成本的项目，而不是为了让你追求个人的软件成就。 你对于公司的唯一价值，就在于能多大程度上为它们增加收入、降低成本。 三、不要自称为程序员很多公司的经理不懂计算机，在他们心目中，程序员就是一群高成本的劳动力，只会在一台复杂的机器上干一些难懂的事情。 如果你自称为”程序员”，当公司需要压缩成本的时候，某些经理首先就会想到解雇你，因为你的工资高。有一家公司叫 Salesforce，口号是”没有软件”，意思就是如果经理们购买了他们的服务，就不再需要别的软件管理销售业务了，也就是说，不再需要自己雇佣程序员了。 正确的做法是，你应该把自己描述成与增加收入、降低成本有关系的人，比如”xx产品的开发者”或”改进者”。有一个 Google Adsense 程序员的自我介绍，是这样写的：”Google 公司97%的收入，与我的代码有关。” 四、不要限定自己年轻学生经常会问，应该选择哪种语言或平台？Java 是不是比 .NET 容易找工作？ 过分强调某一种语言或平台，都是不必要的。如果你把自己限定为 Java 程序员或 .NET 程序员，你就已经输了，因为首先你不应该自称为程序员（理由见上一点），其次这种限定使得你自动被排除在世界上大多数编程工作之外。 现实生活中，学会一种新语言，只需要几个星期，然后再过半年到一年，你就会变成老手。那时，根本没人在乎你以前用什么语言。 天才程序员是很少的，可是需要天才程序员的工作机会却很多很多，大多数场合都是需求远远大于供给。这意味着，即使你不是天才程序员，只要你是一个优秀工程师，那些招聘公司也会立刻录用你，因为它们知道招聘到天才程序员的机会微乎其微。（重复一遍，所谓”优秀工程师”，就是你的履历上有一连串增加收入、降低成本的记录。） 某些公司的人事部门，会根据某个关键词（比如 Java 或 .NET）过滤简历。虽然这样的公司根本不值得去，但是如果你真的想过这一关，也很容易：投入几个晚上和周末，在你当前的项目中设法用到这个关键词，然后再把它写进简历就行了。 五、如何提高求职时的谈判能力？（1）记住你不是在求职，不是在展示编程技巧，而是在推销某种商业问题（增加收入或降低成本）的解决方案。 （2）面试时，要有自信，要平等的对话。你要的是一个互利的录用合同，不要每次对方提出要求，你都说Yes。 （3）雇主可能会问”你的上一份工资是多少”，他们其实在说”给我一个理由，压低你的报酬”。你要想好如何适当地回答这个问题。 （4）要还价。这里不仅仅指钱，还指其它你关心的方面。如果你无法要求更高的薪水，那就试着要求更多的假期。 （5）在对方决定录用你以后，才开始讨论薪水。因为那时，他们已经在你身上，投入了大量的时间和金钱，产生了一定的成本，此时他们可能觉得一些小问题已经不值得再纠缠了，比如每年的工资增加几千元。 六、创业公司是否适合应届毕业生？如果你一毕业就加入创业公司，最可能的结果是，接下来几年你都工作得非常辛苦，然后公司悲惨地失败了，你失业了，不得不又去另一家创业公司工作。 如果你真的想去创业公司，应该首先找一家大公司干上两年，攒一点钱，积累一些经验，然后精心挑选一家创业公司，再去实现自己的梦想。 在创业公司工作，一般情况下，你遇到的都是创业者。他们大多数人没有能力在两年后雇佣你；而在大公司工作，你遇到的都是其他大公司的人，他们中很多人将来有能力雇用你或者帮你介绍工作。 七、沟通技能是最重要的职业技能前面说过，工程师被雇佣，不是因为会编程，而是因为能够创造商业价值。所以，你得让人们相信你能创造价值，这是帮助你找到工作的最重要的能力。这种能力与你真的能创造多少价值，实际上联系不是很紧密。 我认识的一些最优秀的程序员，往往拙于表达。因此，别人不是不想与他们一起工作，就是低估了他们的价值。相反地，如果你看上去很会编程，并且很善于表达，别人就会真的这样看待你。 （完）]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 获取音视频文件的大小、以及播放时长]]></title>
    <url>%2Fblog%2F54695.html</url>
    <content type="text"><![CDATA[简介The JAVE (Java Audio Video Encoder) library is Java wrapper on the ffmpeg project. Developers can take take advantage of JAVE to transcode audio and video files from a format to another. In example you can transcode an AVI file to a MPEG one, you can change a DivX video stream into a (youtube like) Flash FLV one, you can convert a WAV audio file to a MP3 or a Ogg Vorbis one, you can separate and transcode audio and video tracks, you can resize videos, changing their sizes and proportions and so on. Many other formats, containers and operations are supported by JAVE.看介绍这么强大，其实我的需求只是想要获取视频、语音的长度而已。使用 总共只有一个jar包，API也非常简单，不说了，贴代码 首先引入jave-1.0.2.jar， 写了个demo 仅供参考 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.readVideo.test; public class VideoName &#123; private int id; private String name; private String time; private String size; private String leaf; private String url; private String brief; private int VIDEO_DETAIL_ID; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getTime() &#123; return time; &#125; public void setTime(String time) &#123; this.time = time; &#125; public String getSize() &#123; return size; &#125; public void setSize(String size) &#123; this.size = size; &#125; public String getLeaf() &#123; return leaf; &#125; public void setLeaf(String leaf) &#123; this.leaf = leaf; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getBrief() &#123; return brief; &#125; public void setBrief(String brief) &#123; this.brief = brief; &#125; public int getVIDEO_DETAIL_ID() &#123; return VIDEO_DETAIL_ID; &#125; public void setVIDEO_DETAIL_ID(int vIDEO_DETAIL_ID) &#123; VIDEO_DETAIL_ID = vIDEO_DETAIL_ID; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.readVideo.test; import it.sauronsoftware.jave.Encoder;import it.sauronsoftware.jave.MultimediaInfo;import java.io.File;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.List; public class ReadVideoMessages &#123; /** * 得到视频的大小 * * @param f * 文件 * @return 视频的大小 */ public static String getFileSize(File f) &#123; // 保留两位小数 DecimalFormat df = new DecimalFormat(".##"); // 得到视频的长度 Long long1 = f.length(); String size = ""; long G = 1024 * 1024 * 1024; long M = 1024 * 1024; long K = 1024; // 视频大小超过G、超过M不超过G、超过K不超过M if (long1 / G &gt;= 1) &#123; size = df.format((double) long1 / G) + "G"; &#125; else if (long1 / M &gt;= 1) &#123; size = df.format((double) long1 / M) + "M"; &#125; else if (long1 / K &gt;= 1) &#123; size = df.format((double) long1 / K) + "K"; &#125; else &#123; size = long1 + "B"; &#125; // System.out.println(time); return size; &#125; /** * 得到视频的长度 * * @param f * 文件 * @return 视频的长度 */ public static String getVideoTime(File f) &#123; String time = ""; //新建编码器对象 Encoder encoder = new Encoder(); try &#123; //得到多媒体视频的信息 MultimediaInfo m = encoder.getInfo(f); //得到毫秒级别的多媒体是视频长度 long ls = m.getDuration(); //转换为分秒 time = ls / 60000 + "分" + (ls - (ls / 60000 * 60000)) / 1000 + "秒"; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return time; &#125; // 显示目录的方法 /** * 得到视频所有的信息 * * @param file * 文件夹 or 文件 * @return 视频的信息 */ public static List&lt;VideoName&gt; getAllMessage(File file) &#123; List&lt;VideoName&gt; videoNames = new ArrayList&lt;VideoName&gt;(); // System.out.println( file.getAbsolutePath()); String time = ""; String size = ""; // 判断传入对象是否为一个文件夹对象 if (!file.isDirectory()) &#123; System.out.println("你输入的不是一个文件夹，请检查路径是否有误！！"); &#125; else &#123; File[] f = file.listFiles(); for (int i = 0; i &lt; f.length; i++) &#123; // 判断文件列表中的对象是否为文件夹对象，如果是则执行tree递归，直到把此文件夹中所有文件输出为止 if (f[i].isDirectory()) &#123; System.out.println(f[i].getName() + "\tttdir"); // getAllMessage(f[i]); &#125; else &#123; time = getVideoTime(f[i]); if (time.equals("")) &#123; time = "未知"; &#125; size = getFileSize(f[i]); VideoName videoName = new VideoName(); int j = f[i].getName().indexOf("-", 1); videoName.setName(f[i].getName().substring(0, j)); videoName.setSize(size); videoName.setTime(time); videoName.setBrief(f[i].getName().substring(j + 1, f[i].getName().length())); videoName.setUrl("F:/Resource/video/硬件/AltiumDesigner/" + f[i].getName()); videoNames.add(videoName); System.out.println(time + "---" + size + "---" + f[i].getName().substring(0, j) + "---" + f[i].getName().substring(j + 1, f[i].getName().length()) + "---" + "F:/Resource/video/硬件/AltiumDesigner/" + f[i].getName()); &#125; &#125; &#125; return videoNames; &#125; public static void main(String[] args) &#123; File f = new File("F:\\Resource\\video\\软件\\LabView"); List&lt;VideoName&gt; videoMessages = getAllMessage(f); System.out.println(videoMessages.size()); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Listener实现在线统计人数和总访问量]]></title>
    <url>%2Fblog%2F61929.html</url>
    <content type="text"><![CDATA[监听器用于监听web应用中某些对象、信息的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理。当范围对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。常用于统计在线人数和在线用户，系统加载时进行信息初始化，统计网站的访问量等等。 分类： 按监听的对象划分，可以分为 ServletContext对象监听器HttpSession对象监听器ServletRequest对象监听器 按监听的事件划分 对象自身的创建和销毁的监听器对象中属性的创建和消除的监听器session中的某个对象的状态变化的监听器 示例：用监听器统计网站在线人数 原理：每当有一个访问连接到服务器时，服务器就会创建一个session来管理会话。那么我们就可以通过统计session的数量来获得当前在线人数。 监听器应用一般统计在线人数,闲着没事，写个笔记，我们项目中是这样做的 首先定义一个servlet 这个servelt 在服务器启动时，就会调用，初始化： 实现累计访问量的一个方法1.web.xml的配置1234567&lt;!-- added by li'n for 登陆页面自动读取访问数 on 2013-04-15 the beginning --&gt; &lt;servlet&gt; &lt;servlet-name&gt;VisitCounts&lt;/servlet-name&gt; &lt;servlet-class&gt;com.sysware.framework.login.VisitCounts&lt;/servlet-class&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- added by li'n for 登陆页面自动读取访问数 on 2013-04-15 the end --&gt; ２.项目登录页面可以获取访问本项目的总人数（init方法）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.sysware.framework.login; import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException; import javax.servlet.http.HttpServlet; /** * @version 1.0 * @author li'n on 系统工程部 * @since 2013-04-15 17:00 * */public class VisitCounts extends HttpServlet&#123; /** * */ private static final long serialVersionUID = -6737156348721467846L; //累计访问量 public static int counts = 0; public static void setCounts(int counts) &#123; VisitCounts.counts = counts; &#125; /** * * @return 历史访问量 */ public int getCounts() &#123; return counts; &#125; /** * 服务器启动时读取文件中的历史访问量 */ public void init() &#123; //获取visitCount.txt的文件路径 String p = this.getClass().getClassLoader().getResource("").getPath(); File file = new File(p+File.separator +"visitCount.txt"); //读取文件中的数字，即系统的历史访问量 if (file.exists()) &#123; readFile(file); &#125; else &#123; try &#123; file.createNewFile(); readFile(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 读取文件file中的访问量数据 */ @SuppressWarnings("static-access") public void readFile(File file)&#123; BufferedReader reader = null; String tempString = null; try &#123; reader = new BufferedReader(new FileReader(file)); while((tempString = reader.readLine()) != null) &#123; VisitCounts.counts = Integer.parseInt(tempString); System.out.println(); this.setCounts(counts); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; ３.在用户登录时，数量加１并用流写到文件里面（doLogin方法里面处理）123456789if(loginInfo.isSuccess()) &#123; //added by li'n for 访问量统计 on 2013-04-19 the beginning //登录成功，访问量加1 VisitCounts.setCounts(VisitCounts.counts + 1); //将访问量更新到文件visitCount.txt writeFile(); //added by li'n for 访问量统计 on 2013-04-19 the end &#125;&lt;br&gt;/**&lt;br&gt; * 将访问量更新到文件visitCount.txt&lt;br&gt; * @return 历史访问量&lt;br&gt; * @author li'n on 系统工程部&lt;br&gt; * @since 2013-04-19 &lt;br&gt; */&lt;br&gt; public void writeFile()&#123;&lt;br&gt; &lt;br&gt; FileWriter filewrite = null;&lt;br&gt; try &#123;&lt;br&gt; &lt;br&gt; //获得文件路径&lt;br&gt; filewrite = new FileWriter(this.getClass().getClassLoader().getResource("").getPath()+File.separator +"visitCount.txt");&lt;br&gt; &lt;br&gt; //将访问量写入文件&lt;br&gt; int o = VisitCounts.counts;&lt;br&gt; filewrite.write(o + "\r\n");&lt;br&gt; filewrite.flush();&lt;br&gt; filewrite.close();&lt;br&gt; &#125; catch (Exception e) &#123;&lt;br&gt; e.printStackTrace();&lt;br&gt; &#125;&lt;br&gt;&lt;br&gt; &#125; 以上，是实现累计访问量的一个方法； 下面说说实现在线人数，这个就要用到监听器的方式 实现在线人数首先还是在 web.xml中配置你所写的监听器1234&lt;!-- 在线用户session监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;com.sysware.framework.login.OnlineSessionListener&lt;/listener-class&gt; &lt;/listener&gt; ２.监听器类1234567891011121314151617181920212223242526272829303132333435363738394041package com.sysware.framework.login; import javax.servlet.http.HttpSessionAttributeListener;import javax.servlet.http.HttpSessionBindingEvent; import com.sysware.framework.commons.SystemConstants; /** * * * 在线session监听器 * * @version : 1.0 * @since : 2012-5-21下午08:46:02 * @team : 系统管理 * @author : liuxj */public class OnlineSessionListener implements HttpSessionAttributeListener &#123; @Override public void attributeAdded(HttpSessionBindingEvent event) &#123; if (SystemConstants.SESSION_KEY.equals(event.getName())) &#123; OnlineUserContext.getInstance().addSession(event.getSession()); &#125; &#125; @Override public void attributeRemoved(HttpSessionBindingEvent event) &#123; if (SystemConstants.SESSION_KEY.equals(event.getName())) &#123; OnlineUserContext.getInstance().removeSession(event.getSession()); &#125; &#125; @Override public void attributeReplaced(HttpSessionBindingEvent event) &#123; if (SystemConstants.SESSION_KEY.equals(event.getName())) &#123; OnlineUserContext.getInstance().replaceSession(event.getSession()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197package com.sysware.framework.login;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import javax.servlet.http.HttpSession;import com.sysware.framework.commons.SystemConstants;import com.sysware.framework.eobs.commons.ObjectCloneUtils;import com.sysware.utils.SyswareUtil;/** * copyright : Sysware Technology Co., Ltd * * 在线用户信息上下文 * * @version : 1.0 * @since : 2012-5-21下午08:31:07 * @team : 系统管理 * @author : liuxj */public class OnlineUserContext &#123; private static OnlineUserContext onlineUserContext; // 用户在线信息 private Map&lt;String, HttpSession&gt; onlineUserMap; private OnlineUserContext() &#123; onlineUserMap = new HashMap&lt;String, HttpSession&gt;(); &#125; /** * 获取在线用户上下文实例 * * @since : 2012-5-23:下午05:47:55 * @return 在线用户上下文实例 */ public static OnlineUserContext getInstance() &#123; return onlineUserContext == null ? onlineUserContext = new OnlineUserContext() : onlineUserContext; &#125; /** * 加入session触发 * * @since : 2012-5-21:下午09:02:26 * @param session * session对象 */ synchronized void addSession(HttpSession session) &#123; onlineUserMap.put(session.getId(), session); &#125; /** * 移除Session * * @since : 2012-5-21:下午09:02:56 * @param session * session对象 */ synchronized void removeSession(HttpSession session) &#123; if (onlineUserMap.containsKey(session.getId())) &#123; onlineUserMap.remove(session.getId()); &#125; &#125; /** * 替换Session * * @since : 2012-5-21:下午09:03:18 * @param session * session对象 */ synchronized void replaceSession(HttpSession session) &#123; addSession(session); &#125; /** * 根据用户ID判断是否登录 * * @since : 2013-1-28:下午02:01:31 * @param userId * 用户ID * @return true已经登录|false未登录 */ public boolean isLogged(String userId) &#123; List&lt;OnlineUserInfo&gt; list = getOnlineUserInfoList(); for (OnlineUserInfo info : list) &#123; if (info.isLogged() &amp;&amp; info.getUserId().equals(userId)) &#123; return true; &#125; &#125; return false; &#125; /** * 根据sessionId获取session * @since : 2012-12-17:下午01:06:11 * @param sessionId sessionId * @return session */ public HttpSession getSession(String sessionId) &#123; return onlineUserMap.containsKey(sessionId) ? onlineUserMap.get(sessionId) : null; &#125; /** * 根据sessionId移除session * @since : 2012-12-17:下午01:05:39 * @param sessionId sessionId */ public void removeSession(String sessionId) &#123; HttpSession session = getSession(sessionId); if(!SyswareUtil.isEmpty(session)) &#123; session.invalidate(); session = null; &#125; &#125; /** * 获取当前登录操作用户数量 * * @since : 2012-5-21:下午09:20:54 * @return 登录操作用户数量 */ public int getLoginUserCount() &#123; int num = 0; List&lt;OnlineUserInfo&gt; list = getOnlineUserInfoList(); for(OnlineUserInfo info : list) &#123; if(info.isLogged()) &#123; num ++; &#125; &#125; return num; &#125; /** * 获取当前未登录的操作用户数量 * * @since : 2012-5-21:下午09:21:14 * @return 未登录的操作用户数量 */ public int getNoLoginUserCount() &#123; int num = 0; List&lt;OnlineUserInfo&gt; list = getOnlineUserInfoList(); for(OnlineUserInfo info : list) &#123; if(!info.isLogged()) &#123; num ++; &#125; &#125; return num; &#125; /** * 获取当前操作用户总数 * * @since : 2012-5-21:下午09:22:16 * @return 操作用户总数 */ public int getOperatorCount() &#123; return getOnlineUserInfoList().size(); &#125; /** * 获取当前操作用户列表 * * @since : 2012-5-22:上午10:11:39 * @return 操作用户列表 */ public synchronized List&lt;OnlineUserInfo&gt; getOnlineUserInfoList() &#123; List&lt;OnlineUserInfo&gt; list = new ArrayList&lt;OnlineUserInfo&gt;(); Iterator&lt;Entry&lt;String, HttpSession&gt;&gt; iterator = onlineUserMap .entrySet().iterator(); while (iterator.hasNext()) &#123; Entry&lt;String, HttpSession&gt; entry = iterator.next(); OnlineUserInfo info = ObjectCloneUtils.clone(getOnlineUserInfo(entry.getKey())); info.setSessionId(entry.getKey()); list.add(info); &#125; return list; &#125; /** * 获取在线用户信息 * * @since : 2012-5-21:下午09:14:01 * @param sessionId * session的ID * @return 在线用户信息 */ private OnlineUserInfo getOnlineUserInfo(String sessionId) &#123; HttpSession session = getSession(sessionId); return SyswareUtil.isEmpty(session) ? null : (Operator) session.getAttribute(SystemConstants.SESSION_KEY); &#125;&#125; 上面的方法，一个是在线统计人数，一个是实现总访问量，自己项目中运用的，做个笔记。 页面12&lt;div class="visit"&gt;当前访问数：&lt;span id="nowVisitCount" style="color:#5374B1;"&gt;&lt;%=OnlineUserContext.getInstance().getLoginUserCount() %&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="count"&gt;累计访问数：&lt;span id="historyVisitCount" style="color:#5374B1;"&gt;&lt;%=new LoginServiceImpl().getCounts()%&gt;&lt;/span&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时任务框架]]></title>
    <url>%2Fblog%2F35236.html</url>
    <content type="text"><![CDATA[ScheduleIterator接口 import java.util.Date;public interface ScheduleIterator { public Date next();//获取下一个触发的时间点} Scheduler类 import java. 定时任务框架代码。整个框架就3个类： ScheduleIterator.java 12345import java.util.Date;public interface ScheduleIterator &#123; Date next();&#125; Scheduler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class Scheduler &#123; class SchedulerTimerTask extends TimerTask &#123; private SchedulerTask schedulerTask; private ScheduleIterator iterator; public SchedulerTimerTask(SchedulerTask schedulerTask, ScheduleIterator iterator) &#123; this.schedulerTask = schedulerTask; this.iterator = iterator; &#125; public void run() &#123; schedulerTask.run(); reschedule(schedulerTask, iterator); &#125; &#125; private final Timer timer = new Timer(); public Scheduler() &#123; &#125; public void cancel() &#123; timer.cancel(); &#125; public void schedule(SchedulerTask schedulerTask, ScheduleIterator iterator) &#123; Date time = iterator.next(); if (time == null) &#123; schedulerTask.cancel(); &#125; else &#123; synchronized (schedulerTask.lock) &#123; if (schedulerTask.state != SchedulerTask.VIRGIN) &#123; throw new IllegalStateException("Task already scheduled or cancelled"); &#125; schedulerTask.state = SchedulerTask.SCHEDULED; schedulerTask.timerTask = new SchedulerTimerTask(schedulerTask, iterator); timer.schedule(schedulerTask.timerTask, time); &#125; &#125; &#125; private void reschedule(SchedulerTask schedulerTask, ScheduleIterator iterator) &#123; Date time = iterator.next(); if (time == null) &#123; schedulerTask.cancel(); &#125; else &#123; synchronized (schedulerTask.lock) &#123; if (schedulerTask.state != SchedulerTask.CANCELLED) &#123; schedulerTask.timerTask = new SchedulerTimerTask(schedulerTask, iterator); timer.schedule(schedulerTask.timerTask, time); &#125; &#125; &#125; &#125;&#125; SchedulerTask.java 1234567891011121314151617181920212223242526272829303132333435import java.util.TimerTask;public abstract class SchedulerTask implements Runnable &#123; final Object lock = new Object(); int state = VIRGIN; static final int VIRGIN = 0; static final int SCHEDULED = 1; static final int CANCELLED = 2; TimerTask timerTask; protected SchedulerTask() &#123; &#125; public abstract void run(); public boolean cancel() &#123; synchronized (lock) &#123; if (timerTask != null) &#123; timerTask.cancel(); &#125; boolean result = (state == SCHEDULED); state = CANCELLED; return result; &#125; &#125; public long scheduledExecutionTime() &#123; synchronized (lock) &#123; return timerTask == null ? 0 : timerTask.scheduledExecutionTime(); &#125; &#125;&#125; 自己写的ScheduleIterator 实现类 以及一个测试类 SimpleScheduleIterator.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import com.jeecms.common.task.scheduling.ScheduleIterator;/** * 时间进度迭代器 &lt;li&gt;返回 月/周/天/小时/分钟/秒 计划的下一次执行时间&lt;/li&gt; &lt;li&gt;约定：参数以逗号分隔,*号表示无值&lt;/li&gt; &lt;li&gt; * 参数解释： &lt;br&gt; * 第一位：每个月的第几周&lt;/br&gt; &lt;br&gt; * 第二位：每周的第几天&lt;/br&gt; &lt;br&gt; * 第三位：天(几号)&lt;/br&gt; &lt;br&gt; * 第四位：小时(24小时制)&lt;/br&gt; &lt;br&gt; * 第五位：分钟&lt;/br&gt; &lt;br&gt; * 第六位：秒&lt;/br&gt;&lt;/li&gt; &lt;li&gt;参数样例： &lt;br&gt; * 1,6,4,15,20,30 表示 从今天的15:20:30开始，每隔一个月执行一次,即下次执行时间是 下个月的第一周的第6天的15:20:30&lt;/br&gt; * &lt;br&gt; * *,6,4,15,20,30 表示 从今天的15:20:30开始，每隔一周执行一次,即下次执行时间是 下一周的第6天的15:20:30&lt;/br&gt; &lt;br&gt; * *,*,4,15,20,30 表示 从今天的15:20:30开始，每隔一天执行一次,即下次执行时间是 下一天的15:20:30&lt;/br&gt; &lt;br&gt; * *,*,*,15,20,30 表示 从今天的15:20:30开始，每隔一小时执行一次,即下次执行时间是 16:20:30&lt;/br&gt; &lt;br&gt; * *,*,*,*,20,30 表示 从这个小时的20:30开始，每隔一分钟执行一次,即下次执行时间是 *:21:30&lt;/br&gt; &lt;br&gt; * *,*,*,*,*,30 表示 从当前时间的30秒开始，每隔一秒执行一次,即下次执行时间是 *:*:31&lt;/br&gt;&lt;/li&gt; * * @author javacoo * @since 2011-11-03 */public class SimpleScheduleIterator implements ScheduleIterator &#123; private final ScheduleParamBean scheduleParamBean; private final Calendar calendar = Calendar.getInstance(); private final Calendar orginCalendar = Calendar.getInstance(); public SimpleScheduleIterator(final ScheduleParamBean scheduleParamBean) &#123; this(scheduleParamBean, new Date()); &#125; public SimpleScheduleIterator(final ScheduleParamBean scheduleParamBean, Date date) &#123; this.scheduleParamBean = scheduleParamBean; orginCalendar.setTime(date); calendar.setTime(date); if (null != scheduleParamBean.getWeekOfMonth()) &#123; calendar.set(Calendar.WEEK_OF_MONTH, scheduleParamBean.getWeekOfMonth()); &#125; // 如果设置了每周的第几天和一个月的第几天，则忽略一个月的第几天 if (null != scheduleParamBean.getDayOfWeek()) &#123; calendar.set(Calendar.DAY_OF_WEEK, scheduleParamBean.getDayOfWeek()); &#125; else if (null != scheduleParamBean.getDayOfMonth()) &#123; calendar.set(Calendar.DAY_OF_MONTH, scheduleParamBean.getDayOfMonth()); &#125; if (null != scheduleParamBean.getHourOfDay()) &#123; calendar.set(Calendar.HOUR_OF_DAY, scheduleParamBean.getHourOfDay()); &#125; if (null != scheduleParamBean.getMinute()) &#123; calendar.set(Calendar.MINUTE, scheduleParamBean.getMinute()); &#125; if (null != scheduleParamBean.getSecond()) &#123; calendar.set(Calendar.SECOND, scheduleParamBean.getSecond()); &#125; calendar.set(Calendar.MILLISECOND, 0); if (!calendar.getTime().before(date)) &#123; System.out.println(calendar.getTime() + "大于当前时间：" + date); if (null != scheduleParamBean.getWeekOfMonth()) &#123; calendar.add(Calendar.MONTH, -1); &#125; else if (null != scheduleParamBean.getDayOfWeek()) &#123; calendar.add(Calendar.DAY_OF_WEEK, -6); &#125; else if (null != scheduleParamBean.getDayOfMonth()) &#123; calendar.add(Calendar.DAY_OF_MONTH, -1); &#125; else if (null != scheduleParamBean.getHourOfDay()) &#123; calendar.add(Calendar.HOUR_OF_DAY, -1); &#125; else if (null != scheduleParamBean.getMinute()) &#123; calendar.add(Calendar.MINUTE, -1); &#125; else if (null != scheduleParamBean.getSecond()) &#123; calendar.add(Calendar.SECOND, -1); &#125; &#125; else &#123; System.out.println(calendar.getTime() + "小于当前时间：" + date); if (null != scheduleParamBean.getDayOfMonth()) &#123; calendar.add(Calendar.DAY_OF_MONTH, orginCalendar.get(Calendar.DAY_OF_MONTH) - scheduleParamBean.getDayOfMonth()); &#125; else if (null != scheduleParamBean.getHourOfDay()) &#123; calendar.add(Calendar.HOUR_OF_DAY, orginCalendar.get(Calendar.HOUR_OF_DAY) - scheduleParamBean.getHourOfDay()); &#125; else if (null != scheduleParamBean.getMinute()) &#123; calendar.add(Calendar.MINUTE, orginCalendar.get(Calendar.MINUTE) - scheduleParamBean.getMinute()); &#125; else if (null != scheduleParamBean.getSecond()) &#123; calendar.add(Calendar.SECOND, orginCalendar.get(Calendar.SECOND) - scheduleParamBean.getSecond()); &#125; &#125; &#125; public Date next() &#123; if (null != scheduleParamBean.getWeekOfMonth()) &#123; calendar.add(Calendar.MONTH, 1); &#125; else if (null != scheduleParamBean.getDayOfWeek()) &#123; calendar.add(Calendar.DAY_OF_WEEK, 6); &#125; else if (null != scheduleParamBean.getDayOfMonth()) &#123; calendar.add(Calendar.DAY_OF_MONTH, 1); &#125; else if (null != scheduleParamBean.getHourOfDay()) &#123; calendar.add(Calendar.HOUR_OF_DAY, 1); &#125; else if (null != scheduleParamBean.getMinute()) &#123; calendar.add(Calendar.MINUTE, 1); &#125; else if (null != scheduleParamBean.getSecond()) &#123; calendar.add(Calendar.SECOND, 1); &#125; System.out.println("下次执行时间:" + calendar.getTime()); return calendar.getTime(); &#125;&#125; ScheduleParamBean.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 时间计划参数bean * * @author javacoo * @since 2011-11-04 */public class ScheduleParamBean &#123; /** 每个月的第几周,每周的第几天,每个月的第几天,小时(24小时制),分钟,秒 */ private Integer weekOfMonth, dayOfWeek, dayOfMonth, hourOfDay, minute, second; public ScheduleParamBean() &#123; &#125; public ScheduleParamBean(Integer weekOfMonth, Integer dayOfWeek, Integer dayOfMonth, Integer hourOfDay, Integer minute, Integer second) &#123; super(); this.weekOfMonth = weekOfMonth; this.dayOfWeek = dayOfWeek; this.dayOfMonth = dayOfMonth; this.hourOfDay = hourOfDay; this.minute = minute; this.second = second; &#125; public Integer getWeekOfMonth() &#123; return weekOfMonth; &#125; public void setWeekOfMonth(Integer weekOfMonth) &#123; this.weekOfMonth = weekOfMonth; &#125; public Integer getDayOfWeek() &#123; return dayOfWeek; &#125; public void setDayOfWeek(Integer dayOfWeek) &#123; this.dayOfWeek = dayOfWeek; &#125; public Integer getDayOfMonth() &#123; return dayOfMonth; &#125; public void setDayOfMonth(Integer dayOfMonth) &#123; this.dayOfMonth = dayOfMonth; &#125; public Integer getHourOfDay() &#123; return hourOfDay; &#125; public void setHourOfDay(Integer hourOfDay) &#123; this.hourOfDay = hourOfDay; &#125; public Integer getMinute() &#123; return minute; &#125; public void setMinute(Integer minute) &#123; this.minute = minute; &#125; public Integer getSecond() &#123; return second; &#125; public void setSecond(Integer second) &#123; this.second = second; &#125; @Override public String toString() &#123; return "ScheduleParamBean [dayOfMonth=" + dayOfMonth + ", dayOfWeek=" + dayOfWeek + ", hourOfDay=" + hourOfDay + ", minute=" + minute + ", second=" + second + ", weekOfMonth=" + weekOfMonth + "]"; &#125;&#125; TestSchedule.java 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 测试 * * @author javacoo * @since 2011-11-03 */public class TestSchedule &#123; private final Scheduler scheduler = new Scheduler(); private final ScheduleParamBean scheduleParamBean; public TestSchedule(final ScheduleParamBean scheduleParamBean) &#123; this.scheduleParamBean = scheduleParamBean; &#125; public void start() &#123; scheduler.schedule(new SchedulerTask() &#123; public void run() &#123; execute(); &#125; private void execute() &#123; System.out.println("任务执行"); &#125; &#125;, new SimpleScheduleIterator(scheduleParamBean)); &#125; public static void main(String[] args) &#123; ScheduleParamBean scheduleParamBean = new ScheduleParamBean(); scheduleParamBean.setWeekOfMonth(1); scheduleParamBean.setDayOfWeek(6); scheduleParamBean.setDayOfMonth(4); scheduleParamBean.setHourOfDay(16); scheduleParamBean.setMinute(22); scheduleParamBean.setSecond(0); TestSchedule test = new TestSchedule(scheduleParamBean); test.start(); &#125;&#125; 以下是整合到JEECMS采集器多线程版的代码片段 12345678910111213141516171819202122232425262728293031323334/** * 开始执行采集任务 */ public boolean start(Integer id) &#123; CmsAcquisition acqu = cmsAcquisitionMng.findById(id); if (acqu == null || acqu.getStatus() == CmsAcquisition.START) &#123; return false; &#125; TaskSchedulerManage taskManage = new TaskSchedulerManage(this,acqu); taskManage.start(); return true; &#125; private class TaskSchedulerManage &#123; private final Scheduler scheduler = new Scheduler(); private final MultiThreadAcquisitionSvcImpl multiThreadAcquisitionSvc; private final CmsAcquisition acqu; public TaskSchedulerManage(MultiThreadAcquisitionSvcImpl multiThreadAcquisitionSvc,CmsAcquisition acqu) &#123; this.multiThreadAcquisitionSvc = multiThreadAcquisitionSvc; this.acqu = acqu; &#125; public void start() &#123; scheduler.schedule(new SchedulerTask() &#123; public void run() &#123; processer(); &#125; private void processer() &#123; System.out.println("============开始执行计划任务================="); new Thread(new MainThreadProcesser(multiThreadAcquisitionSvc,acqu)).start(); &#125; &#125;, new SimpleScheduleIterator(new ScheduleParamBean(1,6,4,17,24,30))); &#125; &#125; 注：关键是 ScheduleIterator实现类了，框架有多强大 完全取决于你的ScheduleIterator实现类了。]]></content>
      <categories>
        <category>cms</category>
      </categories>
      <tags>
        <tag>cms</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北方的空地]]></title>
    <url>%2Fblog%2F11881.html</url>
    <content type="text"><![CDATA[第二次穿越大羌塘无人区已过三月，期间不少志同道合者询问事宜，今儿便呈一贴，简叙过往。 此次穿越从青藏高原的西端至高点界山大阪开始，时间4月20日，一路向东经邦达错、羊湖、若拉错、岗扎日，横穿整个藏北无人区后改由北上进入阿尔金无人区，经可可西里山脉、昆仑山脉、鲸鱼湖……在阿奇克库勒湖遇人，再三天车程至花土沟镇，时间七月五号，总历时77天。在离开界山大阪至阿奇克库勒湖的74天里独处无人区，此间行程1400公里左右，跨度四个月。 大羌塘藏语“羌塘”意为北方的空地，狭义指藏北无人区，实则是所有北方未知的土地。大羌塘包含藏北无人区、可可西里无人区、阿尔金无人区、昆仑山无人区，这四个无人区连片在一起，构成了世界上独有的超级无人荒原。由于可可西里的概念被炒热，以至于大家一度用可可西里代替了这片广袤的荒原，实际上，可可西里不论是行政疆域还是地理疆域都只是大羌塘这片土地的一小部分。 大羌塘，他是自由最后追逐之地…… 一、羌塘杨柳松穿越的羌塘位于西藏的北部，藏语的意思是”北方的未知之地”。它的北面是昆仑山脉和可可西里山脉，南面是冈底斯山脉和念青唐古拉山脉，属于高山之间的一块高原盆地。 ……南北最宽760公里，东西长约1200公里。面积59.70万平方公里，占青藏高原总面积的1/4。 行政上属西藏自治区的那曲与阿里两地区管辖。 羌塘高原日照强烈，天气变化无常，风力强劲，十一级大风是家常便饭。冬季极寒缺水，雨季沼泽遍布，是地球上最大的无人区之一。 （图片说明：杨柳松的实际路线） 没有后援，没有补给，与外界断绝联系，几十天不遇人，一个人徒步横穿羌塘，谈何容易。此前，还没有人完成过。 最大困惑有三个方面。一是食物补给，在如此长的天数里完全靠自给确无先例，我到底能承受怎样的饥饿状态？二是体能，在海拔五千米的恶劣环境中超负重推行能坚持多久？三是心理状态，孤身荒原中，面对周而复始的困顿何以应对？ 由于太多天没有消息，杨柳松的朋友都以为他遇难了。2014年，另一个网友沿着这条路线进入羌塘，就失踪了，没有走出来。 二、物资准备1400公里的路程，预计80天左右完成，平均每天推进20公里左右。 我必须达到均速二十公里才有可能完成计划中的旅行。二十公里是理想值，比较安全。但算上大雪封路、地貌巨糟、无端生病、洪水卷地、偷懒睡觉、外星人突访等事件，所以每天行距必须超过二十公里才稳妥。十八公里是危险值，最低均速，底线，咬咬牙能接受。低于十八公里，马克思会很想念我。回顾，在遇人救助前的七十五天独行中，每天均速差那么一点到十八公里，悬而又悬的速度。 20公里看上去并不快，但不要忘记这是在5000米的高原。 有过高原经历的人就知道，每天近二十公里的速度是怎么来的。除了极少的路可小骑过个瘾，其余路况很少能一次推百米不停下喘口气的。硬草地一般推个五十米喘口气，寒漠土二十米喘口气，沙土路十米喘口气，重沙地三五米喘口气，陡坡半个轮圈喘口气。这羌塘就是这么一口口气喘过来的。 既然预计80天，那么就需要准备足够的食物。 此行，食物约有一百斤，其中主食七十七斤，包括五十斤糌粑、二十五斤压缩饼干、二斤麦片，实际使用七十五斤，前期糟蹋了二斤主食。辅食二十五斤，大蒜、酥油、花生米三样就占了一半。其余是少量的盐、紫菜、辣椒粉、茶叶等，以及一点打牙祭的奶粉和白糖。全程无肉，吃过一次蔬菜，微量元素靠金施尔康药片。 这些食物根本不够提供足够的热量和营养，但也没法带更多了。 前四十五天日均摄取热量在一千四百大卡左右，大致四两多糌粑和二点五两压缩饼干，一些汤料为辅。热量摄取水平属于联合国认定的中度饥饿状态，下午四点以后基本就无力了。 为了加热食物和取暖，还需要携带汽油。 此行带了8.6升93号汽油，两个锅，1.5升的大锅主要用于烧水。经过几天实测，烧水需时如下：液体水，早晨要用十六分钟左右烧开，晚上则快些；化冰三十五至四十分钟；化雪耗时最长，四十五至五十分钟。为了节省汽油，所以在雪和轻度盐碱水同存的情况下，我多数会选择后者作为饮用水。汽油同样计划八十天用量，理论上是够了，但实际环境中无法准确计算，它包括化冰雪的次数、高原缺氧对汽油燃烧效率的影响，低温下的散温系数、炉头积碳导致的热量损耗等等。唯一有利因素就是低压环境中水的沸点低，只有80℃左右。因此，汽油使用非常节约，每天就是烧两锅水，早晚各一锅，便是所有生活所需了。 除了这些，其他的物品还有许多。 就拿此行束缚类装备来说，就有六毫米登山辅力绳、四毫米登山辅力绳、一点五毫米魔术贴捆扎带、一米魔术贴捆扎带、二十厘米魔术贴捆扎带、硅胶弹力带、普通松紧绳、红头风筝绳、凯夫拉鱼线、两色缝补线、五号铁丝、二号铁丝、大号长尾夹、小号长尾夹、橡皮筋、别针、小快扣、主锁……所有装备乱七八糟地加起来，到底有多少，我现在也没法记清了。 三、自行车所有行李一共200斤，背是背不动的，必须带上自行车。 从徒步角度看，推行速度确实太低了，一半都达不到。选择自行车作为穿越工具并非为骑，它只是一个驮货工具。四个驮包分别置于前后轮两侧，相机包挂在车头，一个二十五升的骑行包随身背着。后货架上还有一个六十升防水驮包，用弹性松紧绳捆绑，其间夹塞着防潮垫、水袋、拖鞋等。驮包总容量一百八十五升左右，不包括外置的盛水容器、闲杂物品等，所有装备总重二百斤左右。试想，推着一辆二百斤的自行车在海拔五千米的沙地里推行，实在是一件令人沮丧的事情。 大部分路段，自行车没法骑，只能推着走。为了提速，杨柳松用伞做了一个帆，利用风力推动自行车。可惜风太大了，只用了两天，伞就被吹坏了。 为了解决用电问题，他带了太阳能电池。 由于单独采用了一块轻薄的太阳能板给GPS供电，使得GPS高耗电成为历史，七十多天里只因故障换过一次电池，节省了需携带的大量干电池。同时备了一块功率5.4瓦的太阳能板，给7.4伏的相机、DV及其他数码设备供电，路上没缺过电只缺过水。 四、出发原定4月1日进入荒原。这个日期是精心选择的。 太早过于寒冷与干旱，人扛不住，水的问题也没法解决。太晚会推迟进入东羌塘的时间，雨季来临，冻土消融，几乎没有通过的可能性。所以四月初进入荒原是个最折中选择，可以使我吃一个半月的西风和冻土路面，剩下时间则在雨季变得强势前迅速撤离。 但是遇到了许多意外，比如在江孜县丢了一个包，不得不重回拉萨采购装备，导致比预定日期推迟了20天，注定后期遭遇雨季，几乎困死于沼泽。 2010年4月20日，他进入羌塘。 五、无人区羌塘是无人区，地理和气候都不适合人类生存。首先，高海拔对生理产生巨大影响。 在海拔五千米荒原行路，相当于在平原地区背负十五公斤物品。高海拔对身体的伤害，首先是视力衰退，所以把狼看成外星人，不仅只是端不稳望远镜。其次是听力，海拔越高影响越大，不仅听力急剧减弱，连声音方位也难辨别，这也是高海拔登山容易发生事故的原因之一。高海拔对大脑的伤害尤为大，记忆力会明显下降，譬如，刚向你借钱就忘了，真不是我想赖账。甚者，导致严重的思维障碍。 然后，终日大风，风声足以致聋。 风大到只敢以屁股相对。风，也是羌塘唯一的声音。时常一整天，耳畔都是巨大的轰鸣声，即便饿狼贴着后脑勺，大声喊”我想你”，也决然感觉不到半点危机。曾经有位边防战士，独自巡逻两天，被荒原大风吹得失聪。 遇到暴风雪，只能躲在自行车后面。 我猥琐地蜷缩在自行车后面，躲避着狂风冰雹。这是标准姿势，面对恶劣天气，将自行车横风倒下，整个人团成个肉球，趴在隆起的驮包后面。远处看，则脑袋不见，屁股半撅，有如鸵鸟。 ……狂风大作，沙尘滚滚，眼前一片昏黄，视野近无。测量，瞬间最高风速达到了27.8m/s，接近十一级。蜷缩在自行车后面，用一个防雨罩把脑袋完全包住，蓦然，不知什么东西击中了屁股，被人踢了一脚似的。理智思量，不会有人路过，并这么无聊地踢我屁股吧。过了一会儿，屁股又被踢了一下，又一下……后背有点发凉，决定用手摸摸，到底何物。摸到屁股位置有根带子，噼里啪啦地风中乱抽。胡思乱想，难不成恶人不是用脚，而是用鞭子抽我屁股？顺着摸，是车首包的背带。 气候极度寒冷，有时帐篷搭得慢一点就没命了。 搭好帐篷去打水，溪流表面已结了薄冰，破之取水。格外酷寒，水杯捞起转瞬间，杯壁上便结了冰。手冷得不行，几秒钟就冻僵。……羌塘冻死，唯雨季风险最大，因为来不及防范，就可能在一场猛烈的冻雨湿雪中失尽体温。 长时间野外行走，手指和脚趾都会冻伤。 一只手握在车座下的竖管上，使劲地往前拉，这也是手指关节处裂口长达几十天不愈的原因。有几次拉车，感觉不到手指，以为被拉断了。脱下手套看看，还在，继续拉。 遇到大雪，甚至会不知不觉窒息而死。 昨夜，睡得很不踏实，中途迷迷糊糊闷醒多次，胸口如压巨石，喘不过气来。再次被闷醒时，见天亮了，但帐篷上明下黑，难道陷到沼泽里了？用手一推才知被大雪埋了。这是此行遭遇的最大一场雪，深度四十厘米左右，最深处一米。后怕，帐篷被大雪完全封死，内部只有一个小透气窗，半掩着，且冰雪又封了一些。简单计算，夜里帐内氧气含量比珠峰峰顶还低，这还不算体内呼出的二氧化碳的致命影响。半夜闷醒多次，居然浑然不觉大难临头。 六、野生动物荒原里面有很多危险的野生动物，遇到狼是家常便饭。 此次遇狼七次，其中五次是直面。这是指看清脸的，幽魂般闪烁的不配我记录在案。 ……先是一只狼从前方沿着土埂小跑，又觉得眼花，土埂后有一黑物闪烁，果然也是只狼，便盯着隐狼看它去向。隐狼完全现身一会儿后又不见了，再看前狼朝我直奔而来。先是放倒车子，故意和车保持一点距离，是想传达我可不是一个人孤军奋战。这招貌似不管用，如果自行车能弯弯车把，向狼打个招呼就好了。我又扶起车子，用身体靠住，万一时刻还能充当下防弹衣。 有时早上起床，发现帐篷外面都是狼的脚印。 帐篷周边发现了一些兽迹，应该是狼的。脚印从戈壁深处来，围了帐篷一圈，在头部位置零散纷乱，估计在判断我的气息，然后脚印沿着湖岸远去。 其他比较危险的，主要是棕熊和野牦牛。 此次旅行遇熊五次，同样，那些小脸都不让我看清的不配记录在案。 有两次刻骨地与野牦牛对峙的经历，距离之近，仿若能看见牛眼里的红血丝，我脊背上的寒气也足以给一间客厅降温避暑了。 再怎么防备，都难以保证百分之百的安全。 晚上宿营没有过任何防范，觉得实在没有必要，睡在哪里不是睡在黑夜里？白天遇野兽连贴身小刀也没摸过，徒步探路时基本无防范。羌塘真的很大，有什么东西早发现了。如果棕熊、野牦牛之类的真攻击你，恐怕带枪也不行，所以说心态最重要，学会相处比学会打架管用。 比野生动物更危险的，其实是人。荒原遇到人，比遇狼还令人担心。 凡是能进入荒原的人，大半我都惹不起，譬如杀人灭口的盗猎者，见财起意的淘金人，恪尽职守的巡山队…… 七、断水二分之一的路段都缺水，即使有水，也是盐碱水，不喝渴死，喝了毒死。 晚上，唯一的水就是前日为以防万一、灌在保温杯里的碱水。一打开盖子，恶臭扑鼻，捂了几天，水质更恶化了。喝是不喝，是个问题。 整个旅程最危险的时候是第40天，已经连续三天断水，滴水不存。必须在一天内找到水。 找水有几个方向，一是附近可能有水的地方，二是回到两天前的营地，三是标准求生方式—-挖坑蒸水。先排除最后一点，挖坑蒸水对地貌要求极高，我周遭环境至少挖坑半米才能见到湿土。假使挖坑还没把我累死，假使一整天都是艳阳高照，我所得到的水够不够我继续挖下一个坑的力气都不好说。回到两天前的地方，往返八十公里寻水太纠结了，且以当下身体状态，这不是一件靠意志力就能胜任的工作，远水解不了近渴。 他不得不停止行程，专程找水，依然一无所获，只能用尿液解渴。 用尿液伴着饼干，勉强吃了一点，明天还得要有体力继续找水。 眼看即将渴死在这个极旱的盐碱地，所幸第41天早上下雪了。 听见打在帐篷上的沙沙声，以为又是风沙作祟，一整夜都是这样。微明，掀开帐篷一角，地上散落着小雪籽，再看了眼天际，灰云铺顶。不喜不悲，白天下雪很难积蓄，雪落无痕。心中也并无打算今天如何找水，身体透支太多，再难强打精神。也无祈祷，该怎样怎样。再次醒来，掀开帐门，雪越下越大，才清醒些，认为是生机。随后，三两分钟掀帐查看一下雪情，生怕老天赏赐的大礼会长脚溜走。待雪稍有积淀，便赶紧用纸片掠雪盛在锅里，沾上的沙土也舍不得丢弃。 八、雨季六月以后，雨季到来，雪水融化，冻土变成沼泽和湖泊。对于旅行者来说，这时才是真正的噩梦开始。 鞋子早就破了，虽然尽量控制不要灌水，但依然是最煎熬的体感。试想，脚上套着两坨沉重的冰行路是何等苦楚，而这种苦楚将一直伴随我走出荒原。 第57天 原定的南下路线被雪水汇成的大河阻断，走不过去了。 晚上考量许久，何去何从？两天来只推行了十多公里，这沼泽路没法走。眼前又是条大河阻挡，豁命也不是没有过去的可能，但过去之后呢？至少还要横切汇入多格错仁强错的三条大河以及大片湖盆沼泽。 最后决定走回头路，掉头北上，穿越阿尔金无人区求生，因为那里的地势高，不易积水。但是，粮食是肯定不够了，只能寄望于路上遇到人。 从阿尔金出去，这是最后一个选择，没法拒绝。从地理上分析，或许北上是条出路，因为要翻越数道山脉，属山地貌，沼泽大河会少很多。北上的最大障碍是线路太长，食物肯定是不够了，且又是”未知”区域。我的打算是尽量赶到鲸鱼湖，传说，那里有获得补给的可能。 九、弹尽粮绝第55天，蔬菜只剩下最后四瓣大蒜，吃光。 第59天，盐和粮食所剩无几 第64天，吃光了最后一包压缩饼干。 再次清点粮食，只剩下五斤左右糌粑，比乒乓球大小还少的盐，一点茶叶，三两左右酥油，再无其他了。 后面的路，都是冻土融化的沼泽地带。 一陷到膝盖，立马倒地匍匐爬出来。不能往前倒，而是后仰，往前倒，如果沼泽过稠，速度过快会折断小腿，如果沼泽过稀，会一下子把脸给埋住，无法呼吸，错失转身时机。后仰的好处是安全，抽腿也容易。 自行车也惨遭灭顶。 自行车再度陷入沼泽，一脚陷脚踝，二脚陷半小腿，三脚弃车跑人。黏性太大了，再不撤来不及了。随后试着拖车，地越踩越烂，地下水都踩了出来，最后连自行车的边都摸不上了。都考虑弃车了，但装备总得要弄出来。用那十块钱的救生膜和两个防雨罩铺在烂泥上，人趴在上面，一番折腾，好歹把驮包给弄了出来。再看垫脚物早没影了，光救生膜铺开可就两平方米。再一会儿，放驮包的地方也无法立足了。也就是说，即便很硬实的地，多踩上几脚，也变成了沼泽嘴脸。转移驮包后，思量着怎么把自行车弄出来，现在弃车毕竟很不理智。用铁丝套上绳子圈在自行车上，拉拽，车子勉强移动一点，再用力，居然把后轮生生地拽掉了，最终和沼泽打了个平手。 第73天，丢弃自行车，徒步逃生。为了减轻负重，把望远镜和水袋也扔了。 第75天，只剩最后一口粮食。幸运的是，在这一天遇见了探矿者。 第77天，走出荒原。 十、动机很多人都有这样的问题：他究竟为什么要进入荒原，如此危险，难道只是为了探险吗？ 杨柳松这样解释，对于城市生活，他始终不太适应。 身体每天都被什么东西紧紧束缚似的，那种感觉就像每天衣服都小一号，每天都必须换上大一号衣服，身体才会舒畅。 每年春天，只要在西藏，他都要去雅鲁藏布江大峡谷看桃花。最喜欢的是下面这样的景色。 最喜孤立的某处，一树粉红桃花与世无争地怒放。 三年前，他第一次见到荒原，就下决心要深入这片土地。这个刹那的闪念，让他长久酝酿，一定要付诸行动。荒原更适合那一颗自由自在的心。 始终没有逃离荒原的心，这样一片神奇土地，怎舍得轻易离去。只要不是毫无生机的绝境，在我的意识里，荒原彼端将是没有尽头的远方。远方，依然是那永远也到达不了的地方。 旅途中，每一次艰难时刻，选择继续前进还是放弃，他都选择前进，始终没有放弃。 事实上，选择北上的真正原因，是自己还没玩够。如果，世界上再无有意思的事，为之无条件追求的事，那活着多没趣。如果真得撑不住了，我就南下徒步逃命去了，三四天时间就可找到牧民，终结这痛苦的旅程。甚至，过河办法都想好了，就是抱着那空油桶，漂啊漂过河，像八仙成员之一似的。 那是一种从骨头里，对喧嚣的平庸生活的厌倦。 这是一个浮躁的时代，很拥挤，很冷漠，不管你愿不愿意，都必须随流而动，因此旅行成了一部分人变相的逃离，而非遵循内心的渴望。就我而言，为何旅行，同样没有一个靠谱的答案，热爱是最接近的答案，去追寻荒野的旷寂。 人生就像没有尽头的荒原，如果不找到一点乐趣，如何坚持着走完？ 人生就是一场漫无目的的旅行，之所以茫然，是因生与死限定了旅行的终与结。有些人乐此不疲地怀揣梦想继续前行，没有目标，没有问题，只是收获一路感受。 他写道，自己很享受在荒野中看云。 困守的唯一好处，就是有足够时间凝视一朵云的万般变化，生成，绚烂，湮灭。 人生难道不是这样吗？我们都是飘荡在天空中的云，匆匆涌起，转眼消散得无影无踪，那么为什么不索性飘荡得远一点呢？ 十一、未来许多友人问，走出荒原是什么感觉？ 事实上，走出荒原没有想象的幸福感，或是什么成就感，甚至是一种轻度的抑郁和迷茫。巨大的幸福并未如期而至，偶尔的幸福也是短暂。生命是一条贯通的河流，一切皆是没有开始的复始。我们所期望的终点并不存在。 如果我拥有足够的热情，如果这片荒原对我有足够的诱惑，那我就继续往前。如果激情退却，诱惑不再，我就哪来哪回。如果激情与诱惑从未真实存在，所有问题也就不是问题了。暮色中，面对荒原，我必须做出抉择，明日之路是前行，还是后退。这个抉择其实从未存在，只是一个矫情的过程，从心底深处再次认识到自己究竟在做些什么。 虽然，路的尽头什么也没有，但不能因此停止步履，因为你就是路本身。 （完）]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring任务调度之Spring-Task]]></title>
    <url>%2Fblog%2F19157.html</url>
    <content type="text"><![CDATA[在工作中有用到spring task作为定时任务的处理，spring通过接口TaskExecutor和TaskScheduler这两个接口的方式为异步定时任务提供了一种抽象。这就意味着spring容许你使用其他的定时任务框架，当然spring自身也提供了一种定时任务的实现：spring task。spring task支持线程池，可以高效处理许多不同的定时任务。同时，spring还支持使用Java自带的Timer定时器和Quartz定时框架。限于篇幅，这里将只介绍spring task的使用。 其实，官方文档已经介绍地足够详细，只不过都是英文版，所以为了更好地理解并使用spring task，首先会对spring task的实现原理做一个简单的介绍，然后通过实际代码演示spring task是如何使用的。这里会涉及到一个很重要的知识点：cron表达式。 TaskExecutor和TaskSchedulerTaskExecutor是spring task的第一个抽象，它很自然让人联想到jdk中concurrent包下的Executor，实际上TaskExecutor就是为区别于Executor才引入的，而引入TaskExecutor的目的就是为定时任务的执行提供线程池的支持，那么，问题来了，为什么spring不直接使用jdk自带的Executor呢？TaskExecutor源码如下？ 123public interface TaskExecutor extends Executor &#123; void execute(Runnable var1);&#125; 那么，答案很显然，TaskExecutor提供的线程池支持也是基于jdk自带的Executor的。用法于Executor没有什么不同。 TaskScheduler是spring task的第二个抽象，那么从字面的意义看，TaskScheduler就是为了提供定时任务的支持咯。TaskScheduler需要传入一个Runnable的任务做为参数，并指定需要周期执行的时间或者触发器，这样Runnable任务就可以周期性执行了。传入时间很好理解，有意思的是传入一个触发器（Trigger）的情况，因为这里需要使用cron表达式去触发一个定时任务，所以有必要先了解下cron表达式的使用。 在spring 4.x中已经不支持7个参数的cronin表达式了，要求必须是6个参数（具体哪个参数后面会说）。cron表达式的格式如下： 1&#123;秒&#125; &#123;分&#125; &#123;时&#125; &#123;日期（具体哪天）&#125; &#123;月&#125; &#123;星期&#125; 秒：必填项，允许的值范围是0-59，支持的特殊符号包括, - /，,表示特定的某一秒才会触发任务，-表示一段时间内会触发任务，表示每一秒都会触发，/表示从哪一个时刻开始，每隔多长时间触发一次任务。分：必填项，允许的值范围是0-59，支持的特殊符号和秒一样，含义类推时：必填项，允许的值范围是0-23，支持的特殊符号和秒一样，含义类推日期：必填项，允许的值范围是1-31，支持的特殊符号相比秒多了?，表示与{星期}互斥，即意味着若明确指定{星期}触发，则表示{日期}无意义，以免引起冲突和混乱。月：必填项，允许的值范围是1-12（JAN-DEC），支持的特殊符号与秒一样，含义类推星期：必填项，允许值范围是1~7 (SUN-SAT),1代表星期天（一星期的第一天），以此类推，7代表星期六，支持的符号相比秒多了?，表达的含义是与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义。比如下面这个cron表达式： 12// 表达的含义是：每半分钟触发一次任务30 * * * * ? spring提供了一个CronTrigger，通过传入一个Runnable任务和CronTrigger，就可以使用cron表达式去指定定时任务了，是不是非常方面。实际上，在工程实践上，cron表达式也是使用很多的。实际上，是执行了下面的代码： 1scheduler.schedule(task, new CronTrigger(&quot;30 * * * * ?&quot;)); TaskScheduler抽象的好处是让需要执行定时任务的代码不需要指定特定的定时框架（比如Timer和Quartz）。TaskScheduler的更简单的实现是ThreadPoolTaskScheduler,它实际上代理一个jdk中的SchedulingTaskExecutor，并且也实现了TaskExecutor接口，所以需要经常执行定时任务的场景可以使用这个实现（Spring推荐）。我们再来看一下TaskExecutor和TaskScheduler的类继承关系：spring-task 通常而言，使用spring task实现定时任务有两种方式：注解和xml配置文件。这里使用xml配置文件的方式加以说明。 实战创建Maven工程，pom.xml:1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.rhwayfun&lt;/groupId&gt; &lt;artifactId&gt;sring-task-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 开发需要执行定时任务的方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.rhwayfun.task;import org.springframework.stereotype.Component;import java.time.LocalDateTime;/** * @author ZhongCB * @date 2016年09月10日 14:30 * @description */@Componentpublic class App &#123; public void execute1()&#123; System.out.printf("Task: %s, Current time: %s\n", 1, LocalDateTime.now()); &#125; public void execute2()&#123; System.out.printf("Task: %s, Current time: %s\n", 2, LocalDateTime.now()); &#125; public void execute3()&#123; System.out.printf("Task: %s, Current time: %s\n", 3, LocalDateTime.now()); &#125; public void execute4()&#123; System.out.printf("Task: %s, Current time: %s\n", 4, LocalDateTime.now()); &#125; public void execute5()&#123; System.out.printf("Task: %s, Current time: %s\n", 5, LocalDateTime.now()); &#125; public void execute6()&#123; System.out.printf("Task: %s, Current time: %s\n", 6, LocalDateTime.now()); &#125; public void execute7()&#123; System.out.printf("Task: %s, Current time: %s\n", 7, LocalDateTime.now()); &#125; public void execute8()&#123; System.out.printf("Task: %s, Current time: %s\n", 8, LocalDateTime.now()); &#125; public void execute9()&#123; System.out.printf("Task: %s, Current time: %s\n", 9, LocalDateTime.now()); &#125; public void execute10()&#123; System.out.printf("Task: %s, Current time: %s\n", 10, LocalDateTime.now()); &#125; public void execute11()&#123; System.out.printf("Task: %s, Current time: %s\n", 11, LocalDateTime.now()); &#125;&#125; spring配置文件如下：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.1.xsd"&gt; &lt;!-- 配置注解扫描 --&gt; &lt;context:component-scan base-package="com.rhwayfun.task"/&gt; &lt;task:scheduler id="taskScheduler" pool-size="100" /&gt; &lt;task:scheduled-tasks scheduler="taskScheduler"&gt; &lt;!-- 每半分钟触发任务 --&gt; &lt;task:scheduled ref="app" method="execute1" cron="30 * * * * ?"/&gt; &lt;!-- 每小时的10分30秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute2" cron="30 10 * * * ?"/&gt; &lt;!-- 每天1点10分30秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute3" cron="30 10 1 * * ?"/&gt; &lt;!-- 每月20号的1点10分30秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute4" cron="30 10 1 20 * ?"/&gt; &lt;!-- 每年10月20号的1点10分30秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute5" cron="30 10 1 20 10 ?"/&gt; &lt;!-- 每15秒、30秒、45秒时触发任务 --&gt; &lt;task:scheduled ref="app" method="execute6" cron="15,30,45 * * * * ?"/&gt; &lt;!-- 15秒到45秒每隔1秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute7" cron="15-45 * * * * ?"/&gt; &lt;!-- 每分钟的每15秒时任务任务，每隔5秒触发一次 --&gt; &lt;task:scheduled ref="app" method="execute8" cron="15/5 * * * * ?"/&gt; &lt;!-- 每分钟的15到30秒之间开始触发，每隔5秒触发一次 --&gt; &lt;task:scheduled ref="app" method="execute9" cron="15-30/5 * * * * ?"/&gt; &lt;!-- 每小时的0分0秒开始触发，每隔3分钟触发一次 --&gt; &lt;task:scheduled ref="app" method="execute10" cron="0 0/3 * * * ?"/&gt; &lt;!-- 星期一到星期五的10点15分0秒触发任务 --&gt; &lt;task:scheduled ref="app" method="execute11" cron="0 15 10 ? * MON-FRI"/&gt; &lt;/task:scheduled-tasks&gt;&lt;/beans&gt; 编写测试代码：12345678910111213141516package com.rhwayfun.task;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author ZhongCB * @date 2016年09月10日 14:55 * @description */public class AppTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("classpath:/app-context-task.xml"); &#125;&#125; 运行测试代码，控制台会定时输出每个定时任务的日志信息，说明测试通过。 小插曲由于项目使用jdk 1.8进行开发，所以初始的时候每次pom文件发生修改，编译器的版本又变成了jdk 1.5，后面发现需要在pom文件中添加build便签那部分才能将默认的编译器进行修改。也算一个小收获了。 附：前一段时间，在工作中要使用定时器功能1、首先web.xml中配置123456&lt;!-- 配置spring核心servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 2、开 启定时启开 关在spring-servlet.xml 中开启 12345678910111213141516171819202122232425&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:task="http://www.springframework.org/schema/task" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd"&gt; &lt;task:annotation-driven /&gt; &lt;!-- 定时器开关 --&gt; &lt;!-- 自动扫描的包名 --&gt; &lt;context:component-scan base-package="com.zxl78585.springtask.task" /&gt; &lt;bean id="myTask" class="com.zxl78585.springtask.task.MyTask"&gt;&lt;/bean&gt; &lt;task:scheduled-tasks&gt; &lt;!-- 这里表示的是每隔五秒执行一次 --&gt; &lt;task:scheduled ref="myTask" method="show" cron="*/10 * * * * ?" /&gt; &lt;/task:scheduled-tasks&gt; &lt;/beans&gt; 3、写自己的定时器123456public class MyTask &#123; public void show()&#123; System.out.println(new Date().getTime()); &#125;&#125; 需要注意的几点： 1、spring的@Scheduled注解 需要写在实现上、 2、 定时器的任务方法不能有返回值（如果有返回值，spring初始化的时候会告诉你有个错误、需要设定一个proxytargetclass的某个值为true、具体就去百度google吧） 3、实现类上要有组件的注解@Component 剩下的就是corn表达式了、具体使用以及参数请百度google、 下面只例出几个式子 123456789101112CRON表达式 含义 &quot;0 0 12 * * ?&quot; 每天中午十二点触发 &quot;0 15 10 ? * *&quot; 每天早上10：15触发 &quot;0 15 10 * * ?&quot; 每天早上10：15触发 &quot;0 15 10 * * ? *&quot; 每天早上10：15触发 &quot;0 15 10 * * ? 2005&quot; 2005年的每天早上10：15触发 &quot;0 * 14 * * ?&quot; 每天从下午2点开始到2点59分每分钟一次触发 &quot;0 0/5 14 * * ?&quot; 每天从下午2点开始到2：55分结束每5分钟一次触发 &quot;0 0/5 14,18 * * ?&quot; 每天的下午2点至2：55和6点至6点55分两个时间段内每5分钟一次触发 &quot;0 0-5 14 * * ?&quot; 每天14:00至14:05每分钟一次触发 &quot;0 10,44 14 ? 3 WED&quot; 三月的每周三的14：10和14：44触发 &quot;0 15 10 ? * MON-FRI&quot; 每个周一、周二、周三、周四、周五的10：15触发]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOA组件模型和系统间数据传输]]></title>
    <url>%2Fblog%2F9382.html</url>
    <content type="text"><![CDATA[面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。SOA，即service-oriented architecture，面向服务架构。 是一种面向通用集成服务的、松耦合的架构实现方式，是web时代服务发展的产物； 使用”分层”理念，比传统的”观察者”模式更高级且更有优势，主要体现在易扩展性和可灾； 适用于大型复杂业务系统的数据共享。 其中的服务平台可以用不同语言实现，比如php,python,java等，比较通用的是RESTFUL接口模式，对于user端，只需明确接口定义，既可以使用HTTP/HTTPS进行通讯，理论上是无限量的。 SOA对于客户端来说极大的简化了开发周期。对于一个特殊需求的出现不会措手不及，更不会大动干戈重构底层，开发者不需要知道具体底层原理即可快速开发实现功能。 SOA定义 它是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。 这种具有中立的接口定义(没有强制绑定到特定的实现上)的特征称为服务之间的松耦合。松耦合系统的好处有两点，一点是它的灵活性，另一点是，当组成整个应用程序的每个服务的内部结构和实现逐渐地发生改变时，它能够继续存在。而另一方面，紧耦合意味着应用程序的不同组件之间的接口与其功能和结构是紧密相连的，因而当需要对部分或整个应用程序进行某种形式的更改时，它们就显得非常脆弱。 对松耦合的系统的需要来源于业务应用程序需要根据业务的需要变得更加灵活，以适应不断变化的环境，比如经常改变的政策、业务级别、业务重点、合作伙伴关系、行业地位以及其他与业务有关的因素，这些因素甚至会影响业务的性质。我们称能够灵活地适应环境变化的业务为按需(On demand)业务，在按需业务中，一旦需要，就可以对完成或执行任务的方式进行必要的更改。 SOA是传统的面向对象架构模型的替代模型，面向对象的模型是紧耦合的，已经存在二十多年了。虽然基于 SOA 的系统并不排除使用面向对象的设计来构建单个服务，但是其整体设计却是面向服务的。由于它考虑到了系统内的对象，所以虽然 SOA 是基于对象的，但是作为一个整体，它却不是面向对象的。不同之处在于接口本身。SOA 系统原型的一个典型例子是通用对象请求代理体系结构(Common Object Request Broker Architecture，CORBA)，它已经出现很长时间了，其定义的概念与 SOA 相似。 然而，现在的 SOA 已经有所不同了，因为它依赖于一些更新的进展，这些进展是以可扩展标记语言(eXtensible Markup Language，XML)为基础的。通过使用基于 XML 的语言(称为 Web 服务描述语言(Web Services Definition Language，WSDL))来描述接口，服务已经转到更动态且更灵活的接口系统中，非以前 CORBA 中的接口描述语言(Interface Definition Language，IDL)可比了。 Web 服务并不是实现 SOA 的惟一方式。前面刚讲的 CORBA 是另一种方式，这样就有了面向消息的中间件(Message-Oriented Middleware)系统。但是为了建立体系结构模型，您所需要的并不只是服务描述。您需要定义整个应用程序如何在服务之间执行其工作流。您尤其需要找到业务的操作和业务中所使用的软件的操作之间的转换点。因此，SOA 应该能够将业务的商业流程与它们的技术流程联系起来，并且映射这两者之间的关系。例如，给供应商付款的操作是商业流程，而更新您的零件数据库，以包括进新供应的货物却是技术流程。因而，工作流还可以在 SOA 的设计中扮演重要的角色。 此外，动态业务的工作流不仅可以包括部门之间的操作，甚至还可以包括与不为您控制的外部合作伙伴进行的操作。因此，为了提高效率，您需要定义应该如何得知服务之间的关系的策略，这种策略常常采用服务级协定和操作策略的形式。 最后，所有这些都必须处于一个信任和可靠的环境之中，以同预期的一样根据约定的条款来执行流程。因此，安全、信任和可靠的消息传递应该在任何 SOA 中都起着重要的作用。 SOA用途 对 SOA 的需要来源于需要使业务 IT 系统变得更加灵活，以适应业务中的改变。通过允许强定义的关系和依然灵活的特定实现，IT 系统既可以利用现有系统的功能，又可以准备在以后做一些改变来满足它们之间交互的需要。 改变和 SOA 系统适应改变的能力是最重要的部分。对于开发人员来说，这样的改变无论是在他们工作的范围之内还是在他们工作的范围之外都有可能发生，这取决于是否有改变需要知道接口是如何定义的以及它们相互之间如何进行交互。与开发人员不同的是，架构师的作用就是引起对 SOA 模型大的改变。这种分工，就是让开发人员集中精力于创建作为服务定义的功能单元，而让架构师和建模人员集中精力于如何将这些单元适当地组织在一起。 SOA技术SOA 本身是应该如何将软件组织在一起的抽象概念。它依赖于用 XML 和 Web 服务实现并以软件的形式存在的更加具体的观念和技术。此外，它还需要安全性、策略管理、可靠消息传递以及会计系统的支持，从而有效地工作。您还可以通过分布式事务处理和分布式软件状态管理来进一步地改善它。 SOA 服务和 Web 服务之间的区别在于设计。SOA 概念并没有确切地定义服务具体如何交互，而仅仅定义了服务如何相互理解以及如何交互。其中的区别也就是定义如何执行流程的战略与如何执行流程的战术之间的区别。而另一方面，Web 服务在需要交互的服务之间如何传递消息有具体的指导原则;从战术上实现 SOA 模型是通过 HTTP 传递的 SOAP 消息中最常见的 SOA 模型。因而，从本质上讲，Web 服务是实现 SOA 的具体方式之一。 尽管我们觉得 Web 服务是实现 SOA 的最好方式，但是 SOA 并不局限于 Web 服务。其他使用 WSDL 直接实现服务接口并且通过 XML 消息进行通信的协议也可以包括在 SOA 之中。正如在别处指出的，CORBA 和 IBM 的 MQ 系统通过使用能够处理 WSDL 的新特征也可以参与到 SOA 中来。如果两个服务需要交换数据，那么它们还会需要使用相同的消息传递协议，但是数据接口允许相同的信息交换。 既为了建立所有这些信息的适当控制，又为了应用安全性、策略、可靠性以及会计方面的要求，在 SOA 体系结构的框架中加入了一个新的软件对象。这个对象就是企业服务总线(Enterprise Service Bus，ESB)，它使用许多可能的消息传递协议来负责适当的控制、流甚至还可能是服务之间所有消息的传输。虽然 ESB 并不是绝对必需的，但它却是在 SOA 中正确管理您的业务流程至关重要的组件。ESB 本身可以是单个引擎，甚至还可以是由许多同级和下级 ESB 组成的分布式系统，这些 ESB 一起工作，以保持 SOA 系统的运行。在概念上，它是从早期比如消息队列和分布式事务计算这些计算机科学概念所建立的存储转发机制发展而来的。 SOA 可以与许多其他技术结合在一起使用，然而，组件的封装和聚合在其中扮演着重要的角色。如前所述，SOA 可以是一个简单对象、复杂对象、对象的集合、包含许多对象的流程、包含其他流程的流程，甚至还可以是输出单一结果的应用程序的整体集合。在服务之外，它可以看作是单个实体，但是在其自身中，它可以具有任何级别的复杂性(如果必要的话)。出于性能方面的考虑，大多数 SOA 服务并没有下降到单一对象的粒度，并且更适合于大中型组件。 除了可能离不开 XML 和 WSDL 之外，SOA 并不是特定于语言的。可以用任何编程语言来实现服务，只要这种编程语言可以生成服务并且可以与 WSDL 结合在一起使用就可以了。SOAP 本身并不是绝对需要的，但它是通用的消息传递系统。因此，可以使用几乎任何一种编程语言和支持 WSDL 的平台来实现 SOA 中的成员服务。 SOA 和 Web 服务是独立于编程语言的，但 Java 是主要的开发语言之一。可以使用定义良好的 Java 接口以及各种协议丰富的 Java 实现为正在构建这个模型的开发人员提供了优势。Java 在此担当了开发每个服务的功能、管理数据对象和与其他在逻辑上封装在服务内的对象进行交互的角色。 SOA 与 Web 的另一个重要的关系是自主计算和网格计算的概念。自主计算的概念应用于管理分布式服务体系结构的范围，具体来说，就是帮助维护策略和服务级协议以及 SOA 系统的总稳定性。 另外，网格计算可以以两个级别与 SOA 系统一起使用。网格是分布式计算的一种形式，它利用分布式特性和服务之间的交互来为 SOA 应用程序提供计算支持。在这种情况下，网格起到了框架的作用，其中实现了一些或所有单独的服务。因此，SOA 应用程序可以是网格服务的消费者。 在另一方面，网格本身也可以构建在 SOA 之上。在这种情况下，每个操作系统服务都是构成整个 SOA 应用程序的成员，而 SOA 应用程序就是网格本身。因此，单独的网格组件既可以使用 Web 服务进行通信，又可以以 SOA 的方式进行交互。总而言之，网格系统可以是 SOA 本身，也可以提供服务来在其上构建应用程序级 SOA 模型。 随着近年来SOA（面向服务技术架构）的兴起，越来越多的应用系统开始进行分布式的设计和部署。系统由原来单一的技术架构变成面向服务的多系统架构。原来在一个系统之间可以完成的业务流程，通过多系统的之间多次交互来实现。这里不打算介绍如何进行SOA架构的设计，而是介绍一下应用系统之间如何进行数据的传输。 应用系统之间数据传输有三个要素：传输方式，传输协议，数据格式 数据传输方式一般无非是以下几种： socket方式Socket方式是最简单的交互方式。是典型才c/s 交互模式。一台客户机，一台服务器。服务器提供服务，通过ip地址和端口进行服务访问。而客户机通过连接服务器指定的端口进行消息交互。其中传输协议可以是tcp/UDP 协议。而服务器和约定了请求报文格式和响应报文格式。如图一所示： 目前我们常用的http调用，java远程调用，webserivces 都是采用的这种方式，只不过不同的就是传输协议以及报文格式。 这种方式的优点是： 易于编程，目前java提供了多种框架，屏蔽了底层通信细节以及数据传输转换细节。 容易控制权限。通过传输层协议https，加密传输的数据，使得安全性提高 通用性比较强，无论客户端是.net架构，java，python 都是可以的。尤其是webservice规范，使得服务变得通用 而这种方式的缺点是： 服务器和客户端必须同时工作，当服务器端不可用的时候，整个数据交互是不可进行。 当传输数据量比较大的时候，严重占用网络带宽，可能导致连接超时。使得在数据量交互的时候，服务变的很不可靠。 2.ftp/文件共享服务器ftp/文件共享服务器方式对于大数据量的交互，采用这种文件的交互方式最适合不过了。系统A和系统B约定文件服务器地址，文件命名规则,文件内容格式等内容，通过上传文件到文件服务器进行数据交互。 最典型的应用场景是批量处理数据：例如系统A把今天12点之前把要处理的数据生成到一个文件，系统B第二天凌晨1点进行处理，处理完成之后，把处理结果生成到一个文件，系统A 12点在进行结果处理。这种状况经常发生在A是事物处理型系统，对响应要求比较高，不适合做数据分析型的工作，而系统B是后台系统，对处理能力要求比较高，适合做批量任务系统。 以上只是说明通过文件方式的数据交互，实际情况B完成任务之后，可能通过socket的方式通知A，不一定是通过文件方式。 这种方式的优点： 在数据量大的情况下，可以通过文件传输，不会超时，不占用网络带宽。 方案简单，避免了网络传输，网络协议相关的概念。这种方式的缺点： 不太适合做实时类的业务 必须有共同的文件服务器，文件服务器这里面存在风险。因为文件可能被篡改，删除，或者存在泄密等。 必须约定文件数据的格式，当改变文件格式的时候，需要各个系统都同步做修改。 3. 数据库共享数据方式系统A和系统B通过连接同一个数据库服务器的同一张表进行数据交换。当系统A请求系统B处理数据的时候，系统A Insert一条数据，系统B select 系统A插入的数据进行处理。 这种方式的优点是 相比文件方式传输来说，因为使用的同一个数据库，交互更加简单。 由于数据库提供相当做的操作，比如更新，回滚等。交互方式比较灵活,而且通过数据库的事务机制，可以做成可靠性的数据交换。这种方式的缺点： 当连接B的系统越来越多的时候，由于数据库的连接池是有限的，导致每个系统分配到的连接不会很多，当系统越来越多的时候，可能导致无可用的数据库连接 一般情况，来自两个不同公司的系统，不太会开放自己的数据库给对方连接，因为这样会有安全性影响 4. message方式Java消息服务（Java Message Service）是message数据传输的典型的实现方式。系统A和系统B通过一个消息服务器进行数据交换。系统A发送消息到消息服务器，如果系统B订阅系统A发送过来的消息，消息服务器会消息推送给B。双方约定消息格式即可。目前市场上有很多开源的jms消息中间件，比如 ActiveMQ, OpenJMS 。 这种方式的优点 由于jms定义了规范，有很多的开源的消息中间件可以选择，而且比较通用。接入起来相对也比较简单 通过消息方式比较灵活，可以采取同步，异步，可靠性的消息处理，消息中间件也可以独立出来部署。 这种方式的缺点 学习jms相关的基础知识，消息中间件的具体配置，以及实现的细节对于开发人员来说还是有一点学习成本的 在大数据量的情况下，消息可能会产生积压，导致消息延迟，消息丢失，甚至消息中间件崩溃。 下面具体来分析一个场景，来看看系统之间数据传输的应用场景 目前业务人员需要导入一个大文件到系统A，系统A保存文件信息，而文件里面的明细信息需要导入到系统B进行分析，当系统B分析完成之后，需要把分析结果通知系统A。A 系统A先保存文件到文件服务器。B 系统A 通过webservice 调用系统B提供的服务器，把需要处理的文件名发送到系统B。由于文件很大，需要处理很长时间，所以B不及时处理文件，而是保存需要处理的文件名到数据库，通过后台定时调度机制去处理。所以B接收请求成功，立刻返回系统A成功。C 系统B定时查询数据库记录，通过记录查找文件路径，找到文件进行处理。这个过程很长。D 系统B处理完成之后发送消息给系统A，告知系统A文件处理完成。E 系统A 接收到系统B请求来的消息，进行展示任务结果 4种系统间交互方法比较 附录 MVC、RPC、SOA框架单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SOA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码去除编号小技巧]]></title>
    <url>%2Fblog%2F58012.html</url>
    <content type="text"><![CDATA[从网上或者哪里拷贝下来的代码前面总有编号，如何去掉呢，网上有说用程序的太麻烦，于是，我找到了下面两种方法，share 一下~1.使用正则表达式：在editorplus（notepad++）里按ctrl+h，弹出框里勾选上“正则表达式（regular expression）”，然后第一个框里写 ^[0-9]*.第二个框里敲一个空格 2.这个是notepad++特有的，而editorplus没有的将代码拷进去，按住ctrl+alt的同时，按住鼠标左键不放，将需要的代码部分截取出来，复制、黏贴即可]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse部署Web项目到tomcat根路径下]]></title>
    <url>%2Fblog%2F50748.html</url>
    <content type="text"><![CDATA[Step1：项目右键-&gt;属性-&gt;web project settings修改程序的Properties下的Web Project Settings将Context root 例如 “/WebSample”修改为“/”。 Step2: 修改services-&gt;modules-&gt;edit-&gt;path 修改path为“/”。 重启tomcat即可。]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMS源码解读]]></title>
    <url>%2Fblog%2F63673.html</url>
    <content type="text"><![CDATA[CMS是”Content Management System”的缩写，意为”内容管理系统”。 内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场。对于内容管理，业界还没有一个统一的定义，不同的机构有不同的理解。· 基于java技术开发，继承其强大、稳定、安全、高效、跨平台等多方面的优点· 采用SpringMVC3+Spring3+Hibernate3+Freemarker主流技术架构· 懂html就能建站，提供最便利、合理的使用方式· 强大、灵活的标签，用户自定义显示内容和显示方式· 在设计上自身预先做了搜索引擎优化,增强对搜索引擎的友好性· 完全生成全站静态页面,可自定义路径结构，全面提高页面访问速度· 轻松建设大规模网站，可通过次级域名建立子站群，各子站后台管理权限分离，全站实现单点登录 jeeCms源码安装时出现的问题及解决装MySQL数据库装不上因为以前本机上装过MySQL,而在卸载时有文件残留，故MySQL会安装失败，失败的表现有两种：一个是安装时未响应，一个是未弹出配置MySQL的界面。 解决办法： 你可以安装MySQL的时候在这一步时它默认的服务名是“MySQL” 只需要把这个名字改了就可以了。 ​ 卸载MySQL 删除安装目录及数据存放目录 在注册表(regedit)查询mysql，全部删除 在c盘查询MySQL，全部删除 重新安装就好了 注意的是注册表 cmd -&gt; regedit，删除以下目录下的MySQL目录 HKEY_LOCAL_MACHINE\SYSTEM\\Eventlog\Application\MySQL 目录 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL 目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL\www.xuanzequan.com\目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControl001t\Services\MYSQL 目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControl002\Services\MYSQL 目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MYSQL 目录 删除C:\Documents and Settings\All Users\Application Data\MySQL 目录 数据库连接不上的问题错误提示： An attempt by a client to checkout a Connection has timed out. 原因： 配置文件中目标数据库的名字错误 （区分大小写） 配置文件中的目标数据库用户名和密码错误。 缺少数据库的驱动jar包（如mysql-connector-5.1.8.jar 包）。缺这个包的原因是在解瘊MySQL连接不上的问题时，会在C盘中查找所有“mysql”的文件。而你的jeeCms源码包正好又放在桌面上，于是你会把所有带mySQL的文件删除，进而误删了源码包中的mySQL连接包（mysql-connector-5.1.8.jar）。当你在把页面上的源码包放到项目中时就少了这个包，故连接不上。 解决办法：删除除mysql安装残留信息时一定要谨慎再谨慎src包中报错的问题：错误提示：所有带HttpServletRequest或HttpServletResponse的类全部显示错误 原因：没有找到servlet包。因为你安装源码包时，没有配置tomcat环境。解决办法：安装源码包时，先在eclipse中配置tomcat环境，再建动态web项目，然后再在web项目中覆盖src和webContent文件夹。 源码解析之一 (web.xml)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app id="WebApp_ID" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;display-name&gt;JeeCmsV7&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- 数据库相关配置并加载了hbm.xml文件 --&gt; /WEB-INF/config/application-context.xml &lt;!-- 数据缓存相关配置 --&gt; /WEB-INF/config/cache-context.xml &lt;!-- 验证码相关配置 --&gt; /WEB-INF/config/captcha-context.xml &lt;!-- 图片，密码，文件上传等配置 --&gt; /WEB-INF/config/jeecms/jeecore-context.xml &lt;!-- spring bean相关配置，如dao层的配置、图片处理，密码加密 --&gt; /WEB-INF/config/jeecms/jeecms-context.xml &lt;!-- 配置权限管理shiro-context.xml框架 --&gt; /WEB-INF/config/shiro-context.xml &lt;!-- 配置其它插件文件，暂时没有 --&gt; /WEB-INF/config/plug/**/*-context.xml &lt;!-- 配置定时任务 --&gt; /WEB-INF/config/quartz-task.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 打印执行时间与访问路径过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;filter-class&gt;com.jeecms.common.web.ProcessTimeFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 编码设置 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 解决Hibernate session延迟加载的问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate3.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--@分隔--&gt; &lt;filter&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.jeecms.common.web.XssFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;excludeUrls&lt;/param-name&gt; &lt;param-value&gt;/member/contribute@/jeeadmin/jeecms@/flow_statistic&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;SplitChar&lt;/param-name&gt; &lt;param-value&gt;@&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;FilterChar&lt;/param-name&gt; &lt;param-value&gt;'@"@\@#@:@%@&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ReplaceChar&lt;/param-name&gt; &lt;param-value&gt;‘@“@＼@＃@：@％@＞&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 后台控制 DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点， 而且负责职责的分派，而且与Spring IoC容器无缝集成，从而可以获得Spring的所有好处 DispatcherServlet主要用作职责调度工作，本身主要用于控制流程，主要职责如下： 1、文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析； 2、通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）； 3、通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)； 4、通过ViewResolver解析逻辑视图名到具体视图实现； 5、本地化解析； 6、渲染具体的视图等； 7、如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;JeeCmsAdmin&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/config/jeecms-servlet-admin.xml /WEB-INF/config/plug/**/*-servlet-admin-action.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 前台控制 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/config/jeecms-servlet-front.xml /WEB-INF/config/plug/**/*-servlet-front-action.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;Jcaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeecms.common.captcha.JcaptchaServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 验证码图片 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Jcaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/captcha.svl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DbFile&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeecms.core.action.front.DbFileServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;SnapScreen&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jeecms.core.action.front.SnapScreenServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SnapScreen&lt;/servlet-name&gt; &lt;url-pattern&gt;/snapscreen.svl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsAdmin&lt;/servlet-name&gt; &lt;url-pattern&gt;/jeeadmin/jeecms/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DbFile&lt;/servlet-name&gt; &lt;url-pattern&gt;/dbfile.svl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。 因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器， 启动容器时，就会默认执行它实现的方法。 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 它是一个在web应用关闭的时候,清除JavaBeans Introspector的监听器. 在web.xml中注册这个listener.可以保证在web 应用关闭的时候释放与掉这个web 应用相关的class loader 和由它管理的类 防止内存泄露 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;session-config&gt; &lt;session-timeout&gt;20&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.shtml&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jhtml&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;error-page&gt; &lt;error-code&gt;403&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error/403.html&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.html&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error/500.html&lt;/location&gt; &lt;/error-page&gt; &lt;mime-mapping&gt; &lt;extension&gt;rar&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;doc&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;wps&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;et&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt;&lt;/web-app&gt; 源码解析之二（application-context.xml）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!--xml进入路径web.xml/application-context.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd" default-lazy-init="true"&gt; &lt;!-- 加载数据库属性文件，以便动态获取 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;/WEB-INF/config/jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 加载其它属性文件 --&gt; &lt;bean id="properties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;!-- 其中包话数据库连接，hbm文件和连接池信息 --&gt; &lt;value&gt;/WEB-INF/config/jdbc.properties&lt;/value&gt; &lt;!-- 暂时未知 --&gt; &lt;value&gt;/WEB-INF/config/jeecms/jeecms.properties&lt;/value&gt; &lt;!-- 暂时未知 --&gt; &lt;value&gt;/WEB-INF/config/plug/**/*.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;qualifier value="main"/&gt; &lt;/bean&gt; &lt;!-- 通过PropertyUtils包操作properties属性文件中的属性，以便动态获取 --&gt; &lt;bean id="propertyUtils" class="com.jeecms.common.util.PropertyUtils"&gt; &lt;property name="properties" ref="properties"/&gt; &lt;/bean&gt; &lt;!-- 根据已加载的数据库属性文件，连接数据库 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!--连接关闭时默认将所有未提交的操作回滚。Default: false --&gt; &lt;property name="autoCommitOnClose" value="true"/&gt; &lt;!--当连接池用完时客户端调用getConnection()后等待获取新连接的时间， 超时后将抛出 SQLException,如设为0则无限期等待。单位毫秒。Default: 0 --&gt; &lt;property name="checkoutTimeout" value="$&#123;cpool.checkoutTimeout&#125;"/&gt; &lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt; &lt;property name="initialPoolSize" value="$&#123;cpool.minPoolSize&#125;"/&gt; &lt;!--连接池中保留的最小连接数。--&gt; &lt;property name="minPoolSize" value="$&#123;cpool.minPoolSize&#125;"/&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name="maxPoolSize" value="$&#123;cpool.maxPoolSize&#125;"/&gt; &lt;!--最大空闲时间,maxIdleTime秒内未使用则连 接被丢弃。若为0则永不丢弃。Default: 0 --&gt; &lt;property name="maxIdleTime" value="$&#123;cpool.maxIdleTime&#125;"/&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; &lt;property name="acquireIncrement" value="$&#123;cpool.acquireIncrement&#125;"/&gt; &lt;!-- default : 0 单位 s 这个配置主要是为了减轻连接池的负载，比如连接池中连接数因为某次数据访问高峰导致创建了很多数据连接 但是后面的时间段需要的数据库连接数很少，则此时连接池完全没有必要维护那么多的连接，所以有必要将 断开丢弃掉一些连接来减轻负载，必须小于maxIdleTime。配置不为0，则会将连接池中的连接数量保持到minPoolSize。 为0则不处理。 --&gt; &lt;property name="maxIdleTimeExcessConnections" value="$&#123;cpool.maxIdleTimeExcessConnections&#125;"/&gt; &lt;/bean&gt; &lt;!-- 设置数据库session工厂 --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 动态地通过properties文件加载映射的hbm文件 --&gt; &lt;property name="mappingLocations" value="#&#123;propertyUtils.getList('hibernate.hbm')&#125;"/&gt; &lt;!-- 配置hibernate属性 --&gt; &lt;property name="hibernateProperties"&gt; &lt;value&gt; &lt;!-- 指定数据库方言 --&gt; hibernate.dialect=$&#123;hibernate.dialect&#125; &lt;!-- 输出所有SQL语句到控制台 --&gt; hibernate.show_sql=false &lt;!-- 格式化输出sql语句 --&gt; hibernate.format_sql=false &lt;!-- 这个配置意思是当你在Hibernate里面输入true的时候，Hibernate会转化为0插入数据库， 当你在Hibernate里面输入false的时候，Hibernate会转化为1插入数据库， --&gt; hibernate.query.substitutions=true 1, false 0 &lt;!-- 指定每次提交SQL的数量。参数值越大，读数据库的次数越少，速度越快。 --&gt; hibernate.jdbc.batch_size=20 &lt;!-- 允许查询缓存,对经常使用的List查询方式，只有在使用查询缓存时， 才会从缓存中通过id去get缓存的值；查询缓存一般缓存查询语句和查询结果的id --&gt; hibernate.cache.use_query_cache=true &lt;/value&gt; &lt;/property&gt; &lt;property name="entityInterceptor"&gt; &lt;ref local="treeInterceptor"/&gt; &lt;/property&gt; &lt;property name="cacheProvider"&gt; &lt;ref local="cacheProvider"/&gt; &lt;/property&gt; &lt;property name="lobHandler"&gt; &lt;ref bean="lobHandler" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 处理 LOB 数据,CLOB 类型,BLOB 类型 --&gt; &lt;bean id="lobHandler" class="org.springframework.jdbc.support.lob.DefaultLobHandler" lazy-init="true"/&gt; &lt;!-- 缓存 --&gt; &lt;bean id="cacheProvider" class="com.jeecms.common.hibernate3.SpringEhCacheProvider"&gt; &lt;property name="configLocation"&gt; &lt;value&gt;/WEB-INF/config/ehcache-hibernate.xml&lt;/value&gt; &lt;/property&gt; &lt;property name="diskStoreLocation"&gt; &lt;value&gt;/WEB-INF/cache/hibernate&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 栏目等树形结构 --&gt; &lt;bean id="treeInterceptor" class="com.jeecms.common.hibernate3.TreeIntercptor"/&gt; &lt;!-- 定义事务管理器（声明式的事务） --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 是隐式地向 Spring 容器注入 --&gt; &lt;context:annotation-config/&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; 源码解析之三（ehcache-hibernate.xml）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194&lt;!-- 其为hibernate 二级缓存的配置 xml进入路径web.xml/application-context.xml/ehcache-hibernate.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"&gt; &lt;!-- 磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存 path:指定在硬盘上存储对象的路径 --&gt; &lt;!--&lt;diskStore path="java.io.tmpdir/jeecms/hibernate"/&gt; --&gt; &lt;!-- defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理 maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象 eternal:代表对象是否永不过期 timeToIdleSeconds:最大的发呆时间 timeToLiveSeconds:最大的存活时间 overflowToDisk:是否允许对象被写入到磁盘 diskSpoolBufferSizeMB：磁盘缓冲区的大小 diskExpiryThreadIntervalSeconds:清理过期缓存120秒 --&gt; &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" diskSpoolBufferSizeMB="30" maxElementsOnDisk="10000000" diskPersistent="false" diskExpiryThreadIntervalSeconds="120" /&gt; &lt;!-- cache:为指定名称的对象进行缓存的特殊配置 name:指定对象的完整名 --&gt; &lt;cache name="org.hibernate.cache.StandardQueryCache" maxElementsInMemory="50" eternal="false" timeToIdleSeconds="3600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="org.hibernate.cache.UpdateTimestampsCache" maxElementsInMemory="5000" eternal="true" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.core.entity.Sys" maxElementsInMemory="20" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.core.entity.DbTpl" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.core.entity.Ftp" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentType" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUserSite" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUserExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ChannelTxt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentTag" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUser" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentTxt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsRole" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsModel" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsGroup" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentCount" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSite" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSiteCompany" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ChannelExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.ContentCheck" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsConfig" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.viewGroups" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSite.attr" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.attr" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsGroup.contriChannels" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsRole.perms" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUser.channels" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.pictures" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSite.txt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.child" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsSite.cfg" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.contentCheckSet" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.users" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsUser.userExtSet" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.attr" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.attachments" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsGroup.viewChannels" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.contriGroups" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.viewGroups" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.tags" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.CmsConfig.attr" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Content.contentTxtSet" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.main.Channel.channelTxtSet" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsVoteTopic.items" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsKeyword" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsCommentExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsGuestbookExt" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsSensitivity" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsVoteTopic" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsGuestbookCtg" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsVoteRecord" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsVoteItem" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsGuestbook" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsComment" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; &lt;cache name="com.jeecms.cms.entity.assist.CmsJobApply" maxElementsInMemory="100" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="7200" overflowToDisk="true" /&gt; 源码解析之四（cache-context.xml）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;pre name="code" class="java"&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" default-lazy-init="true"&gt; &lt;!--缓存--&gt; &lt;bean id="cacheManager" class="com.jeecms.common.web.WebEhCacheManagerFacotryBean"&gt; &lt;property name="configLocation"&gt; &lt;value&gt;/WEB-INF/config/ehcache-application.xml&lt;/value&gt; &lt;/property&gt; &lt;property name="diskStoreLocation"&gt; &lt;value&gt;/WEB-INF/cache/application&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--SESSION缓存--&gt; &lt;bean id="ehSessionCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.common.web.Session&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="session"/&gt; &lt;/bean&gt; &lt;!--内容计数缓存--&gt; &lt;bean id="ehContentCountCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.ContentCount&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="contentCount"/&gt; &lt;/bean&gt; &lt;!--栏目计数缓存--&gt; &lt;bean id="ehChannelCountCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.ChannelCount&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="channelCount"/&gt; &lt;/bean&gt; &lt;!--微信token缓存--&gt; &lt;bean id="ehWeixinTokenCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.weixin.token&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="tokenCache"/&gt; &lt;/bean&gt; &lt;!--站点流量缓存--&gt; &lt;bean id="ehCmsSiteFlowCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsSiteFlow&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsSiteFlow"/&gt; &lt;/bean&gt; &lt;!--一次会话访问缓存--&gt; &lt;bean id="ehCmsSiteAccessCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsAccess&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsAccessCache"/&gt; &lt;/bean&gt; &lt;!--最新会话访问缓存--&gt; &lt;bean id="ehCmsSiteLastAccessCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsLastAccess&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsLastAccessCache"/&gt; &lt;/bean&gt; &lt;!--每次访问页面缓存--&gt; &lt;bean id="ehCmsSiteAccessPagesCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsAccessPage&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsAccessPageCache"/&gt; &lt;/bean&gt; &lt;!--pv总量计数缓存--&gt; &lt;bean id="ehPvTotalCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsSitePvTotal&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsPvTotalCache"/&gt; &lt;/bean&gt; &lt;!--访问者总量计数缓存--&gt; &lt;bean id="ehVisitorTotalCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsSiteVisitorTotal&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsVisitorTotalCache"/&gt; &lt;/bean&gt; &lt;!--搜索词汇缓存--&gt; &lt;bean id="ehSearchWordsCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.front.CmsSearchWords&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="cmsSearchWords"/&gt; &lt;/bean&gt; &lt;!--shiro缓存 &lt;bean id="ehShiroCache" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt; &lt;property name="cacheManager"&gt; &lt;ref local="cacheManager"/&gt; &lt;/property&gt; &lt;property name="cacheName"&gt; &lt;value&gt;com.jeecms.cms.shiro.shiroCache&lt;/value&gt; &lt;/property&gt; &lt;qualifier value="shiroCache"/&gt; &lt;/bean&gt; --&gt;&lt;/beans&gt; 源码解析之五（Spring + FreeMarker的集成）共四步 加载属性文件 application-context.xml下的jeecms.properties，会在第四步用到。12345678910111213141516171819202122232425&lt;web-app id="WebApp_ID" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;display-name&gt;JeeCmsV7&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- 数据库相关配置并加载了hbm.xml文件 (Spring)--&gt; /WEB-INF/config/application-context.xml &lt;!-- 数据缓存相关配置 --&gt; /WEB-INF/config/cache-context.xml &lt;!-- 验证码相关配置 --&gt; /WEB-INF/config/captcha-context.xml &lt;!-- 图片，密码，文件上传等配置 --&gt; /WEB-INF/config/jeecms/jeecore-context.xml &lt;!-- spring bean相关配置，如dao层的配置、图片处理，密码加密 --&gt; /WEB-INF/config/jeecms/jeecms-context.xml &lt;!-- 配置权限管理shiro-context.xml框架 --&gt; /WEB-INF/config/shiro-context.xml &lt;!-- 配置其它插件文件，暂时没有 --&gt; /WEB-INF/config/plug/**/*-context.xml &lt;!-- 配置定时任务 --&gt; /WEB-INF/config/quartz-task.xml &lt;/param-value&gt; &lt;/context-param&gt; ... &lt;/web-app&gt; 前台配置：配置FreeMarkerConfigurer123456789101112131415161718192021222324&lt;!-- 配置freemaker --&gt; &lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;!--获取标签配置--&gt; &lt;property name="freemarkerVariables" value="#&#123;propertyUtils.getBeanMap('directive.')&#125;"/&gt; &lt;property name="templateLoaderPath" value=""/&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="tag_syntax"&gt;auto_detect&lt;/prop&gt; &lt;prop key="template_update_delay"&gt;5&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.######&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;!--空值处理&lt;prop key="classic_compatible"&gt;true&lt;/prop&gt;--&gt; &lt;!--定义FreeMaker引入文件，index.ftl前缀为p,spring.ftl的前缀为s，这样在饮用ftl模版的宏定义时，可以简略使用--&gt; &lt;prop key="auto_import"&gt;/WEB-INF/ftl/jeecms/index.ftl as p,/WEB-INF/ftl/spring.ftl as s&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 解析 FreeMarker 视图12345678910&lt;!-- 解析freemaker视图 --&gt; &lt;bean id="freemarkerViewResolver" class="com.jeecms.common.web.springmvc.SimpleFreeMarkerViewResolver"&gt; &lt;property name="contentType" value="text/html; charset=UTF-8"/&gt; &lt;!-- 请求属性不暴露给freemaker使用 --&gt; &lt;property name="exposeRequestAttributes" value="false"/&gt; &lt;!-- 会话属性不暴露给freemaker使用 --&gt; &lt;property name="exposeSessionAttributes" value="false"/&gt; &lt;!-- 使用宏 --&gt; &lt;property name="exposeSpringMacroHelpers" value="true"/&gt; &lt;/bean&gt; 后台配置配置FreeMarkerConfigurer12345678910111213141516171819202122232425262728293031&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/WEB-INF"/&gt; &lt;property name="freemarkerVariables"&gt; &lt;map&gt; &lt;!--在FCK编辑器中需要用到appBase，以确定connector路径。--&gt; &lt;entry key="appBase" value="/jeeadmin/jeecms"/&gt; &lt;!--后台管理权限控制--&gt; &lt;entry key="cms_perm" value-ref="cms_perm"/&gt; &lt;entry key="text_cut" value-ref="text_cut"/&gt; &lt;entry key="html_cut" value-ref="html_cut"/&gt; &lt;entry key="cms_content_list" value-ref="cms_content_list"/&gt; &lt;entry key="cms_content_page" value-ref="cms_content_page"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;0&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.######&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;!--定义FreeMaker引入文件，index.ftl前缀为p,spring.ftl的前缀为s，这样在饮用ftl模版的宏定义时，可以简略使用--&gt; &lt;prop key="auto_import"&gt;/ftl/jeecms/index.ftl as p,/ftl/spring.ftl as s&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 解析 FreeMarker 视图1234567891011121314&lt;!-- 视图解析器 --&gt; &lt;bean id="freemarkerViewResolver" class="com.jeecms.common.web.springmvc.RichFreeMarkerViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="/jeecms_sys/"/&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".html"/&gt; &lt;property name="contentType" value="text/html; charset=UTF-8"/&gt; &lt;!-- 请求属性不暴露给freemaker使用 --&gt; &lt;property name="exposeRequestAttributes" value="false"/&gt; &lt;!-- 会话属性不暴露给freemaker使用 --&gt; &lt;property name="exposeSessionAttributes" value="false"/&gt; &lt;!-- 使用宏 --&gt; &lt;property name="exposeSpringMacroHelpers" value="true"/&gt; &lt;/bean&gt; 注入freeMarkerConfigurer（jeecms-context.xml）1234567891011121314151617181920212223242526&lt;bean id="staticPageSvc" class="com.jeecms.cms.staticpage.StaticPageSvcImpl"&gt; &lt;property name="tplMessageSource" ref="tplMessageSource"/&gt; &lt;property name="freeMarkerConfigurer"&gt; &lt;bean class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;!-- 从jeecms.properties中获取标签：directive.前缀的 --&gt; &lt;property name="freemarkerVariables" value="#&#123;propertyUtils.getBeanMap('directive.')&#125;"/&gt; &lt;property name="templateLoaderPath" value=""/&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="tag_syntax"&gt;auto_detect&lt;/prop&gt; &lt;prop key="template_update_delay"&gt;5&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.######&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;prop key="auto_import"&gt;/WEB-INF/ftl/jeecms/index.ftl as p,/WEB-INF/ftl/spring.ftl as s&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 源码解析之六（前台页面初始化）项目启动，初始化配置文件123456789101112131415161718192021&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- 数据库相关配置并加载了hbm.xml文件 (Spring)--&gt; /WEB-INF/config/application-context.xml &lt;!-- 数据缓存相关配置 --&gt; /WEB-INF/config/cache-context.xml &lt;!-- 验证码相关配置 --&gt; /WEB-INF/config/captcha-context.xml &lt;!-- 图片，密码，文件上传等配置 --&gt; /WEB-INF/config/jeecms/jeecore-context.xml &lt;!-- spring bean相关配置，如dao层的配置、图片处理，密码加密 ，freemaker的使用--&gt; /WEB-INF/config/jeecms/jeecms-context.xml &lt;!-- 配置权限管理shiro-context.xml框架 --&gt; /WEB-INF/config/shiro-context.xml &lt;!-- 配置其它插件文件，暂时没有 --&gt; /WEB-INF/config/plug/**/*-context.xml &lt;!-- 配置定时任务 --&gt; /WEB-INF/config/quartz-task.xml &lt;/param-value&gt; &lt;/context-param&gt; 浏览器输入http://localhost:8070/jeeCms/1&lt;bean id="dynamicAct" class="com.jeecms.cms.action.front.DynamicPageAct"/&gt; 通过过滤器进入1234567891011121314151617181920212223/** * TOMCAT的默认路径 * * @param request * @param model * @return */ @RequestMapping(value = "/", method = RequestMethod.GET) public String index(HttpServletRequest request,HttpServletResponse response, ModelMap model) &#123; CmsSite site = CmsUtils.getSite(request); FrontUtils.frontData(request, model, site); //带有其他路径则是非法请求 String uri=URLHelper.getURI(request); if(StringUtils.isNotBlank(uri)&amp;&amp;!uri.equals("/"))&#123; return FrontUtils.pageNotFound(request, response, model); &#125; //使用静态首页而且静态首页存在 if(site.getStaticIndex()&amp;&amp;new File(realPathResolver.get(site.getStaticDir()+INDEX)).exists())&#123; return FrontUtils.getTplPath("", site.getStaticDir(), INDEX); &#125;else&#123; return site.getTplIndexOrDef(); &#125; &#125; 返回一个url并 进入主页。123456&lt;!-- 当输入localhost:8080/jeeCms时，会先找第一个欢迎页，没有的话找第二个，依次类推，如果存在，就不找了 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.shtml&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jhtml&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 通过标签进入指定的类，并调用期execute()方法（以前台@cms_content_list为例）前台标签：123456789101112131415&lt;div class="cl"&gt; &lt;ul class="slideshow" id="slidesImgs"&gt; [@&lt;strong&gt;cms_content_list&lt;/strong&gt; count='5' orderBy='4' typeId='3' titLen='18' channelOption='1' channelId='1'] [#list tag_list as a] &lt;li&gt; &lt;a href="$&#123;a.url&#125;" target="_blank"&gt; &lt;img src="$&#123;a.typeImg!site.defImg&#125;" alt="$&#123;a.title&#125;" width="100%" /&gt; &lt;/a&gt; &lt;span class="title"&gt; [@text_cut s=a.title len=titLen /] &lt;/span&gt; &lt;/li&gt; [/#list] [/@cms_content_list] &lt;/ul&gt; &lt;/div&gt; 在web.xml—&gt;jeecms-contextxml 配置中找到相关的处理类1&lt;bean id="cms_content_list" class="com.jeecms.cms.action.directive.ContentListDirective"/&gt; 调用其execute（）方法对其进行处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * 模板名称 */ public static final String TPL_NAME = "content_list"; /** * 输入参数，文章ID。允许多个文章ID，用","分开。排斥其他所有筛选参数。 */ public static final String PARAM_IDS = "ids"; @SuppressWarnings("unchecked") public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; //获取站点 CmsSite site = FrontUtils.getSite(env); //获取内容列表，可通过此处进行更改，获取自己数据库中的数据 List&lt;Content&gt; list = getList(params, env); Map&lt;String, TemplateModel&gt; paramWrap = new HashMap&lt;String, TemplateModel&gt;(params); //OUT_LIST 的值是tag_list，在DirectiveUtils中声名，将内容列表放入其中 paramWrap.put(OUT_LIST, DEFAULT_WRAPPER.wrap(list)); //将params的值复制上到ariable中 Map&lt;String, TemplateModel&gt; origMap = DirectiveUtils.addParamsToVariable(env, paramWrap); //获取的是参数PARAM_TPL，是否调用模板及调用的模板类型 InvokeType type = DirectiveUtils.getInvokeType(params); //获取模板的传入参数，列表样式，根据不两只的参数获取不同的样式列表 String listStyle = DirectiveUtils.getString(PARAM_STYLE_LIST, params); if (InvokeType.sysDefined == type) &#123; if (StringUtils.isBlank(listStyle)) &#123; throw new ParamsRequiredException(PARAM_STYLE_LIST); &#125; //列表样式模板 env.include(TPL_STYLE_LIST + listStyle + TPL_SUFFIX, UTF8, true); &#125; else if (InvokeType.userDefined == type) &#123; if (StringUtils.isBlank(listStyle)) &#123; throw new ParamsRequiredException(PARAM_STYLE_LIST); &#125; //列表样式模板的路径 FrontUtils.includeTpl(TPL_STYLE_LIST, site, env); &#125; else if (InvokeType.custom == type) &#123; //这个模板是自己声明的，即content_list.html,如果采用自定义模板的话，页面中可以只写上标签，并添加上标签内需要的几个参数不需要写标签的内容，会去自动调用模板中的标签体。 FrontUtils.includeTpl(TPL_NAME, site, params, env); &#125; else if (InvokeType.body == type) &#123; body.render(env.getOut()); &#125; else &#123; throw new RuntimeException("invoke type not handled: " + type); &#125; //将variable中的params值移除 DirectiveUtils.removeParamsFromVariable(env, paramWrap, origMap); &#125; @SuppressWarnings("unchecked") protected List&lt;Content&gt; getList(Map&lt;String, TemplateModel&gt; params, Environment env) throws TemplateException &#123; Integer[] ids = DirectiveUtils.getIntArray(PARAM_IDS, params); if (ids != ) &#123; //根据ID数组获取文章列表 return contentMng.getListByIdsForTag(ids, getOrderBy(params)); &#125; else &#123; return (List&lt;Content&gt;) super.getData(params, env); &#125; &#125; 前台通过标签循环取出数据123456789101112131415&lt;ul class="slideshow" id="slidesImgs"&gt; [@cms_content_list count='5' orderBy='4' typeId='3' titLen='18' channelOption='1' channelId='1'] &lt;!-- 将OUT_LIST 即tag_list中的值遍历出来 --&gt; [#list tag_list as a] &lt;li&gt; &lt;a href="$&#123;a.url&#125;" target="_blank"&gt; &lt;img src="$&#123;a.typeImg!site.defImg&#125;" alt="$&#123;a.title&#125;" width="100%" /&gt; &lt;/a&gt; &lt;span class="title"&gt; [@text_cut s=a.title len=titLen /] &lt;/span&gt; &lt;/li&gt; [/#list] [/@cms_content_list] &lt;/ul&gt; 源码解析之七（前台页面初始化是request赋值）问题：当输入http://localhost:8070/jeeCms/时，通过拦截器“/”后台时，request 中包含了很多值是哪里来的？ 回答：加载web.xml12345678910111213&lt;!-- 前台控制 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;JeeCmsFront&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/config/jeecms-servlet-front.xml /WEB-INF/config/plug/**/*-servlet-front-action.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; 其初使化方法中 进入jeecms-servlet-front.xml，初使化：1&lt;bean id="frontContextInterceptor" class="com.jeecms.cms.web.FrontContextInterceptor"/&gt; 为reques和中放入值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * CMS上下文信息拦截器 * * 包括登录信息、权限信息、站点信息 */ public class FrontContextInterceptor extends HandlerInterceptorAdapter &#123; public static final String SITE_COOKIE = "_site_id_cookie"; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException &#123; CmsSite site = ; List&lt;CmsSite&gt; list = cmsSiteMng.getListFromCache(); int size = list.size(); if (size == 0) &#123; throw new RuntimeException("no site record in database!"); &#125; else if (size == 1) &#123; site = list.get(0); &#125; else &#123; String server = request.getServerName(); String alias, redirect; for (CmsSite s : list) &#123; // 检查域名 if (s.getDomain().equals(server)) &#123; site = s; break; &#125; // 检查域名别名 alias = s.getDomainAlias(); if (!StringUtils.isBlank(alias)) &#123; for (String a : StringUtils.split(alias, ',')) &#123; if (a.equals(server)) &#123; site = s; break; &#125; &#125; &#125; // 检查重定向 redirect = s.getDomainRedirect(); if (!StringUtils.isBlank(redirect)) &#123; for (String r : StringUtils.split(redirect, ',')) &#123; if (r.equals(server)) &#123; try &#123; response.sendRedirect(s.getUrl()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; return false; &#125; &#125; &#125; &#125; if (site == ) &#123; throw new SiteNotFoundException(server); &#125; &#125; &lt;span style="background-color: rgb(204, 153, 51);"&gt;CmsUtils.setSite(request, site);&lt;/span&gt; CmsThreadVariable.setSite(site); Subject subject = SecurityUtils.getSubject(); if (subject.isAuthenticated()|| subject.isRemembered()) &#123; String username = (String) subject.getPrincipal(); CmsUser user = cmsUserMng.findByUsername(username); CmsUtils.setUser(request, user); // Site加入线程变量 CmsThreadVariable.setUser(user); &#125; createJsessionId(request, response, site); return true; &#125; 源码解析之八（jeeCms整合webservice）第一步：在jeeCms .添加jar包第二步：增加webservice相关配置。web.xml 1234567891011121314151617181920212223&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!-- 数据库相关配置并加载了hbm.xml文件 (Spring)--&gt; /WEB-INF/config/application-context.xml &lt;!-- 数据缓存相关配置 --&gt; /WEB-INF/config/cache-context.xml &lt;!-- 验证码相关配置 --&gt; /WEB-INF/config/captcha-context.xml &lt;!-- 图片，密码，文件上传等配置 --&gt; /WEB-INF/config/jeecms/jeecore-context.xml &lt;!-- spring bean相关配置，如dao层的配置、图片处理，密码加密 ，freemaker的使用--&gt; /WEB-INF/config/jeecms/jeecms-context.xml &lt;!-- 配置权限管理shiro-context.xml框架 --&gt; /WEB-INF/config/shiro-context.xml &lt;!-- 配置其它插件文件，暂时没有 --&gt; /WEB-INF/config/plug/**/*-context.xml &lt;!-- 配置定时任务 --&gt; /WEB-INF/config/quartz-task.xml &lt;!-- 配置webservice --&gt; &lt;span style="color:#ff6666;"&gt; /WEB-INF/config/webservice/cxf-service.xml&lt;/span&gt; &lt;/param-value&gt; &lt;/context-param&gt; 12345678910&lt;!-- CXF webservice --&gt; &lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/ws/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; cxf-service.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:jaxws="http://cxf.apache.org/jaxws" xmlns:http-conf="http://cxf.apache.org/transports/http/configuration" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd http://cxf.apache.org/transports/http/configuration http://cxf.apache.org/schemas/configuration/http-conf.xsd"&gt; &lt;http-conf:conduit name="*.http-conduit"&gt; &lt;http-conf:client ConnectionTimeout="60000" ReceiveTimeout="60000"/&gt; &lt;/http-conf:conduit&gt; &lt;!-- 这两个xml文件来源cxf jar包 --&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt; &lt;!-- 这个文件中用来配置webservice服务器 --&gt; &lt;import resource="action-cxf.xml" /&gt; &lt;/beans&gt; action-cxf.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"&gt; &lt;!-- &lt;jaxws:endpoint id="ActPromWebService" implementor="#bizActPromWebService" address="/ActPromWebService" /&gt; --&gt;&lt;/beans&gt; 第三步 创建webService 接口类，用来存放调用webService 的方法1234567891011121314151617181920212223package com.jeecms.cms.action.directive; import javax.jws.WebMethod; import javax.jws.WebParam; import javax.jws.WebService; @WebService(targetNamespace="http://webservice.cus.biz.cbp.cj.com/") public interface countInfoInterfaceNpl &#123; public static final String SERVICE_NAME = "FindAllCustWebSerrvice"; /** * 根据客户ID查询客户的详细信息 * * @param traT * @param custB * @return */ @WebMethod String findByIdCustB(@WebParam(name = "partnerId") String partnerId, @WebParam(name = "traT") String traT, @WebParam(name = "custB") String custB, @WebParam(name = "orderId") String orderId,@WebParam(name = "verifyCode") String verifyCode); &#125; 第四步 java类中调用webservice1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.jeecms.cms.action.directive; import static com.jeecms.common.web.freemarker.DirectiveUtils.OUT_BEAN; import static freemarker.template.ObjectWrapper.DEFAULT_WRAPPER; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import javax.jws.WebService; import org.apache.cxf.interceptor.LoggingInInterceptor; import org.apache.cxf.interceptor.LoggingOutInterceptor; import org.apache.cxf.jaxws.JaxWsProxyFactoryBean; import com.jeecms.common.web.freemarker.DirectiveUtils; import freemarker.core.Environment; import freemarker.template.TemplateDirectiveBody; import freemarker.template.TemplateDirectiveModel; import freemarker.template.TemplateException; import freemarker.template.TemplateModel; /** * 总计信息 */ public class CountInfoNpl implements TemplateDirectiveModel &#123; @SuppressWarnings("unchecked") public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; try &#123; int i=1; if(i==1)&#123; JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean(); factory.getInInterceptors().add(new LoggingInInterceptor()); factory.getOutInterceptors().add(new LoggingOutInterceptor()); factory.setServiceClass(countInfoInterfaceNpl.class);//调用的接口类 factory.setAddress("http://127.0.0.1:8060/ws/FindAllCustWebSerrvice"); Object cInstance = factory.create(); Method invokeMethod = ; //循环接口类的所有方法，并与实际调用的方法比较，若不存在，则给出错误信息 for(Method m : (countInfoInterfaceNpl.class).getDeclaredMethods())&#123; if(!m.getName().equalsIgnoreCase(""))&#123; invokeMethod = m; break; &#125; &#125; if(invokeMethod == ) throw new Exception("ERROR:method not found"); //为webService添加参数 Object[] params1 = new Object[5]; params1[0] = ; params1[1] = "aaaa"; params1[2] = "bbnn"; params1[3] = ; params1[4] = ; //调用webService接口，并用CustNpl接收返回值 CustBNpl res = (CustBNpl) invokeMethod.invoke(cInstance, params1); System.out.println("aaa"); &#125;else&#123; Map&lt;String,String&gt; cmsVoteInfo=new HashMap&lt;String,String&gt;(); cmsVoteInfo.put("publicInfo", "加薪宝涨息"); cmsVoteInfo.put("totalCaptial","20000001"); cmsVoteInfo.put("goldCaptial","5555555"); cmsVoteInfo.put("getMoney","6666666"); Map&lt;String, TemplateModel&gt; paramWrap = new HashMap&lt;String, TemplateModel&gt;( params); paramWrap.put(OUT_BEAN, DEFAULT_WRAPPER.wrap(cmsVoteInfo)); Map&lt;String, TemplateModel&gt; origMap = DirectiveUtils.addParamsToVariable(env, paramWrap); body.render(env.getOut()); DirectiveUtils.removeParamsFromVariable(env, paramWrap, origMap); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>cms</category>
      </categories>
      <tags>
        <tag>cms</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Freemaker开发学习笔记]]></title>
    <url>%2Fblog%2F39074.html</url>
    <content type="text"><![CDATA[Freemaker是一个强大的模板引擎，相比velocity而言，其强大的过程调用、递归和闭包回调功能让freemaker可以完成几乎所有我们所想的功能。从个人看法而言，freemaker完全有能力作为MDA的代码辅助生成工具。本文试图越过传统的概念性介绍，通过一组例子直接把读者带入到Freemaker应用的较高层阶。 大家看文章标题就应该知道，我想用一篇文章，把大家从对freemaker的陌生直接带入到比较深入的境界，所以不想说一些基础性的东西，如果大家不习惯我的表达方法，大可通过google去找习惯于自己阅读方式的相关文章。我用过velocity，最近才用freemaker，才知道我以前的选择是错了，因为velocity不支持过程的调用，所以我为velocity增加了很多的东西，写了很多代码，而且脚本也累赘得要命。freemaker首先吸引我的是它强大的过程调用和递归处理能力，其次则是xml风格的语法结构有着明显的边界，不象velocity要注意段落之间要留空格。所以我建议大家直接使用Freemaker，虽然freemaker没有.net版本，我想不嵌入程序中使用的话，freemaker是绝对的首选。（题外话，谁有兴趣移植一个NFreeMaker？）在使用之前我们先要设置运行环境，在使用Freemaker的时候，我们需要下载相关的程序： freemaker: http://freemarker.sourceforge.net/ fmpp: http://fmpp.sourceforge.net/ 其中fmpp是一个freemaker的辅助工具，有了它，我们可以实现更多的功能。以下例子必须fmpp辅助。这里我们首先提出问题。大家看如下的一个xml文件，虽然freemaker的能力不仅在于处理xml文件，但是用xml作为例子更直观一些： 12345678910111213141516171819202122232425&lt;?xml version='1.0' encoding="gb2312" ?&gt;&lt;types xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:DruleForm-Lite.xsd"&gt; &lt;type name="Type1" &gt; &lt;labels&gt; &lt;label lang="zh-CN" value="投保单"/&gt; &lt;/labels&gt; &lt;field name="Field11" type="Float" lbound="1" ubound="1" &gt; &lt;labels&gt; &lt;label lang="zh-CN" value="投保单ID"/&gt; &lt;/labels&gt; &lt;/field&gt; &lt;field name="Field12" type="String" lbound="1" ubound="*"/&gt; &lt;field name="Field13" type="Integer" lbound="1" ubound="*"/&gt; &lt;field name="Field14" type="Type2" lbound="1" ubound="*"&gt; &lt;type name="Type2"&gt; &lt;field name="Field21" type="String" lbound="1" ubound="*"/&gt; &lt;field name="Field22" type="Integer" lbound="1" ubound="*"/&gt; &lt;/type&gt; &lt;/field&gt; &lt;field name="Field15" type="InsuranceProduct" lbound="1" ubound="*"/&gt; &lt;type&gt; &lt;type name="Type3"&gt; &lt;field name="Field31" type="Type1" lbound="1" ubound="*" /&gt; &lt;/type&gt; &lt;/types&gt; freemaker的基本语法 &lt;# … &gt; 中存放所有freemaker的内容，之外的内容全部原样输出。 &lt;@ … /&gt; 是函数调用两个定界符内的内容中，第一个符号表示指令或者函数名，其后的跟随参数。 freemaker提供的控制包括如下：freemaker的基本语法 &lt;# … &gt; 中存放所有freemaker的内容，之外的内容全部原样输出。 &lt;@ … /&gt; 是函数调用两个定界符内的内容中，第一个符号表示指令或者函数名，其后的跟随参数。 freemaker语句：1234&lt;#if condition&gt; &lt;#elseif condition&gt; &lt;#else&gt;&lt;/#if&gt; 条件判断 12&lt;#list hash_or_seq as var&gt;&lt;/#list&gt; 遍历hash表或者collection（freemaker称作sequence）的成员 123&lt;#macro name param1 param2 ... &gt;&lt;#nested param&gt;&lt;/#macro&gt; 宏，无返回参数 123&lt;#function name param1 param2&gt;&lt;#return val&gt;&lt;/#function&gt; 函数，有返回参数 1var?member_function(...) 用函数对var进行转换，freemaker称为build-ins。实际内部实现类似 1member_function(var, ...) stringA[M .. N] 取子字符串，类似 12substring(stringA, M, N)&#123;key:value, key2:value2 ...&#125; 直接定义一个hash表 1[item0, item1, item2 ...] 直接定义一个序列 1hash0[key0] 存取hash表中key对应的元素 1seq0[5] 存取序列指定下标的元素 1&lt;@function1 param0 param1 ... /&gt; 调用函数function1 12&lt;@macro0 param0 param1 ; nest_param0 nest_param1 ...&gt; nest_body &lt; /@macro&gt; 调用宏，并处理宏的嵌套 1&lt;#assign var = value &gt; 定义变量并初始化 1&lt;#local var = value&gt; 在 macro 或者 function 中定义局部变量并初始化 1&lt;#global var = value &gt; 定义全局变量并初始化 1$&#123;var&#125; 输出并替换为表达式的值 1&lt;#visit xmlnode&gt; 调用macro匹配xmlnode本身及其子节点 1&lt;#recurse xmlnode&gt; 调用macro匹配xmlnode的子节点 freemaker–设计指导一个ftl标记不能放在另外一个ftl标记里面，但是注释标记能够放在ftl标记里面。 系统预定义指令采用&lt;#…&gt;&lt;/#&gt; 用户自定义指令采用&lt;@…&gt;&lt;/@&gt; hash片段可以采用： products[10..19] or products[5..] 的格式。 序列也可以做加法计算：passwords + {“joe”:”secret42”}缺省值: name!”unknown” 或者 (user.name)!”unknown” 或者 name! 或者 (user.name)!null值检查: name?? or (user.name)?? 转义列表： Escape sequence Meaning \” Quotation mark (u0022) \’ Apostrophe (a.k.a. apostrophe-quote) (u0027) \ Back slash (u005C) \n Line feed (u000A) \r Carriage return (u000D) \t Horizontal tabulation (a.k.a. tab) (u0009) \b Backspace (u0008) \f Form feed (u000C) \l Less-than sign: &lt; \g Greater-than sign: &gt; \a Ampersand: &amp; { Curly bracket: { \xCode Character given with its hexadecimal Unicode code (UCS code) 如果想打印${，则需要将{转义，可以写成”${user}”，或者可以用生字符（r指令）：$(r “${xx}”} 序列构成：1&lt;#list ["winter", "spring", "summer", "autumn"] as x&gt;$&#123;x&#125;&lt;/#list&gt; 不同的对象可以存放在一个序列里面，比如：[2 + 2, [1, 2, 3, 4], “whatnot”]. 第一个是数字，第二个是序列，第三个是字符串。 可用采用start..end的方式来定义一个数字序列，start可以小于end，同时，end也可以省略。 hash取值支持一下四种模式： 1234book.author.name, book["author"].name, book.author.["name"], book["author"]["name"]. 特殊变量是指freemaker引擎本身定义的变量。访问时，以.variable_name的语法访问。 变量表达式支持嵌套模式，比如：${“Hello ${user}!”}。 变量表达式在指令中的使用情况：变量表达式可以在指令中，用“”的方式存在，不如：&lt;#include “/footer/${company}.html”&gt;.但是不允许下面的方式存在： &lt;#if ${isBig}&gt;Wow!&lt;/#if&gt; 正确写法1&lt;#if isBig&gt;Wow!&lt;/#if&gt; 而且 &lt;#if “${isBig}”&gt;Wow!&lt;/#if&gt;写法也不正确，因为”${isBig}”返回的是字符串，不是boolean类型。 字符串中取字符或字符串采用以下语法：1$&#123;user[0]&#125;,$&#123;user[0..2]&#125; $&#123;user[4..]&#125;,$&#123;user?string(4)&#125; 序列操作： 加法：&lt;#list [“Joe”, “Fred”] + [“Julia”, “Kate”] as user&gt; 但要注意串联之后的读取速度变慢。 子序列：seq[1..4] 序列和hash的串联都只能用于两个相加，不能有多个相加的模式，hash相加，如果两个相加的hash存在相同的key，则后面会覆盖前面的。 在使用&gt;=或者&gt;时，需要注意一些问题，因为freemaker会将&gt;解释成标记的关闭符，为了解决这个问题，需要在表达式加上括号，比如： &lt;#if (x &gt; y)&gt;. 或者使用 &gt; and &amp;lt符号来代替。 无值变量（包括无该变量，null，返回void，无属性等）：unsafe_expr!default_expr or unsafe_expr! or (unsafe_expr)!default_expr or (unsafe_expr)!缺省值可以是任何类型，不一定是数字，比如：hits!0 或者 colors![“red”, “green”, “blue”]. 如果缺省值忽略，那么将会默认为空串、空序列或者空hash，因为freemarker支持多类型的值。不过要让默认值为0或false，则不能省略缺省值。 非顶层变量的无值处理： product.color!”red”：只处理product不为空，color为空的缺省值处理，如果product为空，则freemaker会抛出异常。(product.color)!”red”：则会处理product为空，color为空，或者没有color属性的无值情况。 无值变量的判断操作：unsafe_expr?? or (unsafe_expr)??判断变量是否是无值。 普通变量插入方式:${expression},${3+5); 数字变量插入方式:#{expression} or #{expression; format}：过期。变量只能用于文本区或者是字符串里面，比如：Hello ${name}!以及 &lt;#include “/footer/${company}.html”&gt; 数字值的插入：根据缺省的number_format输出，以及可以通过setting来达到设置数字格式的目的，也可以通过内置函数string来改变输出格式。 日期类型的格式设置：date_format, time_format 和 datetime_format 定义宏： 不带参数：&lt;#macro 宏名&gt;…&lt;/#macro&gt;，引用&lt;@宏名 /&gt; 带参数：&lt;#macro 宏名 参数…&gt;…&lt;/#macro&gt;，引用&lt;@宏名 参数1=值1…/&gt;，带有参数的宏，调用是参数的值必须和参数的个数相同。当然也可以在宏定义时给参数一些默认值。比如：&lt;#macro greet person color=”black”&gt; 宏里面的嵌套内容：&lt;#macro border&gt; &lt;#nested&gt; &lt;/#macro&gt;在宏的定义body中加入&lt;#nested&gt;指令。嵌套的内容可以是任何正确的ftl块。 宏的本地变量在嵌套内容中是不可见的。 宏定义时，&lt;#nest&gt;指令相当于调用定义的内容，而使用宏时，nest body相当于定义。&lt;#macro repeat count&gt; &lt;#list 1..count as x&gt; &lt;#nested x, x/2, x==count&gt; &lt;/#list&gt;&lt;/#macro&gt;&lt;@repeat count=4 ; c, halfc, last&gt; ${c}. ${halfc}&lt;#if last&gt; Last!&lt;/#if&gt;&lt;/@repeat&gt; 定义变量： 在模板中定义的变量将会隐藏（不是更改）数据模型根下面的同名的变量。 模板中的3种类型变量： 1：plain variables，能够在模板中的任何地方访问，一个模板include另外一个模板，也可以访问被包含模板的变量。可以通过assign或者macro指令产生或替换变量。 如果要访问数据模型中的变量，则可以通过.global来访问： &lt;#assign user = “Joe Hider”&gt; ${user} &lt;#– prints: Joe Hider –&gt; ${.globals.user} &lt;#– prints: Big Joe–&gt; 2：Local variables，宏定义body中用local指令创建或者替换。 3：Loop variables:由list指令产生。 namespaces:&lt;#import “/lib/my_test.ftl” as my&gt; &lt;#– the hash called “my” will be the “gate” –&gt;&lt;@my.copyright date=”1999-2002”/&gt;${my.mail} 设置命名空间里面的变量：&lt;#assign mail=”jsmith@other.com“ in my&gt;命名空间与数据模型：命名空间的ftl可以访问数据模型的变量。同样命名空间的变量也会隐藏数据模型中同名的变量。空白问题： 1：White-space stripping，默认为enabled，清除ftl标记带来的空白以及缩进。处理模板的空白。 2：t, rt, lt指令。 3：ftl的参数strip_text. 用compress directive或者transform来处理输出。&lt;#compress&gt;…&lt;/#compress&gt;：消除空白行。&lt;@compress single_line=true&gt;.../@compress将输出压缩为一行。 可替换语法：freemarker可用”[“代替”&lt;”.在模板的文件开头加上[#ftl]. Spring MVC 使用 Freemarker• Freemaker是取代JSP的又一种视图技术，和Velocity非常类似，但是它比Velocity多了一个格式化的功能，因此使用上较Velocity方便一点，但语法也稍微复杂一些。将Velocity替换为Freemarker只需要改动一些配置文件，同样，在Spring中使用Freemarker也非常方便，根本无须与Freemarker的API打交道。我们将Spring_Velocity工程复制一份，命名为Spring_Freemarker 修改dispatcher-servlet.xml，将velocityConfig删除，修改viewResolver为FreeMarker ViewResolver，并添加一个freemarkerConfig。 123456789101112&lt;!-- 使用Freemarker视图解析器 --&gt;&lt;bean id="viewResolver" class="org.springframework.web.servlet.view. freemarker.FreeMarkerViewResolver"&gt; &lt;property name="contentType" value="text/html;charset=UTF-8" /&gt; &lt;property name="prefix" value="/" /&gt; &lt;property name="suffix" value=".html" /&gt;&lt;/bean&gt;&lt;!-- 配置Freemarker --&gt;&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view. freemarker.FreeMarkerConfigurer"&gt; &lt;!-- 视图资源位置 --&gt; &lt;property name="templateLoaderPath" value="/" /&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt;&lt;/bean&gt; 模板test.html可以稍做修改，加入Freemarker内置的格式化功能来定制Date类型的输出格式。 123456789&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;Spring_Freemarker&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Hello, $&#123;name&#125;, it is $&#123;time?string("yyyy-MM-dd HH:mm:ss")&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 添加freemarker.jar到web/WEB-INF/lib目录后，启动Resin，可以看到由Freemarker渲染的页面 FreeMarker入门：快速入门模板 + 数据模型 = 输出 FreeMarker基于设计者和程序员是具有不同专业技能的不同个体的观念 他们是分工劳动的：设计者专注于表示——创建HTML文件、图片、Web页面的其它可视化方面；程序员创建系统，生成设计页面要显示的数据 经常会遇到的问题是：在Web页面（或其它类型的文档）中显示的信息在设计页面时是无效的，是基于动态数据的 在这里，你可以在HTML（或其它要输出的文本）中加入一些特定指令，FreeMarker会在输出页面给最终用户时，用适当的数据替代这些代码 下面是一个例子： 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href="$&#123;latestProduct.url&#125;"&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;! &lt;/body&gt; &lt;/html&gt; 这个例子是在简单的HTML中加入了一些由${…}包围的特定代码，这些特定代码是FreeMarker的指令，而包含FreeMarker的指令的文件就称为模板（Template）至于user、latestProduct.url和latestProduct.name来自于数据模型（data model） 数据模型由程序员编程来创建，向模板提供变化的信息，这些信息来自于数据库、文件，甚至于在程序中直接生成 模板设计者不关心数据从那儿来，只知道使用已经建立的数据模型 下面是一个可能的数据模型： 123456789(root) | +- user = &quot;Big Joe&quot; | +- latestProduct | +- url = &quot;products/greenmouse.html&quot; | +- name = &quot;green mouse&quot; 数据模型类似于计算机的文件系统，latestProduct可以看作是目录，而user、url和name看作是文件，url和name文件位于latestProduct目录中（这只是一个比喻，实际并不存在） 当FreeMarker将上面的数据模型合并到模板中，就创建了下面的输出： 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome Big Joe!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href="products/greenmouse.html"&gt;green mouse&lt;/a&gt;! &lt;/body&gt; &lt;/html&gt; 数据模型典型的数据模型是树型结构，可以任意复杂和深层次，如下面的例子： 123456789101112131415161718192021222324252627(root) | +- animals | | | +- mouse | | | | | +- size = &quot;small&quot; | | | | | +- price = 50 | | | +- elephant | | | | | +- size = &quot;large&quot; | | | | | +- price = 5000 | | | +- python | | | +- size = &quot;medium&quot; | | | +- price = 4999 | +- test = &quot;It is a test&quot; | +- whatnot | +- because = &quot;don&apos;t know&quot; 类似于目录的变量称为hashes，包含保存下级变量的唯一的查询名字 类似于文件的变量称为scalars，保存单值 scalars保存的值有两种类型：字符串（用引号括起，可以是单引号或双引号）和数字（不要用引号将数字括起，这会作为字符串处理） 对scalars的访问从root开始，各部分用“.”分隔，如animals.mouse.price 另外一种变量是sequences，和hashes类似，只是不使用变量名字，而使用数字索引，如下面的例子： 1234567891011121314151617181920212223242526272829303132333435(root) | +- animals | | | +- (1st) | | | | | +- name = "mouse" | | | | | +- size = "small" | | | | | +- price = 50 | | | +- (2nd) | | | | | +- name = "elephant" | | | | | +- size = "large" | | | | | +- price = 5000 | | | +- (3rd) | | | +- name = "python" | | | +- size = "medium" | | | +- price = 4999 | +- whatnot | +- fruits | +- (1st) = "orange" | +- (2nd) = "banana" 这种对scalars的访问使用索引，如animals[0].name 模板 在FreeMarker模板中可以包括下面三种特定部分： ${…}：称为interpolations，FreeMarker会在输出时用实际值进行替代 FTL标记（FreeMarker模板语言标记）：类似于HTML标记，为了与HTML标记区分，用#开始（有些以@开始，在后面叙述） 注释：包含在&lt;#--和--&gt;（而不是&lt;!--和--&gt;）之间 下面是一些使用指令的例子： if指令12345&lt;#if animals.python.price &lt; animals.elephant.price&gt; Pythons are cheaper than elephants today. &lt;#else&gt; Pythons are not cheaper than elephants today. &lt;/#if&gt; list指令We have these animals: html NamePrice &lt;#list animals as being&gt; ${being.name}${being.price} Euros &lt;/#list&gt;1234567891011 输出为： &lt;p&gt;We have these animals: ```html&lt;table border=1&gt; &lt;tr&gt;&lt;th&gt;Name&lt;th&gt;Price &lt;tr&gt;&lt;td&gt;mouse&lt;td&gt;50 Euros &lt;tr&gt;&lt;td&gt;elephant&lt;td&gt;5000 Euros &lt;tr&gt;&lt;td&gt;python&lt;td&gt;4999 Euros &lt;/table&gt; include指令12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Test page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Test page&lt;/h1&gt; &lt;p&gt;Blah blah... &lt;#include "/copyright_footer.html"&gt; &lt;/body&gt; &lt;/html&gt; 一起使用指令We have these animals: 1234567891011&lt;table border=1&gt; &lt;tr&gt;&lt;th&gt;Name&lt;th&gt;Price &lt;#list animals as being&gt; &lt;tr&gt; &lt;td&gt; &lt;#if being.size = "large"&gt;&lt;b&gt;&lt;/#if&gt; $&#123;being.name&#125; &lt;#if being.size = "large"&gt;&lt;/b&gt;&lt;/#if&gt; &lt;td&gt;$&#123;being.price&#125; Euros &lt;/#list&gt; &lt;/table&gt; 常用语法EG.一个对象BOOK 1.输出1$&#123;book.name&#125; 空值判断：123$&#123;book.name?if_exists &#125;,$&#123;book.name?default(‘xxx’)&#125;//默认值xxx$&#123; book.name!"xxx"&#125;//默认值xxx 日期格式：1$&#123;book.date?string('yyyy-MM-dd')&#125; 数字格式：123$&#123;book?string.number&#125;--20$&#123;book?string.currency&#125;--&lt;#-- $20.00 --&gt;$&#123;book?string.percent&#125;—&lt;#-- 20% --&gt; 插入布尔值： 12&lt;#assign foo=ture /&gt;$&#123;foo?string("yes","no")&#125; &lt;#-- yes --&gt; 2．逻辑判断a: 1234&lt;#if condition&gt;...&lt;#elseif condition2&gt;...&lt;#elseif condition3&gt;......&lt;#else&gt;... 其中空值判断可以写成1&lt;#if book.name?? &gt; b: 12345678910111213&lt;#switch value&gt;&lt;#case refValue1&gt;...&lt;#break&gt;&lt;#case refValue2&gt;...&lt;#break&gt;...&lt;#case refValueN&gt;...&lt;#break&gt;&lt;#default&gt;... 3．循环读取12&lt;#list sequence as item&gt;... 空值判断1234&lt;#if bookList?size = 0&gt;e.g.&lt;#list employees as e&gt;$&#123;e_index&#125;. $&#123;e.name&#125; 输出: 121. Readonly2. Robbin freemarker中Map的使用 12345&lt;#list testMap?keys as testKey&gt; &lt; option value="$&#123;testKey&#125;" &gt; $&#123;testMap[testKey]&#125; &lt;/option&gt; &lt;/#list&gt; 解析FreeMarker视图声明一个针对FreeMarker的视图解析器： 1234&lt;bean id="viewResolver" class="org.springframework. ➥web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="suffix"&gt;&lt;value&gt;.ftl&lt;/value&gt;&lt;/property&gt; &lt;/bean&gt; FreeMarkerViewResolver和VelocityViewResolver或InternalResourceViewResolver的工作机制相同。模板资源是通过在视图的逻辑名上增加prefix属性的值作为前缀，以及增加suffix属性的值作为后缀进行解析的。和VelocityViewResolver一样，在这里我们又一次只设置suffix属性，因为模板的路径已经在FreeMarkerConfigurer的templateLoaderPath属性中定义了。暴露请求和会话属性。你看到如何告诉VelocityViewResolver将请求和会话属性复制到模型map中，从而它们能够在模板中作为变量使用。采用同样的方式配置FreeMarkerViewResolver，可以将请求和会话属性作为变量暴露给FreeMarker模板使用。要做到这一点，可以设置exposeRequestAttributes或者exposeSessionAttributes为true： 12345678910&lt;bean id="viewResolver" class="org.springframework. web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; … &lt;property name="exposeRequestAttributes"&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property name="exposeSessionAttributes"&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 这里，两个属性都被设置为true。结果是请求和会话属性都被复制到模板的属性集中，可以使用FreeMarker的表达式语言来访问并显示。 数据源+freemarker+servlet生成xml文件一.步骤:1.在server.xml文件中建立数据源.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;Service name="Cms"&gt; &lt;Connector debug="0" enableLookups="false" port="8084" protocol="AJP/1.3" redirectPort="8443"/&gt; &lt;Connector acceptCount="100" connectionTimeout="20000" debug="0" disableUploadTimeout="true" enableLookups="false" maxSpareThreads="75" maxThreads="150" minSpareThreads="25" port="8081" redirectPort="8443"/&gt; &lt;Engine defaultHost="localhost_Cms" name="Catalina_Cms"&gt; &lt;Logger className="org.apache.catalina.logger.FileLogger" prefix="localhost_cmt_log." suffix=".txt" timestamp="true"/&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"/&gt; &lt;Host autoDeploy="true" debug="0" name="localhost_Cms" unpackWARs="true" xmlNamespaceAware="false" xmlValidation="false"&gt; &lt;Context debug="0" docBase="D:WorkspaceCMSweb" path="/" reloadable="true" workDir="D:WorkspaceCMSj2src"&gt; &lt;Resource name="jdbc/news_DB" auth="Container" type="javax.sql.DataSource"/&gt; &lt;ResourceParams name="jdbc/news_DB"&gt; &lt;parameter&gt; &lt;name&gt;factory&lt;/name&gt; &lt;!-- DBCP Basic Datasource Factory --&gt; &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;maxActive&lt;/name&gt; &lt;value&gt;1000&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;validationQuery&lt;/name&gt; &lt;value&gt;select 1+1&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;maxIdle&lt;/name&gt; &lt;value&gt;100&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;maxWait&lt;/name&gt; &lt;value&gt;10000&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;removeAbandoned&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;removeAbandonedTimeout&lt;/name&gt; &lt;value&gt;60&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;logAbandoned&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;username&lt;/name&gt; &lt;value&gt;aaaa&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;password&lt;/name&gt; &lt;value&gt;bbbbbb&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;driverClassName&lt;/name&gt; &lt;value&gt;net.sourceforge.jtds.jdbc.Driver&lt;/value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;url&lt;/name&gt; &lt;value&gt;jdbc:jtds:sqlserver://111.111.111.111:1433/cms&lt;/value&gt; &lt;/parameter&gt; &lt;/ResourceParams&gt; &lt;/Context&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; 2.在web.xml文件中配置servlet12345678910&lt;servlet&gt; &lt;description&gt;generate xml file&lt;/description&gt; &lt;servlet-name&gt;NewsXmlServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;xml.NewsXmlServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;NewsXmlServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/xmlServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; 3.newsXmlServlet.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package xml; import java.io.*; import java.nio.charset.Charset; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.sql.DataSource; import freemarker.template.Configuration; import freemarker.template.Template; import freemarker.template.TemplateException; import java.util.Locale; public class NewsXmlServlet extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub try &#123; Connection conn=null; Context ctx = new InitialContext(); DataSource ds=(DataSource)ctx.lookup("java:comp/env/jdbc/news_DB"); conn=ds.getConnection(); Statement stmt=conn.createStatement(); ResultSet rs=stmt.executeQuery("select url,updatetime,tpf_edu_contentTitle,tpf_edu_contentneirong,tpf_edu_contentlaiyuan,tpf_edu_contentkeyword from tp5__edu_content where url&lt;&gt;'' and url is not null and dateDiff(d,updatetime,getDate())=1 order by updatetime desc"); Configuration cfg=new Configuration(); cfg.setDirectoryForTemplateLoading(new File("E:/wwwroot/CMS/web/WEB-INF/classes/xml")); Template tem=cfg.getTemplate("news.ftl"); List list=new ArrayList(); OutputStreamWriter out=new OutputStreamWriter(System.out); while(rs.next())&#123; Map item=new HashMap(); item.put("title",rs.getString(3)); item.put("link","http://test.com.cn"+rs.getString(1)); item.put("pubdate",rs.getTimestamp(2)); item.put("content",DelHtml(rs.getString(4))); item.put("source",rs.getString(5)); item.put("keywords",DelHtml(rs.getString(6))); list.add(item); &#125; Map data=new HashMap(); data.put("items",list); StringWriter writer=new StringWriter(); tem.process(data,writer); String content=writer.toString(); writer.close(); createXml(content); out.close(); //resp.setContentType("text/xml; charset=utf-8"); //resp.getWriter().write(content); &#125; catch (NamingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (TemplateException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public String DelHtml(String content)&#123; String contents=content.replaceAll("&lt;\/?\s*(\S+)(\s*[^&gt;]*)?\s*\/?&gt;",""); contents=contents.replaceAll("&amp;ldquo;", "”"); contents=contents.replaceAll("&amp;rdquo;","”"); contents=contents.replaceAll("&amp;ldquo;", "‘"); contents=contents.replaceAll("&amp;rdquo;","’"); contents=contents.replaceAll("&amp;middot;","•"); contents=contents.replaceAll("&amp;mdash;","—"); contents=contents.replaceAll("&amp;hellip;","…"); contents=contents.replaceAll("&amp;nbsp;",""); contents=contents.replaceAll(","," "); return contents; &#125; public void createXml(String fileContent)&#123; try &#123; String filePath="E:/wwwroot/cmsHtml/education/news.xml"; File fileXml=new File(filePath); if(!fileXml.exists())&#123; fileXml.createNewFile(); &#125; /*FileWriter fileWriter=new FileWriter(fileXml); fileWriter. fileWriter.write(fileContent); fileWriter.close();*/ OutputStreamWriter writer=new OutputStreamWriter(new FileOutputStream(fileXml), Charset.forName("utf-8")); writer.write(fileContent); writer.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public void destroy() &#123; // TODO Auto-generated method stub super.destroy(); &#125; public void init() throws ServletException &#123; // TODO Auto-generated method stub super.init(); &#125; &#125; 4.news.ftl1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;document&gt; &lt;webSite&gt;edu.aweb.com.cn&lt;/webSite&gt; &lt;webMaster&gt;webmaster@aweb.com.cn&lt;/webMaster&gt; &lt;updatePeri&gt;1440&lt;/updatePeri&gt; &lt;#list items as it&gt; &lt;item&gt; &lt;title&gt;&lt;![CDATA[$&#123;it.title&#125;]]&gt;&lt;/title&gt; &lt;link&gt;$&#123;it.link&#125;&lt;/link&gt; &lt;pubDate&gt;$&#123;it.pubdate&#125;&lt;/pubDate&gt; &lt;text&gt;&lt;![CDATA[$&#123;it.content&#125;]]&gt;&lt;/text&gt; &lt;image/&gt; &lt;source&gt;$&#123;it.source&#125;&lt;/source&gt; &lt;keywords&gt;&lt;![CDATA[$&#123;it.keywords&#125;]]&gt;&lt;/keywords&gt; &lt;/item&gt; &lt;/#list&gt; &lt;/document&gt; Spring中使用FreeMaker或Vilocity模板发送邮件 本文以用户注册后为用户发送一封邮件为例子，讲述如何在Spring中使用FreeMaker或Vilocity发送邮件。 Spring配置文件：xml 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt; &lt;property name="host" value="smtp.163.com"/&gt; &lt;property name="username" value="test"/&gt; &lt;property name="password" value="123456"/&gt; &lt;property name="javaMailProperties"&gt; &lt;props&gt; &lt;prop key="mail.smtp.auth"&gt;trueprop&gt; props&gt; property&gt; bean&gt; &lt;bean id="freeMarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/WEB-INF/freemakertemplate/" /&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;0prop&gt; &lt;prop key="default_encoding"&gt;GBKprop&gt; &lt;prop key="locale"&gt;zh_CNprop&gt; props&gt; property&gt; bean&gt; &lt;bean id="velocityEngine" class="org.springframework.ui.velocity.VelocityEngineFactoryBean"&gt; &lt;property name="resourceLoaderPath" value="/WEB-INF/vilocitytemplate/" /&gt; &lt;property name="velocityProperties"&gt; &lt;props&gt; &lt;prop key="velocimacro.library"&gt;*.vmprop&gt; &lt;prop key="default.contentType"&gt;text/html; charset=utf-8prop&gt; &lt;prop key="output.encoding"&gt;utf-8prop&gt; &lt;prop key="input.encoding"&gt;utf-8prop&gt; props&gt; property&gt; bean&gt; &lt;bean id="mailMessage" class="org.springframework.mail.SimpleMailMessage" singleton="false"&gt; &lt;property name="from" value="test@163.com"/&gt; bean&gt; &lt;bean id="mailEngine" class="test.MailEngine"&gt; &lt;property name="mailSender" ref="mailSender"/&gt; &lt;property name="velocityEngine" ref="velocityEngine"/&gt; &lt;property name="freeMarkerConfigurer" ref="freeMarkerConfigurer" /&gt; bean&gt; java 代码MailEngine类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class MailEngine &#123; protected static final Log log = LogFactory.getLog(MailEngine.class); // private FreeMarkerConfigurer freeMarkerConfigurer; private VelocityEngine velocityEngine; private MailSender mailSender; // public void setFreeMarkerConfigurer( // FreeMarkerConfigurer freeMarkerConfigurer) &#123; // this.freeMarkerConfigurer = freeMarkerConfigurer; // &#125; public void setMailSender(MailSender mailSender) &#123; this.mailSender = mailSender; &#125; public void setVelocityEngine(VelocityEngine velocityEngine) &#123; this.velocityEngine = velocityEngine; &#125; /** * 通过模板产生邮件正文 * @param templateName 邮件模板名称 * @param map 模板中要填充的对象 * @return 邮件正文（HTML） */ public String generateEmailContent(String templateName, Map map) &#123; //使用FreeMaker模板 // try &#123; // Configuration configuration = freeMarkerConfigurer.getConfiguration(); // Template t = configuration.getTemplate(templateName); // return FreeMarkerTemplateUtils.processTemplateIntoString(t, map); // &#125; catch (TemplateException e) &#123; // log.error("Error while processing FreeMarker template ", e); // &#125; catch (FileNotFoundException e) &#123; // e.printStackTrace(); // //log.error("Error while open template file ", e); // &#125; catch (IOException e) &#123; // log.error("Error while generate Email Content ", e); // &#125; // 使用Vilocity模板 try &#123; return VelocityEngineUtils.mergeTemplateIntoString(velocityEngine, templateName, map); &#125; catch (VelocityException e) &#123; log.error("Error while processing Vilocity template ", e); &#125; return null; &#125; /** * 发送邮件 * @param emailAddress 收件人Email地址的数组 * @param fromEmail 寄件人Email地址, null为默认寄件人web@vnvtrip.com * @param bodyText 邮件正文 * @param subject 邮件主题 * @param attachmentName 附件名 * @param resource 附件 * @throws MessagingException */ public void sendMessage(String[] emailAddresses, String fromEmail, String bodyText, String subject, String attachmentName, ClassPathResource resource) throws MessagingException &#123; MimeMessage message = ((JavaMailSenderImpl) mailSender) .createMimeMessage(); // use the true flag to indicate you need a multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setTo(emailAddresses); if(fromEmail != null)&#123; helper.setFrom(fromEmail); &#125; helper.setText(bodyText, true); helper.setSubject(subject); if(attachmentName!=null &amp;&amp; resource!=null) helper.addAttachment(attachmentName, resource); ((JavaMailSenderImpl) mailSender).send(message); &#125; /** * 发送简单邮件 * @param msg */ public void send(SimpleMailMessage msg) &#123; try &#123; ((JavaMailSenderImpl) mailSender).send(msg); &#125; catch (MailException ex) &#123; //log it and go on log.error(ex.getMessage()); &#125; &#125; /** * 使用模版发送HTML格式的邮件 * * @param msg 装有to,from,subject信息的SimpleMailMessage * @param templateName 模版名,模版根路径已在配置文件定义于freemakarengine中 * @param model 渲染模版所需的数据 */ public void send(SimpleMailMessage msg, String templateName, Map model) &#123; //生成html邮件内容 String content = generateEmailContent(templateName, model); MimeMessage mimeMsg = null; try &#123; mimeMsg = ((JavaMailSenderImpl) mailSender).createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMsg, true, "utf-8"); helper.setTo(msg.getTo()); if(msg.getSubject()!=null) helper.setSubject(msg.getSubject()); if(msg.getFrom()!=null) helper.setFrom(msg.getFrom()); helper.setText(content, true); ((JavaMailSenderImpl) mailSender).send(mimeMsg); &#125; catch (MessagingException ex) &#123; log.error(ex.getMessage(), ex); &#125; &#125; &#125; //发送邮件： SimpleMailMessage message = (SimpleMailMessage) getBean("mailMessage"); message.setTo(user.getName() + "&lt;" + user.getEmail() + "&gt;"); Map model = new HashMap(); model.put("user", user); MailEngine engine = (MailEngine)getBean("mailEngine"); //Vilocity模板 engine.send(message, "notifyUser.vm", model); //FreeMaker模板 //engine.send(message, "NotifyUser.ftl", model); 以上的User为用户类。 xml 代码模板： 12345678910111213&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt; &lt;title&gt;用户注册通知title&gt; head&gt; &lt;body&gt; &lt;p&gt;$&#123;user.name&#125; 您好，恭喜您，已经成为本站会员！p&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;用户名：td&gt;&lt;td&gt;$&#123;user.name&#125;td&gt;tr&gt; &lt;tr&gt;&lt;td&gt;密码：td&gt;&lt;td&gt;$&#123;user.password&#125;td&gt;tr&gt; table&gt; body&gt; html&gt;]]></content>
      <categories>
        <category>Freemaker</category>
      </categories>
      <tags>
        <tag>Freemaker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三目运算详解]]></title>
    <url>%2Fblog%2F44114.html</url>
    <content type="text"><![CDATA[三目运算符，又称条件运算符，指的是计算机语言的重要组成部分。它是唯一有3个操作数的运算符，所以有时又称为三元运算符。一般来说，三目运算符的结合性是右结合的。 对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。[1] &lt;表达式1&gt; ? &lt;表达式2&gt; : &lt;表达式3&gt;; “?”运算符的含义是：先求表达式1的值，如果为真，则执行表达式2，并返回表达式2的结果；如果表达式1的值为假，则执行表达式3，并返回表达式3的结果。 可以理解为条件 ? 结果1 : 结果2 里面的？号是格式要求。也可以理解为是不是条件成立，条件成立为结果1否则为结果2。 注意：在C语言中，结果1 和 结果2的类型必须一致。 a ? b : c简单理解方式为: 12345if(a) &#123; return b;&#125; else &#123; return c; &#125; 对于有些选择分支结构,可以使用简单的条件运算符来代替. 如: 1234if(a&lt;b) min=a;else min=b; 可以用下面的条件运算符来处理 1min=(a&lt;b)?a:b; 其中”(a&lt;b)?a:b”是一个”条件表达式”,它是这样执行的: 如果a&lt;b为真,则表达式取a值,否则取b值. 条件运算符由两个符号组成”?”和”:”,要求有3个操作对象,所以也叫它三目运算符,它是C语言中唯一的三目运算符. 它的一般形式为: 表达式1?表达式2:表达式3; 以下是关于条件运算符的几点说明: 通常情况下,表达式1是关系表达式或逻辑表达式,用于描述条件表达式中的条件,表达式2和表达式3可以是常量,变量或表达式.例如: 123(x==y)?'Y':'N'(d=b*b-4*a*c)&gt;=0?sqrt(d):sqrt(-d)ch=(ch&gt;='A'&amp;&amp;ch&lt;='Z')?(ch+32):ch 以上均为合法的条件表达式. 条件表达式的执行顺序为:先求解表达式1,若值为非0,表示条件为真,则求解表达式2,此时表达式2的值就作为整个条件表达式的值; 若表达式1的值为0,表示条件为假,则求解表达式3,表达式3的值就是整个条件表达式的值.例如: (a&gt;=0)?a:-a 执行结果是a的绝对值. 在程序中,通过把条件表达式的值直接赋予某个变量.例如: min=(a&lt;b)?a:b 执行结果就是将条件表达式的值赋予变量min,即将a和b二者中较小的数赋给min. 条件表达式的优先级别仅高于赋值运算符,而低于前面遇到过的所有运算符. 因此,min=(a&lt;b)?a:b括号可以不要,可直接写成,min=a&lt;b?a:b如果有x&lt;y?x+1:y-1等效于x&lt;y(x+1):(y-1)而不等效于(x&lt;y?x+1:y)-1 条件运算符的结合方向为”自右至左”. 条件表达式允许嵌套,即允许条件表达式中的表达式2和表达式3又是一个条件表达式.例如: 1x&gt;0?1:x&lt;0?-1:0 上述条件表达式中,表达式3部分又是一个条件表达式.根据条件表达式的结合性,上述条件表达式等价于: x&gt;0?1:(x&lt;0?-1:0) 其作用是判断x的符号情况.当x为正数时,该条件表达式的值为1;当x为负数时,该条件表达式的值为-1;当x为0时,该条件表达式的值为0. 条件表达式不能取代一般的if语句,仅当if语句中内嵌的语句为赋值语句(且两个分支都给同一变量赋值)时才能代替if语句.例如: 1234if(a%2==0) printf("even/n"); else printf("odd/n" ); 不能写成: 1(a%2==0)?printf("even/n"):printf("odd/n"); 但可以用下面语句代替: 1printf("%s/n",(a%2==0?"even":"o dd”); 该语句的作用是:若 a 为偶数,输出 even;若 a 为奇数,输出odd. 表达式1,表达式2,表达式3的类型可以不同.此时条件表达式的值的类型为它们中较高的类型.例如: 1234567891011main() &#123; char c1, ch; ch = getchar(); c1 = ch &lt;= 'Z' &amp;&amp; ch &gt;= 'A' ? ' @ ' : ch ; putchar(c1); &#125; 该程序的作用是从键盘输入任意一个字符,判别它们是否大写字母,如果是,输出一个@;否则按原样输出 dot 上例中,程序第6行是关键语句,该语句实现输入字符的判断,选择与更换工作. 其执行过程为:先由此语句中的赋值号右侧的条件运算符对输入的字符进行判断和选择,若ch&gt;=’A’&amp;&amp;ch&lt;=’Z’成立,说明ch是大写英文字母,此时选@;否则仍选原字符ch,然后把选择的结果赋值给原变量ch 。]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>三目运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch 4.0.0批处理框架]]></title>
    <url>%2Fblog%2F31932.html</url>
    <content type="text"><![CDATA[Spring Batch 4.0.0 已发布，Spring Batch 是一个轻量级的，完全面向 Spring 的批处理框架，可以应用于企业级大量的数据处理系统。Spring Batch 以 POJO 和 Spring 框架为基础，使开发者更容易的访问和利用企业级服务。Spring Batch 可以提供大量的，可重复的数据处理功能，包括日志记录/跟踪，事务管理，作业处理统计工作重新启动、跳过，和资源管理等重要功能。Spring Batch 4.0 是自2014年 3.0 发布以来的又一个主要版本。3.0 发布至今，Spring 生态系统发生了很大变化，4.0 版本旨在让 Spring Batch 更新这些变化。 New Baseline Spring Batch 3 基于 Spring Framework 4 ，Spring Batch 4 重新审视了它的依赖关系树，将它与即将到来的 Spring Boot 2 依赖关系树进行了更新，包括将 Spring Framework 5 和 Java 8 作为基线要求。 改进的 Java 配置如前所述，Spring Batch 4 是 Spring Boot 发布以来的第一个主要版本。在这个版本中，改善了让用户的 Java 配置体验。所有 ItemReader 和 ItemWriter 实现现在都可以使用构建器。使用 Spring Batch 3 的 Java 配置功能，将需要如下所示： 1234567891011121314151617181920212223242526@Beanpublic FlatFileItemReader&lt;Foo&gt; reader(Resource resource) throws Exception &#123; FlatFileItemReader&lt;Foo&gt; reader = new FlatFileItemReader&lt;&gt;(); reader.setName(“fooReader”); reader.setResource(resource); BeanWrapperFieldSetMapper&lt;Foo&gt; fieldSetMapper = new BeanWrapperFieldSetMapper&lt;&gt;(); fieldSetMapper.setTargetType(Foo.class); fieldSetMapper.afterPropertiesSet(); DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer(); tokenizer.setNames(new String[] &#123;“first”, “second”, “third”&#125;); tokenizer.afterPropertiesSet(); DefaultLineMapper lineMapper = new DefaultLineMapper(); lineMapper.setLineTokenizer(tokenizer); lineMapper.setFieldSetMapper(fieldSetMapper); reader.setLineMapper(lineMapper); return reader; &#125; 使用 Spring Batch 4，配置简化如下： 12345678910@Beanpublic FlatFileItemReader&lt;Foo&gt; reader(Resource resource) &#123; return new FlatFileItemReaderBuilder&lt;Foo&gt;() .name(“fooReader”) .resource(resource) .delimited() .names(new String[]&#123;“first”, “second”, “third”&#125;) .targetType(Foo.class) .build();&#125; 开始创建批处理服务本指南将引导您完成创建基本批处理驱动解决方案的过程。 你要建什么您将构建一个服务，该服务从CSV电子表格中导入数据，用自定义代码对其进行转换，并将最终结果存储在数据库中。 你需要什么大约15分钟 最喜欢的文本编辑器或IDEJDK 1.8或以后 Gradle 2.3或Maven 3.0+ 您还可以直接将代码导入IDE中： Spring Tool Suite (STS) IntelliJ IDEA 如何完成本指南像大多数Spring一样入门指南，您可以从头开始并完成每个步骤，也可以绕过您已经熟悉的基本设置步骤。无论哪种方式，你最终都会得到工作代码。 到白手兴家，继续前进用Gradle建造… 到跳过基础，做以下工作： 下载并解压缩本指南的源存储库，或用Git:1git clone https://github.com/spring-guides/gs-batch-processing.git cd into gs-batch-processing/initial 跳到创建一个business类… 当你完成中的代码检查结果，gs-batch-processing/complete. 用Gradle创建首先，您设置了一个基本的构建脚本。在使用Spring构建应用程序时，您可以使用任何您喜欢的构建系统，但是您需要使用的代码用Gradle和Maven包括在这里。如果您对这两种情况都不熟悉，请参阅用Gradle构建Java项目或使用Maven构建Java项目… 创建目录结构在您选择的项目目录中，创建以下子目录结构；例如，使用mkdir-p src/main/java/hello关于*nix系统： 1234└── src └── main └── java └── hello 创建一个Gradle构建文件下面是initial Gradle build file…. build.gradle 1234567buildscript&#123;repositories&#123;mavenCentral() &#125;dependencies&#123;classpath("org.springframework.boot:spring-boot-gradle-plugin:1.5.9.RELEASE") &#125;&#125;apply plugin: 'java'apply plugin: 'eclipse'apply plugin: 'idea'apply plugin: 'org.springframework.boot'jar&#123;baseName= 'gs-batch-processing'version= '0.1.0'&#125;repositories&#123;mavenCentral()&#125;sourceCompatibility= 1.8targetCompatibility= 1.8dependencies&#123;compile("org.springframework.boot:spring-boot-starter-batch")compile("org.hsqldb:hsqldb")testCompile("junit:junit")&#125; Spring Boot gradle plugin提供了许多方便的功能： 它收集类路径上的所有JAR，并构建一个可运行的“über-jar”，这使得执行和传输服务更加方便。 它搜索public static void main()方法标记为可运行的类。 它提供了一个内置的依赖项解析器，它将版本号设置为匹配。Spring Boot dependencies您可以覆盖任何版本，但它将默认为Boot所选的一组版本。 用Maven构建首先，您设置了一个基本的构建脚本。在使用Spring构建应用程序时，您可以使用任何您喜欢的构建系统，但是您需要使用的代码马文包括在这里。如果您不熟悉Maven，请参阅使用Maven构建Java项目… 创建目录结构在您选择的项目目录中，创建以下子目录结构；例如，使用mkdir-p src/main/java/hello关于*nix系统： 1234└── src └── main └── java └── hello pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0"encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;gs-batch-processing&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 大Spring Boot Maven插件提供了许多方便的功能： 它收集类路径上的所有JAR，并构建一个可运行的“über-jar”，这使得执行和传输服务更加方便。 它搜索public static void main()方法标记为可运行的类。 它提供了一个内置的依赖项解析器，它将版本号设置为匹配。Spring Boot dependencies您可以覆盖任何版本，但它将默认为Boot所选的一组版本。 用IDE构建 阅读如何将本指南直接导入Spring Tool Suite… 阅读如何使用本指南IntelliJ IDEA… 业务数据通常，您的客户或业务分析师提供电子表格。在这种情况下，你自己编出来的。 SRC/Main/Resources/Sample-data.csv 12345Jill,DoeJoe,DoeJustin,DoeJane,DoeJohn,Doe 此电子表格包含每行的名称和姓氏，以逗号分隔。正如您所看到的，这是Spring处理的一个非常常见的模式。 接下来，编写一个SQL脚本来创建一个表来存储数据。 SRC/main/resources/schema-all.sql 12DROP TABLE people IF EXISTS;CREATE TABLE people(person_id BIGINT IDENTITY NOT NULL PRIMARY KEY,first_name VARCHAR(20),last_name VARCHAR(20)); Spring Boot模式schema-@@platform@@.sql启动时自动。-all是所有平台的默认设置。 创建一个business类现在您已经看到了数据输入和输出的格式，您可以编写代码来表示一行数据. 12345678910111213141516171819202122232425262728293031323334353637packagehello;public class Person &#123; private StringlastName; private StringfirstName; public Person() &#123; &#125; public Person(StringfirstName, StringlastName) &#123; this.firstName=firstName; this.lastName=lastName; &#125; public voidsetFirstName(StringfirstName) &#123; this.firstName=firstName; &#125; public StringgetFirstName() &#123; returnfirstName; &#125; public StringgetLastName() &#123; returnlastName; &#125; public voidsetLastName(StringlastName) &#123; this.lastName=lastName; &#125; @Override public StringtoString() &#123; return "firstName: " +firstName+ ", lastName: " +lastName; &#125;&#125; 您可以实例化person通过构造函数，或通过设置属性，使用姓和名初始化。 创建中间处理器（ intermediate processor）批处理中的一个常见范例是摄取数据，转换数据，然后将其输送到其他地方。在这里，您将编写一个简单的转换器，将名称转换为大写。 SRC/main/java/hello/PersonItemProcessor.java 12345678910111213141516171819202122packagehello;importorg.slf4j.Logger;importorg.slf4j.LoggerFactory;importorg.springframework.batch.item.ItemProcessor;public class PersonItemProcessor implements ItemProcessor&lt;Person, Person&gt; &#123; private static final Loggerlog= LoggerFactory.getLogger(PersonItemProcessor.class); @Override public Personprocess(final Personperson) throws Exception &#123; final StringfirstName=person.getFirstName().toUpperCase(); final StringlastName=person.getLastName().toUpperCase(); final PersontransformedPerson= new Person(firstName,lastName);log.info("Converting (" +person+ ") into (" +transformedPerson+ ")"); returntransformedPerson; &#125;&#125; PersonItemProcessor器实现Spring批处理ItemProcessor接口。这使代码很容易连接到一个批处理作业中，您可以在本指南中进一步对其进行定义。根据接口，您将收到一个传入的person对象，然后将其转换upper-cased Person. 不需要输入和输出类型相同。事实上，在读取一个数据源之后，有时应用程序的数据流需要不同的数据类型。 把一批工作放在一起现在，您将实际的批处理作业组合在一起。SpringBatch提供了许多实用程序类，这些类减少了编写自定义代码的需要。相反，您可以专注于业务逻辑。 SRC/main/java/hello/BatchConfiguration.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980packagehello;importjavax.sql.DataSource;importorg.springframework.batch.core.Job;importorg.springframework.batch.core.JobExecutionListener;importorg.springframework.batch.core.Step;importorg.springframework.batch.core.configuration.annotation.EnableBatchProcessing;importorg.springframework.batch.core.configuration.annotation.JobBuilderFactory;importorg.springframework.batch.core.configuration.annotation.StepBuilderFactory;importorg.springframework.batch.core.launch.support.RunIdIncrementer;importorg.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;importorg.springframework.batch.item.database.JdbcBatchItemWriter;importorg.springframework.batch.item.file.FlatFileItemReader;importorg.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper;importorg.springframework.batch.item.file.mapping.DefaultLineMapper;importorg.springframework.batch.item.file.transform.DelimitedLineTokenizer;importorg.springframework.beans.factory.annotation.Autowired;importorg.springframework.context.annotation.Bean;importorg.springframework.context.annotation.Configuration;importorg.springframework.core.io.ClassPathResource;importorg.springframework.jdbc.core.JdbcTemplate;@Configuration@EnableBatchProcessingpublic class BatchConfiguration &#123; @Autowired public JobBuilderFactoryjobBuilderFactory; @Autowired public StepBuilderFactorystepBuilderFactory; @Autowired public DataSourcedataSource; // tag::readerwriterprocessor[] @Bean public FlatFileItemReader&lt;Person&gt;reader() &#123; FlatFileItemReader&lt;Person&gt;reader= new FlatFileItemReader&lt;Person&gt;();reader.setResource(new ClassPathResource("sample-data.csv"));reader.setLineMapper(new DefaultLineMapper&lt;Person&gt;() &#123;&#123;setLineTokenizer(new DelimitedLineTokenizer() &#123;&#123;setNames(new String[] &#123; "firstName", "lastName" &#125;); &#125;&#125;);setFieldSetMapper(new BeanWrapperFieldSetMapper&lt;Person&gt;() &#123;&#123;setTargetType(Person.class); &#125;&#125;); &#125;&#125;); returnreader; &#125; @Bean public PersonItemProcessorprocessor() &#123; return new PersonItemProcessor(); &#125; @Bean public JdbcBatchItemWriter&lt;Person&gt;writer() &#123; JdbcBatchItemWriter&lt;Person&gt;writer= new JdbcBatchItemWriter&lt;Person&gt;();writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider&lt;Person&gt;());writer.setSql("INSERT INTO people (first_name, last_name) VALUES (:firstName, :lastName)");writer.setDataSource(dataSource); returnwriter; &#125; // end::readerwriterprocessor[] // tag::jobstep[] @Bean public JobimportUserJob(JobCompletionNotificationListenerlistener) &#123; returnjobBuilderFactory.get("importUserJob") .incrementer(new RunIdIncrementer()) .listener(listener) .flow(step1()) .end() .build(); &#125; @Bean public Stepstep1() &#123; returnstepBuilderFactory.get("step1") .&lt;Person, Person&gt;chunk(10) .reader(reader()) .processor(processor()) .writer(writer()) .build(); &#125; // end::jobstep[]&#125; 首先，@EnableBatchProcessing注释添加了许多支持作业的关键bean，并为您节省了大量的腿工作。此示例使用基于内存的数据库(由@EnableBatchProcessing)，这意味着当它完成时，数据就会消失。 把它分解： SRC/main/java/hello/BatchConfiguration.java 12345678910111213141516171819@Beanpublic FlatFileItemReader&lt;Person&gt;reader() &#123; FlatFileItemReader&lt;Person&gt;reader= new FlatFileItemReader&lt;Person&gt;();reader.setResource(new ClassPathResource("sample-data.csv"));reader.setLineMapper(new DefaultLineMapper&lt;Person&gt;() &#123;&#123;setLineTokenizer(new DelimitedLineTokenizer() &#123;&#123;setNames(new String[] &#123; "firstName", "lastName" &#125;); &#125;&#125;);setFieldSetMapper(new BeanWrapperFieldSetMapper&lt;Person&gt;() &#123;&#123;setTargetType(Person.class); &#125;&#125;); &#125;&#125;); returnreader;&#125;@Beanpublic PersonItemProcessorprocessor() &#123; return new PersonItemProcessor();&#125;@Beanpublic JdbcBatchItemWriter&lt;Person&gt;writer() &#123; JdbcBatchItemWriter&lt;Person&gt;writer= new JdbcBatchItemWriter&lt;Person&gt;();writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider&lt;Person&gt;());writer.setSql("INSERT INTO people (first_name, last_name) VALUES (:firstName, :lastName)");writer.setDataSource(dataSource); returnwriter;&#125; 第一个代码块定义输入、处理器和输出。—reader()创建ItemReader.它查找一个名为sample-data.csv并使用足够的信息解析每一行项，从而将其转换为person…processor()创建我们的PersonItemProcessor您在前面定义，目的是大写数据。—write(DataSource)创建ItemWriter。此对象针对JDBC目标，并自动获取由@EnableBatchProcessing它包括插入单个person由Javabean属性驱动。 下一部分重点关注实际的作业配置。SRC/main/java/hello/BatchConfiguration.java 12345678910111213141516171819@Beanpublic JobimportUserJob(JobCompletionNotificationListenerlistener) &#123; returnjobBuilderFactory.get("importUserJob") .incrementer(new RunIdIncrementer()) .listener(listener) .flow(step1()) .end() .build();&#125;@Beanpublic Stepstep1() &#123; returnstepBuilderFactory.get("step1") .&lt;Person, Person&gt;chunk(10) .reader(reader()) .processor(processor()) .writer(writer()) .build();&#125; 第一个方法定义作业，三定义一个步骤。作业是由步骤构建的，每个步骤都可以包含一个阅读器、一个处理器和一个编写器。 在此作业定义中，您需要一个增量器，因为作业使用数据库来维护执行状态。然后列出每个步骤，其中此作业只有一个步骤。作业结束，JavaAPI生成一个配置完美的作业。 在步骤定义中，定义一次写入多少数据。在这种情况下，它一次最多写十条记录。接下来，使用前面注入的位来配置读取器、处理器和写入器。 chunk()是前缀&lt;Person,Person&gt;因为这是一个通用的方法。这表示处理的每个“块”的输入和输出类型，并与ItemReader和ItemWriter... SRC/main/java/hello/JobCompletionNotificationListener.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546packagehello;importjava.sql.ResultSet;importjava.sql.SQLException;importjava.util.List;importorg.slf4j.Logger;importorg.slf4j.LoggerFactory;importorg.springframework.batch.core.BatchStatus;importorg.springframework.batch.core.JobExecution;importorg.springframework.batch.core.listener.JobExecutionListenerSupport;importorg.springframework.beans.factory.annotation.Autowired;importorg.springframework.jdbc.core.JdbcTemplate;importorg.springframework.jdbc.core.RowMapper;importorg.springframework.stereotype.Component;@Componentpublic class JobCompletionNotificationListener extends JobExecutionListenerSupport &#123; private static final Loggerlog= LoggerFactory.getLogger(JobCompletionNotificationListener.class); private final JdbcTemplatejdbcTemplate; @Autowired public JobCompletionNotificationListener(JdbcTemplatejdbcTemplate) &#123; this.jdbcTemplate=jdbcTemplate; &#125; @Override public voidafterJob(JobExecutionjobExecution) &#123; if(jobExecution.getStatus() == BatchStatus.COMPLETED) &#123;log.info("!!! JOB FINISHED! Time to verify the results"); List&lt;Person&gt;results=jdbcTemplate.query("SELECT first_name, last_name FROM people", new RowMapper&lt;Person&gt;() &#123; @Override public PersonmapRow(ResultSetrs, introw) throws SQLException &#123; return new Person(rs.getString(1),rs.getString(2)); &#125; &#125;); for (Personperson:results) &#123;log.info("Found &lt;" +person+ "&gt; in the database."); &#125; &#125; &#125;&#125; 此代码监听作业为BatchStatus.COMPLETED，然后使用JdbcTemplate检查结果。 使应用程序可执行虽然批处理可以嵌入到Web应用程序和WAR文件中，但下面演示的更简单的方法创建了一个独立的应用程序。您将所有东西打包到一个可执行的JAR文件中，该文件由一个好的旧Java驱动。main()方法。 src/main/java/hello/Application.java 123456789101112packagehello;importorg.springframework.boot.SpringApplication;importorg.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static voidmain(String[]args) throws Exception &#123; SpringApplication.run(Application.class,args); &#125;&#125; @SpringBootApplication是一个方便的注释，它添加了以下所有内容： @Configuration将类标记为应用程序上下文的bean定义的源。 @EnableAutoConfiguration告诉SpringBoot根据类路径设置、其他bean和各种属性设置开始添加bean。 通常你会添加@EnableWebMvc对于SpringMVC应用程序，但是SpringBoot在看到Springwebmvc在类路径上。这会将应用程序标记为web应用程序，并激活关键行为，例如设置DispatcherServlet… @ComponentScan告诉Spring在hello包，让它找到控制器。 main()方法使用SpringBoot的SpringApplication.run()方法来启动应用程序。您注意到没有一行XML吗？不web.xml也要归档。这个Web应用程序是100%纯Java，您不必处理配置任何管道或基础设施的问题。 出于演示目的，有一些代码可以创建一个JdbcTemplate，查询数据库，并打印批处理作业插入的人员的名称。 构建一个可执行的JAR您可以使用Gradle或Maven从命令行运行应用程序。或者，您可以构建一个包含所有必需的依赖项、类和资源的单个可执行JAR文件，并运行该文件。这使得在整个开发生命周期、跨不同环境等将服务作为应用程序进行发布、版本和部署变得非常容易。 如果使用Gradle则可以使用./gradlew bootRun.或者您可以使用以下方法构建JAR文件./gradlew build然后可以运行JAR文件： 1java -jar build/libs/gs-batch-processing-0.1.0.jar 如果您使用的是Maven则可以使用./mvnw Spring-boot：运行.或者您可以用./mvnw clean package然后可以运行JAR文件： 1java -jar target/gs-batch-processing-0.1.0.jar 上面的过程将创建一个可运行的JAR。你也可以选择构建一个经典的WAR文件相反。 该职务为每个被转换的人打印一行。作业运行后，还可以看到查询数据库的输出。 12345678910Converting (firstName: Jill, lastName: Doe) into (firstName: JILL, lastName: DOE)Converting (firstName: Joe, lastName: Doe) into (firstName: JOE, lastName: DOE)Converting (firstName: Justin, lastName: Doe) into (firstName: JUSTIN, lastName: DOE)Converting (firstName: Jane, lastName: Doe) into (firstName: JANE, lastName: DOE)Converting (firstName: John, lastName: Doe) into (firstName: JOHN, lastName: DOE)Found in the database.Found in the database.Found in the database.Found in the database.Found in the database. 摘要恭喜你！您构建了一个批处理作业，该作业从电子表格中摄取数据，并对其进行处理，并将其写入数据库。 See also The following guides may also be helpful: Building an Application with Spring Boot Accessing Data with GemFire Accessing Data with JPA Accessing Data with MongoDB Accessing data with MySQL]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穷忙族的人生]]></title>
    <url>%2Fblog%2F54997.html</url>
    <content type="text"><![CDATA[穷忙族来自英文单词“working poor”，原指那些薪水不多，整日奔波劳动，却始终无法摆脱贫穷的人。但是随着逐渐壮大的“穷忙一族”队伍，主要界定为每周工时低于平均工时的三分之二、收入低于全体平均60%者。这个定义又逐渐发展成一种为了填补空虚生活，而不得不连续消费，之后继续投入忙碌的工作中，而在消费过后最终又重返空虚的“穷忙”。 随着经济的发展和城市化进程的加快，个体的生存压力确实在增强， 但绝对没有“紧张”到要让“穷忙族”同时兼几份职拼命赚钱的程度；盲从、攀比的心理，或许存在于部分人之中，可不会是普遍性的主流心态，至于个人欲望，在现代文明的视野下，为了物质享受不惜放弃一切的人不是没有，但毕竟还是少数。 问题的关键恐怕还是在于，现实社会存在的“结构性危机”——社会结构，原本是一个“流水不腐”的动态机构框架。社会阶层之间，有一条不断流动循环的“河流”。穷人成为富人或者富人再次变得一贫如洗，大众变成精英或者精英沦落为草根，都是很正常的事情。但现实却是，户籍、收入分配、教育等诸多领域体制性的落后甚至是不公正，逐渐导致精英“寡头化”和底层人“固化”，阶层与阶层之间的流动困难。穷人变富越来越难，草根成为精英近乎天方夜谭。 香港曾经有一档电视真人秀，叫做《穷富翁大作战》，专门邀请富人体验穷人的生活。 有一期节目的主人公是田北辰。他的父亲田元灏是香港纺织界的头面人物，人称”一代裤王”。他本科毕业于康奈尔大学电子工程专业，又去读了哈佛大学 MBA，回到香港后创办了服装品牌 G2000 和 U2，是那种很努力的”富二代”。 他崇尚自由竞争和人生奋斗，座右铭是”如果你今天对自己满意，明天就会被淘汰”，一直宣扬 “如果你有斗志，弱者也可以变成强者。” 但是，参加了这次电视节目以后，他的观点发生了180度转变，对着电视镜头公开说： “这个社会在极严厉地惩罚，那些没条件读书的人。穷人一輩子都不可能变有钱人。在強弱悬殊的情况下，只有弱者越弱，越來越慘！” 田北辰为什么改变观点，认为穷人不可能翻身呢？原来，节目组请他体验了两天清洁工的生活，薪资是每小时25港币，每天的生活费只有50港币，住在只有1.6平方米的”笼屋”，月租1350港币。 所谓”笼屋”，外面看着像衣橱，门一拉开，里面只能放下一张床，关上门四面全挨着木板墙，东西都挂在墙上。就是这种条件，房产中介还称它为”豪华笼屋”，因为还有600港币的更低档，就是在马桶上放一块木板睡人。 上班时间是早上五点，地铁头班车还没开，只能坐夜宵巴士，车费是13港币，田北辰惊呼：”每天生活费只有50港币，这怎么坐得起！” 开始工作后，好不容易熬到中午吃饭，但只有15元的预算，大部分的饭要20元，他最后只能坐在街边的楼梯上，就着白开水嚼干粮。 吃完了，还要抓紧时间躺在花坛上休息一会。 做满9个小时，就可以下班了。但是，真正的清洁工为了养家户口，还要去做夜班，一天在外近17个小时，只能睡5、6个小时。田北辰说，因为只有两天，自己才有斗志坚持下去，如果要做一个月，甚至半年，那就太绝望了！ “没有学历、技术的人，为了活下去，不是住笼屋就是要工作到半夜，对于他们，最重要事情是下一顿吃什么，怎么会有时间和精力去思考未来怎么发展？来来去去都在死胡同！” 每天忙于工作，干到累死，但还是很穷，只能租屋住，没有自己的积蓄，一旦停止工作或者生病在床，生活来源顿时就成问题。田北辰体验的这种人生，社会学家早就注意到了，起名为”穷忙族”，百度百科的定义如下。 “穷忙族是指那些薪水不多，整日奔波劳动，却始终无法摆脱贫穷的人。最早出现于上世纪90年代的美国，指拼命工作仍然无法摆脱最低水准生活的人们。日本经济学家门仓贵史在《穷忙族》一书中，他对”穷忙族”下的定义是：每天繁忙地工作却依然不能过上富裕生活的人。” 不仅香港有”穷忙族”，内地也越来越多。举例来说，根据报道，2016年上海送外卖最多的送餐员，是一位叫做何文妹的中年女性，至少送出了12214单。即使全年无休，每天平均也要33单，从午饭时间一直送到深夜，一刻不停。电瓶车的电瓶，一天要准备6组。车上插着两个手机，一个导航，一个接单。 这种强度的劳动，每年能有多少收入呢？每单的送餐费是8元，这就是说，何文妹一年的送餐总收入在10万元左右。扣除电瓶费、车辆维护费、通信费等等以后，净收入大概还能剩下8万多元。这是”送餐王”的收入水平，大部分送餐员的收入，应该远不如她，可能只有一半左右。 上海的底层劳动者，收入基本就是这种水平。他们还要用这些钱支付房租。每天下班回到家，累得就想睡觉，睁开眼就要去上班，日复一日，人生的出路在哪里？ 将来的”穷忙族”，不仅是低技能的底层劳动者，还将包括很多受过高等教育、写字楼工作的白领。年轻人如果没有家庭支持，想要靠自己的努力出人头地，会变得越来越难。因为单靠工资收入，已经不足以积累财富了。 有一项统计说： “1993年属于低等收入者的城里人，到了1995年有43%都能向上爬。而相比之下，2011年属于低等收入者的城里人，到了2013年只有20%摘掉最底层的帽子。一个不恰当的比喻，如果上世纪90年代算是城市穷人的黄金时代的话，那今天这种好日子已经结束了。” “一方面，城里穷人越来越难走出贫困；另一方面，城里富人的位置也坐得越来越稳。1993-1995年，城里的高等收入者有64%的概率能一直当富人。而到了2011-2013年，高等收入者竟然有84%的概率能保证自己不被从富人列表中除名。” 上面的数字就是说，如果你是穷人，80%的概率以后你还是穷人；如果你是富人，84%的概率是以后你还是富人。一个台湾人感叹说： “那种奴隶化的生活（长时间工作，却仅能勉强满足温饱）才是历史的常态。过去三十年社会阶层的大幅流动，是历史的不正常，现在开始回归常态。99%的我们，都面临着这种大趋势的吞噬：你的工资不变，但房价和物价却是越来越高，于是你必需花更多时间来挣钱，甚至一天做二份工，最后成为没有自己时间的奴隶。” 总的来看，下一代青年不太可能有上一代那么多机会。经济增长率已经开始放缓，还将继续放缓，人口增长高峰已经过去，老龄化越来越严重，老人的消费远不及年轻人。矿业、制造业、零售业、证券业……除了高科技，几乎所有行业都不会有以前那么高的增长率。上一代人赶上了中国经济起飞，还拥有依靠房地产翻身的机会，但是下一代人不会再有这样的机会。你现在买入一套房子，十年后价值翻上十倍，完全是零可能。 越来越多的人将会发现，即使从小就努力学习，从很好的学校毕业，后来努力工作，但迎接他们的将是”长久的低薪、难升迁的职场、高昂的物价、买不起的房子……”。尽管你很努力，待人友善，有公德心，但就是挣不到钱，只能在社会的底层挣扎。 2015年，社会工作者藤田孝典调查日本的老人问题。 他发现，很多老人年轻时都拿过中产阶级的薪水（400万日元），但是现在已经沦落到社会的底层，过着非常困苦的生活。”七老八十还要在大热天当廉价劳工，因经济拮据而妻离子散，唯有独居烂屋，孤零零度过晚年。” 藤田孝典将这些老人称为”下流老人”（底层老人）。他称，日本的下流老人以后可能会达到1亿人。要知道，日本现在的总人口也只有1.27亿。 下流老人有三大特征。（1）收入极低，即使政府提供补助费，也难以维持健康饮食，以及一般家庭应有的生活；（2）存款不足，老人必须提心吊胆地过活，一旦碰到突发事故或慢性病，日常已经捉襟见肘的生活，就会面临崩溃危险；（3）老无所依，子女连自己都养不起，更遑论赡养老人。日本不少老人因家庭破碎而长期独居，平日缺乏与亲朋邻里的交流，关系疏离，一旦发生意外无人照应。在晚年失去可以依靠的人，是下流老人最悲苦的特征。 下流老人的根源就是，钱花光了，人还没死。日本媒体还发明了一个词”老后破产”，这就是长寿的恶梦。 现代科技如此发达，人的寿命越来越长，可是工作又积累不了财富，于是，”清贫青年，流沙中年，下流老人”就成了大多数人必然的命运归宿。]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAML脚本学习笔记]]></title>
    <url>%2Fblog%2F2295.html</url>
    <content type="text"><![CDATA[YAML是“另一种标记语言”的外语缩写；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。它是类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。诞生YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822。Clark Evans在2001年5月在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。命名YAML是”YAML Ain’t a Markup Language”（YAML不是一种置标语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种置标语言），功能YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表，标量等资料形态、。它使用空白符号缩排和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种设定档、倾印除错内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。尽管它比较适合用来表达阶层式（hierarchical model）的数据结构，不过也有精致的语法可以表示关联性（relational model）的资料。由于YAML使用空白字符和分行来分隔资料，使的他特别适合用grep、Python、Perl、Ruby操作。其让人最容易上手的特色是巧妙避开各种封闭符号，如：引号、各种括号等，这些符号在嵌套结构中会变得复杂而难以辨认。 YAML预研文档YAML概要YAML是”YAML Ain’t a Markup Language”（YAML不是一种置标语言）的递归缩写，早先YAML的意思其实是：”Yet Another Markup Language”（另外一种置标语言），但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名，YAML的官方定义很简单，即一种人性化的数据格式定义语言，其主要功能用途类似于XML或JSON，YAML使用空白字符和分行来分隔数据，且巧妙避开各种封闭符号，如：引号、括号等，以避免这些符号在复杂层次结构中变得难以辨认。YAML的语法与高阶语言类似，可以很简单地表述序列（java中的list）、杂凑表（java中的map）、标量（java中的基本类型等）数据结构，它重点强调可阅读性。 YAML vs XML与YAML相似的数据格式定义语言是XML，YAML比XML优越性表现在 优势: YAML的可读性好 YAML和脚本语言的交互性好 YAML使用实现语言的数据类型 YAML有一个一致的信息模型 YAML易于实现 上面5条是XML不足的地方，同时，YAML也具有XML的下列优点： YAML可以基于流来处理 YAML表达能力强，扩展性好 YAML类似于XML的数据描述语言，语法比XML简单很多，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务。 YAML vs JSONJSON的语法其实是YAML的子集，大部分的JSON文件都可以被YAML的剖析器剖析。虽然大部分的数据分层形式也可以使用类似JSON的格式，不过YAML并不建议这样使用，除非这样编写能让文件可读性增加，更重要的是，YAML的许多扩展在JSON是找不到的，如：进阶资料形态、关系锚点、字串不需要引号、映射资料形态会储存键值的顺序等。 YAML用途脚本语言由于实现简单，解析成本很低，YAML特别适合在脚本语言中使用。列一下现有的语言实现：Ruby，Java，Perl，Python，PHP，OCaml，JavaScript，除了Java，其他都是脚本语言。 序列化YAML比较适合做序列化。因为它是宿主语言数据类型直转的。 配置文件YAML做配置文件也不错。写YAML要比写XML快得多(无需关注标签或引号)，并且比ini文档功能更强。 调试由于其很强的阅读性，用于调试过程中dump出信息供分析也是一种比较方便的做法。 YAML缺陷与不足YAML没有自己的数据类型的定义，而是使用实现语言的数据类型。一个YAML文件，在不同语言中解析后得到的数据类型可能会不同，由于其兼容性问题，不同语言间的数据流转不建议使用YAML。 YAML语法与范例 YAML使用可打印的Unicode字符，可使用UTF-8或UTF-16 使用空白字符（不能使用Tab）分层，同层元素左侧对齐 单行注解由井字号（ # ）开始，可以出现在行中任何位置 每个清单成员以单行表示，并用短杠+空白（- ）起始 每个杂凑表的成员用冒号+空白（: ）分开键和值 杂凑表的键值可以用问号 (?)起始，表示多个词汇组成的键值 字串一般不使用引号，但必要的时候可以用引号框住 使用双引号表示字串时，可用倒斜线（\）进行特殊字符转义 区块的字串用缩排和修饰词（非必要）来和其他资料分隔，有新行保留（使用符号|）或新行折叠（使用符号&gt;）两种方式 在单一档案中，可用连续三个连字号（—）区分多个档案 可选择性的连续三个点号（…）用来表示档案结尾(在流式传输时非常有用，不需要关闭流即可知道到达结尾处) 重复的内容可使从参考标记星号 (*)复制到锚点标记（&amp;） 指定格式可以使用两个惊叹号 ( !! )，后面接上名称 123456789101112131415161718192021222324252627receipt: Oz-Ware Purchase Invoicedate: 2007-08-06customer: given: Dorothy family: Galeitems: - part_no: A4786 descrip: Water Bucket (Filled) price: 1.47 quantity: 4 - part_no: E1628 descrip: High Heeled &quot;Ruby&quot; Slippers price: 100.27 quantity: 1bill-to: &amp;id001 street: | 123 Tornado Alley Suite 16 city: East Westville state: KSship-to: *id001 specialDelivery: &gt; Follow the Yellow Brick Road to the Emerald City. Pay no attention to the man behind the curtain.... 这个文件的的顶层由七个键值组成：其中一个键值”items”，是个两个元素构成的清单，清单中的两个元素同时也是包含了四个键值的杂凑表。文件中重复的部分处理方式：使用锚点（&amp;）和参考（*）标签将”bill-to”杂凑表的内容复制到”ship-to”杂凑表。也可以在文件中加入选择性的空行，以增加可读性。 YAML的JAVA实现YAML已经有了多种语言不少实现，详见YAML官网。一般YAML文件扩展名为.yaml，比如John.yaml，其内容为：12345678910name: John Smithage: 37children: - name: Jimmy Smith age: 15 - name: Jenny Smith age: 12spouse: name: Jane Smith age: 25 由于yaml的超强可读性，我们了解到：John今年37岁，两个孩子Jimmy 和Jenny活泼可爱，妻子Jane年轻美貌，而且年仅25岁，一个幸福的四口之家。对John.yaml进行java描述，抽象出一个Person类，如下：1234567public class Person &#123; private String name; private int age; private Person sponse; private Person[] children; // setXXX, getXXX方法略.&#125; 现在我们使用java装配一个Jone：12345678910111213Person john = new Person();john.setAge(37);john.setName(&quot;John Smith&quot;);Person sponse = new Person();sponse.setName(&quot;Jane Smith&quot;);sponse.setAge(25);john.setSponse(sponse);Person[] children = &#123;new Person(), new Person()&#125;;children[0].setName(&quot;Jimmy Smith&quot;);children[0].setAge(15);children[1].setName(&quot;Jenny Smith&quot;);children[1].setAge(12);john.setChildren(children); 使用SnakeYAML实现项目主页：http://code.google.com/p/snakeyaml/使用手册：https://code.google.com/p/snakeyaml/wiki/DocumentationSnakeYAML是一个标准的YAML的java实现，它有以下特点： 完全支持YAML 1.1，可以跑通规范中的所有示例 支持YAML的所有类型 支持UTF-8/UTF-16的输入和输出 提供了本地java对象的序列化和反序列化的高层API 提供相对合理的错误提示信息 使用SnakeYAML将john dump出来，如果有引用相同对象，则dump出到yaml文件会自动使用&amp;和*进行锚点和引用：123456DumperOptions options = new DumperOptions();options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);Yaml yaml = new Yaml(options);//Yaml yaml = new Yaml();String dump = yaml.dump(john);System.out.println(dump); 内容如下：1234567891011121314151617!!Personage: 37children:- age: 15 children: null name: Jimmy Smith sponse: null- age: 12 children: null name: Jenny Smith sponse: nullname: John Smithsponse: age: 25 children: null name: Jane Smith sponse: null 现在用SnakeYAML把yaml load进来，如果yaml文件中使用了&amp;和*，则会自动对load出来的对象赋相同的值：1234Yaml yaml = new Yaml();Object load = yaml.load(new FileInputStream(new File(&quot;jhon.yaml&quot;)));System.out.println(load.getClass());System.out.println(yaml.dump(load)); 或123Yaml yaml = new Yaml(options);Person person = yaml.loadAs(inputStream, Person.class);System.out.println(person.getSponse().getChildren().length); 如果一个yaml文件中有多个文档，由—分割，解析如下：123456Yaml yaml = new Yaml(); int counter = 0; for (Object data : yaml.loadAll(input)) &#123; System.out.println(data); counter++; &#125; 保存一个Map对象：1234567891011Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); data.put(&quot;name&quot;, &quot;Silenthand Olleander&quot;); data.put(&quot;race&quot;, &quot;Human&quot;); data.put(&quot;traits&quot;, new String[] &#123; &quot;ONE_HAND&quot;, &quot;ONE_EYE&quot; &#125;); Yaml yaml = new Yaml(); String output = yaml.dump(data); System.out.println(output); // or StringWriter writer = new StringWriter(); yaml.dump(data, writer); System.out.println(writer.toString()); 将多个文档dump出到同一个yaml文件中去：12345678910List&lt;Integer&gt; docs = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt; 4; i++) &#123; docs.add(i); &#125; DumperOptions options = new DumperOptions(); //options.setCanonical(true); options.explicitStart(true); Yaml yaml = new Yaml(options); System.out.println(yaml.dump(docs)); System.out.println(yaml.dumpAll(docs.iterator())); 12345--- [1, 2, 3]--- 1--- 2--- 3 YAML与java类型对照表：YAML | JAVA——– | ——-!null |null!!bool |Boolean!!int |Integer, Long, BigInteger!!float |Double!!binary |String!!timestamp |java.util.Date, java.sql.Date, java.sql.Timestamp!!omap, !!pairs |List of Object[]!!set |Set!!str |String!!seq |List!!map |Map 集合的默认实现是： List: ArrayList Map: LinkedHashMap 使用JYaml实现JYaml（最新版本是2007年的，可以考虑放弃了），使用JYaml把Jone “Dump” 出来：12File dumpfile = new File(&quot;John_dump.yaml&quot;);Yaml.dump(john, dumpfile); 下面我们看看John_dump.yaml是什么样子：12345678910111213--- !yaml.test.internal.Personage: 37children: !yaml.test.internal.Person[] - !yaml.test.internal.Person age: 15 name: Jimmy Smith - !yaml.test.internal.Person age: 12 name: Jenny Smithname: John Smithsponse: !yaml.test.internal.Person age: 25 name: Jane Smith 其中!yaml.test.internal.Person是一些类型的信息。load的时候需要用。现在用JYaml把Jone_dump.yaml load进来：1Person john2 = (Person) Yaml.loadType(dumpfile, Person.class); 还可以用下面的代码dump出没有类型信息的John.yaml：1Yaml.dump(john,dumpfile, true); 我们再来看看JYaml对流处理的支持，为简便起见，我们只是把同一个john写10次：1234567 YamlEncoder enc = new YamlEncoder(new FileOutputStream(dumpfile)); for(int i=0; i&lt;10; i++)&#123; john.setAge(37+i); enc.writeObject(john); enc.flush(); &#125;enc.close(); 下面再把这十个对象一个一个读出来（注意while循环退出的方式）：1234567891011YamlDecoder dec = new YamlDecoder(new FileInputStream(dumpfile));int age = 37;while(true)&#123; try&#123; john = (Person) dec.readObject(); assertEquals(age, john.getAge()); age++; &#125;catch(EOFException eofe)&#123; break; &#125;&#125; 格式多行缩进数据结构可以用类似大纲的缩排方式呈现，结构通过缩进来表示，连续的项目通过减号“-”来表示，map结构里面的key/value对用冒号“:”来分隔。样例如下： 123456789101112131415house: family: name: Doe parents: - John - Jane children: - Paul - Mark - Simone address: number: 34 street: Main Street city: Nowheretown zipcode: 12345 注意：字串不一定要用双引号标识； 在缩排中空白字符的数目并不是非常重要，只要相同阶层的元素左侧对齐就可以了（不过不能使用TAB字符）； 允许在文件中加入选择性的空行，以增加可读性； 在一个档案中，可同时包含多个文件，并用“——”分隔； 选择性的符号“…”可以用来表示档案结尾（在利用串流的通讯中，这非常有用，可以在不关闭串流的情况下，发送结束讯号）。 单行缩写YAML也有用来描述好几行相同结构的数据的缩写语法，数组用’[]’包括起来，hash用’{}’来包括。因此，上面的这个YAML能够缩写成这样: 123house: family: &#123; name: Doe, parents: [John, Jane], children: [Paul, Mark, Simone] &#125; address: &#123; number: 34, street: Main Street, city: Nowheretown, zipcode: 12345 &#125;]]></content>
      <categories>
        <category>xml</category>
      </categories>
      <tags>
        <tag>yaml</tag>
        <tag>yml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWFUpload文件上传详解]]></title>
    <url>%2Fblog%2F15202.html</url>
    <content type="text"><![CDATA[SWFUpload是一个客户端文件上传工具，最初由Vinterwebb.se开发，它通过整合Flash与JavaScript技术为WEB开发者提供了一个具有丰富功能继而超越传统input type=”file”标签的文件上传模式。官方站点：http://www.swfupload.org/DEMO地址：http://demo.swfupload.org/ 主要特点 可以同时上传多个文件； 类似AJAX的无刷新上传； 可以显示上传进度； 良好的浏览器兼容性； 兼容其他JavaScript库 (例如：jQuery, Prototype等)； 支持Flash 8和Flash 9； SWFUpload不同于其他基于Flash构建的上传工具，它有着优雅的代码设计，开发者可以利用XHTML、CSS和JavaScript来随心所欲的定制它在浏览器下的外观；它还提供了一组简明的JavaScript事件，借助它们开发者可以方便的在文件上传过程中更新页面内容来营造各种动态效果。 在使用SWFUpload之前，请确认你具备一定的JavaScript和DOM知识。在实际开发中，大部分的错误都是由于错误的设置和低劣的Event Handlers处理程序所造成的。 SWFUpload的文件上传流程： 引入相应的js文件 实例化SWFUpload对象，传入一个配置参数对象进行各方面的配置。 点击SWFUpload提供的Flash按钮，弹出文件选取窗口选择要上传的文件； 文件选取完成后符合规定的文件会被添加到上传的队列里； 调用startUpload方法让队列里文件开始上传； 文件上传过程中会触发相应的事件，开发者利用这些事件来更新ui、处理错误、发出提示等等； SWFUpload包括三部分的内容：SWFUpload.js、swfupload.swf、初始化配置参数及各种事件处理函数。 所以首先在页面引入SWFUpload.js 在页面中实例化一个SWFUpload对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var swfu; window.onload = function () &#123; var settings_object = &#123;//定义参数配置对象 upload_url : "http://www.swfupload.org/upload.php", flash_url : "http://www.swfupload.org/swfupload.swf", file_post_name : "Filedata", post_params : &#123; "post_param_name_1" : "post_param_value_1", "post_param_name_2" : "post_param_value_2", "post_param_name_n" : "post_param_value_n" &#125;, use_query_string : false, requeue_on_error : false, http_success : [201, 202], assume_success_timeout : 0, file_types : "*.jpg;*.gif", file_types_description: "Web Image Files", file_size_limit : "1024", file_upload_limit : 10, file_queue_limit : 2, debug : false, prevent_swf_caching : false, preserve_relative_urls : false, button_placeholder_id : "element_id", button_image_url : "http://www.swfupload.org/button_sprite.png", button_width : 61, button_height : 22, button_text : "&lt;b&gt;Click&lt;/b&gt; &lt;span class="redText"&gt;here&lt;/span&gt;", button_text_style : ".redText &#123; color: #FF0000; &#125;", button_text_left_padding : 3, button_text_top_padding : 2, button_action : SWFUpload.BUTTON_ACTION.SELECT_FILES, button_disabled : false, button_cursor : SWFUpload.CURSOR.HAND, button_window_mode : SWFUpload.WINDOW_MODE.TRANSPARENT, swfupload_loaded_handler : swfupload_loaded_function, file_dialog_start_handler : file_dialog_start_function, file_queued_handler : file_queued_function, file_queue_error_handler : file_queue_error_function, file_dialog_complete_handler : file_dialog_complete_function, upload_start_handler : upload_start_function, upload_progress_handler : upload_progress_function, upload_error_handler : upload_error_function, upload_success_handler : upload_success_function, upload_complete_handler : upload_complete_function, debug_handler : debug_function, &#125;; swfu = new SWFUpload(settings_object);//实例化一个SWFUpload，传入参数配置对象 &#125;; /*定义各种事件监听函数*/ function swfupload_loaded_function()&#123;&#125; function file_dialog_start_function()&#123;&#125; //...等等 ​ 我们看到要实现一个SWFUpload上传功能很简单，就是实例化一个SWFUpload对象。但繁琐的地方就在于实例化实要用到的参数配置对象，以及各种事件的发生时机以和提供的参数。所以重点来了。下面几个表格对开发中要用到的东西列举了出来，虽然已经蛮多了，但并不是SWFUpload的全部，我列出来的只是常用的。要查看完整的文档，请到SWFUpload官网上查询。 配置参数对象中的常用属性及说明 属性 类型 默认值 描述 upload_url String 处理上传文件的服务器端页面的url地址，可以是绝对地址，也可以是相对地址，当为相对地址时相对的是当前代码所在的文档地址 preserve_relative_urls Boolean false 如果为false则SWFUpload会把swfupload.swf用到的相对地址转换为绝对地址，以达到更好的兼容性 file_post_name String Filedata 相当于用普通的文件域上传文件时的name属性，服务器端接收页面通过该名称来获取上传的文件 post_params Object(直接量) 一个对象直接量，里面的键/值对会随着每一个文件一起上传，文件上传要附加一些信息时很有用 use_query_string Boolean false 为false时,post_params属性定义的参数会以post方式上传；为true时，则会以get方式上传（即参数会以查询字符串的形式附加到url后面） file_types String 该属性指定了允许上传的文件类型，当有多个类型时使用分号隔开，比如：.jpg;.png ,允许所有类型时请使用 . file_types_description String 指定在文件选取窗口中显示的文件类型描述，起一个提示和说明的作用吧 file_size_limit String 指定要上传的文件的最大体积，可以带单位，合法的单位有:B、KB、MB、GB，如果省略了单位，则默认为KB。该属性为0时，表示不限制文件的大小。 file_upload_limit Number 指定最多能上传多少个文件，当上传成功的文件数量达到了这个最大值后，就不能再上传文件了，也不能往上传队列里添加文件了。把该属性设为0时表示不限制文件的上传数量。 file_queue_limit Number 指定文件上传队列里最多能同时存放多少个文件。当超过了这个数目后只有当队列里有文件上传成功、上传出错或被取消上传后，等同数量的其他文件才可以被添加进来。当file_upload_limit的数值或者剩余的能上传的文件数量小于file_queue_limit时，则取那个更小的值 flash_url String swfupload.swf文件的绝对或相对地址，相对地址是指相对于当前的页面地址。实例化swfupload后，就不能再改变该属性的值了。 prevent_swf_caching Boolean 为true时会加一个随机数在swfupload.swf地址的后面，以阻止flash影片被缓存，这是为了防止某些版本的IE浏览器在读取缓存的falsh影片时出现的bug button_placeholder_id String 指定一个dom元素的id,该dom元素在swfupload实例化后会被Flash按钮代替，这个dom元素相当于一个占位符 button_placeholder DOMElement 指定一个dom元素,该dom元素在swfupload实例化后会被Flash按钮代替，这个dom元素相当于一个占位符。当button_placeholder_id与button_placeholder都存在时，以button_placeholder_id为优先 button_image_url String 指定Flash按钮的背景图片，相对地址或绝对地址都可以。该地址会受到preserve_relative_urls属性的影响，遵从与upload_url一样的规则。该背景图片必须是一个sprite图片,从上到下包含了Flash按钮的正常、鼠标悬停、按下、禁用这四种状态。因此该图片的高度应该是Flash按钮高度的四倍 button_width Number 指定Flash按钮的宽度 button_height Number 指定Flash按钮的高度，应该为button_image_url所指定的按钮背景图片高度的1/4 button_text String 指定Flash按钮上的文字，也可以是html代码 button_text_style String Flash按钮上的文字的样式，使用方法见示例 button_text_top_padding Number 指定Flash按钮顶部的内边距，可使用负值 button_text_left_padding Number 指定Flash按钮左边的内边距，可使用负值 button_disabled Boolean false 为true时Flash按钮将变为禁用状态，点击也不会触发任何行为 button_cursor 指定鼠标悬停在Flash按钮上时的光标样式，可用值为SWFUpload.CURSOR里定义的常量 button_window_mode 指定Flash按钮的WMODE属性，可用值为SWFUpload.WINDOW_MODE里定义的常量 file_dialog_start_handler Function fileDialogStart事件侦听函数 file_queued_handler Function fileQueued事件侦听函数 file_queue_error_handler Function fileQueueError事件侦听函数 file_dialog_complete_handler Function fileDialogComplete事件侦听函数 upload_start_handler Function uploadStart事件侦听函数 upload_progress_handler Function uploadProgress事件侦听函数 upload_error_handler Function uploadError事件侦听函数 upload_success_handler Function uploadSuccess事件侦听函数 upload_complete_handler Function uploadComplete事件侦听函数 各种事件说明要实现与用户的交互，靠的就是在这些事件上做文章了 fileDialogStart ( ) 在文件选取窗口将要弹出时触发 fileQueued ( file object ) 当一个文件被添加到上传队列时会触发此事件，提供的唯一参数为包含该文件信息的file object对象 fileQueueError ( file object, error code, message ) 当文件添加到上传队列失败时触发此事件，失败的原因可能是文件大小超过了你允许的数值、文件是空的或者文件队列已经满员了等。该事件提供了三个参数。第一个参数是当前出现问题的文件对象，第二个参数是具体的错误代码，可以参照SWFUpload.QUEUE_ERROR中定义的常量 fileDialogComplete ( number of files selected, number of files queued, total number of files in the queued ) 当文件选取完毕且选取的文件经过处理后（指添加到上传队列），会立即触发该事件。可以在该事件中调用this.startUpload()方法来实现文件的自动上传参数number of files selected指本次在文件选取框里选取的文件数量参数number of files queued指本次被添加到上传队列的文件数量参数total number of files in the queued指当前上传队列里共有多少个文件（包括了本次添加进去的文件） uploadStart ( file object ) 当文件即将上传时会触发该事件,该事件给了你在文件上传前的最后一次机会来验证文件信息、增加要随之上传的附加信息或做其他工作。可以通过返回false来取消本次文件的上传参数file object为当前要上传的文件的信息对象 uploadProgress ( file object, bytes complete, total bytes ) 该事件会在文件的上传过程中反复触发，可以利用该事件来实现上传进度条参数file object为文件信息对象参数bytes complete为当前已上传的字节数参数total bytes为文件总的字节数 uploadError ( file object, error code, message ) 文件上传被中断或是文件没有成功上传时会触发该事件。停止、取消文件上传或是在uploadStart事件中返回false都会引发这个事件，但是如果某个文件被取消了但仍然还在队列中则不会触发该事件参数file object为文件信息对象参数error code为错误代码，具体的可参照SWFUpload.UPLOAD_ERROR中定义的常量 uploadSuccess ( file object, server data, received response ) 当一个文件上传成功后会触发该事件参数file object为文件信息对象参数server data为服务器端输出的数据 uploadComplete( file object ) 当一次文件上传的流程完成时（不管是成功的还是不成功的）会触发该事件，该事件表明本次上传已经完成，上传队列里的下一个文件可以开始上传了。该事件发生后队列中下一个文件的上传将会开始 swfupload实例的方法方法中大多数是动态改变参数配置对象的方法 destroy ( ) 当不需要再使用SWFUpload了的时候,可以使用该方法来销毁它的实例和dom元素 startUpload( file_id ) 开始上传队列中指定的文件参数file_id代表要上传的文件的id，如果未填写这个参数，则会上传队列中第一个文件 cancelUpload ( file_id, trigger_error_event ) 取消文件的上传参数file_id为要取消的文件的id,如果该参数为undefined或者未填写，则会取消队列里的第一个文件参数trigger_error_event接受一个布尔值，当为false时取消文件不会触发uploadError事件，默认为true stopUpload ( ) 终止当前正在上传的文件，会触发uploadError事件。如果当前没有文件在上传，则该方法什么都不会做 getStats ( ) 获取队列的stats object setStats ( stats_object ) 修改队列的stats_object，传入修改过的stats_object作为参数 getFile ( file_id, index ) 根据文件id或文件索引来获取一个File Object,当使用文件id时只能获得队列里的文件，当使用文件索引时所有文件（包括队列内和队列外）都可获得 addPostParam ( name, value) 往配置对象中post_params指定的附加信息对象中增加键/值对 removePostParam ( name) 移除置配置对象中的post_params包含的某一个键/值对，参数name为要移除的值的键名 addFileParam ( file_id, name, value) 为某个特定文件增加随之一起上传的附加信息。注意，只有在该指定的文件上传时，附加的信息才会一起上传。而配置对象中post_param设置的附加信息在任一文件上传时都会与之一起发送。参数file_id为要指定的文件id,参数name和value分别为附加信息的名称和值 removeFileParam ( file_id, name) 移除通过addFileParam方法增加的附加信息，两个参数相信就不用我多讲了吧 setUploadURL ( url) 动态设置配置对象中upload_url的值 setPostParams ( param_object) 动态设置配置对象中post_params属性的值，新的值会覆盖旧的值。参数param_object必须为一个对象直接量，且里面的属性和值都只能为字符串 setFileTypes ( types, description) 动态设置配置对象中file_types 和 file_types_description属性的值。两个参数都不能省略 setFileSizeLimit ( file_size_limit) 动态设置配置对象中file_size_limit属性的值 setFileUploadLimit ( file_upload_limit) 动态设置配置对象中file_upload_limit属性的值 setFileQueueLimit ( file_queue_limit) 动态设置配置对象中file_queue_limit属性的值 setFilePostName ( file_post_name) 动态设置配置对象中file_post_name属性的值 setUseQueryString ( use_query_string) 动态设置配置对象中use_query_string属性的值 setButtonImageURL ( url) 动态设置配置对象中button_image_url属性的值 setButtonDimensions ( width, height) 动态设置Flash按钮的宽度和高度，两个参数分别为宽度和高度的值，类型为数字，且不能带单位 setButtonText ( text) 动态设置配置对象中button_text属性的值 setButtonTextStyle ( css_style_text) 动态设置配置对象中button_text_style属性的值 setButtonTextPadding ( left, top ) 动态设置Flash按钮的左边内边距和顶部内边距 setButtonDisabled ( isDisabled ) 动态对Flash按钮进行禁用和不禁用的操作，参数为一个布尔值 setButtonCursor ( buttonCursor ) 动态设置配置对象中button_cursor的值 文件信息对象 File Object在事件监听函数中，经常要用到文件信息对象来获取文件的信息以供下一步的操作 属性 类型 描述 id String SWFUpload定义的文件id,用来控制文件的上传 index Number 文件的索引，用在getFile(i)方法中 name String 文件的原始名称，不包括路径 type String 文件类型 creationdate Date 文件的创建日期 modificationdate Date 文件的最后修改日期 filestatus Number 当前文件的状态，详细的请参照SWFUpload.FILE_STATUS中定义的常量 队列状态对象 Stats Object用来获取当前队列的状况 属性 类型 描述 in_progress Number 得到的值为1或0，表明当前队列是否有文件正在上传中 files_queued Number 目前上传队列中的文件数量 successful_uploads Number 已成功上传(指触发了uploadSuccess事件)的文件数量 upload_errors Number 上传失败的文件数量(包括被取消上传的文件) upload_cancelled Number 被取消上传的文件数量 queue_errors Number 触发了fileQueueError事件的文件数量 一些常量定义的一些常量，便于理解 常量名 描述 SWFUpload.instances 该常量是一个对象，代表一个页面上所有的SWFUpload实例的引用的集合，用SWFUpload实例的movieName属性进行索引 SWFUpload.movieCount 页面上存在的SWFUpload实例的数量 SWFUpload.QUEUE_ERROR.QUEUE_LIMIT_EXCEEDED 用户选取的文件超过了允许的数量 SWFUpload.QUEUE_ERROR.FILE_EXCEEDS_SIZE_LIMIT 文件的体积超过了允许的大小 SWFUpload.QUEUE_ERROR.ZERO_BYTE_FILE 文件是空的 SWFUpload.QUEUE_ERROR.INVALID_FILETYPE 不允许的文件类型 SWFUpload.UPLOAD_ERROR.HTTP_ERROR 服务器返回的状态码不是200 SWFUpload.UPLOAD_ERROR.MISSING_UPLOAD_URL 没有设置 upload_url SWFUpload.UPLOAD_ERROR.IO_ERROR 读取或传输文件时发生错误 SWFUpload.UPLOAD_ERROR.SECURITY_ERROR 上传受到了安全方面的限制 SWFUpload.UPLOAD_ERROR.UPLOAD_LIMIT_EXCEEDED 上传的文件数量超过了允许的最大值 SWFUpload.UPLOAD_ERROR.UPLOAD_FAILED 上传出现错误 SWFUpload.UPLOAD_ERROR.SPECIFIED_FILE_ID_NOT_FOUND 给startUpload()方法传入的文件id不存在 SWFUpload.UPLOAD_ERROR.FILE_VALIDATION_FAILED uploadStart()方法中返回了false SWFUpload.UPLOAD_ERROR.FILE_CANCELLED 上传被取消了 SWFUpload.UPLOAD_ERROR.UPLOAD_STOPPED 上传被终止了 SWFUpload.FILE_STATUS.QUEUED 文件正在队列中等待上传 SWFUpload.FILE_STATUS.IN_PROGRESS 文件正在上传 SWFUpload.FILE_STATUS.ERROR 文件在添加到队列或是上传的时候出现了错误 SWFUpload.FILE_STATUS.COMPLETE 文件已上传成功 SWFUpload.FILE_STATUS. 文件被取消上传 SWFUpload.CURSOR.ARROW 鼠标以箭头显示 SWFUpload.CURSOR.HAND 鼠标以手形显示 SWFUpload.WINDOW_MODE.WINDOW Flash按钮会显示在页面的所有dom元素上面 SWFUpload.WINDOW_MODE.OPAQUE 允许其他dom元素覆盖住Flash按钮 SWFUpload.WINDOW_MODE.TRANSPARENT 允许Flash按钮透明显示 struts2+swfUpload简单例子index.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;link href="&lt;%=basePath%&gt;css/default.css" rel="stylesheet" type="text/css" /&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;js/swfupload.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;js/swfupload.queue.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;js/fileprogress.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;js/handlers.js"&gt;&lt;/script&gt; &lt;!-- 初始化swfupload 对象--&gt; &lt;script type="text/javascript"&gt; var upload1; window.onload = function() &#123; upload1 = new SWFUpload(&#123; //提交路径 upload_url: "upload.action", //向后台传递额外的参数 post_params: &#123;"name" : "kaobian"&#125;, //上传文件的名称 file_post_name: "file", // 下面自己按照字面意思理解 file_size_limit : "102400", // 100MB file_types : "*.*", file_types_description : "All Files", file_upload_limit : "10", file_queue_limit : "0", // 事件处理 file_dialog_start_handler : fileDialogStart, file_queued_handler : fileQueued, file_queue_error_handler : fileQueueError, file_dialog_complete_handler : fileDialogComplete, upload_start_handler : uploadStart, upload_progress_handler : uploadProgress, upload_error_handler : uploadError, upload_success_handler : uploadSuccess, upload_complete_handler : uploadComplete, // 按钮的处理 button_image_url : "images/XPButtonUploadText_61x22.png", button_placeholder_id : "spanButtonPlaceholder1", button_width: 61, button_height: 22, // Flash Settings flash_url : "js/swfupload.swf", custom_settings : &#123; progressTarget : "fsUploadProgress1", cancelButtonId : "btnCancel1" &#125;, // Debug Settings debug: false &#125;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/div&gt; &lt;div id="content"&gt; &lt;form action="upload.action" method="post" name="thisform" enctype="multipart/form-data"&gt; &lt;table&gt; &lt;tr valign="top"&gt; &lt;td&gt; &lt;div&gt; &lt;div style="padding-left: 5px;"&gt; &lt;span id="spanButtonPlaceholder1"&gt;&lt;/span&gt; &lt;!--&lt;input type="button" value="上传" onclick="upload1.addPostParam('idname',encodeURI(document.getElementById('myFileName').value));upload1.startUpload();"/&gt; --&gt;&lt;input id="btnCancel1" type="button" value="Cancel Uploads" onclick="cancelQueue(upload1);" disabled="disabled" style="margin-left: 2px; height: 22px; font-size: 8pt;" /&gt; &lt;br /&gt; &lt;/div&gt; &lt;div class="fieldset flash" id="fsUploadProgress1"&gt; &lt;span class="legend"&gt;文件上传&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Upload.action12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.action; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import org.apache.struts2.ServletActionContext; import com.opensymphony.xwork2.ActionSupport; public class FileUploadAction extends ActionSupport &#123; private File file; private String fileFileName; private String fileContentType; private String savePath; public String execute() throws Exception &#123; InputStream is = new FileInputStream(file); String root = getSavePath(); //String tempName = System.currentTimeMillis()+this.getFileFileName().substring(this.getFileFileName().indexOf(".")); File deskFile = new File(root, this.getFileFileName()); OutputStream os = new FileOutputStream(deskFile); byte[] bytefer = new byte[1024]; int length = 0; while ((length = is.read(bytefer)) != -1) &#123; os.write(bytefer, 0, length); &#125; os.close(); is.close(); return "success"; &#125; public String getSavePath() &#123; return ServletActionContext.getServletContext().getRealPath(savePath); &#125; public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; public File getFile() &#123; return file; &#125; public void setFile(File file) &#123; this.file = file; &#125; public String getFileFileName() &#123; return fileFileName; &#125; public void setFileFileName(String fileFileName) &#123; this.fileFileName = fileFileName; &#125; public String getFileContentType() &#123; return fileContentType; &#125; public void setFileContentType(String fileContentType) &#123; this.fileContentType = fileContentType; &#125; &#125; Web.xml123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; Struts.xml123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt; &lt;struts&gt; &lt;!-- 配置struts2.1.8 上传是文件的最大限制为100M --&gt; &lt;constant name="struts.multipart.maxSize" value="104857600" /&gt; &lt;!-- 设置struts2 上传文件时 保存的临时目录 --&gt; &lt;constant name="struts.multipart.saveDir" value="C:\temp"&gt;&lt;/constant&gt; &lt;package name="struts2" extends="struts-default"&gt; &lt;action name="upload" class="com.action.FileUploadAction"&gt; &lt;param name="savePath"&gt;/upload&lt;/param&gt; &lt;result name="success"&gt;/index.jsp&lt;/result&gt; &lt;result name="input"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; ​ SWFUpload的上传过程中各个步骤的显示方式要改变；我们需要往服务器传递参数；需要从服务器返回参数；这些问题上面的例子都没有解决。 看下面这个图片，这是我在项目中的SWFUpload上传附件的效果（其实仿的是126邮箱做的）。 上传完成。（上传成功的附件不消失，上传发生错误文件消失。） 删除：删除上传完成的文件（删除后文件逐渐消失）。 SWFUpload如何改upload控件的样式修改上传flash按钮样式SWFUpload Demo文件中提供了一个XPButtonUploadText_61x22.png 图片文件 重新制作一个类似的图片文件替换它。 如果你做的这个图片文件的长款与原图不同，不要忘记修改 12345/ 按钮的处理 button_image_url : "images/XPButtonUploadText_61x22.png", button_placeholder_id : "spanButtonPlaceholder1", button_width: 61, button_height: 22, Java代码 修改上传队列附件样式这个东西的构建是通过fileprogress.js文件和defaut.css来完成的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function FileProgress(file, targetID) &#123; this.fileProgressID = file.id; this.opacity = 100; this.height = 0; this.fileProgressWrapper = document.getElementById(this.fileProgressID); if (!this.fileProgressWrapper) &#123; this.fileProgressWrapper = document.createElement("div"); this.fileProgressWrapper.className = "progressWrapper"; this.fileProgressWrapper.id = this.fileProgressID; this.fileProgressElement = document.createElement("div"); this.fileProgressElement.className = "progressContainer"; var progressCancel = document.createElement("a"); progressCancel.className = "progressCancel"; progressCancel.href = "#"; progressCancel.style.visibility = "hidden"; progressCancel.appendChild(document.createTextNode(" ")); var progressText = document.createElement("div"); progressText.className = "progressName"; progressText.appendChild(document.createTextNode(file.name)); var progressBar = document.createElement("div"); progressBar.className = "progressBarInProgress"; var progressStatus = document.createElement("div"); progressStatus.className = "progressBarStatus"; progressStatus.innerHTML = "&amp;nbsp;"; this.fileProgressElement.appendChild(progressCancel); this.fileProgressElement.appendChild(progressText); this.fileProgressElement.appendChild(progressStatus); this.fileProgressElement.appendChild(progressBar); this.fileProgressWrapper.appendChild(this.fileProgressElement); document.getElementById(targetID).appendChild(this.fileProgressWrapper); &#125; else &#123; this.fileProgressElement = this.fileProgressWrapper.firstChild; this.reset(); &#125; this.height = this.fileProgressWrapper.offsetHeight; this.setTimer(); &#125; //…… &#125; 每当我们选择一个文件上传时它就会new FileProgress(file, this.customSettings.progressTarget); 根据上面的代码分析其实就是在网页中添加了以下html代码 12345678910&lt;div id=file.id class="progressWrapper"&gt; &lt;div class="progressContainer" &gt; &lt;a href="#" class="progressCancel" style="visibility:hidden"&gt; &lt;/a&gt; &lt;div class="progressName"&gt; file.name &lt;/div&gt; &lt;div class="progressBarInProgress"&gt;&lt;/div&gt; &lt;div class="progressBarStatus"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; //css文件在defaut.css中。 //file.id 和file.name 选中上传文件的id和name属性的值。 这段代码会被插入下面这段代码里面 123&lt;div class="fieldset flash" id="fsUploadProgress1"&gt; &lt;span class="legend"&gt;文件上传&lt;/span&gt; &lt;/div&gt; 如果你的css和javascrpt能力很强，动态在页面中创建对象改变这个控件的外貌是不是很容易呢。 选择好事件重写事件代码就ok了。 不过提醒一下，不要改变现有的这些对象的顺序，您看下后面的代码就这道了。 12this.fileProgressElement.childNodes[3].className = "progressBarInProgress"; this.fileProgressElement.childNodes[3].style.width = percentage + "%"; 如何控制上传队列中的文件消失（hidden）情况12// Fades out and clips away the FileProgress box. FileProgress.prototype.disappear = function () &#123;//…&#125; 这段代码是FileProgress文件disappear的属性代码。 1) 如果想上传后FileProgress不消失 在fileprogress.js文件找到下面代码，像我一样注释掉最后3行就ok了。当然你也可以在相应的事件中重写函数。 12345678910FileProgress.prototype.setComplete = function () &#123; this.fileProgressElement.className = "progressContainer blue"; this.fileProgressElement.childNodes[3].className = "progressBarComplete"; this.fileProgressElement.childNodes[3].style.width = ""; var oSelf = this; //this.setTimer(setTimeout(function () &#123; // oSelf.disappear(); //&#125;, 10000)); &#125;; ​ 2) 删除的时候让FileProgress消失 在fileprogress.js文件中增加 12345678910FileProgress.prototype.setDelete = function () &#123; this.fileProgressElement.className = "progressContainer"; this.fileProgressElement.childNodes[3].className = "progressBarError"; this.fileProgressElement.childNodes[3].style.width = ""; var oSelf = this; this.setTimer(setTimeout(function () &#123; oSelf.disappear(); &#125;, 0)); &#125;; 在删除事件中调用即可。 SWFUpload向服务器传递参数 SWFUpload传递参数有3中方式： 1、在url后加连接： 1upload_url: "&lt;%=basePath%&gt;upload?action=up", 2、使用swfupload传递参数，在setting中配置 1234567post_params: &#123; "hello" : "Here I Am", "name" : "张三", "ff" : document.getElementById("tf").value &#125;, use_query_string : true,//要传递参数用到的配置 3、采用swfupload的函数： 1addPostParam("myFileName",encodeURI(file.name));//这个是我用来传递文件名称的 ​ 我的方法是修改了一下uploadStart函数 1234567891011121314151617function uploadStart(file) &#123; try &#123; /* I don't want to do any file validation or anything, I'll just update the UI and return true to indicate that the upload should start */ var progress = new FileProgress(file, this.customSettings.progressTarget); //progress.setStatus("Uploading..."); progress.setStatus("上传中..."); progress.toggleCancel(true, this); this.setPostParams(&#123; 'fileName':encodeURIComponent(file.name) &#125;); &#125; catch (ex) &#123; &#125; return true; &#125; SWFUpload接受服务器Action返回的参数 首先我们要了解这个函数 1234567891011function uploadSuccess(file, serverData) &#123; try &#123; var progress = new FileProgress(file, this.customSettings.progressTarget); progress.setComplete(); progress.setStatus("Complete."); progress.toggleCancel(false); &#125; catch (ex) &#123; this.debug(ex); &#125; &#125; file为上传的文件对象，我们可以获得，file.id、file.name、file.type、file.size 等信息。 serverData的意思是服务器返回的数据，如果你指定页面，那服务器返回的应该就是这个jsp的数据了，这里最好用type=json的格式 action 代码 123456789101112//…… //返回页面信息 HttpServletResponse response=ServletActionContext.getResponse(); response.setContentType("text/html; charset=UTF-8"); response.setHeader("Cache-Control", "no-cache"); PrintWriter out = response.getWriter(); out.write(“action返回的参数”); out.flush(); out.close(); return SUCCESS; struts.xml 123456&lt;package name="upload"[color=red] extends="json-default" [/color]namespace=""&gt; &lt;action name="upload" class="com.action.FileUploadAction"&gt; &lt;param name="savePath"&gt;/upload&lt;/param&gt; &lt;result name="success" type="json"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 这个配置会出现一个bug（如果你以前没用过json插件的话） 当前使用struts2.23版本，使用了jsonplugin-0.3x.jar报错 引用 java.lang.ClassNotFoundException: com.opensymphony.xwork2.util.TextUtils 解决： 在下载好的Struts2的lib文件夹里找到了以下jar包： 引用 json-lib-2.x.jarstruts2-json-plugin-2.x.x.jarstruts2-junit-plugin-2.x.x.jar 上面三个包加入项目里之后，再删除jsonplugin-0.3x.jar包 SWFUpload中文乱码问题 在网上搜的帖子，关于这个问题的解决方法有很多。 第一种：fileName= new String(fileName.getBytes(&quot;UTF-8&quot;),&quot;GBK&quot;);用这种方式能解决大部分乱码，但如果文件名中有特殊字符和标点符号有时候会转不过来。第二种：我使用的是这种办法，测试已经通过 123456789101112131415161718192021/**在设置时需要设置一下上传事件 *upload_start_handler : UploadStart, *动态传参数，解决文件名中文乱码问题 **/ function uploadStart(file) &#123; try &#123; /* I don't want to do any file validation or anything, I'll just update the UI and return true to indicate that the upload should start */ var progress = new FileProgress(file, this.customSettings.progressTarget); //progress.setStatus("Uploading..."); progress.setStatus("上传中..."); progress.toggleCancel(true, this); this.setPostParams(&#123; 'fileName':&lt;span style="color: #ff0000;"&gt;encodeURIComponent(file.name) &lt;/span&gt; &#125;); &#125; catch (ex) &#123; &#125; return true; &#125; 在action中使用 1fileName = URLDecoder.decode(fileName, "UTF-8"); ​ 第三种：配置web.config配置文件这种方法我没试，不知道行不行。 参考：谈web开中几种经典的大文件上传组件]]></content>
      <categories>
        <category>fileupload</category>
      </categories>
      <tags>
        <tag>swfupload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo高级教程SEO优化]]></title>
    <url>%2Fblog%2F180.html</url>
    <content type="text"><![CDATA[hexo高阶教程next主题优化之加入网易云音乐、网易云跟帖、动态背景、自定义主题、统计功能，本着生命就是要折腾的原则，我又做了如下的优化： ● seo优化 ● 多终端修改项目 ● 同时托管到github和coding上 ● 设置google和百度sitemap，让搜索引擎更好的抓取你的网站 ● 使用gulp对css、js进行优化 ● 接入七牛图床 ● 加入打赏功能 ● 加入照片模块我们要做对搜索引擎友好的站点所以我就在想，怎么才能让其他小伙伴搜索到我写的文章呢？于是就想到了对网站进行seo优化，这段时间也一直在做网站的seo优化，对于hexo生成的博客来说，代码其实修改的并不多，主要是要多用心去给各个搜索引擎提交你的sitemap，让搜索引擎的小蜘蛛多来你的站点，这样别人在搜索东西的时候才有更多的可能搜出你的文章，给你的网站带来人气~作为一个前端工作者，对网站的优化肯定还是需要有很多的，奈何时间基本都被工作占用，所以就先把优化功能先放了放，只进行了代码压缩在这半个月的时间，对于hexo搭建搭建的个人博客，虽然没有让我对某一门语言的深度增加，但是却让我对整个建站流程的宽度增加了不少，优化是一件比写出代码的技术难度还要高的事情。seo优化推广是一个烦人的事情啊喂，特别是对于我们搞技术的来说，可能就不擅长推广，那么怎么才能让别人知道我们呢，我们就要想办法让别人通过搜索就可以搜索到你博客的内容，给我们带来自然流量，这就需要seo优化,让我们的站点变得对搜索引擎友好SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。让百度收录你的站点我们首先要做的就是让各大搜索引擎收录你的站点，我们在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入site:&lt;域名&gt;,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站 验证网站所有权登录百度站长平台：http://zhanzhang.baidu.com,只要有百度旗下的账号就可以登录，登录成功之后在站点管理中点击添加网站然后输入你的站点地址，建议输入的网站为www开头的，不要输入github.io的，因为github是不允许百度的spider爬取github上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名 在选择完网站的类型之后需要验证网站的所有权，验证网站所有权的方式有三种：文件验证。html标签验证和cname解析验证，使用哪一种方式都可以，都是比较简单的，但是一定要注意，使用文件验证文件存放的位置需要放在source文件夹下，如果是html文件那么hexo就会将其编译，所以必须要加上的layout:false，这样就不会被hexo编译。（如果验证文件是txt格式的就不需要），其他两种方式也是很简单的，我个人推荐文件验证和cname验证，cname验证最为简单，只需加一条解析就好~ 生成网站地图我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎安装sitemap插件12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 修改博客配置文件在根目录配置文件中修改url为你的站点地址123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://cherryblog.siteroot: /permalink: :title.htmlpermalink_defaults: 执行完之后就会在网站根目录生成sitemap.xml文件和baidusitemap.xml文件，可以通过http://www.cherryblog.site/baidusitemap.xml,查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。向百度提交链接然后我们就可以将我们生成的sitemap文件提交给百度，还是在百度站长平台，找到链接提交，这里我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap如何选择链接提交方式1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。4、手动提交：一次性提交链接给百度，可以使用此种方式。一般主动提交比手动提交效果好，这里介绍主动提交的三种方法从效率上来说：主动推送&gt;自动推送&gt;sitemap 主动推送安装插件npm install hexo-baidu-url-submit –save然后再根目录的配置文件中新增字段12345baidu_url_submit: count: 100 # 提交最新的一个链接 host: www.cherryblog.site # 在百度站长平台中注册的域名 token: 8OGYpxowYnhgVsUM # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 在加入新的deploye12deploy: - type:baidu_url_submitter 这样执行hexo deploy的时候，新的链接就会被推送了设置自动推送在主题配置文件下设置,将baidu_push设置为true：12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true 然后就会将一下代码自动推送到百度，位置是themes\next\layout_scripts\baidu_push.swig,这样每次访问博客中的页面就会自动向百度提交sitemap 12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; sitemap将我们上一步生成的sitemap文件提交到百度就可以了~ 我记得被百度收录过程还是蛮久的，一度让我以为我的方法有问题，提交链接在站长工具中有显示大概是有两天的时候，站点被百度收录大概花了半个月= =，让大家看一下现在的成果在百度搜索site:cherryblog.site已经可以搜索到结果 在搜索框输入域名也可以找到站点 输入关键字的名字也可以在第二页就找到呢，好开森~ 让google收录你的站点相比于百度，google的效率实在不能更快，貌似十分钟左右站点就被收录了，其实方法是和百度是一样的，都是先验证你的站点所有权，然后提交sitemapgoogle站点平台：https://www.google.com/webmasters/，然后就是注册账号、验证站点、提交sitemap，一步一步来就好，过不了过久就可以被google收录了 让其他搜索引擎收录你的站点除了百度和google两大搜索引擎，还有搜狗、360等其他的搜索引擎，流程都是一样的，大家就自行选择添加哈，这里就不再赘述了~优化你的urlseo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：1234url: http://cherryblog.siteroot: /permalink: :title.htmlpermalink_defaults: 其他seo优化seo优化应该说是一个收益延迟的行为，可能你做的优化短期内看不到什么效果，但是一定要坚持，seo优化也是有很深的可以研究的东西，从我们最初的网站设计，和最基础的标签的选择都有很大的关系，网站设计就如我们刚刚说的，要让用户点击三次可以到达网站的任何一个页面，要增加高质量的外链，增加相关推荐（比如说我们经常见到右侧本站的最高阅读的排名列表），然后就是给每一个页面加上keyword和描述在代码中，我们应该写出能让浏览器识别的语义化HTML，这样有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；并且对外链设置nofollow标签，避免spider爬着爬着就爬出去了（减少网站的跳出率），并且我们要尽量在一些比较大的网站增加我们站点的曝光率，因为spider会经常访问大站，比如我们在掘金等技术社区发表文章中带有我们的站点，这样spider是很有可能爬到我们中的站点的，so…. 网站外链的推广度、数量和质量 网站的内链足够强大 网站的原创质量 网站的年龄时间 网站的更新频率（更新次数越多越好） 网站的服务器 网站的流量：流量越高网站的权重越高 网站的关键词排名：关键词排名越靠前，网站的权重越高 网站的收录数量：网站百度收录数量越多，网站百度权重越高 网站的浏览量及深度：用户体验越好，网站的百度权重越高同时托管到github和coding上前面已经提到过一个惨绝人寰的消息，那就是github是不允许百度的爬虫爬取内容的，所以我们的项目如果是托管在github上的话基本是不会被百度收录的，所以我又同时托管到了coding上，然后在做解析的时候海外的ip 指向到github，国内的或者说百度的直接指向coding将你的项目托管在coding上 Coding 是一个面向开发者的云端开发平台[1] ，目前提供代码托管，运行空间，质量控制，项目管理等功能。此外，还提供社会化协作功能，包含了社交元素，方便开发者进行技术讨论和协作。2016年3月CODING宣布收购代码托管平台GitCafe。之前好多小伙伴都是将项目托管在gitcafe上，但是现在gitcafe被coding收购了，于是就转到coding上了，之前好多人说github的服务器在国外，于是就转战国内的coding了，我将代码迁移至coding还有另外一个原因，github不让百度的爬虫爬取啊，让我哭一会，不然也不会这样折腾。coding就是中国版的github（只是打一个比喻），有提供pages服务。在coding上创建仓库首先我们先要创建一个coding账号并且在coding上创建一个项目,必须要是公开项目，私有项目是没有page服务的，项目名称可以随意起 将hexo博客同步到新创建的仓库中第一次使用coding需要使用ssh，方法和之前github是一样一样的，将ssh公钥复制到coding上 在coding中添加过ssh公钥之后我们需要修改hexo根目录下的配置文件,官方要求配置格式如下 123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 所以我的配置就是这样的(我这个配置github和coding都有ssh和https两种方式)： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: #github: git@github.com:sunshine940326/sunshine940326.github.io.git github: https://github.com/sunshine940326/sunshine940326.github.io.git coding: git@git.coding.net:cherry940326/cherry940326.git #coding: https://git.coding.net/cherry940326/cherry940326.git 完成之后在git bash 中输入ssh -T git@git.coding.net ● 1如果得到如图提示就说明配置成功了 然后重新部署hexo就将代码上传至coding上了设置coding的pages服务将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了 设置域名解析然后我们到万网下面设置我们的域名解析，将默认ip解析到coding上（这里要注意，解析到coding时记录值是pages.coding.me，并没有具体的账号名或者仓库名，并且只有设置完成域名解析才可以在coding上设置自定义域名），将海外的ip解析到github上，设置如下： 至此就完成了将你的hexo编译的博客同时部署在github和coding上多终端编辑hexo博客之前就想到了一个问题，如果我想要在公司写博客怎么办，或者说如果我换电脑了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上，这道题的解题思路（哈哈，突然想到这个词了）是，将我们的源文件上传至username.github.io的Hexo分支，并且设置为默认分支（分支需要自己创建），然后对我们的源文件进行版本管理，这样我们就可以在另一台电脑上pull我们的源码，然后编译完之后push上去。更为优雅的方式是使用travis-ci，然后用webhook自动部署。你只需要写markdown，push到github就行了。根本不用关心deploy，只要维护你的markdown就行。详情请参考：http://blog.bigruan.com/2015-03-09-Continuous-Integration-Your-Hexo-Blog-With-TravisCI/创建Hexo分支创建两个分支：master 与 Hexo,并将Hexo设置为默认分支（这个Hexo分支就是存放我们源文件的分支，我们只需要更新Hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的）删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件因为有些主题是从git上clone过来的，所以我们要先删除.git缓存文件，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。.git文件夹被删除后整个文件对应的git仓库状态也会被清空).gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容： 123/.deploy_git/public /_config.yml .deploy_git是hexo默认的.git配置文件夹，不需要同步public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制 12git initgit remote add origin &lt;server&gt; 是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端将博客源文件上传至Hexo分支依次执行 123git add .git commit -m &quot;...&quot;git push origin hexo 提交网站相关的文件；对B电脑进行的操作假设B电脑现在没有我们的源文件 1234git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。git fetch --allgit reset --hard origin/master 日常改动平时我们对源文件有修改的时候记得先pull一遍代码，再将代码push到Hexo分支，就和日常的使用git一样~ 依次执行git add .、git commit -m “…”、git push origin Hexo指令将改动推送到GitHub（此时当前分支应为Hexo）； 然后才执行hexo g -d发布网站到master分支上。使用gulp压缩你的代码当你在你的博客页面右键查看源代码的时候，你会发现你的html页面中会有大段大段的空白，这个时候我们就要使用压缩工具对我们的代码进行压缩，在前一段时间参见的前端开发者大会（FDCon2017）中，携程的框架式就有讲到，在携程，线上的资源是需要申请的（单位具体到k），所以说我们的代码不压缩实在是太奢侈~什么是gulp在2017年的前端中，gulp似乎不是最流行的自动化工具，但是谁让我们公司用的是gulp呢。为了能和公司用一样的构建工具，所以我自己的博客也是使用的gulp。gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器。不仅能对网站的资源进行优化，并且能在开发过程中能够对很多重复的任务使其自动完成。能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。既然gulp是基于node，所以我们就要先有node环境，不过我们本身就是使用hexo构建我们的博客，就已经是基于node环境了~npm小知识npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）使用npm安装插件：npm install [g] [–save -dev]● :node 插件名称● -g:全局安装，会在node安装的根目录下载对应的包，在计算机的任何文件都可以使用该插件，默认的node安装目录是：C:\Users\Administrator\AppData\Roaming\npm;如果不带该属性，将会安装在当前目录，下载安装包的位置是当前目录的node_modules文件夹● –save：将配置信息保存在node项目配置文件package.json中● -dev：保存至package.json 的devDependencies节点，如果没有该属性，该插件将会被保存至dependencies节点，devDependencies和dependencies有什么区别呢？其实从名字就应该可以看出来两者的区别，devDependencies中dev是development（开发）的缩写，dependencies是依赖的意思。所以 dependencies 是程序正常运行所需要安装的依赖，而devDependencies是开发所需要的依赖，比如一些单元测试的包~● 为什么要保存至package.json？因为我们使用node的时候需要很多的包，所以我们将我们的配置信息，也就是我们需要包的名称等其他信息保存至一个文件中，如果说其他开发者就可以直接使用一个命令就可以安装和我们相同的配置，这个命令就是npm install，就可以下载package.json 下所有需要的包。npm install –production则只下载dependencies下的包使用npm卸载插件：npm unstall [-g] [–save-dev]● 在npm中要卸载插件不是将文件夹删除就可以了，因为你的配置信息还在package中，所以要使用npm unstall [-g] [–save-dev] 命令● 删除全部插件:rimraf node_modules（首先你需要先安装rimraf 插件）更新npm插件：npm update [g] [–save-dev]使用cnpm什么是cnpm呢，大家都知道，由于不可描述原因，我们访问国外的资源有时候的速度，大家懂的，所以淘宝除了一个npm镜像，服务器就在中国。c可以理解为China（应该可以这样理解吧）,cnpm使用方法和npm完全相同，只需将npm全部换成cnpm就可以。本文都是使用的npm，如果想要尝试cnpmde的麻烦自行替换~这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。cnpm 官网地址：http://npm.taobao.org；安装命令为npm install cnpm -g –registry=https://registry.npm.taobao.org注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；全局安装gulp言归正传，简单介绍了gulp和npm，我们需要的是使用gulp压缩我们的代码npm install gulp -g,然后npm -v 查看版本号就可以知道我们是不是安装成功了~★,°:.☆(￣▽￣)/$:.°★。撒花！新建package.json使用npm init就可以创建package.json文件 ，然后输入yes之后你就会在文件夹中找到创建好的package.json文件。来贴一下我现在的package.json文件，已经是安装了不少包的了~ 123456789101112131415161718192021222324252627282930313233343536&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.2.2" &#125;, "dependencies": &#123; "gulp": "^3.9.1", "gulp-htmlclean": "^2.7.14", "gulp-htmlmin": "^3.0.0", "gulp-imagemin": "^3.2.0", "gulp-minify-css": "^1.2.4", "gulp-uglify": "^2.1.2", "hexo": "^3.2.0", "hexo-baidu-url-submit": "0.0.5", "hexo-deployer-git": "^0.2.0", "hexo-generator-archive": "^0.1.4", "hexo-generator-baidu-sitemap": "^0.1.2", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.0", "hexo-generator-sitemap": "^1.1.2", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.2.0", "hexo-renderer-marked": "^0.2.10", "hexo-renderer-stylus": "^0.3.1", "hexo-server": "^0.2.0", "hexo-util": "^0.6.0", "hexo-wordcount": "^2.0.1" &#125;, "devDependencies": &#123; "gulp-babel": "^6.1.2", "gulp-clean": "^0.3.2", "hexo-generator-baidu-sitemap": "^0.1.2" &#125;&#125; 本地安装gulp插件在你的Hexo目录下右键git bash here然后执行npm install –save,和gulp有关的包名称有以下几个，只需将替换一下就好~ 123456"gulp": "^3.9.1", "gulp-htmlclean": "^2.7.14", "gulp-htmlmin": "^3.0.0", "gulp-imagemin": "^3.2.0", "gulp-minify-css": "^1.2.4", "gulp-uglify": "^2.1.2", 聪明的你是不是觉得有些眼熟，对的，就是我po出来的package.json中dependencies下面对应的包名称和版本号~是不是和刚刚所讲的npm的知识联系到了一块呢~建立gulp.jsgulp.js是gulp的配置文件，需要我们手动创建（应该还会有更高级的方法T T ）我的gulp.js文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 获取 gulp-imagemin 模块var imagemin = require('gulp-imagemin')// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input checked /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type="text/javascript" removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type="text/css" minifyJS: true, //压缩页面JS minifyCSS: true //压缩页面CSS &#125;)) .on('error', function(err) &#123; console.log('html Error!', err.message); this.end(); &#125;) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src('./photos/*.*') // 2. 压缩图片 .pipe(imagemin(&#123; progressive: true &#125;)) // 3. 另存图片 .pipe(gulp.dest('dist/images'))&#125;);// 执行 gulp 命令时执行的任务gulp.task('build', [ 'minify-html','minify-css','minify-js','images',]); 执行gulp：gulp build 在git bash中执行在git bash中直接输入命令gulp build就可以，这个gulp build是你自己创建的任务，你创建的任务是什么名的就在gulp后面跟什么名字在webstorm中执行webstorm真的太强大，已经帮我们继承了gulp，我们只需要动动鼠标就可以执行gulp 增加七牛图床增加七牛图床就是要将我们电脑上的图片上传至七牛，然后获得外链，在我们使用md写博客的时候直接插入外链，更方便的是可以直接获取带水印、压缩、剪裁过后的图片~注册七牛万年不变的第一步，注册。官网：七牛云上传资源在登录成功之后，点击对象存储 上传完图片之后，关闭上传页面，可以在图片列表的最后面有一个眼睛的icon，点击之后就会在右下角找到该图片的外链，在用md写博客的时候就可以直接加入外链就好~也可以对上传的源文件进行重命名，因为大部分我上传到七牛上的图片都是相册中使用的，所以我将源文件的名字都改成统一的形式，在引用的时候只需要修改最后的数字就可以~ 添加水印使用七牛图床最棒的地方在于可以对图片进行处理，我就只拿添加水印来举例。七牛可以对上传的图片添加图片样式 增加图片样式就是对图片进行处理，这里的处理方式有很多，比如缩放方式、裁剪、增加图片水印、设置输出格式。 在设置了图片样式之后我们要怎么使用呢，开始我也是一脸懵逼的，不知道怎么使用，百度之后才知道，你直接访问获取的外链就是你上传的原图，在外链的后面加上连接符和你的样式名称访问的就是经过处理后的图片，有没有很赞~既可以访问到你的原图片，也可以访问到经过处理后的图片，只不过是连接不同，还可以给一个图片增加多个样式访问，就不需要我们一张一张对图片进行处理了~简直不能太赞~(～￣▽￣)～]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击漏洞修复]]></title>
    <url>%2Fblog%2F26499.html</url>
    <content type="text"><![CDATA[​ 跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。​ XSS攻击分成两类，一类是来自内部的攻击，主要指的是利用程序自身的漏洞，构造跨站语句，如:dvbbs的showerror.asp存在的跨站漏洞。另一类则是来自外部的攻击，主要指的自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个有跨站漏洞的网页，然后构造跨站语句，通过结合其它技术，如社会工程学等，欺骗目标服务器的管理员打开。XSS分为：存储型和反射型​ 存储型XSS：存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。​ 反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。 web.xml里面加入XssFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.jeecms.common.web.XssFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;SplitChar&lt;/param-name&gt; &lt;param-value&gt;@&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;FilterChar&lt;/param-name&gt; &lt;param-value&gt;'@"@\@#@:@%@&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ReplaceChar&lt;/param-name&gt; &lt;param-value&gt;\'@\"@＼@＃@：@％@＞&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jhtml&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;processTime&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;osivFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/jeeadmin/jeecms/login.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; XssFilter类源码123456789101112131415161718192021222324252627import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;public class XssFilter implements Filter &#123; private String filterChar; private String replaceChar; private String splitChar; FilterConfig filterConfig = null; public void init(FilterConfig filterConfig) throws ServletException &#123; this.filterChar=filterConfig.getInitParameter("FilterChar"); this.replaceChar=filterConfig.getInitParameter("ReplaceChar"); this.splitChar=filterConfig.getInitParameter("SplitChar"); this.filterConfig = filterConfig; &#125; public void destroy() &#123; this.filterConfig = null; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; chain.doFilter(new XssHttpServletRequestWrapper((HttpServletRequest) request,filterChar,replaceChar,splitChar), response); &#125;&#125; XssFilter实现方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import static com.jeecms.common.web.Constants.UTF8;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import org.apache.commons.lang.StringUtils;/** * @author Tom */public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; private String[]filterChars; private String[]replaceChars; public XssHttpServletRequestWrapper(HttpServletRequest request,String filterChar,String replaceChar,String splitChar) &#123; super(request); if(filterChar!=null&amp;&amp;filterChar.length()&gt;0)&#123; filterChars=filterChar.split(splitChar); &#125; if(replaceChar!=null&amp;&amp;replaceChar.length()&gt;0)&#123; replaceChars=replaceChar.split(splitChar); &#125; &#125; public String getQueryString() &#123; String value = super.getQueryString(); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt; * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖 */ public String getParameter(String name) &#123; String value = super.getParameter(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; public String[] getParameterValues(String name) &#123; String[]parameters=super.getParameterValues(name); if (parameters==null||parameters.length == 0) &#123; return null; &#125; for (int i = 0; i &lt; parameters.length; i++) &#123; parameters[i] = xssEncode(parameters[i]); &#125; return parameters; &#125; /** * 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt; getHeaderNames 也可能需要覆盖 */ public String getHeader(String name) &#123; String value = super.getHeader(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 将容易引起xss漏洞的半角字符直接替换成全角字符 * * @param s * @return */ private String xssEncode(String s) &#123; if (s == null || s.equals("")) &#123; return s; &#125; //%作为特殊解码字符，get方式提交的汉字+%会解码不了 try &#123; s = URLDecoder.decode(s, UTF8); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;catch(Exception e)&#123; &#125; for (int i = 0; i &lt; filterChars.length; i++) &#123; if(s.contains(filterChars[i]))&#123; s=s.replace(filterChars[i], replaceChars[i]); &#125; &#125; return s; &#125;&#125; 相关资料：XSS漏洞解析：https://www.secpulse.com/archives/48976.html]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene的Field域和索引维护]]></title>
    <url>%2Fblog%2F40393.html</url>
    <content type="text"><![CDATA[一、Field域1.Field属性Field是文档中的域，包括Field名和Field值两部分，一个文档可以包括多个Field，Document只是Field的一个承载体，Field值即为要索引的内容，也是要搜索的内容。是否分词(tokenized)是：作分词处理，即将Field值进行分词，分词的目的是为了索引。比如：商品名称、商品简介等，这些内容用户要输入关键字搜索，由于搜索的内容格式大、内容多需要分词后将语汇单元索引。 否：不作分词处理比如：商品id、订单号、身份证号等 是否索引(indexed)是：进行索引。将Field分词后的词或整个Field值进行索引，索引的目的是为了搜索。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。 否：不索引。该域的内容无法搜索到比如：商品id、文件路径、图片路径等，不用作为查询条件的不用索引。 是否存储(stored)是：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。 否：不存储Field值，不存储的Field无法通过Document获取比如：商品简介，内容较大不用存储。如果要向用户展示商品简介可以从系统的关系数据库中获取商品简介。 如果需要商品描述，则根据搜索出的商品ID去数据库中查询，然后显示出商品描述信息即可。 2.Field常用类型开发中常用 的Filed类型，注意Field的属性，根据需求选择： Field常用类型.PNG3.Field改进代码图书id： 是否分词：不用分词，因为不会根据商品id来搜索商品是否索引：不索引，因为不需要根据图书ID进行搜索是否存储：要存储，因为查询结果页面需要使用id这个值。图书名称： 是否分词：要分词，因为要将图书的名称内容分词索引，根据关键搜索图书名称抽取的词。是否索引：要索引。是否存储：要存储。图书价格： 是否分词：要分词，lucene对数字型的值只要有搜索需求的都要分词和索引，因为lucene对数字型的内容要特殊分词处理，本例子可能要根据价格范围搜索，需要分词和索引。是否索引：要索引是否存储：要存储图书图片地址： 是否分词：不分词是否索引：不索引是否存储：要存储图书描述： 是否分词：要分词是否索引：要索引是否存储：因为图书描述内容量大，不在查询结果页面直接显示，不存储。不存储是来不在lucene的索引文件中记录，节省lucene的索引文件空间，如果要在详情页面显示描述，思路：从lucene中取出图书的id，根据图书的id查询关系数据库中book表得到描述信息。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void createIndex() throws Exception &#123;// 采集数据BookDao dao = new BookDaoImpl();List&lt;Book&gt; list = dao.queryBooks();// 将采集到的数据封装到Document对象中List&lt;Document&gt; docList = new ArrayList&lt;&gt;();Document document;for (Book book : list) &#123; document = new Document(); // store:如果是yes，则说明存储到文档域中 // 图书ID // 不分词、索引、存储 StringField Field id = new StringField("id", book.getId().toString(), Store.YES); // 图书名称 // 分词、索引、存储 TextField Field name = new TextField("name", book.getName(), Store.YES); // 图书价格 // 分词、索引、存储 但是是数字类型，所以使用FloatField Field price = new FloatField("price", book.getPrice(), Store.YES); // 图书图片地址 // 不分词、不索引、存储 StoredField Field pic = new StoredField("pic", book.getPic()); // 图书描述 // 分词、索引、不存储 TextField Field description = new TextField("description", book.getDescription(), Store.NO); // 设置boost值 if (book.getId() == 4) description.setBoost(100f); // 将field域设置到Document对象中 document.add(id); document.add(name); document.add(price); document.add(pic); document.add(description); docList.add(document);&#125; 二、索引维护需求： 管理人员通过电商系统更改图书信息，这时更新的是数据库，如果使用lucene搜索图书信息需要在数据库表book信息变化时及时更新lucene索引库。 1.添加索引调用 indexWriter.addDocument（doc）添加索引。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Testpublic void createIndex() throws Exception &#123;// 采集数据BookDao dao = new BookDaoImpl();List&lt;Book&gt; list = dao.queryBooks();// 将采集到的数据封装到Document对象中List&lt;Document&gt; docList = new ArrayList&lt;&gt;();Document document;for (Book book : list) &#123; document = new Document(); // store:如果是yes，则说明存储到文档域中 // 图书ID Field id = new TextField("id", book.getId().toString(), Store.YES); // 图书名称 Field name = new TextField("name", book.getName(), Store.YES); // 图书价格 Field price = new TextField("price", book.getPrice().toString(), Store.YES); // 图书图片地址 Field pic = new TextField("pic", book.getPic(), Store.YES); // 图书描述 Field description = new TextField("description", book.getDescription(), Store.YES); // 将field域设置到Document对象中 document.add(id); document.add(name); document.add(price); document.add(pic); document.add(description); docList.add(document);&#125;// 创建分词器，标准分词器Analyzer analyzer = new StandardAnalyzer();// 创建IndexWriterIndexWriterConfig cfg = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);// 指定索引库的地址File indexFile = new File("E:\\11-index\\hm19\\");Directory directory = FSDirectory.open(indexFile);IndexWriter writer = new IndexWriter(directory, cfg);// 通过IndexWriter对象将Document写入到索引库中for (Document doc : docList) &#123; writer.addDocument(doc);&#125;// 关闭writerwriter.close();&#125; 2.删除索引2.1删除指定索引 根据Term项删除索引，满足条件的将全部删除。 Term是索引域中最小的单位。根据条件删除时，建议根据唯一键来进行删除。在solr中就是根据ID来进行删除和修改操作的。 12345678910111213141516171819@Testpublic void deleteIndex() throws Exception &#123;// 创建分词器，标准分词器Analyzer analyzer = new StandardAnalyzer();// 创建IndexWriterIndexWriterConfig cfg = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);Directory directory = FSDirectory .open(new File("E:\\11-index\\hcx\\"));// 创建IndexWriterIndexWriter writer = new IndexWriter(directory, cfg);// Termswriter.deleteDocuments(new Term("id", "1"));writer.close();&#125; 2.2删除全部索引（慎用） 将索引目录的索引信息全部删除，直接彻底删除，无法恢复。慎用！ 123456789101112131415161718// 删除索引@Testpublic void deleteIndex() throws Exception &#123;// 1、指定索引库目录Directory directory = FSDirectory.open(new File("E:\\11-index\\0720"));// 2、创建IndexWriterConfigIndexWriterConfig cfg = new IndexWriterConfig(Version.LATEST, new StandardAnalyzer());// 3、 创建IndexWriterIndexWriter writer = new IndexWriter(directory, cfg);// 4、通过IndexWriter来删除索引// a)、删除全部索引writer.deleteAll();// 5、关闭IndexWriterwriter.close();&#125; 建议参照关系数据库基于主键删除方式，所以在创建索引时需要创建一个主键Field，删除时根据此主键Field删除。 索引删除后将放在Lucene的回收站中，Lucene3.X版本可以恢复删除的文档，3.X之后无法恢复。 3.修改索引更新索引是先删除再添加，建议对更新需求采用此方法并且要保证对已存在的索引执行更新，可以先查询出来，确定更新记录存在执行更新操作。 123456789101112131415161718192021222324@Testpublic void updateIndex() throws Exception &#123;// 创建分词器，标准分词器Analyzer analyzer = new StandardAnalyzer();// 创建IndexWriterIndexWriterConfig cfg = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);Directory directory = FSDirectory .open(new File("E:\\11-index\\hcx\\"));// 创建IndexWriterIndexWriter writer = new IndexWriter(directory, cfg);// 第一个参数：指定查询条件// 第二个参数：修改之后的对象// 修改时如果根据查询条件，可以查询出结果，则将以前的删掉，然后覆盖新的Document对象，如果没有查询出结果，则新增一个Document// 修改流程即：先查询，再删除，在添加Document doc = new Document();doc.add(new TextField("name", "lisi", Store.YES));writer.updateDocument(new Term("name", "zhangsan"), doc);writer.close(); }]]></content>
      <categories>
        <category>Lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene全文搜索解析]]></title>
    <url>%2Fblog%2F3536.html</url>
    <content type="text"><![CDATA[一、创建查询对象的方式对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法。类似关系数据库Sql语法一样，Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。可通过两种方法创建查询对象： 使用Lucene提供Query子类Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。 如下代码： Query query = new TermQuery(new Term(“name”, “lucene”));使用QueryParse解析查询表达式QueryParser会将用户输入的查询表达式解析成Query对象实例。如下代码： QueryParser queryParser = new QueryParser(“name”, new IKAnalyzer());Query query = queryParser.parse(“name:lucene”);二、通过Query子类搜索2.1 TermQueryTermQuery项查询，TermQuery不使用分析器，搜索关键词作为整体来匹配Field域中的词进行查询，比如订单号、分类ID号等。 private void doSearch(Query query) {12345678910111213141516171819202122232425262728293031323334353637IndexReader reader = null;try &#123; // a) 指定索引库目录 Directory indexdirectory = FSDirectory.open(new File( "E:\\11-index\\0720")); // b) 创建IndexReader对象 reader = DirectoryReader.open(indexdirectory); // c) 创建IndexSearcher对象 IndexSearcher searcher = new IndexSearcher(reader); // d) 通过IndexSearcher对象执行查询索引库，返回TopDocs对象 // 第一个参数：查询对象 // 第二个参数：最大的n条记录 TopDocs topDocs = searcher.search(query, 10); // e) 提取TopDocs对象中的文档ID，如何找出对应的文档 ScoreDoc[] scoreDocs = topDocs.scoreDocs; System.out.println("总共查询出的结果总数为：" + topDocs.totalHits); Document doc; for (ScoreDoc scoreDoc : scoreDocs) &#123; // 文档对象ID int docId = scoreDoc.doc; doc = searcher.doc(docId); // f) 输出文档内容 System.out.println(doc.get("filename")); System.out.println(doc.get("path")); System.out.println(doc.get("size")); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; } @Testpublic void testTermQuery() throws Exception {1234// 1、 创建查询（Query对象）Query query = new TermQuery(new Term("filename", "apache"));// 2、 执行搜索doSearch(query); }2.2 NumericRangeQueryNumericRangeQuery，指定数字范围查询. @Testpublic void testNumbericRangeQuery() throws Exception {123456789// 创建查询// 第一个参数：域名// 第二个参数：最小值// 第三个参数：最大值// 第四个参数：是否包含最小值// 第五个参数：是否包含最大值Query query = NumericRangeQuery.newLongRange("size", 1l, 100l, true,true);// 2、 执行搜索doSearch(query); }2.3 BooleanQueryBooleanQuery，布尔查询，实现组合条件查询。 @Testpublic void booleanQuery() throws Exception {1234567891011121314BooleanQuery query = new BooleanQuery();Query query1 = new TermQuery(new Term("id", "3"));Query query2 = NumericRangeQuery.newFloatRange("price", 10f, 200f, true, true);//MUST：查询条件必须满足，相当于AND//SHOULD:查询条件可选，相当于OR//MUST_NOT：查询条件不能满足，相当于NOT非query.add(query1, Occur.MUST);query.add(query2, Occur.SHOULD);System.out.println(query);search(query); }组合关系代表的意思如下: 1、MUST和MUST表示“与”的关系，即“交集”。2、MUST和MUST_NOT前者包含后者不包含。3、MUST_NOT和MUST_NOT没意义4、SHOULD与MUST表示MUST，SHOULD失去意义；5、SHOUlD与MUST_NOT相当于MUST与MUST_NOT。6、SHOULD与SHOULD表示“或”的概念。三、通过QueryParser搜索通过QueryParser也可以创建Query，QueryParser提供一个Parse方法，此方法可以直接根据查询语法来查询。Query对象执行的查询语法可通过System.out.println(query);查询。 3.1 QueryParser代码实现： @Testpublic void testQueryParser() throws Exception {123456789// 创建QueryParser// 第一个参数：默认域名// 第二个参数：分词器QueryParser queryParser = new QueryParser("name", new IKAnalyzer());// 指定查询语法 ，如果不指定域，就搜索默认的域Query query = queryParser.parse("lucene");System.out.println(query);// 2、 执行搜索doSearch(query); }查询语法： 1、基础的查询语法，关键词查询： 域名+“：”+搜索的关键字例如：content:java2、范围查询 域名+“:”+[最小值 TO 最大值]例如：size:[1 TO 1000]注意：QueryParser不支持对数字范围的搜索，它支持字符串范围。数字范围搜索建议使用NumericRangeQuery。3、组合条件查询 组合条件查询.PNG1）+条件1 +条件2：两个条件之间是并且的关系and例如：+filename:apache +content:apache 2）+条件1 条件2：必须满足第一个条件，忽略第二个条件例如：+filename:apache content:apache 3）条件1 条件2：两个条件满足其一即可。例如：filename:apache content:apache 4）-条件1 条件2：必须不满足条件1，要满足条件2例如：-filename:apache content:apache 第二种写法：条件1 AND 条件2条件1 OR 条件2条件1 NOT 条件23.2 MultiFieldQueryParser通过MultiFieldQueryParser对多个域查询。 @Testpublic void testMultiFieldQueryParser() throws Exception {12345678910// 可以指定默认搜索的域是多个String[] fields = &#123; "name", "description" &#125;;// 创建一个MulitFiledQueryParser对象QueryParser parser = new MultiFieldQueryParser(fields, new IKAnalyzer());// 指定查询语法 ，如果不指定域，就搜索默认的域Query query = parser.parse("lucene");//等同于name:lucene OR description:lucene// Query query = parser.parse("name:lucene OR description:lucene");// 2、 执行搜索doSearch(query); }四、TopDocsLucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下： topdocs属性.PNG注意： Search方法需要指定匹配记录数量n：indexSearcher.search(query, n)TopDocs.totalHits：是匹配索引库中所有记录的数量TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n]]></content>
      <categories>
        <category>Lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene实现文档进行全文检索功能]]></title>
    <url>%2Fblog%2F10596.html</url>
    <content type="text"><![CDATA[Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。这里讲一下使用Lucene对doc、docx、pdf、txt文档进行全文检索功能的实现。 涉及到的类一共有两个： LuceneCreateIndex，创建索引： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package com.yhd.test.poi;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.Date;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.document.DateTools;import org.apache.lucene.document.Document;import org.apache.lucene.document.Field;import org.apache.lucene.index.IndexWriter;import org.apache.lucene.store.Directory;import org.apache.lucene.store.SimpleFSDirectory;import org.apache.lucene.util.Version;import org.apache.pdfbox.pdfparser.PDFParser;import org.apache.pdfbox.pdmodel.PDDocument;import org.apache.pdfbox.util.PDFTextStripper;import org.apache.poi.hwpf.extractor.WordExtractor;import org.apache.poi.xwpf.extractor.XWPFWordExtractor;import org.apache.poi.xwpf.usermodel.XWPFDocument;public class LuceneCreateIndex &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; // 保存word文件的路径 String dataDirectory = "D:\\Studying\\poi\\test\\dataDirectory"; // 保存Lucene索引文件的路径 String indexDirectory = "D:\\Studying\\poi\\test\\indexDirectory"; // 创建Directory对象 ，也就是分词器对象 Directory directory = new SimpleFSDirectory(new File(indexDirectory)); // 创建一个简单的分词器,可以对数据进行分词 Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_30); // 创建索引实例 // 第1个参数是Directory, // 第2个是分词器, // 第3个表示是否是创建, true代表覆盖原先数据, 如果为false为在此基础上面修改, // 第4个MaxFieldLength表示对每个Field限制建立分词索引的最大数目， // 如果是MaxFieldLength.UNLIMITED，表示长度没有限制; // 如果是MaxFieldLength.LIMITED则表示有限制，可以通过IndexWriter对象的setMaxFieldLength（int // n）进行指定 IndexWriter indexWriter = new IndexWriter(directory, analyzer, true, IndexWriter.MaxFieldLength.UNLIMITED); // 获取所有需要建立索引的文件 File[] files = new File(dataDirectory).listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; // 文件是第几个 System.out.println("这是第" + i + "个文件----------------"); // 文件的完整路径 System.out.println("完整路径：" + files[i].toString()); // 获取文件名称 String fileName = files[i].getName(); // 获取文件后缀名，将其作为文件类型 String fileType = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length()).toLowerCase(); // 文件名称 System.out.println("文件名称：" + fileName); // 文件类型 System.out.println("文件类型：" + fileType); Document doc = new Document(); // String fileCode = FileType.getFileType(files[i].toString()); // 查看各个文件的文件头标记的类型 // System.out.println("fileCode=" + fileCode); InputStream in = new FileInputStream(files[i]); InputStreamReader reader = null; if (fileType != null &amp;&amp; !fileType.equals("")) &#123; if (fileType.equals("doc")) &#123; // 获取doc的word文档 WordExtractor wordExtractor = new WordExtractor(in); // 创建Field对象，并放入doc对象中 // Field的各个字段含义如下： // 第1个参数是设置field的name， // 第2个参数是value，value值可以是文本（String类型，Reader类型或者是预分享的TokenStream）, // 二进制（byet[]）, 或者是数字（一个 Number类型） // 第3个参数是Field.Store，选择是否存储，如果存储的话在检索的时候可以返回值 // 第4个参数是Field.Index，用来设置索引方式 doc.add(new Field("contents", wordExtractor.getText(), Field.Store.YES, Field.Index.ANALYZED)); // 关闭文档 wordExtractor.close(); System.out.println("注意：已为文件“" + fileName + "”创建了索引"); &#125; else if (fileType.equals("docx")) &#123; // 获取docx的word文档 XWPFWordExtractor xwpfWordExtractor = new XWPFWordExtractor( new XWPFDocument(in)); // 创建Field对象，并放入doc对象中 doc.add(new Field("contents", xwpfWordExtractor.getText(), Field.Store.YES, Field.Index.ANALYZED)); // 关闭文档 xwpfWordExtractor.close(); System.out.println("注意：已为文件“" + fileName + "”创建了索引"); &#125; else if (fileType.equals("pdf")) &#123; // 获取pdf文档 PDFParser parser = new PDFParser(in); parser.parse(); PDDocument pdDocument = parser.getPDDocument(); PDFTextStripper stripper = new PDFTextStripper(); // 创建Field对象，并放入doc对象中 doc.add(new Field("contents", stripper.getText(pdDocument), Field.Store.NO, Field.Index.ANALYZED)); // 关闭文档 pdDocument.close(); System.out.println("注意：已为文件“" + fileName + "”创建了索引"); &#125; else if (fileType.equals("txt")) &#123; // 建立一个输入流对象reader reader = new InputStreamReader(in); // 建立一个对象，它把文件内容转成计算机能读懂的语言 BufferedReader br = new BufferedReader(reader); String txtFile = ""; String line = null; while ((line = br.readLine()) != null) &#123; // 一次读入一行数据 txtFile += line; &#125; // 创建Field对象，并放入doc对象中 doc.add(new Field("contents", txtFile, Field.Store.NO, Field.Index.ANALYZED)); System.out.println("注意：已为文件“" + fileName + "”创建了索引"); &#125; else &#123; System.out.println(); continue; &#125; &#125; // 创建文件名的域，并放入doc对象中 doc.add(new Field("filename", files[i].getName(), Field.Store.YES, Field.Index.NOT_ANALYZED)); // 创建时间的域，并放入doc对象中 doc.add(new Field("indexDate", DateTools.dateToString(new Date(), DateTools.Resolution.DAY), Field.Store.YES, Field.Index.NOT_ANALYZED)); // 写入IndexWriter indexWriter.addDocument(doc); // 换行 System.out.println(); &#125; // 查看IndexWriter里面有多少个索引 System.out.println("numDocs=" + indexWriter.numDocs()); // 关闭索引 indexWriter.close(); &#125;&#125; LuceneSearch，进行搜索： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.yhd.test.poi;import java.io.File;import java.io.IOException;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.document.Document;import org.apache.lucene.queryParser.ParseException;import org.apache.lucene.queryParser.QueryParser;import org.apache.lucene.search.IndexSearcher;import org.apache.lucene.search.Query;import org.apache.lucene.search.ScoreDoc;import org.apache.lucene.search.TopDocs;import org.apache.lucene.store.Directory;import org.apache.lucene.store.SimpleFSDirectory;import org.apache.lucene.util.Version;public class LuceneSearch &#123; public static void main(String[] args) throws IOException, ParseException &#123; // 保存索引文件的地方 String indexDirectory = "D:\\Studying\\poi\\test\\indexDirectory"; // 创建Directory对象 ，也就是分词器对象 Directory directory = new SimpleFSDirectory(new File(indexDirectory)); // 创建 IndexSearcher对象，相比IndexWriter对象，这个参数就要提供一个索引的目录就行了 IndexSearcher indexSearch = new IndexSearcher(directory); // 创建QueryParser对象, // 第1个参数表示Lucene的版本, // 第2个表示搜索Field的字段, // 第3个表示搜索使用分词器 QueryParser queryParser = new QueryParser(Version.LUCENE_30, "contents", new StandardAnalyzer(Version.LUCENE_30)); // 生成Query对象 Query query = queryParser.parse("百度"); // 搜索结果 TopDocs里面有scoreDocs[]数组，里面保存着索引值 TopDocs hits = indexSearch.search(query, 10); // hits.totalHits表示一共搜到多少个 System.out.println("找到了" + hits.totalHits + "个"); // 循环hits.scoreDocs数据，并使用indexSearch.doc方法把Document还原，再拿出对应的字段的值 for (int i = 0; i &lt; hits.scoreDocs.length; i++) &#123; ScoreDoc sdoc = hits.scoreDocs[i]; Document doc = indexSearch.doc(sdoc.doc); System.out.println(doc.get("filename")); &#125; indexSearch.close(); &#125;&#125; 详细的解释在代码注释里都有了，就不做过多解释了。需要的jar包如下： 读取poi的类到poi官网下载，读取pdf的类到Apache PDFBox官网下载，这里用的1.8.13版本，2.0版本的调用方式与1.0版本已经不太一样了。 项目整体结构如下： 先运行类： LuceneCreateIndex 会读取目录dataDirectory，即： D:\Studying\poi\test\dataDirectory 下的文件，建立索引，索引会保存在目录indexDirectory，即： D:\Studying\poi\test\indexDirectory 下，然后运行： LuceneSearch 使用索引进行查询，就能看到效果了。]]></content>
      <categories>
        <category>Lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Travis CI 自动更新 GitHub Pages]]></title>
    <url>%2Fblog%2F32102.html</url>
    <content type="text"><![CDATA[​ 这年头要是没有个博客都不好意思给别人说你是程序员，我用XX笔记呀，不行吗？不行，这玩意儿要么不能公开分享，要么公开分享要会员，现在到处都是开源，自己学到了东西都不能分享给需要帮助的人，真是伤心呀。那么今天就来聊聊当你用Hexo搭建了博客，怎么自动更新呢，大家都知道Hexo是需要手动生成HTML静态网页的，虽然命令很少，但是每次写完博客先得推送到git然后在生成静态文件，再推送到服务器，想想我这个心也是醉了，不过看到知乎上还有人带着U盘，我只能呵呵了~，你们耐心真好~那我们今天就来说说怎么使用Travis CI来自动构建你的博客 什么是Travis CI Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，同时他是在在线的服务，不像jenkins需要你本地打架服务器，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。对于做开源项目或者github的使用者，如果你的项目还没有加入Travis CI构建队列，那么我真的想对你说out了。 我的博客架构 也算是一个框架吧 首先我的博客是使用Hexo来搭建的，托管到Github提供的Gitpage服务上的 每次写完博客git push到github，然后Travis自动构建，构建完成后自动推送到Gitpage服务上 生成后的HTML文件和博客的源文件我是放到一个仓库的，只是使用了不同的分支 master：博客的静态文件，也就是hexo生成后的HTML文件，因为要使用Gitpage服务，所以他规定的网页文件必须是在master分支 blog-source：是博客的源代码 当然这样做有隐私问题，因为任何人都能哪的你的博客源码，当然既然是博客，所以就没有这些问题了 启用要构建的项目 首先如果你要使用Travis CI，你必须要GIthub账号（好像Travis CI只支持构建github的项目）和一个项目 使用Github账号登录Travis CI官网，如下图 登录完后会进入如下界面 当然如果你以前没用使用过，所以你登录完是没有上图红框内的内容的，这里是因为我在写这篇博客前已经使用了，所以会有这些内容 接下来我们点击My Repositories旁边的+，意思是添加一个要自动构建的仓库，如下图： 点击后就会来到如下界面： 可以看到这个界面会显示当前github账号的所以项目，如果没有显示，点击右上角的“Sync account”按钮，就可以同步过来了（ps：上次用windows电脑始终同步不过来项目，最后换成mac可以同步了，最后又换回windows也可以了，汗(⊙﹏⊙)b，不太懂，什么个情况） 居然仓库都同步过来了，那么下一步肯定是要开启你需要构建的仓库，可以看到我开启了lifengsofts.github.io这个项目，当然这个也是我就是我的博客啦 开启后我们还需要进行一些配置，操作如下 点击红框的那个菜单按钮，就会出现这样的下拉菜单，我们选择设置，来到这个界面，我们按照如下勾选 Build only if .travis.yml is present：是只有在.travis.yml文件中配置的分支改变了才构建 Build pushes：当推送完这个分支后开始构建 到这一步， 我们已经开启了要构建的仓库，但是还有个问题就是，构建完后，我们怎么将生成的文件推送到github上呢，如果不能推送那我们就不需要倒腾一番来使用Travis CI服务了，我们要的结果就是，我们只要想github一push，他就自动构建并push静态文件到gitpages呢，那么下面要解决的就是Travis CI怎么访问github了 在Travis CI配置Github的Access Token 标题已经说得很明白了吧，我们需要在Travis上配置Access Token，这样我们就可以在他构建完后自动push到gitpgaes了，到这里肯定有人要问了，咋你把用户名密码直接写文件里呢，如果你真有这样的问题，那我只能说呵呵~，但我要告诉你的是写里面肯定是可以push成功的 在github上生成Access Token 首先我们来到github的设置界面，点击到Personal access tokens页面，点击右上角的Generate new token按钮会重新生成一个，点击后他会叫你输入密码，然后来到如下界面，给他去一个名字，下面是勾选一些权限 生成完后，你需要拷贝下来，只有这时候他才显示，下载进来为了安全他就不会显示了，如果忘了只能重新生成一个了，拷贝完以后我们需要到Travis CI网站配置下 在Travis CI配置 配置界面还是在项目的setting里面，如下图 至于为什么我们要在这里配置，我想大家肯定应该明白了，写在程序里不安全，配置到这里相当于一个环境变量，我们在构建的时候就可以引用他。 到这里我已经配置了要构建的仓库和要访问的Token，但是问题来了，他知道怎么构建，怎么生成静态文件吗，怎么push的gitpages，又push到那个仓库吗，所以这里我们还需要在源代码的仓库里创建一个.travis.yml配置文件，放到源代码的根目录，如下图 其中内容如下： 12345678910111213141516language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm install#before_script: # - npm install -g gulpscript: - hexo gafter_script: - cd ./public - git init - git config user.name "lifengsofts" - git config user.email "lifengsofts@gmail.com" - git add . - git commit -m "Update docs" - git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"master:master# E: Build LifeCyclebranches: only: - blog-sourceenv: global: -GH_REF: github.com/lifengsofts/lifengsofts.github.io.git 其中给你需要更换的又git config后面的配置信息 GH_REF的值更改为你的仓库地址 到这一步我们配置已经完成了，现在就是见证奇迹的时候了 Push文章到Github 到这一步，我们可以写一篇文章，添加到你的博客的_posts目录下，如图： 然后commit并push到你的Github上 git push origin blog-source:blog-source 如果不出意外，我们可以就可以在Travis CI网站看到他已经在构建了，如下图： 构建完成后 是不是逼格十足呢 如果我的文章对来带来的帮助，可加我微信，微博，QQ什么啥的交个朋友也是不错的，另外微信，微博都会不定期发一些优质的文章，感谢大家的支持~~，联系方式在我的个人介绍里啦，感谢你的阅读，谢谢~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse报"Building workspace". GC overhead limit exceeded]]></title>
    <url>%2Fblog%2F64632.html</url>
    <content type="text"><![CDATA[eclipse一直报An internal error occurred during: “Building workspace”. GC overhead limit exceeded 最近导入到eclipse里的工程挺大的，每次eclipse启动之后都回update workspace，然后就一直报： An internal error occurred during: “Building workspace”. GC overhead limit exceeded 这个错误。 解决方法： 原因是Eclipse默认配置内存太小需要更改Eclipse安装文件夹下的eclipse.ini文件。 Eclipse.ini默认文件如下： 修改如下： -Xms512m -Xmx1024m 第一个是最小的初始化内存，第二个是最大的占有内存 还可以加上 -XX:MaxPermSize=1024m这个意思是在编译文件时一直占有最大内存，重启Eclipse。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RestService和WebService的区别]]></title>
    <url>%2Fblog%2F27499.html</url>
    <content type="text"><![CDATA[什么是WebService？且看百度百科是如何定义： Web service是一个平台独立的，松耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。 从定义中可以了解， WebService 主要具备三大特点：平台独立性，松耦合、自包含，分布式互操作。 首先，能称为Web Service的应用，具备平台独立性，所谓平台独立性，在Windows、Linux、Unix平台等等都可以使用，是大家遵守的行业标准或者是某些事实标准，有些虽然不是行业标准，但大家都这么做，也都支持，也就慢慢变成事实了。 那什么不是通用的解决方案呢？如：Windows平台的COM/DCOM技术，只能局限于某个平台，一旦脱离该平台就不可以使用。 基次，具备Web Service应用程序，是松耦合的，自包含的。所谓松耦合，即模块之间的依赖型和制约比较小，更改一个模块不会比较大的影响其他模块，说白了，不用关心模块内部是如何实现的，给你标准的接口，你用大家都用的技术与我互通即可。关于自包含的理解，指在组件重用时不需要包含其他的可重用组件，自己搞掂一切，呵呵。 再次，分布式互操作性，这点大家非常好理解，开发出来的应用，要具备与其它系统之间的互操作，现在系统都不是孤立的，开放出来的接口，可以在任意平台上可调用，不具有依赖性。 Web Service标准早期，软件巨头们定义的Web Service标准，主要由三部分构成： SOAP,WSDL,UDDI。 SOAP 即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。它有三个主要方面：XML-envelope为描述信息内容和如何处理内容定义了框架，将程序对象编码成为XML对象的规则，执行远程过程调用(RPC)的约定。SOAP可以运行在任何其他传输协议上。这里需要注意，SOAP是可以在其他协议上，不仅是HTTP, 可以基于SMTP，消息队列等。 WSDL 是web Service描述语言 就是用机器能阅读的方式提供的一个正式描述文档而基于XML的语言，用于描述Web Service及其函数、参数和返回值。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的。 UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。 UDDI 基本没有实现，这种想法也不现实。可以理解UDDI是个Web Service公共仓库，服务写好注册到UDDI中，以便是其他系统方便调用。 Rest Service随着互联网技术的兴起，XML越来越令人诟病，XML的数据包越来重，SOAP协议方便性和灵活性都有欠缺，尤其兴起的Web2.0发展，由Yahoo、Google 和 Facebook等大型互联网公司的倡导，REST代表性状态传输（Representational State Transfer，REST）在 Web 领域已经得到了广泛的接受，是基于 SOAP 和 Web 服务描述语言（Web Services Description Language，WSDL）的 Web 服务的更为简单的替代方法。如GOOGLE 这些提供者弃用或放弃了基于 SOAP 和 WSDL 的接口，而采用了更易于使用、面向资源的模型来公开其服务。 Rest 服务定义： 即REST(Representational State Transfer表述性状态转移)是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。 Rest Service特点： 客户端和服务器结构 连接协议具有无状态性 能够利用Cache机制增进性能 层次化的系统 随需代码 Rest Service 相比Web Service建议的标准更轻量级，甚到用Javascript都可以调用，使用方更方便、高效、简单。REST架构遵循了CRUD原则，CRUD原则对于资源只需要四种行为：Create（创建）、Read（读取）、Update（更新）和Delete（删除）就可以完成对其操作和处理。 Web Service与Rest Service 区别REST 从资源的角度来观察整个网络，分布在各处的资源由URI确定，而客户端的应用通过URI来获取资源的表征。获得这些表征致使这些应用程序转变了其状态。随着不断获取资源的表征，客户端应用不断地在转变着其状态，所谓表征状态转移（Representational State Transfer）。 Rest Service具备Web Service的所有特点：平台独立、松耦合、互操作性。并且，Rest 更轻量级，更简单。可以这么说吧，Rest Service 是Web Service的一种实现，并不是说Rest是Web service替代。]]></content>
      <categories>
        <category>BackEnd</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论工业社会及其未来]]></title>
    <url>%2Fblog%2F16463.html</url>
    <content type="text"><![CDATA[工业革命极大增加了城市规模和城市人口比例，而人群聚集会增加压力与攻击性。 技术变革导致现代社会的变化十分迅速，因此整个社会不存在稳定的框架和价值观。 有些人急于拯救自由却不愿牺牲技术带来的所谓好处，他们会提出天真的新式社会构想来调和自由与技术。 所有人都理所当然地认为，每一个人都必需向技术的需要低头，而且理由十分充分：如果人的需求被摆在了优先于技术需要的地位，就会出现经济问题、失业、短缺甚至更糟。在我们的社会当中，”精神健康”的概念主要被定义为在多大程度一个人能够根据体系的需要行事并且不会流露出承受精神压力的迹象。 经济体系所能容纳的企业数是有限的，我们大多数人只有成为别人的雇员才可以生存。 工业-技术体系可能幸存也可能崩溃。假如该体系幸存下来，可能最终将会降低生理与心理的痛苦水平，但在此之前必须经历一段漫长而痛苦的调整期，而且人类与众多其他生命体也将付出惨重代价，永远沦为社会机器上的齿轮。更有甚者，假如这个体系幸存下来，将会导致不可避免的后果：没有任何方法能够改革或改进这一体系，使之不至于剥夺人的尊严与自主。 假如这一体系崩溃，结果依旧会十分痛苦。但是体系规模越大，崩溃造成的结果就越可怕。因此假如真要崩溃的话最好赶早不赶迟。 所以我们主张发动针对工业体系的革命。这场革命可能使用或不使用暴力，可能突然完成也可能在几十年时间里相对循序渐进地进行。我们无法预测这一点。但是我们的确为那些憎恨工业体系的人们勾勒了一套十分宽泛的方法，从而为反对这一特定社会形式的革命铺平道路。这不是一场政治革命。革命目标并非推翻政府，而是颠覆现存社会的经济与技术基础。 一般来说科学家都是这样。可能其中也有少数例外，但总体而言他们的动机既不是好奇也不是造福人类，而是完成权力过程的需要。其他动机对于许多科学家来说也有作用，例如金钱与地位。 科学技术也构成了群体权力运动，许多科学家都通过认同这一运动来满足自己的权力需求。 因此科学盲目地前进，不考虑人类种族的真正福祉或任何其他标准，仅仅服从科学家以及提供研究资金的政府官员与企业高管的心理需求。 体系需要科学家、数学家与工程师，否则就无法正常运作。 遗传工程的伦理规范事实上将成为管制人类遗传构造的手段。一部分人（多半是上层阶级）将决定如此这般的遗传工程合乎”道德”，如此这般的做法则不道德，因而他们将在实际上将自己的价值观强加于整个人口的遗传构造。即使伦理规范是以完全民主的方式选择出来的，多数族裔也会将他们自己的价值观强加于那些很可能对于如何 “道德地”运用遗传工程另有看法的少数族裔。真正能够保护自由的伦理规范只能是一条，那就是禁止任何人类遗传工程。而我们可以十分有把握地说，这一点恰恰不可能在技术社会中得到实现。任何将遗传工程贬低成配角的规范都不可能维持下去，因为生物技术的巨大力量所产生的诱惑是无法抗拒的。特别是在大多数人看来，大量生物技术的应用显然且肯定是有益的（可以根除身体与精神疾病，赋予人们当今世界所需要的能力）。基因技术必将不可避免地得到大规模应用，但应用方式只能与工业-技术体系的需求相一致。 技术之所以是如此强有力的社会力量的另一个理由是，在给定社会的条件下技术进步只会不可逆地朝一个方向前进。只要某项技术发明被引进，人们就往往会对其产生依赖，除非它被某种更先进的发明所取代。人们不仅仅作为个人依赖这项新技术。甚至体系作为一个整体都会依赖它。（例如请想像一下，如果没有了计算机，今天的体系会怎么样）因此，体系只能朝向更加技术化的方向移动。在不至于颠覆整个技术体系的前提下，技术将会不断地逼迫自由后退。 技术的进步十分迅速并在许多方面威胁自由（拥挤、规章制度、个人对于大型组织越发严重的依赖、宣传与其他心理学技术、遗传工程、通过监视设备和计算机侵犯隐私，等等），阻挡任何一项对于自由的威胁都需要一场单独的社会斗争。那些想要保卫自由的人会被无数的新攻势及其发展速度所压倒，他们会变得微不足道并停止抵抗。分别反击这些威胁是无效的。只有把技术体系作为一个整体来反击才有成功的希望，但这就是革命而不是改革了。 人们倾向于想当然地认为，由于革命带来的变化比改革大，所以革命也就比改革更难发动。实际上，在某些条件下革命比改革容易得多。这是因为一场革命运动能够激发出人们极大的献身热情，而一场改革运动却不能。一场革命运动许诺一下子解决所有问题并创造整个新世界；它提供人民为之甘冒风险、甘作牺牲的理想。由于这些理由，推翻整个技术体系要比对技术的某一部分—-如遗传工程的应用发展—-进行有效、持久的限制容易得多。在适当的条件下，许许多多的人会热情地献身于推翻工业技术体系的革命。正如我们提到的那样，寻求限制技术的某些方面的改革者是为了避免不良后果而工作。然而，革命者是为了获得强力的报偿—-实现其革命理想—-而工作，因此他们比改革者更努力且更执著。 现代社会不是去改变那些使人们抑郁的条件，而是给人们抗抑郁药。 但另一方面，请假设今后几十年的压力超出了体系的承受能力。如果体系崩溃，可能会有一个混乱时期，”动乱年代”，就像在过去各个时代历史所记载的那样。不可能预见动乱年代最后会产生什么结果。但无论如何人类会被赋予一个新机会。最大的危险是工业化社会很可能在崩溃后不几年就开始重组其自身，肯定会有许多人（特别是权力饥渴型的人们）急于重新开动工厂。 工业体系将人类贬低到了被奴役的状态，而憎恨这种被奴役状态的人则面临两个任务。第一，我们必须增强体系内的社会紧张态势，以加快其崩溃或把它弱化到足够程度，使得反对体系的革命成为可能。第二，当体系充分弱化时，我们必须发展并宣传一种反对技术和工业社会的意识形态。当工业社会崩溃时，这种意识形态将有助于保证其残余被粉碎到无法修复的地步，这样体系就无法重组。工厂将被捣毁，技术书籍将被烧掉，等等。 工业体系的崩溃不会纯粹是革命行动的结果，它不会那么难以抵御革命的攻击，除非它自身内部的发展问题导致了极为严重的困难。因此如果体系崩溃，那么它或是自发崩溃，或是部分自发、部分由革命者促发的崩溃。如果崩溃是突如其来的，许多人都会死去，因为世界人口已如此过分膨胀，离开了先进技术就无法养活自己。甚至即使崩溃足够缓慢，人口的减少可以主要通过出生率的降低而不是死亡率的提高而实现，非工业化的过程也多半是极度混乱和极度痛苦的。幻想通过平稳控制的有序方式逐步废除技术是天真的，特别是要考虑到技术爱好者们的负隅顽抗。那么，致力于体系的崩溃是否因此就十分残酷呢？也许是，也许不是。首先，除非体系本来就已经陷入了深重的困难，无论如何都很可能最终自行崩溃，否者单靠革命者是不可能强行使其崩溃的。而且体系发展得规模越大，崩溃的后果就越严重。因此加速体系崩溃的革命者或许反倒控制了灾难的规模。 其次，我们必须权衡斗争与死亡和丧失自由与尊严这两方面的得失。对于我们之中的许多人来说，自由与尊严比长寿和避免肉体痛苦更重要。再者，我们早晚会死，死于为生存或为某一事业而战，强于活得空虚而无目的。 第三，体系的存续所带来的痛苦并不一定就比体系崩溃所带来的痛苦更少。在全世界范围内，体系已经招致、并且正在招致的巨大痛苦曾使人类千百年与他人以及环境和睦相处的古代文化被与其解接触的工业社会所摧毁。其结果就是全方位的经济、环境、社会和心理问题。工业社会的侵扰所产生的影响之一，就是传统的人口控制在全球范围内一下子失去了平衡，因而产生了人口爆炸及其所有连带后果。接着就是心理疾病席卷了整个所谓”幸运”的西方社会。没有人知道臭氧层耗尽、温室效应及其他现在还不能预测的环境问题最终会为这个世界带来怎样的后果。而且就像核扩散已经显示的那样，我们无法防止新技术落入独裁者和不负责任的第三世界国家手中。愿意猜猜伊位克或北朝鲜将用遗传工程来干什么吗? “嗨！”技术爱好者们会说，”科学能解决所有这些问题！我们将征服饥荒、消灭心理病痛，让每一个人都健康而快乐！”是的，是的。他们200年前就是这么说的。人们曾指望工业社会能够消灭贫穷，使每一个人都快乐，等等。实际结果却不是那么回事。技术爱好者对社会问题的理解简直是无可救药地天真（或自欺欺人）。他们没有意识到（或故意视而不见）这样一个事实：当巨大的变化，即使是看上去有利的变化，被引入一个社会时，将会引发一长串其他变化，这些变化之中的大都分是不可预见的其结果则是社会的混乱。因此，技术爱好者们在试图消灭贫穷和疾病，设计制造驯顺、快乐的人格等等时，很可能会创造出比现在还糟糕的社会体系。例如，科学家们吹嘘说他们能够创造出新的、经遗传工程改造的粮食植物以消灭饥荒。然而，这将会允许人口无限膨胀下去，而众所周知，拥挤会导致紧张和攻击性的增强。这仅仅是技术会导致的可预见问题中的一个例子。我们强调指出，历史经验告诉我们，技术进步给社会带来新问题的速度远比它解决旧问题的速度要快。因此技术爱好者们要经过一个漫长的试错时期才能够为他们的美丽新世界排除掉所有的故障（假设他们最终能做到的话）。而与此同时所产生的痛苦将会如此巨大，以至于体系生存下去所带来的痛苦不见得就比体系崩溃更少。技术己将人类带入了一条无法轻易逃脱的死胡同。 更好的办法是把这个腐朽的体系整个扔进垃圾堆，并勇敢地承受其后果。 现在的两个主要任务是在工业社会中促进社会紧张与不稳定，以及宣传一种反对技术和工业体系的意识形态。当体系变得足够紧张和不稳定时，一场反对技术的革命就有机会发动了。这一模式将十分类似于法国和俄国革命。在两国各自革命之前的几十年里，法国和俄国社会都显示出了越来越多的紧张与脆弱迹象。同时，提供一个与旧世界完全不同的新世界愿景的意识形态发展了起来。以俄国的情况为例，革命者积极从事于破坏旧秩序的工作。然后当旧体系面临着足够的额外紧张时（法国是财政危机，俄国是军事失败），它就会被革命一扫而光。我们预想的就是这样的道路。 大多数革命都有两个目标，一个目标是摧毁一个旧社会，另一个目标是建立革命者想像的新社会。法国和俄国的革命者没有能够成功地建立他们所梦想的新社会（这是十分幸运的事），但她们非常成功地摧毁了既存社会。 然而，一种意识形态如想争取到热情支持，除了负面理想外必须还有正面理想，决不能只破不立。我们的正面理想是自然，即野生自然，按照其本来面目运行的地球，不依赖于人类管理、摆脱人类干涉和控制的地球生灵。我们的野生自然也包括人类本性，即不受有组织社会管制、自主运行的个人，成为偶然性或自由意志或上帝（由你的宗教或哲学观念）的产物。 一个社会的经济与技术结构在决定一般人的生活方式方面远比政治结构更加重要。 我们不应主张无力或消极，我们应主张打破工业体系的权力，而这将大大增加个人和小群体的权力和自由。 （据称）贯穿整个历史，技术都是进步的，从未退步过，因此技术退步是不可能的。但这并非事实。对于”进步”的热情是现代社会形态的特殊现象，在大约十七世纪之前并不存在。 导言 1.工业革命及其后果对于人类是一场灾难。工业革命大大延长了我们这些“发达”国家的人的预期寿命了，但也使得社会变得不稳定，人类丧尸尊严，导致了广泛的心里痛苦(在第三世界则还包括胜利痛苦)，并给自然界带来严重破坏。技术的持续进步将使情况变得更糟。技术进步将必然导致人类的进一步屈辱和自然界的进一步破坏，技术进步也很可能导致社会的进一步瓦解和人类更深重的心理痛苦，它甚至在“发达”国家也很可能导致生理痛苦。2.工业–技术体系有可能存在下去，也有可能崩溃。如其存在下去，这一体系最终可能达到一个较少造成人类身心痛苦的境界，但这必须经历一个长期而痛苦的调整过程，且其代价是人类及其他许多生命体被贬低到仅仅是设计制造的产品或社会机器上的一个齿轮的地步。尤其是，如其幸存，那么，我们绝无改革或调整以防止其剥夺人类尊严及自治之道。3.如其崩溃，其后果亦将十分痛苦。然而，这一体系发展得越庞大，其崩溃之后果就越可怕，因此，如其必然崩溃，则越早越好。4.因此，我们主张进行革命以推翻工业体系。这一革命可以使暴力的，也可以是非暴力的;可以使突变的，也可以是有一个数十年渐进的过程。我们无法预言。但我们可以大致勾勒出憎恨工业体系的人们为铺平这一革命道路所应采取的行动的大致框架。浙江不是一场政治革命。这场革命的目标将不是推翻政府，而是摒除现存社会的经济及技术基础。5.在本文中，我们将仅仅集中论述工业–技术体系所带来的一部分负面发展。但这并不是说那些我们一大而过或干脆忽略的发展就不重要。为了注重实效，我们须将讨论集中到那些未受公众充分关注或我们另有创见的领域。例如，环境及野生动物保护运动已十分成熟，我们就不再赘言这些问题，尽管我们认为这些问题十分重要。 现代左派心理学 6.我们生活在一个陷入深重困境的社会，几乎没有人怀疑这点。我们这个世界的疯狂病症的最广为传播的表现之一就是左翼思想，因此，有关左派心理学的讨论可以作为讨论现代社会一般问题的入手点。7.然而，什么是左翼思想?20世纪上半叶，左翼思想可以说就是社会主义。今天的左派分裂了，谁是左派也不十分清楚了。在本文中，当我们使用“左派”这个字眼时，我们主要是指社会主义者，集体主义者，“政治正确性”的倡导者，女权主义者，同性恋者、残疾人活动积极分子、动物权益保护主义者等等。但并不是这些活动中的每一个人都是左派。我们在讨论左翼思想时，所指的对象与其说是一种运动或意识形态，不如说是一种心理类型，或者说一组相关的心理类型。(请参看227-230段)8.即使如此，我们关于左派的概念仍旧是模糊不清的，这是没有办法的事情。我们只是想大致指出两类我们认为是现代左派的主要驱动力的心理倾向。我们绝未声称我们涵盖了全部左派心理学。至于在多大程度上我们的讨论适用于19世纪及20世纪前叶的左派，我们暂且不下结论。9.我们将现代左派两种内在心理倾向称为“自卑感”(feelings of inferiority)和“过度社会化”(oversocialization)。自卑感是现代左派的整体特性，而过度社会化则仅仅是其中一部分的特性，但这一部分是影响特别大的一部分。 自卑感 10.我们是在广义上使用“自卑感”这个词的，它意指缺乏自尊心，无力感，抑郁倾向、失败主义、负罪感、自我厌憎等等。我们认为现代左派具有这些心理感觉(有可能多多少少受到一些抑制)，而这些心理感觉决定了现代左派的方向。11.如果某个人把几乎所有涉及到他(或他认同的群体)的表述都解读成贬损，那么我们可以确认，这个人有自卑感或缺乏自尊心。这种倾向在少数民族权利支持者之中特别显著，无论他们本人是否属于少数民族。他们对于标识少数民族的词汇超度敏感。“黑人”(negro)、“东方人”(oriental)、“残废”(handicapped)或“小妞”这些词汇无非是指非洲人、亚洲人、残疾人(disabled)或女人，原本并无贬损的内涵。“娘们”(broad)和“小妞”(chick)只不过是“家伙”(guy)、“汉子”(dude)、“哥们”(fellow)的女性对应词。其负面内涵是那些活动分子们自己加上的。某些动物权益保护主义者居然不准使用“宠物”(pet)这个字眼，而坚持改称“动物伴侣”(animal companion)。左派人类学家在谈及原始民族时费尽心机避免使用任何可作负面解释的字眼。他们要用“不是用文字的”(nonliterate)来取代“原始”(primitive)这个词。他们对任何有可能暗示原始文化比我们低劣的说法害怕到了变态偏执的地步。(我们并不是说原始文化比我们低劣，我们仅仅是指出左派人类学家的超敏感性。)12.那些对于“真智商不正确(politically incorrect)”术语最敏感的人并不是普通的贫民窟里的黑人、亚洲移民、受虐待的妇女或残疾人，而是少数活动分子。他们之中的许多人并不属于任何“受压迫”的群众，而是来自社会的特权阶层。政治正确性(political correctness)在大学教授之中有着牢固的基础，这些教授有着安全的就业保障和可过舒适生活的收入，其中大多数人是异性恋、白人、来自中产阶级家庭。13.许多左派对那些有着弱者(妇女)、失败者(印第安人)、受排斥者(同性恋)等低劣形象的群体的问题高度认同。其实，这些左派自己觉得这些群体是低劣的。他们当然不会承认这一点，但他们确确实实是因为他们自己把这些群体看作是低劣的才认同与这些群体的问题的。(我们并没有说妇女、印第安人等等是低劣的，我们只是说明左派心理学的一个方面。)14.女权主义者们几近绝望地想证明妇女与男子一样强，一样有能力。很明显，这只不过是因为他们被妇女很可能不如男子强、不如男子有能力的恐惧所困扰。15.左派仇恨所有有着强大、优秀、成功的形象的东西。他们恨美国、恨西方文明、恨白人男子、恨理性。他们仇恨西方等事物的真实动机绝非他们所声称的那些理由。他们说他们之所以仇恨西方是因为西方好战、帝国主义、性别歧视、种族中心等等。但当社会主义国家和原始文化也存在同样的毛病时，左派却为他们找借口，或至多不情愿地承认这些问题存在;而当西方文明存在这些毛病时，左派就会十分起劲并且时常是竭力夸大的到处宣扬。因此我们可以断定，这些毛病并不是左派仇恨美国和西方的真实原因，真实原因是美国和西方的强大和成功。16.在自由派和左派的语汇中，很少有“自信”、“自力更生”、“首创”、“进取”、“乐观主义”等词汇的地位。左派反对个人主义而提倡集体主义。他们要求社会满足每一个人的需求，照顾每一个人。他们内心不相信一个人有能力解决自己的问题、满足自己的需求。左派抗拒竞争的概念，因为在内心深处，他们觉得自己是失败者。17.现代左派知识分子所喜爱的艺术形式热衷于表现污秽、失败和绝望，再不然就是纵欲狂欢，把任何理性的控制抛到一旁，似乎理性不可能有任何造就，唯有沉溺于当下的感官刺激。18.现代左派哲学家往往摒弃理性、科学、客观现实，而坚持任何事物都具有文化相对性。人们当然可以严肃地质疑科学知识的基础，可以质疑如何界定客观现实的概念。然而十分明显，现代左派哲学家并非头脑冷静的逻辑学家，他们并不系统的分析知识的基础。他们之所以攻击真理和现实是由于深陷于感情冲动而不能自拔。他们攻击真理和现实是出于自己的心理需求。他们的攻击从某种角度说是发泄敌意，将敌意发泄出来可以满足他们的权力欲。尤其重要的是，科学和理性把一些信念划分为真(也就是成功的、优越的)，另一些信念划分为假(也就是失败的、低劣的)，因此做派仇恨科学和理性。左派的自卑感几臻于极致，他们甚至忍受不了对事物做任何成败和优劣的划分。这也是许多左派不承认精神病和反对智商测验的原因。左派反对对人类的能力和行为作遗传学解释，因为这类解释使得一部分人显得优于或劣于其他人。左派往往将个人的能力大小归因于社会。这样，如果一个人“”低劣，则过错就不再与他而在于社会，在于他的成长环境。19.有些自卑者变成了自吹自擂者，恃强凌弱者、无情竞争者。这类人并未完全丧失自信。而左派则连这些人也不如。左派感觉不到自我的力量和价值，却还自认为有能力成为强者，而他们的令人讨厌的行为就出自其力图使自己成为强者的努力。[1]但他们的自卑感是如此根深蒂固，以至于他们无法想象自己个人可以成为强者或有价值的人。所以左派是集体主义者。他们只有在作为一个大组织或一场大运动中的一员时才感觉到自己是强者。20.请主义左派战术的受虐狂倾向。左派躺在车轮子前面进行抗议，他们故意挑逗警察和种族主义分子虐待自己。这些战术往往可能是有效的，但许多左派使用这些战术并不是因为她们是达到目的的手段，而是因为他们喜欢受虐战术。自我憎恨也是左派的一个特点。21.左派可以宣称他们的行动主义是出于同情心或道德原则的感召。确实，对于那些过度社会化类型的左派，道德原则起了一定作用。但同情心和道德原则并非左派行动主义的主要动机。敌意是左派行为的极为重要的组成部分，海游权力欲。尤其是，许多左派行为并不是经过理性计算来为他们声称要帮助的人们谋划的。例如，有人相信反歧视行动有利于黑人，然而，以充满敌意和冥顽不化的方式推行反歧视运动又能有什么意义?显然，至少在口头上或符号上，对那些认为受到反歧视行为的歧视的白人群众做一些让步之类的外交和安抚会更有效一些。但左派行动主义者们不干，因为这满足不了他们的感情需求。帮助黑人不是他们的真实目标。种族问题只是他们发泄自己的敌意和受挫的权力欲的一个借口。他们这样做实际上是损害了黑人，因为行动主义者对白人大多数的敌意会计划种族仇恨。22.即使我们的社会没有任何问题，左派也会发明出问题来给他们提供折腾的借口。23.我们必须强调指出，前面所述并非是对每一个左派的精确描绘。我们只是粗略勾画出左派的一般倾向。 过度社会化 24.心理学家使用“社会化”这个词来描述训练儿童按照社会的要求进行思考和行动的过程。如果一个人相信并遵从他所在社会的道德规范，并且能很好地适应社会，承担某一部分社会功能，我们就说他“社会化的很好”。如果我们说许多左派是过度社会化的，这好像很矛盾，因为人们都认为左派是反叛者。其实，许多左派实际上并不是反叛者。 25.我们社会的道德规范要求极高，以至于没有任何一个人在思考、感觉和行动时完全不违反道德。例如，道德规范要求我们不仇恨任何人，然而，几乎每一个人都在此时或彼时仇恨某个人，无论承认与否。某些人已被高度社会化，试图道德的思考、感觉和行动已经成了他们的一个沉重负担。为了不内疚，他们必须不断的在动机问题上欺骗自己，并且为他们在现实中并不道德的感觉和行为找到道德的解释。我们用“过度社会化”这个词汇来描述这些人. 26.过度社会化导致缺乏自尊心、无力感、失败主义、负罪感等等。我们的社会对儿童进行社会化训练的一个重要手段，就是让他们为自己有悖于社会期待的行为或言论感到羞耻。这一点如果做过了头，一个儿童就会对这种感觉特别敏感，他最后会变得为自己感到羞耻。尤其是，过度社会化的人们的思想与行为比轻度社会化的人们更受社会期待的限制。大多数人都会做不少不规矩的事。他们撒谎、小偷小摸、不遵守交通规则、在工作中偷懒、恨其他人、恶语伤人、背后做手脚把别人拽下来。过度社会化的人不敢做这些事，做了就会感到内疚或自我厌憎。过度社会化的人甚至不能毫不内疚地体验不不道德的想法和感觉;他们根本就不敢想到“不干净”的想法。社会化并不仅仅牵扯到道德，它要求我们遵从的许多行为规范并不能归到道德名下。过度社会化的人被套上了心理枷锁，只能按照社会为他指定的轨道了此一生。这使得许多过度社会化的人感到抑郁和无力，生活成为苦刑。我们认为过度社会化是人类折磨自己同类的酷刑之一。 27.我们认为现代左派之中非常重要、非常有影响的一部分是过度社会化，他们的过度社会化在很大程度上决定了现代左派的方向。过度社会化的左派多半是知识分子或出身于上层阶级的人。请注意大学里的知识分子[3]是我们社会中社会化程度最高的一部分，也是最左倾的部分。 28.过度社会化的左派试图通过反叛来摆脱其心理枷锁并实现自主权(autonomy)，但往往却缺乏反叛社会最基本价值观的力量。一般说来，今天的左派的目标不是与既定道德作斗争，正相反，左派接受既定的道德原则，把这种道德原则看成是自己的，然后指责主流社会违反了这些原则。例子:种族平等、性别平等、帮助穷人、和平反战、非暴力、言论自由、爱护动物;更为基本的:个人服务社会与社会照顾个人。所有这些都是我们社会(至少是中、上层阶级)长久以来的深层价值观。这些价值观都是由主流媒体和教育体制直接或间接地灌输给我们的。左派，尤其是过度社会化类型的左派，往往并不反叛这些原则，而是声称(倒也不失正确)社会没能实现这些原则，以此作为他们对于社会抱有敌意的正当理由. 29.这里举一个实例来说明，过度社会化的左派实际上与我们社会的常规难舍难分，却假装反叛者。许多左派一再要求反歧视行动，要求把黑人提升到高位，要求改善黑人学校的教育并投入更多的经费;他们把黑人“下层阶级”的生活方式看作是社会的耻辱。他们要求将黑人整合进体制，把黑人变成企业主管、律师、科学家，就像上中阶级的白人一样。左派声称他们决不想把黑人变成白人的复制品;他们是要保留非洲裔美国人的文化。然而，何谈保留非洲裔美国人的文化?除吃点黑人饭、听点黑人音乐、穿点黑人衣服、去几趟黑人教堂或清真寺，哪里还有什么黑人文化?黑人文化只能存在于这些最肤浅的东西之中了。在所有本质方面，多数过度社会化类型的左派都是要把黑人按照白人中产阶级的理想进行改造，他们要黑人学习技术专业，成为企业主管或科学家，把一生耗费在爬地位阶梯上，以证明黑人和白人一样优秀。他们要黑人父亲“负责”，他们要黑人团伙放弃暴力，等等。但是，这些都是不折不扣的工业–技术体系的价值观。这个体系并不在乎一个人听什么音乐，穿什么衣服，信什么宗教，只要他上学，有体面的工作，爬地位阶梯，做“负责”的父亲，非暴力等等。实际上，不管过度社会化的左派如何极力否认，他们是要黑人整合进体制，要黑人接受体制的价值。 30.我们并没有说左派，甚至过度社会化的左派，从未反叛过我们社会的基本价值。显然他们有时候也反叛。某些过度社会化的左派甚至翻盘现代社会最重要的原则，他们甚至诉诸暴力。照他们自己的话说，暴力对于他们是某种形式的“解放”。换句话说，通过暴力行为，他们打破了从小灌输进他们的心理制约。因为他们过度社会化，这些制约对于他们就比别人来得严厉，所以他们需要摆脱它们。然而他们却往往用主流价值来论证自己的反叛的正当性，如果它们使用暴力，他们总是声称他们在与种族主义战斗之类。 31.我们知道可以对前述的丑陋的左派心理学提出多种反论。实际情况十分复杂，即使所需的数据都可以得到，完整的描述也需要更多的笔墨。我们只是非常粗糙的勾画出现代左派的两种心理倾向。 32.左派的问题体现了我们社会整体的问题。缺乏自尊、抑郁倾向和失败主义并不仅仅局限于左派。虽然这些问题在左派身上特别明显，它们却是我们全社会的痼疾。今天的社会对我们进行的社会化的努力比过去的社会更高。我们甚至要有专家来知道如何吃、如何锻炼、如何做爱、如何带孩子等等。 ——Industrial Society and Its Future/希尔多·卡辛斯基(Theodore Kaczynski)]]></content>
      <categories>
        <category>Think</category>
      </categories>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出REST]]></title>
    <url>%2Fblog%2F46218.html</url>
    <content type="text"><![CDATA[不知你是否意识到，围绕着什么才是实现异构的应用到应用通信的“正确”方式，一场争论正进行的如火如荼：虽然当前主流的方式明显地集中在基于SOAP、WSDL和WS-*规范的Web Services领域，但也有少数人用细小但洪亮的声音主张说更好的方式是REST，表述性状态转移（REpresentational State Transfer）的简称。在本文中，我不会涉及争论的话题，而是尝试对REST和RESTful HTTP应用集成做实用性的介绍。以我的经验，有些话题一旦触及就会引来众多的讨论，当涉及到这方面话题的时候，我会深入详细地阐述。 REST关键原则大部分对REST的介绍是以其正式的定义和背景作为开场的。但这儿且先按下不表，我先提出一个简单扼要的定义：REST定义了应该如何正确地使用（这和大多数人的实际使用方式有很大不同）Web标准，例如HTTP和URI。如果你在设计应用程序时能坚持REST原则，那就预示着你将会得到一个使用了优质Web架构（这将让你受益）的系统。总之，五条关键原则列举如下： 为所有“事物”定义ID 将所有事物链接在一起 使用标准方法 资源多重表述 无状态通信 下面让我们进一步审视这些原则。 为所有“事物”定义ID在这里我使用了“事物”来代替更正式准确的术语“资源”，因为一条如此简单的原则，不应该被淹没在术语当中。思考一下人们构建的系统，通常会找到一系列值得被标识的关键抽象。每个事物都应该是可标识的，都应该拥有一个明显的ID——在Web中，代表ID的统一概念是：URI。URI构成了一个全局命名空间，使用URI标识你的关键资源意味着它们获得了一个唯一、全局的ID。 对事物使用一致的命名规则（naming scheme）最主要的好处就是你不需要提出自己的规则——而是依靠某个已被定义，在全球范围中几乎完美运行，并且能被绝大多数人所理解的规则。想一下你构建的上一个应用（假设它不是采用RESTful方式构建的）中的任意一个高级对象（high-level object），那就很有可能看到许多从使用唯一标识中受益的用例。比如，如果你的应用中包含一个对顾客的抽象，那么我可以相当肯定，用户会希望将一个指向某个顾客的链接，能通过电子邮件发送到同事那里，或者加入到浏览器的书签中，甚至写到纸上。更透彻地讲：如果在一个类似于Amazon.com的在线商城中，没有用唯一的ID（一个URI）标识它的每一件商品，可想而知这将是多么可怕的业务决策。 当面对这个原则时，许多人惊讶于这是否意味着需要直接向外界暴露数据库记录（或者数据库记录ID）——自从多年以来面向对象的实践告诫我们，要将持久化的信息作为实现细节隐藏起来之后，哪怕是刚有点想法都常会使人惊恐。但是这条原则与隐藏实现细节两者之间并没有任何冲突：通常，值得被URI标识的事物——资源——要比数据库记录抽象的多。例如，一个定单资源可以由定单项、地址以及许多其它方面（可能不希望作为单独标识的资源暴露出来）组成。标识所有值得标识的事物，领会这个观念可以进一步引导你创造出在传统的应用程序设计中不常见的资源：一个流程或者流程步骤、一次销售、一次谈判、一份报价请求——这都是应该被标识的事物的示例。同样，这也会导致创建比非RESTful设计更多的持久化实体。 下面是一些你可能想到的URI的例子： 1234http://example.com/customers/1234http://example.com/orders/2007/10/776654http://example.com/products/4554http://example.com/processes/salary-increase-234 正如我选择了创建便于阅读的URI——这是个有用的观点，尽管不是RESTful设计所必须的——应该能十分容易地推测出URI的含义：它们明显地标识着单一“数据项”。但是再往下看： 12http://example.com/orders/2007/11http://example.com/products?color=green 首先，这两个URI看起来与之前的稍有不同——毕竟，它们不是对一件事物的标识，而是对一类事物集合的标识（假定第一个URI标识了所有在2007年11月份提交的定单，第二个则是绿颜色产品的集合）。但是这些集合自身也是事物（资源），也应该被标识。 注意，使用唯一、全局统一的命名规则的好处，既适用于浏览器中的Web应用，也适用于机对机（machine-to-machine，m2m）通信。 来对第一个原则做下总结：使用URI标识所有值得标识的事物，特别是应用中提供的所有“高级”资源，无论这些资源代表单一数据项、数据项集合、虚拟亦或实际的对象还是计算结果等。 将所有事物链接在一起接下来要讨论的原则有一个有点令人害怕的正式描述：“超媒体被当作应用状态引擎（Hypermedia as the engine of application state）”，有时简写为HATEOAS。（严格地说，这不是我说的。）这个描述的核心是超媒体概念，换句话说：是链接的思想。链接是我们在HTML中常见的概念，但是它的用处绝不局限于此（用于人们网络浏览）。考虑一下下面这个虚构的XML片段： 12345&lt;order self=&quot;http://example.com/customers/1234&quot;&gt; &lt;amount&gt;23&lt;/amount&gt; &lt;product ref=&quot;http://example.com/products/4554&quot;&gt; &lt;customer ref=&quot;http://example.com/customers/1234&quot;&gt; &lt;/customer&gt; &lt;/product&gt;&lt;/order&gt; 如果你观察文档中product和customer的链接，就可以很容易地想象到，应用程序（已经检索过文档）如何“跟随”链接检索更多的信息。当然，如果使用一个遵守专用命名规范的简单“id”属性作为链接，也是可行的——但是仅限于应用环境之内。使用URI表示链接的优雅之处在于，链接可以指向由不同应用、不同服务器甚至位于另一个大陆上的不同公司提供的资源——因为URI命名规范是全球标准，构成Web的所有资源都可以互联互通。 超媒体原则还有一个更重要的方面——应用“状态”。简而言之，实际上服务器端（如果你愿意，也可以叫服务提供者）为客户端（服务消费者）提供一组链接，使客户端能通过链接将应用从一个状态改变为另一个状态。稍后我们会在另一篇文章中探究这个方面的影响；目前，只需要记住：链接是构成动态应用的非常有效的方式。 对此原则总结如下：任何可能的情况下，使用链接指引可以被标识的事物（资源）。也正是超链接造就了现在的Web。 使用标准方法在前两个原则的讨论中暗含着一个假设：接收URI的应用程序可以通过URI明确地做一些有意义的事情。如果你在公共汽车上看到一个URI，你可以将它输入浏览器的地址栏中并回车——但是你的浏览器如何知道需要对这个URI做些什么呢？ 它知道如何去处理URI的原因在于所有的资源都支持同样的接口，一套同样的方法（只要你乐意，也可以称为操作）集合。在HTTP中这被叫做动词（verb），除了两个大家熟知的（GET和POST）之外，标准方法集合中还包含PUT、DELETE、HEAD和OPTIONS。这些方法的含义连同行为许诺都一起定义在HTTP规范之中。如果你是一名OO开发人员，就可以想象到RESTful HTTP方案中的所有资源都继承自类似于这样的一个类（采用类Java、C#的伪语法描述，请注意关键的方法）： 1234567class Resource &#123; Resource(URI u); Response get(); Response post(Request r); Response put(Request r); Response delete();&#125; 由于所有资源使用了同样的接口，你可以依此使用GET方法检索一个表述（representation）——也就是对资源的描述。因为规范中定义了GET的语义，所以可以肯定当你调用它的时候不需要对后果负责——这就是为什么可以“安全”地调用此方法。GET方法支持非常高效、成熟的缓存，所以在很多情况下，你甚至不需要向服务器发送请求。还可以肯定的是，GET方法具有幂等性[译注：指多个相同请求返回相同的结果]——如果你发送了一个GET请求没有得到结果，你可能不知道原因是请求未能到达目的地，还是响应在反馈的途中丢失了。幂等性保证了你可以简单地再发送一次请求解决问题。幂等性同样适用于PUT（基本的含义是“更新资源数据，如果资源不存在的话，则根据此URI创建一个新的资源”）和DELETE（你完全可以一遍又一遍地操作它，直到得出结论——删除不存在的东西没有任何问题）方法。POST方法，通常表示“创建一个新资源”，也能被用于调用任意过程，因而它既不安全也不具有幂等性。 如果你采用RESTful的方式暴露应用功能（如果你乐意，也可以称为服务功能），那这条原则和它的约束同样也适用于你。如果你已经习惯于另外的设计方式，则很难去接受这条原则——毕竟，你很可能认为你的应用包含了超出这些操作表达范围的逻辑。请允许我花费一些时间来让你相信不存在这样的情况。 来看下面这个简单的采购方案例子： 可以看到，例子中定义了两个服务程序（没有包含任何实现细节）。这些服务程序的接口都是为了完成任务（正是我们讨论的OrderManagement和CustomerManagement服务）而定制的。如果客户端程序试图使用这些服务，那它必须针对这些特定接口进行编码——不可能在这些接口定义之前，使用客户程序去有目的地和接口协作。这些接口定义了服务程序的应用协议（application protocol）。 在RESTful HTTP方式中，你将通过组成HTTP应用协议的通用接口访问服务程序。你可能会想出像这样的方式： 可以看到，服务程序中的特定操作被映射成为标准的HTTP方法——为了消除歧义，我创建了一组全新的资源。“这是骗人的把戏”，我听见你叫嚷着。不，这不是欺骗。标识一个顾客的URI上的GET方法正好相当于getCustomerDetails操作。有人用三角形形象化地说明了这一点： 把三个顶点想象为你可以调节的按钮。可以看到在第一种方法中，你拥有许多操作，许多种类的数据以及固定数量的“实例”（本质上和你拥有的服务程序数量一致）。在第二种方法中，你拥有固定数量的操作，许多种类的数据和许多调用固定方法的对象。它的意义在于，证明了通过这两种方式，你基本上可以表示任何你喜欢的事情。 为什么使用标准方法如此重要？从根本上说，它使你的应用成为Web的一部分——应用程序为Web变成Internet上最成功的应用所做的贡献，与它添加到Web中的资源数量成比例。采用RESTful方式，一个应用可能会向Web中添加数以百万计的客户URI；如果采用CORBA技术并维持应用的原有设计方式，那它的贡献大抵只是一个“端点（endpoint）”——就好比一个非常小的门，仅仅允许有钥匙的人进入其中的资源域。 统一接口也使得所有理解HTTP应用协议的组件能与你的应用交互。通用客户程序（generic client）就是从中受益的组件的例子，例如curl、wget、代理、缓存、HTTP服务器、网关还有Google、Yahoo!、MSN等等。 总结如下：为使客户端程序能与你的资源相互协作，资源应该正确地实现默认的应用协议（HTTP），也就是使用标准的GET、PUT、POST和DELETE方法。 资源多重表述到目前为止我们一直忽略了一个稍微复杂的问题：客户程序如何知道该怎样处理检索到的数据，比如作为GET或者POST请求的结果？原因是，HTTP采取的方式是允许数据处理和操作调用之间关系分离的。换句话说，如果客户程序知道如何处理一种特定的数据格式，那就可以与所有提供这种表述格式的资源交互。让我们再用一个例子来阐明这个观点。利用HTTP内容协商（content negotiation），客户程序可以请求一种特定格式的表述： 123GET /customers/1234 HTTP/1.1Host: example.com Accept: application/vnd.mycompany.customer+xml 请求的结果可能是一些由公司专有的XML格式表述的客户信息。假设客户程序发送另外一个不同的请求，就如下面这样： 123GET /customers/1234 HTTP/1.1Host: example.com Accept: text/x-vcard 结果则可能是VCard格式的客户地址。（在这里我没有展示响应的内容，在其HTTP Content-type头中应该包含着关于数据类型的元数据。）这说明为什么理想的情况下，资源表述应该采用标准格式——如果客户程序对HTTP应用协议和一组数据格式都有所“了解”，那么它就可以用一种有意义的方式与世界上任意一个RESTful HTTP应用交互。不幸的是，我们不可能拿到所有东西的标准格式，但是，或许我们可以想到在公司或者一些合作伙伴中使用标准格式来营造一个小环境。当然以上情况不仅适用于从服务器端到客户端的数据，反之既然——倘若从客户端传来的数据符合应用协议，那么服务器端就可以使用特定的格式处理数据，而不去关心客户端的类型。 在实践中，资源多重表述还有着其它重要的好处：如果你为你的资源提供HTML和XML两种表述方式，那这些资源不仅可以被你的应用所用，还可以被任意标准Web浏览器所用——也就是说，你的应用信息可以被所有会使用Web的人获取到。 资源多重表述还有另外一种使用方式：你可以将应用的Web UI纳入到Web API中——毕竟，API的设计通常是由UI可以提供的功能驱动的，而UI也是通过API执行动作的。将这两个任务合二为一带来了令人惊讶的好处，这使得使用者和调用程序都能得到更好的Web接口。 总结：针对不同的需求提供资源多重表述。 无状态通信无状态通信是我要讲到的最后一个原则。首先，需要着重强调的是，虽然REST包含无状态性（statelessness）的观念，但这并不是说暴露功能的应用不能有状态——事实上，在大部分情况下这会导致整个做法没有任何用处。REST要求状态要么被放入资源状态中，要么保存在客户端上。或者换句话说，服务器端不能保持除了单次请求之外的，任何与其通信的客户端的通信状态。这样做的最直接的理由就是可伸缩性——如果服务器需要保持客户端状态，那么大量的客户端交互会严重影响服务器的内存可用空间（footprint）。（注意，要做到无状态通信往往需要需要一些重新设计——不能简单地将一些session状态绑缚在URI上，然后就宣称这个应用是RESTful。） 但除此以外，其它方面可能显得更为重要：无状态约束使服务器的变化对客户端是不可见的，因为在两次连续的请求中，客户端并不依赖于同一台服务器。一个客户端从某台服务器上收到一份包含链接的文档，当它要做一些处理时，这台服务器宕掉了，可能是硬盘坏掉而被拿去修理，可能是软件需要升级重启——如果这个客户端访问了从这台服务器接收的链接，它不会察觉到后台的服务器已经改变了。 理论上的REST我承认：以上我所说的REST不是真正的REST，而且我可能有点过多地热衷于简单化。但因为我想有一个与众不同的开场，所以没有在一开始就介绍其正式的定义和背景。现在就让我们稍微简要地介绍一下这方面的内容。 首先，先前我并没有明确地区分HTTP、RESTful HTTP和REST。要理解这些不同方面之间的关系，我们要先来看看REST的历史。 Roy T. Fielding在他的博士学位论文（实际上你应该访问这个链接——至少对于一篇学术论文来说，它是相当易读的。此论文已被翻译成中文）中定义了术语REST。Roy曾是许多基本Web协议的主要设计者，其中包括HTTP和URIs，并且他在论文中对这些协议提出了很多想法。（这篇论文被誉为“REST圣经”，这是恰当的——毕竟，是作者发明了这个术语，所以在定义上，他写的任何内容都被认为是权威的。）在论文中，Roy首先定义一种方法论来谈论架构风格——高级、抽象的模式，来表达架构方法背后的核心理念。每一个架构风格由一系列的约束（constraints）定义形成。架构风格的例子包括“没有风格”（根本没有任何约束）、管道和过滤器（pipe and filter）、客户端/服务器、分布式对象以及——你猜到它了——REST。 如果对你来说这些听起来都太抽象了，那就对了——REST在本质上是一个可以被许多不同技术实现的高层次的风格，而且可以被实例化——通过为它的抽象特性赋上不同的值。比如，REST中包含资源和统一接口的概念——也就是说，所有资源都应该对这些相同的方法作出反应。但是REST并没有说明是哪些方法，或者有多少方法。 REST风格的一个“化身”便是HTTP（以及一套相关的一套标准，比如URI），或者稍微抽象一些：Web架构自身。接着上面的例子，HTTP使用HTTP动词作为REST统一接口的“实例”。由于Fielding是在Web已经（或者至少是大部分）“完善”了之后才定义的REST风格，有人可能会争论两者是不是100%的匹配。但是无论如何，整体上来说Web、HTTP和URI仅仅是REST风格的一个主要实现。不过，由于Roy Fielding即是REST论文的作者，又对Web架构设计有过深远的影响，两者相似也在情理之中。 最后，我在前面一次又一次地使用着术语“RESTful HTTP”，原因很简单：许多使用HTTP的应用因为一些理由并没有遵循REST原则，有人会说使用HTTP而不遵循REST原则就等同于滥用HTTP。当然这听起来有点狂热——事实上违反REST约束的原因通常是，仅仅因为每个约束带来的设计权衡可能不适合于一些特殊情况。但通常，违背REST约束的原因可归咎于对其好处认知的缺乏。来看一个明显的反面案例：使用HTTP GET调用类似于删除对象的操作，这违反了REST的安全约束和一般性常识（客户程序不应为此负责，服务器端开发人员大概不是有意而为之）。但在随后的文章中，我会提及更多这样或那样的对HTTP的滥用。 总结本文试图对REST（Web架构）背后的概念提供快速的介绍。RESTful HTTP暴露功能的方式与RPC、分布式对象以及Web Services是不相同的；要真正理解这些不同是需要一些心态的转变。不管你构建的应用是仅仅想暴露Web UI还是想把API变成Web的一份子，了解下REST的原则还是有好处的。 Stefan Tilkov是InfoQ SOA社区的首席编辑，并且是位于德国和瑞士的innoQ公司的共同创始人、首席顾问和REST狂热分子首领。 查看英文原文：A Brief Introduction to REST]]></content>
      <categories>
        <category>rest</category>
      </categories>
      <tags>
        <tag>rest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST客户端编程实例]]></title>
    <url>%2Fblog%2F14233.html</url>
    <content type="text"><![CDATA[导读JAX-RS 2.0 又称 JSR 339 不仅定义了一套用于构建 RESTful 网络服务的 API，同时也通过增强客户端 API 功能简化了REST 客户端的构建过程。 JAX-RS: Java API for RESTful Web Services是一个Java编程语言的应用程序接口,支持按照 表象化状态转变 (REST)架构风格创建Web服务Web服务[1]. JAX-RS使用了Java SE 5引入的Java 标注来简化Web服务客户端和服务端的开发和部署 [wikipedia]。 在下面的教程中，我们将为一个预先设置好的 REST 服务构建一个客户端，并在这个过程中探索新的构建选项。例如，如何处理同步或者异步的请求，如何给一个请求注册一个回调，如何指定调用对象来构建一个请求使得请求可以被延迟执行。再或者比如，如何使用客户端请求和相应的过滤方法来过滤客户端与服务器之前的通信。 我们开始吧对于想要重建下述客户端例子的读者，我已经使用 Maven 创建好了一个完整的 RESTful 网络服务程序。程序中有内嵌的应用程序服务器，以及一个可独立运行的应用服务器 （war-file 可以通过下文中的下载地址获取）。 请根据下面的一系列命令来下载并启动 REST 服务器 （下载所有依赖可能会耗费些时间……）： 1clone https://bitbucket.org/hascode/jaxrs2-client-tutorial.git &amp;&amp; cd jaxrs2-client-tutorial &amp;&amp; make rest-server 现在，让我们先来看看这个 REST 服务的一些实现细节和我们的客户端示例中要用到的对象。如果你对这些没什么兴趣，大可以略过服务端的细节直接去看客户端示例。 REST 服务下面的代码就是个客户端提供服务的 REST 服务。这里的 BookRepository 就是一个由 @Singleton 和 @Startup 修饰的简单 session bean，这个 bean 用来模拟存储或获取 Book Entity。服务对外提供了保存一本书、删除一本书、根据标识查找书籍和获取所有可用书籍的接口。当一本书被保存在服务端时，服务器会为该书生成一个 id，并会返回一个 entity 或一组 entity 的 JSON 数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hascode.tutorial.jaxrs.server;import java.util.List;import javax.ejb.EJB;import javax.ejb.Stateless;import javax.ws.rs.Consumes;import javax.ws.rs.DELETE;import javax.ws.rs.GET;import javax.ws.rs.POST;import javax.ws.rs.Path;import javax.ws.rs.PathParam;import javax.ws.rs.Produces;import javax.ws.rs.core.GenericEntity;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import com.hascode.tutorial.jaxrs.entity.Book;@Stateless@Path("/book")public class BookStoreService &#123; @EJB private BookRepository bookRepository; @POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response saveBook(final Book book) &#123; Book bookPersisted = bookRepository.saveBook(book); return Response.ok(bookPersisted).build(); &#125; @DELETE @Path("/&#123;id&#125;") public Response deleteBook(final @PathParam("id") String id) &#123; bookRepository.deleteBook(id); return Response.ok().build(); &#125; @GET @Produces(MediaType.APPLICATION_JSON) public Response getAll() &#123; List&lt;Book&gt; books = bookRepository.getAll(); GenericEntity&lt;List&lt;Book&gt;&gt; bookWrapper = new GenericEntity&lt;List&lt;Book&gt;&gt;(books) &#123;&#125;; return Response.ok(bookWrapper).build(); &#125; @GET @Path("/&#123;id&#125;") @Produces(MediaType.APPLICATION_JSON) public Response getById(final @PathParam("id") String id) &#123; Book book = bookRepository.getById(id); return Response.ok(book).build(); &#125;&#125; 备注：我修改了应用服务器，以便使用 Jackson 提供的服务发现机制处理 JSON 数据。 Book Entity下面代码中的 bean 就是贯穿本教程的 Book Entity，它包含id、书名、价格和出版日期属性。 12345678910111213141516package com.hascode.tutorial.jaxrs.entity;import java.io.Serializable;import java.math.BigDecimal;import java.util.Calendar;public class Book implements Serializable &#123; private static final long serialVersionUID = 1L; private String id; private String title; private BigDecimal price; private Calendar published; // getter+setter..&#125; 创建并绑定一个客户端我们可以创建一个 REST 客户端，将其绑定到一个特定的目标 URL 上。并且为它指定专属的、参数化的路径。具体步骤如下： 通过 ClientBuilder 获取一个客户端的引用：*Client client = ClientBuilder.newClient();* 使用 target() 方法将客户端绑定到 REST 服务上提供的某个 URL：*client.target(“http://localhost:8080/myrestservice”);* 通过 path() 和 resolveTemplate() 方法来处理动态的 URL 路径参数：*client.target(..).path(“{id}”).resolveTemplate(“id”, someId);* 使用 request() 函数来初始化一个请求并用后续的 post 或者 get 等方法来指定请求的类型，例如：client.target(..).request().get(); 每一步都提供了多样的可选择的参数和配置选项，稍后的教程中我将用到其中的一些配置像异步请求、回调处理、还有过滤器注册和特性类等。 现在，让我们先看一些具备说明性的例子。 客户端例子由于我把所有客户端示例都融进了 jUnit 和 Hamcrest 驱动的测试用例，因此下面的代码实际上在每一个测试用例中都有使用。不过为了让文章尽量简练，重复代码将在后面的代码示例中省略。 12345678910111213141516private static final String REST_SERVICE_URL = "http://localhost:8080/tutorial/rs/book";private static final String TITLE = "One big book";private static final BigDecimal PRICE = new BigDecimal("20.0");private static final GregorianCalendar PUBLISHED = new GregorianCalendar(, 12, 24);Client client = ClientBuilder.newClient().register(JacksonFeature.class);public Book mockBook() &#123; Book book = new Book(); book.setTitle(TITLE); book.setPrice(PRICE); book.setPublished(PUBLISHED); return book;&#125; 唯一值得注意的是，我在客户端运行时中加入了 Jackson 框架，因此可以通过 javax.ws.rs.client.ClientBuilder 来获取客户端实例。 Maven 整合所有代码示例运行都需要用到下面依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 基础操作下面的示例中我们首先将一个书本实体的信息序列化成 JSON 格式，通过 POST 请求发送到服务端来保存这本书。 之后，我们使用客户端提供的 path() 和 resolveTemplate() 方法通过匹配服务端返回值的协议来获取该本书的标识。 第三步， 我们获取所有可用图书的列表，并在最后删除掉刚才保存的那本书。 1234567891011121314151617181920212223242526272829303132333435@Testpublic void crudExample() &#123; // 1. Save a new book Book book = mockBook(); Book bookPersisted = client .target(REST_SERVICE_URL) .request() .post(Entity.entity(book, MediaType.APPLICATION_JSON), Book.class); String bookId = bookPersisted.getId(); assertThat(bookId, notNullValue()); // 2. Fetch book by id Book book2 = client.target(REST_SERVICE_URL).path("/&#123;bookId&#125;") .resolveTemplate("bookId", bookId).request().get(Book.class); assertThat(book2, notNullValue()); assertThat(book2.getTitle(), equalTo(TITLE)); assertThat(book2.getPrice(), equalTo(PRICE)); assertThat(book2.getPublished().getTime(), equalTo(PUBLISHED.getTime())); // 3. Fetch all books GenericType&lt;List&lt;Book&gt;&gt; bookType = new GenericType&lt;List&lt;Book&gt;&gt;() &#123; &#125;; // generic type to wrap a generic list of books List&lt;Book&gt; books = client.target(REST_SERVICE_URL).request() .get(bookType); assertThat(books.size(), equalTo(1)); // 4. Delete a book client.target(REST_SERVICE_URL).path("/&#123;bookId&#125;") .resolveTemplate("bookId", bookId).request().delete(); List&lt;Book&gt; books2 = client.target(REST_SERVICE_URL).request() .get(bookType); assertThat(books2.isEmpty(), equalTo(true));&#125; 异步处理只要给请求构造器加一个简单的 async() 方法，我们就可以使用 Java 的 Future API 提供的多种途径来异步地处理请求。 下面的例子中，我们在第一个请求中添加一本书，然后再删除它。最后获取所有可用图书的列表。 1234567891011121314151617181920212223242526@Testpublic void asyncExample() throws Exception &#123; Book book = mockBook(); Future&lt;Book&gt; fb = client .target(REST_SERVICE_URL) .request() .async() .post(Entity.entity(book, MediaType.APPLICATION_JSON), Book.class); Book bookPersisted = fb.get(); String bookId = bookPersisted.getId(); assertThat(bookId, notNullValue()); client.target(REST_SERVICE_URL).path("/&#123;bookId&#125;") .resolveTemplate("bookId", bookId).request().async().delete() .get(); Future&lt;List&lt;Book&gt;&gt; bookRequest = client.target(REST_SERVICE_URL) .request().async().get(new GenericType&lt;List&lt;Book&gt;&gt;() &#123; &#125;); List&lt;Book&gt; books2 = bookRequest.get(); assertThat(books2.isEmpty(), equalTo(true));&#125; 发起回调在客户端与服务器通信过程中，我们还有另一种方式可以对服务器的相应进行修改，那就是在请求中加入一个 InvocationCallback 回调处理。 可以看到，下面代码段中有着很多缩进那部分就是我们的回调函数了，这些回调可以打印保存成功的图书的完整信息，或者在出现错误的情况下则打印错误和堆栈信息。 123456789101112131415161718192021222324252627282930313233343536@Testpublic void invocationCallbackExample() throws Exception &#123; Book book = mockBook(); client.target(REST_SERVICE_URL) .request() .async() .post(Entity.entity(book, MediaType.APPLICATION_JSON), new InvocationCallback&lt;Book&gt;() &#123; @Override public void completed(final Book bookPersisted) &#123; System.out.println("book saved: " + bookPersisted); assertThat(bookPersisted.getId(), notNullValue()); &#125; @Override public void failed(final Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;).get(); client.target(REST_SERVICE_URL).request().async() .get(new InvocationCallback&lt;List&lt;Book&gt;&gt;() &#123; @Override public void completed(final List&lt;Book&gt; books) &#123; System.out.println(books.size() + " books received"); assertThat(books.size(), greaterThanOrEqualTo(1)); &#125; @Override public void failed(final Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125;).get();&#125; 延迟调用 / 请求构建通过 javax.ws.rs.client.Invocation 类，我们可以先构建一个请求而不用即时发送。这个请求可以是同步的, 也可以是异步的。 在下面的示例中，我们构建了两个调用但并不马上使用—— 一个请求用来保存图书，另一个请求则是获取所有可用的图书。然后，我们在后面调用时才使用这两个构建好的请求。 我们应当使用 invoke() 方法来同步地调用一个请求。当需要使用异步请求时，则需要用 submit() 方法——两种调用都会返回一个 javax.ws.rs.core.Response 对象。如果调用者在调用参数中给定了返回实体的类，则上述方法会返回该类。 1234567891011121314151617181920@Testpublic void requestPreparationExample() throws Exception &#123; Book book = mockBook(); Invocation saveBook = client.target(REST_SERVICE_URL).request() .buildPost(Entity.entity(book, MediaType.APPLICATION_JSON)); Invocation listBooks = client.target(REST_SERVICE_URL).request() .buildGet(); Response response = saveBook.invoke(); Book b1 = response.readEntity(Book.class); // alternative: Book b1 = saveBook.invoke(Book.class); assertThat(b1.getId(), notNullValue()); // async invocation Future&lt;List&lt;Book&gt;&gt; b = listBooks.submit(new GenericType&lt;List&lt;Book&gt;&gt;() &#123; &#125;); List&lt;Book&gt; books = b.get(); assertThat(books.size(), greaterThanOrEqualTo(2));&#125; 客户端请求过滤器JAX-RS 允许我们使用请求过滤器来截获客户端发送到服务器的请求。 为了达成这个目标，只需要实现 javax.ws.rs.client.ClientRequestFilter 这个接口。当创建客户端时，使用客户端的 register() 方法将 ClientRequestFilter 的具体实现注册到客户端中。 javax.ws.rs.client.ClientRequestContext 对象将赋予访问信息请求足够的权限。 下面就是一个客户端请求过滤的例子。这个例子中，所有客户端发出的 POST 请求中如果包含书籍实体，则书籍价格都会被这个过滤器修改（虽然这不是一个好的实际示例）。对价格的修改则依据相应的税率。 12345678910111213141516171819202122232425package com.hascode.tutorial.client;import java.io.IOException;import java.math.BigDecimal;import javax.ws.rs.client.ClientRequestContext;import javax.ws.rs.client.ClientRequestFilter;import com.hascode.tutorial.jaxrs.entity.Book;public class TaxAdjustmentFilter implements ClientRequestFilter &#123; public static final BigDecimal TAX_RATE = new BigDecimal("2.5"); @Override public void filter(final ClientRequestContext rc) throws IOException &#123; String method = rc.getMethod(); if ("POST".equals(method) &amp;&amp; rc.hasEntity()) &#123; Book book = (Book) rc.getEntity(); BigDecimal priceWithTaxes = book.getPrice().multiply(TAX_RATE); book.setPrice(priceWithTaxes); rc.setEntity(book); &#125; &#125;&#125; 在我们的测试用例中，只要把这个过滤器注册到客户端上，随后就会看到：保存书籍时候，书本的价格就会根据税率进行的调整。 12345678910111213141516171819@Testpublic void clientRequestFilterExample() &#123; Book book = mockBook(); Client client = ClientBuilder.newClient() .register(JacksonFeature.class) .register(TaxAdjustmentFilter.class); Book bookPersisted = client .target(REST_SERVICE_URL) .request() .post(Entity.entity(book, MediaType.APPLICATION_JSON), Book.class); String bookId = bookPersisted.getId(); assertThat(bookId, notNullValue()); assertThat(bookPersisted.getPrice(), equalTo(PRICE.multiply(TaxAdjustmentFilter.TAX_RATE)));&#125; 客户端响应过滤器为了获得对服务器相应的控制，有一个十分类似的办法：客户端相应过滤器。 同样地，只要实现 javax.ws.rs.client.ClientResponseFilter 这个接口，就能够修改或者截获服务器返回的响应。 下面这个响应过滤器能够将一些 HTTP 响应头打印到标准输出（STDOUT）： 1234567891011121314151617181920212223242526272829303132package com.hascode.tutorial.client;import java.io.IOException;import java.util.List;import java.util.Map.Entry;import javax.ws.rs.client.ClientRequestContext;import javax.ws.rs.client.ClientResponseContext;import javax.ws.rs.client.ClientResponseFilter;public class ClientResponseLoggingFilter implements ClientResponseFilter &#123; @Override public void filter(final ClientRequestContext reqCtx, final ClientResponseContext resCtx) throws IOException &#123; System.out.println("status: " + resCtx.getStatus()); System.out.println("date: " + resCtx.getDate()); System.out.println("last-modified: " + resCtx.getLastModified()); System.out.println("location: " + resCtx.getLocation()); System.out.println("headers:"); for (Entry&lt;String, List&lt;String&gt;&gt; header : resCtx.getHeaders() .entrySet()) &#123; System.out.print("\t" + header.getKey() + " :"); for (String value : header.getValue()) &#123; System.out.print(value + ", "); &#125; System.out.print("\n"); &#125; System.out.println("media-type: " + resCtx.getMediaType().getType()); &#125;&#125; 要使用这个过滤器，只需要把它注册到我们的客户端程序中： 123456789101112@Testpublic void clientResponseFilterExample() &#123; Book book = mockBook(); Client client = ClientBuilder.newClient() .register(JacksonFeature.class) .register(ClientResponseLoggingFilter.class); client.target(REST_SERVICE_URL) .request() .post(Entity.entity(book, MediaType.APPLICATION_JSON), Book.class);&#125; 使用内嵌的 GlassFish 服务，POST 请求将有如下结果： 1234567891011status: 200date: Sat Dec 28 18:50:16 CET 2013last-modified: nulllocation: nullheaders: Date :Sat, 28 Dec 2013 17:50:16 GMT, Transfer-Encoding :chunked, Content-Type :application/json, Server :GlassFish Server Open Source Edition 3.1, X-Powered-By :Servlet/3.0 JSP/2.2 (GlassFish Server Open Source Edition 3.1 Java/Oracle Corporation/1.7),media-type: application 译注：GlassFish是SUN所研发的开放源代码应用服务器，GlassFish以Java编写以增加跨平台性[wikipedia]。 教程源码欢迎下载本教程中的源码，你可以用 Git 来 Fork 或者直接 Clone：Bitbucket代码仓库。 下载 war-File REST 服务器你可以从这里下载 war-file 然后运行自己的 RESTful 服务：https://bitbucket.org/hascode/jaxrs2-client-tutorial/downloads JAX-RS 1.0 and JAX-B如果你对旧版本的协议感兴趣，这篇文章正是你需要的。 翻译： ImportNew.com - 靳禹 译文链接： http://www.importnew.com/8939.html]]></content>
      <categories>
        <category>BackEnd</category>
      </categories>
      <tags>
        <tag>restClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request Mapping 基础用法]]></title>
    <url>%2Fblog%2F47293.html</url>
    <content type="text"><![CDATA[@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上。在这篇文章中，你将会看到 @RequestMapping 注解在被用来进行 Spring MVC 控制器方法的映射可以如何发挥其多才多艺的功能的。 Request Mapping 基础用法在 Spring MVC 应用程序中，RequestDispatcher (在 Front Controller 之下) 这个 servlet 负责将进入的 HTTP 请求路由到控制器的处理方法。 在对 Spring MVC 进行的配置的时候, 你需要指定请求与处理方法之间的映射关系。 要配置 Web 请求的映射，就需要你用上 @RequestMapping 注解。 @RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。 在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上。之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系。 下面是一个同时在类和方法上应用了 @RequestMapping 注解的示例： 1234567891011121314@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping("/") String get() &#123; //mapped to hostname:port/home/ return "Hello from get"; &#125; @RequestMapping("/index") String index() &#123; //mapped to hostname:port/home/index/ return "Hello from index"; &#125;&#125; 如上述代码所示，到 /home 的请求会由 get() 方法来处理，而到 /home/index 的请求会由 index() 来处理。 @RequestMapping 来处理多个 URI你可以将多个请求映射到一个方法上去，只需要添加一个带有请求路径值列表的 @RequestMapping 注解就行了。 1234567891011121314@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = &#123; "", "/page", "page*", "view/*,**/msg" &#125;) String indexMultipleMapping() &#123; return "Hello from index multiple mapping."; &#125;&#125; 如你在这段代码中所看到的，@RequestMapping 支持统配符以及ANT风格的路径。前面这段代码中，如下的这些 URL 都会由 indexMultipleMapping() 来处理： localhost:8080/home localhost:8080/home/ localhost:8080/home/page localhost:8080/home/pageabc localhost:8080/home/view/ localhost:8080/home/view/view 带有 @RequestParam 的 @RequestMapping@RequestParam 注解配合 @RequestMapping 一起使用，可以将请求的参数同处理方法的参数绑定在一起。 @RequestParam 注解使用的时候可以有一个值，也可以没有值。这个值指定了需要被映射到处理方法参数的请求参数, 代码如下所示： 123456789101112131415@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/id") String getIdByValue(@RequestParam("id") String personId) &#123; System.out.println("ID is " + personId); return "Get ID from query string of URL with value element"; &#125; @RequestMapping(value = "/personId") String getId(@RequestParam String personId) &#123; System.out.println("ID is " + personId); return "Get ID from query string of URL without value element"; &#125;&#125; 在代码的第6行，id 这个请求参数被映射到了 thegetIdByValue() 这个处理方法的参数 personId 上。 如果请求参数和处理方法参数的名称一样的话，@RequestParam 注解的 value 这个参数就可省掉了, 如代码的第11行所示。 @RequestParam 注解的 required 这个参数定义了参数值是否是必须要传的。 12345678@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/name") String getName(@RequestParam(value = "person", required = false) String personName) &#123; return "Required element of request param"; &#125;&#125; 在这段代码中，因为 required 被指定为 false，所以 getName() 处理方法对于如下两个 URL 都会进行处理： /home/name?person=xyz /home/name @RequestParam 的 defaultValue 取值就是用来给取值为空的请求参数提供一个默认值的。 12345678@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/name") String getName(@RequestParam(value = "person", defaultValue = "John") String personName) &#123; return "Required element of request param"; &#125;&#125; 在这段代码中，如果 person 这个请求参数为空，那么 getName() 处理方法就会接收 John 这个默认值作为其参数。 用 @RequestMapping 处理 HTTP 的各种方法Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的请求默认都会是 HTTP GET 类型的。 为了能降一个请求映射到一个特定的 HTTP 方法，你需要在 @RequestMapping 中使用 method 来声明 HTTP 请求所使用的方法类型，如下所示： 123456789101112131415161718192021222324@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(method = RequestMethod.GET) String get() &#123; return "Hello from get"; &#125; @RequestMapping(method = RequestMethod.DELETE) String delete() &#123; return "Hello from delete"; &#125; @RequestMapping(method = RequestMethod.POST) String post() &#123; return "Hello from post"; &#125; @RequestMapping(method = RequestMethod.PUT) String put() &#123; return "Hello from put"; &#125; @RequestMapping(method = RequestMethod.PATCH) String patch() &#123; return "Hello from patch"; &#125;&#125; 在上述这段代码中， @RequestMapping 注解中的 method 元素声明了 HTTP 请求的 HTTP 方法的类型。 所有的处理处理方法会处理从这同一个 URL( /home)进来的请求, 但要看指定的 HTTP 方法是什么来决定用哪个方法来处理。 例如，一个 POST 类型的请求 /home 会交给 post() 方法来处理，而一个 DELETE 类型的请求 /home 则会由 delete() 方法来处理。 你会看到 Spring MVC 将使用这样相同的逻辑来映射其它的方法。 用 @RequestMapping 来处理生产和消费对象可以使用 @RequestMapping 注解的 produces 和 consumes 这两个元素来缩小请求映射类型的范围。 为了能用请求的媒体类型来产生对象, 你要用到 @RequestMapping 的 produces 元素再结合着 @ResponseBody 注解。 你也可以利用 @RequestMapping 的 comsumes 元素再结合着 @RequestBody 注解用请求的媒体类型来消费对象。 下面这段代码就用到的 @RequestMapping 的生产和消费对象元素： 12345678910111213141516171819@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/prod", produces = &#123; "application/JSON" &#125;) @ResponseBody String getProduces() &#123; return "Produces attribute"; &#125; @RequestMapping(value = "/cons", consumes = &#123; "application/JSON", "application/XML" &#125;) String getConsumes() &#123; return "Consumes attribute"; &#125;&#125; 在这段代码中， getProduces() 处理方法会产生一个 JSON 响应， getConsumes() 处理方法可以同时处理请求中的 JSON 和 XML 内容。 使用 @RequestMapping 来处理消息头@RequestMapping 注解提供了一个 header 元素来根据请求中的消息头内容缩小请求映射的范围。 在可以指定 header 元素的值，用 myHeader = myValue 这样的格式： 12345678910@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/head", headers = &#123; "content-type=text/plain" &#125;) String post() &#123; return "Mapping applied along with headers"; &#125;&#125; 在上面这段代码中， @RequestMapping 注解的 headers 属性将映射范围缩小到了 post() 方法。有了这个，post() 方法就只会处理到 /home/head 并且 content-typeheader 被指定为 text/plain 这个值的请求。 你也可以像下面这样指定多个消息头： 12345678910@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/head", headers = &#123; "content-type=text/plain", "content-type=text/html" &#125;) String post() &#123; return "Mapping applied along with headers"; &#125;&#125; 这样， post() 方法就能同时接受 text/plain 还有 text/html 的请求了。 使用 @RequestMapping 来处理请求参数@RequestMapping 直接的 params 元素可以进一步帮助我们缩小请求映射的定位范围。使用 params 元素，你可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。 你可以用 myParams = myValue 这种格式来定义参数，也可以使用通配符来指定特定的参数值在请求中是不受支持的。 12345678910111213141516@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/fetch", params = &#123; "personId=10" &#125;) String getParams(@RequestParam("personId") String id) &#123; return "Fetched parameter using params attribute = " + id; &#125; @RequestMapping(value = "/fetch", params = &#123; "personId=20" &#125;) String getParamsDifferent(@RequestParam("personId") String id) &#123; return "Fetched parameter using params attribute = " + id; &#125;&#125; 在这段代码中，getParams() 和 getParamsDifferent() 两个方法都能处理相同的一个 URL (/home/fetch) ，但是会根据 params 元素的配置不同而决定具体来执行哪一个方法。 例如，当 URL 是 /home/fetch?id=10 的时候, getParams() 会执行，因为 id 的值是10,。对于 localhost:8080/home/fetch?personId=20 这个URL, getParamsDifferent() 处理方法会得到执行，因为 id 值是 20。 使用 @RequestMapping 处理动态 URI@RequestMapping 注解可以同 @PathVaraible 注解一起使用，用来处理动态的 URI，URI 的值可以作为控制器中处理方法的参数。你也可以使用正则表达式来只处理可以匹配到正则表达式的动态 URI。 1234567891011121314@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping(value = "/fetch/&#123;id&#125;", method = RequestMethod.GET) String getDynamicUriValue(@PathVariable String id) &#123; System.out.println("ID is " + id); return "Dynamic URI parameter fetched"; &#125; @RequestMapping(value = "/fetch/&#123;id:[a-z]+&#125;/&#123;name&#125;", method = RequestMethod.GET) String getDynamicUriValueRegex(@PathVariable("name") String name) &#123; System.out.println("Name is " + name); return "Dynamic URI parameter fetched using regex"; &#125;&#125; 在这段代码中，方法 getDynamicUriValue() 会在发起到 localhost:8080/home/fetch/10 的请求时执行。这里 getDynamicUriValue() 方法 id 参数也会动态地被填充为 10 这个值。 方法 getDynamicUriValueRegex() 会在发起到 localhost:8080/home/fetch/category/shirt 的请求时执行。不过，如果发起的请求是 /home/fetch/10/shirt 的话，会抛出异常，因为这个URI并不能匹配正则表达式。 @PathVariable 同 @RequestParam的运行方式不同。你使用 @PathVariable 是为了从 URI 里取到查询参数值。换言之，你使用 @RequestParam 是为了从 URI 模板中获取参数值。 @RequestMapping 默认的处理方法在控制器类中，你可以有一个默认的处理方法，它可以在有一个向默认 URI 发起的请求时被执行。 下面是默认处理方法的示例： 123456789@RestController@RequestMapping("/home")public class IndexController &#123; @RequestMapping() String default () &#123; return "This is a default method for the class"; &#125;&#125; 在这段代码中，向 /home 发起的一个请求将会由 default() 来处理，因为注解并没有指定任何值。 @RequestMapping 快捷方式Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。 例如，@GetMapping 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。方法级别的注解变体有如下几个： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 如下代码展示了如何使用组合注解： 12345678910111213141516171819202122232425262728@RestController@RequestMapping("/home")public class IndexController &#123; @GetMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; getPerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from GET", HttpStatus.OK); &#125; @GetMapping("/person/&#123;id&#125;") public @ResponseBody ResponseEntity &lt; String &gt; getPersonById(@PathVariable String id) &#123; return new ResponseEntity &lt; String &gt; ("Response from GET with id " + id, HttpStatus.OK); &#125; @PostMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; postPerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from POST method", HttpStatus.OK); &#125; @PutMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; putPerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from PUT method", HttpStatus.OK); &#125; @DeleteMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; deletePerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from DELETE method", HttpStatus.OK); &#125; @PatchMapping("/person") public @ResponseBody ResponseEntity &lt; String &gt; patchPerson() &#123; return new ResponseEntity &lt; String &gt; ("Response from PATCH method", HttpStatus.OK); &#125;&#125; 在这段代码中，每一个处理方法都使用 @RequestMapping 的组合变体进行了注解。尽管每个变体都可以使用带有方法属性的 @RequestMapping 注解来互换实现, 但组合变体仍然是一种最佳的实践 — 这主要是因为组合注解减少了在应用程序上要配置的元数据，并且代码也更易读。 @RequestMapping 总结如你在本文中所看到的，@RequestMapping 注解是非常灵活的。你可以使用该注解配置 Spring MVC 来处理大量的场景用例。它可以被用来在 Spring MVC 中配置传统的网页请求，也可以是 REST 风格的 Web 服务。]]></content>
      <categories>
        <category>BackEnd</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker自定义TemplateDirectiveModel(二)]]></title>
    <url>%2Fblog%2F37707.html</url>
    <content type="text"><![CDATA[FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java 等。 ​ 摘要: 采用的是freemarker版本 2.3.21 采用 BeansWrapperBuilder替代DEFAULT_WRAPPER 的方式。 自定义标签需要实现TemplateDirectiveModel这个接口中的execute方法 实例代码如下 123456789101112131415161718192021public class UserListDirective implements TemplateDirectiveModel&#123; @Autowired private UserDAO userDao; @Override public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; String name = params.get("name").toString(); List&lt;User&gt; userlist = userDao.findByProperty("name", name); env.setVariable("userList", getBeansWrapper().wrap(userlist)); body.render(env.getOut()); &#125; public static BeansWrapper getBeansWrapper()&#123; BeansWrapper beansWrapper = new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build(); return beansWrapper; &#125;&#125; 配置 UserListDirective 到spring bean xml中 1&lt;bean id="userListDirective" class="com.action.directive.UserListDirective"&gt;&lt;/bean&gt; 将spring bean 设置到freemarkerConfig全局变量中去。 1234567891011121314151617181920212223&lt;bean id="freemarkerConfig2" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/" /&gt; &lt;property name="freemarkerVariables"&gt; &lt;map &gt; &lt;entry key="userListDirective" value="userListTag" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;0&lt;/prop&gt; &lt;prop key="defaultEncoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="url_escaping_charset"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="boolean_format"&gt;true,false&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="time_format"&gt;HH:mm:ss&lt;/prop&gt; &lt;prop key="number_format"&gt;0.######&lt;/prop&gt; &lt;prop key="whitespace_stripping"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; ftl文件中的访问方式 1234567&lt;@userListTag name="zhangsan"&gt; &lt;#if userList?? &amp;&amp; userList?size gt 0&gt; &lt;#list userList as user&gt; &lt;a href=""&gt;$&#123;user.name&#125;&lt;/a&gt; &lt;/#list&gt; &lt;/#if&gt; &lt;/@userListTag&gt; freemarker 遍历 map 第一种方式（2.3.21版本之前好像可以用） 12345&lt;#list testMap?keys as testKey&gt; &lt; option value="$&#123;testKey&#125;" &gt; $&#123;testMap.get(testKey)&#125; &lt;/option&gt; &lt;/#list&gt; 12345&lt;#list testMap.keySet() as testKey&gt; &lt; option value="$&#123;testKey&#125;" &gt; $&#123;testMap.get(testKey)&#125; &lt;/option&gt; &lt;/#list&gt; 附摘： 在采用FreeMarker做前台视图模板的情况下，我们可以通过&lt;#include&gt;标签和自定义宏来解决很多重复性工作。 一个简单的FreeMarker宏： 123&lt;#macro sayHello name=""&gt; hello $&#123;name&#125;&lt;/#macro&gt; 然后通过如下的形式调用： 1&lt;@sayHello name="shannon" /&gt; ​ 不过这种在模板页中定义的宏能力有限。【1】假设，我们很多页面都要输出一个热门排行框，而排行数据需要从controller层动态获取，我们可以用这种宏来完成所有的展示工作，但前提是相应的controller和接口中层需要预先将这些排行数据放到model中去，因此对于后端来说这也是一个重复性的工作。那么有没有一种方式可以让后端也脱离这种重复工作呢？答案是肯定的，这也是写这篇博客的目的。 ​ 在一个偶然的机会发现jeecms项目中用到了这种方式，于是借鉴了一番。 ​ FreeMarker不仅可以在前端的模板页中定义宏，还可以通过扩展其接口在后端实现宏，这有什么好处呢？这种方式就好比让你的模板页具备了从前端再次回到后端的能力。这样我们就能很好的解决【1】处的假设，我们无需在各个controller的各个接口中去重复的向model中添加所需的排行数据，而是当FreeMarker渲染模板页时遇到相应的宏它可以回到后端去调用相应的方法取到所需的数据。例子如下： 1234567891011121314151617181920212223242526272829303132333435import freemarker.core.Environment;import freemarker.template.ObjectWrapper;import freemarker.template.TemplateDirectiveModel;/** * FreeMarker自定义宏 * 获取App下载排行列表 * 参数包括 length（列表长度） mtypeCode(主类型代码) typeCode（小类型代码） rankMode（排行模式1、2、3） * @author shannon * */public class FMAppRankDirective implements TemplateDirectiveModel &#123; @Resource(name = "appRankService") private AppRankService appRankService; @SuppressWarnings("unchecked") @Override public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; //DirectiveUtils是借用jeecms项目中的工具类，主要是因为它集成了一些异常处理功能， //其实完全可以不用它，params是个Map，自己通过key取值就可以了，做一下空值判断 Integer length = DirectiveUtils.getInt("length", params); Integer mtypeCode = DirectiveUtils.getInt("mtypeCode", params); Integer typeCode = DirectiveUtils.getInt("typeCode", params); Integer rankMode = DirectiveUtils.getInt("rankMode", params); ArrayList&lt;App&gt; rankList = appRankService.getRankList(length, mtypeCode, typeCode, rankMode); env.setVariable("appRankList", ObjectWrapper.DEFAULT_WRAPPER.wrap(rankList)); if (body != null) &#123; body.render(env.getOut()); &#125; &#125;&#125; ​ 通过实现FreeMarker的TemplateDirectiveModel就在后端实现了一个自定义的宏，这个宏的功能很简单，只是根据给定的参数将排行数据“appRankList”放到model中去，然后模板页中就可以使用这个变量了。 FreeMarker的配置参数中需要将这个宏加入进去。 12345678910&lt;bean id="appRankDirective" class="com.shannon.example.rank.util.FMAppRankDirective" /&gt;&lt;bean id="freemarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; ……其他配置略…… &lt;property name="freemarkerVariables"&gt; &lt;map&gt; ……其他配置略…… &lt;entry key="appRankDirective" value-ref="appRankDirective"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 在模板页中使用： 1234567891011121314&lt;#-- 应用下载排行框，title为该框的标题，length为排行列表长度，mtypeCode为主类型代码，typeCode为小类型代码，rankMode为排行方式 1为总下载量，2为月下载量，3为昨日增长下载量--&gt;&lt;#macro appRankBox title="" length=10 mtypeCode=1 typeCode=-1 rankMode=1&gt; &lt;@appRankDirective length=length mtypeCode=mtypeCode typeCode=typeCode rankMode=rankMode /&gt; &lt;h3 class="box-title"&gt;$&#123;title&#125;&lt;/h3&gt; &lt;div class="box"&gt; &lt;ul class="row-list"&gt; &lt;#list appRankList as item&gt; ……详细输出内容略…… &lt;/#list&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/#macro&gt; ​ 这里我在模板页中又定义了一个宏，负责内容及样式的输出，因为模板页中的宏比较直观，让后端的宏只负责拿数据。其他页面直接使用“appRankBox”就可以了，然后由它来调用后端的“appRankDirective”宏来拿数据。 这样，controller就从重复工作中脱身了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker自定义TemplateDirectiveModel(一)]]></title>
    <url>%2Fblog%2F21487.html</url>
    <content type="text"><![CDATA[FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java 等。 一、Freemarker的介绍​ Freemarker 是一款模板引擎，是一种基于模版生成静态文件的通用 工具，它是为java程序员提供的一个开发包，或者说是一个类库，它不是面向最终用户的，而是为程序员提供了一款可以嵌入他们开发产品的应用程序。 ​ Freemarker 是使用纯java编写的，为了提高页面的访问速度，需要把页面静态化， 那么Freemarker就是被用来生成html页面。 ​ 到目前为止，Freemarker使用越来越广泛，不光光只是它强大的生成技术，而且它能够与spring进行很好的集成。 ​ 现在开始一层层揭开它的神秘面纱。。 二、Freemarker的准备条件​ freemarker.2.3.16.jar 三、Freemarker生成静态页面的原理​ Freemarker 生成静态页面，首先需要使用自己定义的模板页面，这个模板页面可以是最最普通的html，也可以是嵌套freemarker中的 取值表达式， 标签或者自定义标签等等，然后后台读取这个模板页面，解析其中的标签完成相对应的操作， 然后采用键值对的方式传递参数替换模板中的的取值表达式，做完之后 根据配置的路径生成一个新的html页面， 以达到静态化访问的目的。 四、Freemarker提供的标签Freemarker提供了很多有用 常用的标签，Freemarker标签都是&lt;#标签名称&gt;这样子命名的，${value} 表示输出变量名的内容 ，具体如下： list：该标签主要是进行迭代服务器端传递过来的List集合，比如： 123&lt;#list nameList as names&gt; $&#123;names&#125; &lt;/#list&gt; ​ name是list循环的时候取的一个循环变量，freemarker在解析list标签的时候，等价于： 123for (String names : nameList) &#123; System.out.println(names); &#125; if： 该标签主要是做if判断用的，比如： 123&lt;#if (names=="陈靖仇")&gt; 他的武器是: 十五~~&lt;/#if&gt; ​ 这个是条件判断标签，要注意的是条件等式必须用括号括起来， 等价于： 123if(names.equals("陈靖仇"))&#123; System.out.println("他的武器是: 十五~~"); &#125; include：该标签用于导入文件用的。 1&lt;#include "include.html"/&gt; ​ 这个导入标签非常好用，特别是页面的重用。 另外在静态文件中可以使用${} 获取值，取值方式和el表达式一样，非常方便。 ​ 下面举个例子（static.html）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;描述：$&#123;description&#125;&lt;br/&gt;集合大小:$&#123;nameList?size&#125;&lt;br/&gt;迭代list集合：&lt;br/&gt;&lt;#list nameList as names&gt;这是第$&#123;names_index+1&#125;个人，叫做：&lt;label style="color:red"&gt;$&#123;names&#125;&lt;/label&gt;if判断：&lt;br/&gt;&lt;#if (names=="陈靖仇")&gt; 他的武器是: 十五~~&lt;#elseif (names=="宇文拓")&gt; &lt;#--注意这里没有返回而是在最后面--&gt; 他的武器是: 轩辕剑~·&lt;#else&gt;她的绝招是：蛊毒~~&lt;/#if&gt;&lt;br/&gt;&lt;/#list&gt;迭代map集合：&lt;br/&gt;&lt;#list weaponMap?keys as key&gt;key---&gt;$&#123;key&#125;&lt;br/&gt;value-----&gt;$&#123;weaponMap[key]!("null")&#125;&lt;#-- fremarker 不支持null, 可以用！ 来代替为空的值。其实也可以给一个默认值 value-----$&#123;weaponMap[key]?default("null")&#125;还可以 在输出前判断是否为null&lt;#if weaponMap[key]??&gt;&lt;/#if&gt;都可以--&gt;&lt;br/&gt;&lt;/#list&gt;include导入文件：&lt;br/&gt;&lt;#include "include.html"/&gt;&lt;/body&gt;&lt;/html&gt; ​ 实际代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.chenghui.test;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import freemarker.template.Configuration;import freemarker.template.DefaultObjectWrapper;import freemarker.template.Template;import freemarker.template.TemplateException;public class CreateHtml &#123; public static void main(String[] args) &#123; try &#123; //创建一个合适的Configration对象 Configuration configuration = new Configuration(); configuration.setDirectoryForTemplateLoading(new File("D:\\project\\webProject\\WebContent\\WEB-INF\\template")); configuration.setObjectWrapper(new DefaultObjectWrapper()); configuration.setDefaultEncoding("UTF-8"); //这个一定要设置，不然在生成的页面中 会乱码 //获取或创建一个模版。 Template template = configuration.getTemplate("static.html"); Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); paramMap.put("description", "我正在学习使用Freemarker生成静态文件！"); List&lt;String&gt; nameList = new ArrayList&lt;String&gt;(); nameList.add("陈靖仇"); nameList.add("玉儿"); nameList.add("宇文拓"); paramMap.put("nameList", nameList); Map&lt;String, Object&gt; weaponMap = new HashMap&lt;String, Object&gt;(); weaponMap.put("first", "轩辕剑"); weaponMap.put("second", "崆峒印"); weaponMap.put("third", "女娲石"); weaponMap.put("fourth", "神农鼎"); weaponMap.put("fifth", "伏羲琴"); weaponMap.put("sixth", "昆仑镜"); weaponMap.put("seventh", null); paramMap.put("weaponMap", weaponMap); Writer writer = new OutputStreamWriter(new FileOutputStream("success.html"),"UTF-8"); template.process(paramMap, writer); System.out.println("恭喜，生成成功~~"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 这样子基本上可以算的上可以简单的去做一点简单的生成了，但是要在实际中去运用，还是差的很远的，因为freemarker给的标签完全满足不了我们的需要，这时候就需要自定义标签来完成我们的需求了。。 五、Freemarker自定义标签Freemarker自定义标签就是自己写标签，然后自己解析，完全由自己来控制标签的输入输出，极大的为程序员提供了很大的发挥空间。 基于步骤： ​ 以前写标签需要在&lt;后加# ，但是freemarker要识别自定义标签需要在后面加上@，然后后面可以定义一些参数，当程序执行template.process(paramMap, out);,就会去解析整个页面的所有的freemarker标签。 ​ 自定义标签 需要自定义一个类，然后实现TemplateDirectiveModel，重写execute方法，完成获取参数，根据参数do something等等。 ​ 将自定义标签与解析类绑定在一起需要在paramMap中放入该解析类的实例，存放的key与自定义标签一致即可。 ​ 注意：在自定义标签中，如果标签内什么也没有，开始标签和结束标签绝对不能再同一行，不然会报错 freemarker.log.JDK14LoggerFactory$JDK14Logger error 例:static.html模板 1234567891011121314151617181920&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;#--自定义变量--&gt;&lt;#assign num='hehe'/&gt;$&#123;num&#125;&lt;br/&gt;自定义标签 &lt;@content name="chenghui" age="120"&gt; $&#123;output&#125; $&#123;append&#125; &lt;/@content&gt; &lt;/body&gt;&lt;/html&gt; static.html模板解析类： ​ 参数解释： TemplateDirectiveModel接口是freemarker自定标签或者自定义指令的核心处理接口。通过实现该接口，用户可以自定义标签（指令）进行任意操作， 任意文本写入模板的输出。该接口中只定义了如下方法，当模板页面遇到用户自定义的标签指令时，该方法会被执行。public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException; @param env：系统环境变量，通常用它来输出相关内容，如Writer out = env.getOut(); @param params：自定义标签传过来的对象，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等 @param loopVars 循环替代变量 @param body 用于处理自定义标签中的内容，如&lt;@myDirective&gt;将要被处理的内容&lt;/@myDirective&gt;；当标签是&lt;@myDirective /&gt;格式时，body=null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.chenghui.test;import static freemarker.template.ObjectWrapper.DEFAULT_WRAPPER;import java.io.IOException;import java.io.Writer;import java.util.Map;import freemarker.core.Environment;import freemarker.template.TemplateDirectiveBody;import freemarker.template.TemplateDirectiveModel;import freemarker.template.TemplateException;import freemarker.template.TemplateModel;import freemarker.template.TemplateModelException;import freemarker.template.TemplateNumberModel;import freemarker.template.TemplateScalarModel;/** * 自定义标签解析类 * @author Administrator * */public class ContentDirective implements TemplateDirectiveModel&#123; private static final String PARAM_NAME = "name"; private static final String PARAM_AGE = "age"; @Override public void execute(Environment env, Map params,TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; if(body==null)&#123; throw new TemplateModelException("null body"); &#125;else&#123; String name = getString(PARAM_NAME, params); Integer age = getInt(PARAM_AGE, params); //接收到参数之后可以根据做具体的操作，然后将数据再在页面中显示出来。 if(name!=null)&#123; env.setVariable("output", DEFAULT_WRAPPER.wrap("从ContentDirective解析类中获得的参数是："+name+", ")); &#125; if(age!=null)&#123; env.setVariable("append", DEFAULT_WRAPPER.wrap("年龄："+age)); &#125; Writer out = env.getOut(); out.write("从这里输出可以再页面看到具体的内容，就像document.writer写入操作一样。&lt;br/&gt;"); body.render(out); /* 如果细心的话，会发现页面上是显示out.write（）输出的语句，然后再输出output的内容， 可见 在body在解析的时候会先把参数放入env中，在页面遇到对应的而来表单时的才会去取值 但是，如果该表单时不存在，就会报错， 我觉得这里freemarker没有做好，解析的时候更加会把错误暴露在页面上。 可以这样子弥补$&#123;output!"null"&#125;,始终感觉没有el表达式那样好。 */ &#125; &#125; /** * 获取String类型的参数的值 * @param paramName * @param paramMap * @return * @throws TemplateModelException */ public static String getString(String paramName, Map&lt;String, TemplateModel&gt; paramMap) throws TemplateModelException&#123; TemplateModel model = paramMap.get(paramName); if(model == null)&#123; return null; &#125; if(model instanceof TemplateScalarModel)&#123; return ((TemplateScalarModel)model).getAsString(); &#125;else if (model instanceof TemplateNumberModel) &#123; return ((TemplateNumberModel)model).getAsNumber().toString(); &#125;else&#123; throw new TemplateModelException(paramName); &#125; &#125; /** * * 获得int类型的参数 * @param paramName * @param paramMap * @return * @throws TemplateModelException */ public static Integer getInt(String paramName, Map&lt;String, TemplateModel&gt; paramMap) throws TemplateModelException&#123; TemplateModel model = paramMap.get(paramName); if(model==null)&#123; return null; &#125; if(model instanceof TemplateScalarModel)&#123; String str = ((TemplateScalarModel)model).getAsString(); try &#123; return Integer.valueOf(str); &#125; catch (NumberFormatException e) &#123; throw new TemplateModelException(paramName); &#125; &#125;else if(model instanceof TemplateNumberModel)&#123; return ((TemplateNumberModel)model).getAsNumber().intValue(); &#125;else&#123; throw new TemplateModelException(paramName); &#125; &#125;&#125; ​ 然后再前面的实际代码中加上： 1paramMap.put("content", new ContentDirective()); 这样子基本上可以使用，freemarker完成自定义标签了，解决一写简单的业务逻辑， 但是在实际的项目中不可能这样子去做，因为还没有和spring进行集成使用，每次都需要在解析的时候把解析类的实例放进去。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识梳理（三）—— html&JavaScript&ajax部分]]></title>
    <url>%2Fblog%2F42994.html</url>
    <content type="text"><![CDATA[html&amp;JavaScript&amp;ajax 判断第二个日期比第一个日期大​ 如何用脚本判断用户输入的的字符串是下面的时间格式2004-11-21 必须要保证用户的输入是此格式，并且是时间，比如说月份不大于12等等，另外我需要用户输入两个，并且后一个要比前一个晚，只允许用JAVASCRIPT，请详细帮助作答. //这里可用正则表达式判断提前判断一下格式，然后按下提取各时间字段内容 123456789101112131415161718192021222324252627282930&lt;scripttype="text/javascript"&gt;window.onload = function()&#123;//这么写是为了实现js代码与html代码的分离，当我修改js时，不能影响html代码。document.getElementById("frm1").onsubmit=function()&#123; var d1 =this.d1.value; var d2 =this.d2.value; if(!verifyDate (d1))&#123;alert("第一个日期格式不对");return false;&#125; if(!verifyDate (d2))&#123;alert("第二个日期格式不对");return false;&#125; if(!compareDate(d1,d2))&#123;alert("第二个日期比第一日期小");return false;&#125; &#125;;&#125;functioncompareDate(d1,d2)&#123; var arrayD1 =d1.split("-"); var date1 = new Date(arrayD1[0],arrayD1[1],arrayD1[2]); var arrayD2 =d2.split("-"); var date2 = newDate(arrayD2[0],arrayD2[1],arrayD2[2]); if(date1 &gt;date2) return false; return true;&#125;functionverifyDate(d)&#123; var datePattern= /^\d&#123;4&#125;-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2]\d|3[0-1])$/;returndatePattern.test(d);&#125;&lt;/script&gt;&lt;formid="frm1" action="xxx.html"&gt;&lt;inputtype="text" name="d1" /&gt;&lt;inputtype="text" name="d2" /&gt;&lt;inputtype="submit"/&gt;&lt;/form&gt; 用table显示n条记录，每3行换一次颜色，即1，2，3用红色字体，4，5，6用绿色字体，7，8，9用红颜色字体。12345678910111213141516171819202122232425&lt;body&gt;&lt;tableid="tbl"&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;9&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;scripttype="text/javascript"&gt;window.onload=function()&#123; var tbl =document.getElementById("tbl"); rows =tbl.getElementsByTagName("tr");for(i=0;i&lt;rows.length;i++)&#123; var j =parseInt(i/3); if(j%2==0)rows[i].style.backgroundColor="#f00"; else rows[i].style.backgroundColor="#0f0"; &#125;&#125;&lt;/script&gt; HTML 的 form 提交之前如何验证数值文本框的内容全部为数字? 否则的话提示用户并终止提交?12345678910111213141516&lt;formonsubmit=’return chkForm(this)’&gt;&lt;inputtype="text" name="d1"/&gt;&lt;inputtype="submit"/&gt;&lt;/form&gt;&lt;scripttype=”text/javascript” /&gt; function chkForm(this)&#123; var value= thist.d1.value; var len =value.length; for(vari=0;i&lt;len;i++)&#123; if(value.charAt(i)&gt;"9"|| value.charAt(i)&lt;"0")&#123; alert("含有非数字字符");return false; &#125; &#125; return true;&#125;&lt;/script&gt; 请写出用于校验HTML文本框中输入的内容全部为数字的javascript代码1234567891011121314&lt;inputtype="text" id="d1" onblur=" chkNumber(this)"/&gt;&lt;scripttype=”text/javascript” /&gt;functionchkNumber(eleText) &#123; var value =eleText.value; var len =value.length;for(vari=0;i&lt;len;i++)&#123; if(value.charAt(i)&gt;"9"|| value.charAt(i)&lt;"0")&#123; alert("含有非数字字符"); eleText.focus(); break; &#125; &#125;&#125;&lt;/script&gt; 除了写完代码，还应该在网页上写出实验步骤和在代码中加入实现思路，让面试官一看就明白你的意图和检查你的结果。]]></content>
      <categories>
        <category>Java</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>html</tag>
        <tag>JavaScript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识梳理（二）——算法与编程]]></title>
    <url>%2Fblog%2F44611.html</url>
    <content type="text"><![CDATA[Java算法编程。java排序算法，经典问题算法，单例模式 编写一个程序，将a.txt文件中的单词与b.txt文件中的单词交替合并到c.txt文件中，a.txt文件中的单词用回车符分隔，b.txt文件中用回车或空格进行分隔。答： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.File;import java.io.FileReader;import java.io.FileWriter;public class MainClass &#123; public static void main(String[] args) throws Exception &#123; FileManager a = new FileManager("a.txt", new char[] &#123; '\n' &#125;); FileManager b = new FileManager("b.txt", new char[] &#123; '\n', ' ' &#125;); FileWriter c = new FileWriter("c.txt"); String aWord = null; String bWord = null; while ((aWord = a.nextWord()) != null) &#123; c.write(aWord + "\n"); bWord = b.nextWord(); if (bWord != null) c.write(bWord + "\n"); &#125; while ((bWord = b.nextWord()) != null) &#123; c.write(bWord + "\n"); &#125; c.close(); &#125;&#125;class FileManager &#123; String[] words = null; int pos = 0; public FileManager(String filename, char[] seperators) throws Exception &#123; File f = new File(filename); FileReader reader = new FileReader(f); char[] buf = new char[(int) f.length()]; int len = reader.read(buf); String results = new String(buf, 0, len); String regex = null; if (seperators.length &gt; 1) &#123; regex = "" + seperators[0] + "|" + seperators[1]; &#125; else &#123; regex = "" + seperators[0]; &#125; words = results.split(regex); &#125; public String nextWord() &#123; if (pos == words.length) return null; return words[pos++]; &#125;&#125; 编写一个程序，将d:\java目录下的所有.java文件复制到d:\jad目录下，并将原来文件的扩展名从.java改为.jad。（大家正在做上面这道题，网上迟到的朋友也请做做这道题，找工作必须能编写这些简单问题的代码！） 答：listFiles方法接受一个FileFilter对象，这个FileFilter对象就是过虑的策略对象，不同的人提供不同的FileFilter实现，即提供了不同的过滤策略。 123456789101112131415161718192021222324252627282930313233343536373839import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FilenameFilter;import java.io.InputStream;import java.io.OutputStream;public class Jad2Java &#123; public static void main(String[] args) throws Exception &#123; File srcDir = new File("java"); if (!(srcDir.exists() &amp;&amp; srcDir.isDirectory())) throw new Exception("目录不存在"); File[] files = srcDir.listFiles(new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; return name.endsWith(".java"); &#125; &#125;); System.out.println(files.length); File destDir = new File("jad"); if (!destDir.exists()) destDir.mkdir(); for (File f : files) &#123; FileInputStream fis = new FileInputStream(f); String destFileName = f.getName().replaceAll(".java", ".jad"); FileOutputStream fos = new FileOutputStream(new File(destDir, destFileName)); copy(fis, fos); fis.close(); fos.close(); &#125; &#125; private static void copy(InputStream ips, OutputStream ops) throws Exception &#123; int len = 0; byte[] buf = new byte[1024]; while ((len = ips.read(buf)) != -1) &#123; ops.write(buf, 0, len); &#125; &#125;&#125; 由本题总结的思想及策略模式的解析： 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.File;import java.io.FileFilter;import java.util.Arrays;class jad2java1&#123;//得到某个目录下的所有的java文件集合//1.1得到目录 File srcDir =new File("d:java");//1.2 得到目录下的所有java文件： File[] files =srcDir.listFiles(new MyFileFilter());//1.3 只想得到.java的文件： class MyFileFilter implements FileFilter&#123; public boolean accept(File pathname)&#123; return pathname.getName().endsWith(".java"); &#125;&#125;//2.将每个文件复制到另外一个目录，并改扩展名//2.1 得到目标目录，如果目标目录不存在，则创建之//2.2 根据源文件名得到目标文件名，注意要用正则表达式，注意.的转义。//2.3 根据表示目录的File和目标文件名的字符串，得到表示目标文件的File。 //要在硬盘中准确地创建出一个文件，需要知道文件名和文件的目录。//2.4 将源文件的流拷贝成目标文件流，拷贝方法独立成为一个方法，方法的参数采用抽象流的形式。 //方法接受的参数类型尽量面向父类，越抽象越好，这样适应面更宽广。&#125;//分析listFiles方法内部的策略模式实现原理File[] listFiles(FileFilter filter)&#123;File[] files = listFiles(filter);//Arraylist acceptedFilesList = newArrayList();File[] acceptedFiles = new File[files.length];int pos = 0;for(File file: files)&#123;boolean accepted = filter.accept(file);if(accepted)&#123;//acceptedFilesList.add(file);acceptedFiles[pos++] = file; &#125;&#125;Arrays.copyOf(acceptedFiles,pos);//return (File[])accpetedFilesList.toArray(); &#125;&#125; 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。答： 首先要了解中文字符有多种编码及各种编码的特征。 ​ 假设n为要截取的字节数。 123456789101112131415161718192021public class TrimGBK &#123; public static void main(String[] args) throws Exception &#123; String str = "我a爱中华abc我爱传智def"; int num = trimGBK(str.getBytes("GBK"), 5); System.out.println(str.substring(0, num)); &#125; public static int trimGBK(byte[] buf, int n) &#123; int num = 0; boolean bChineseFirstHalf = false; for (int i = 0; i &lt; n; i++) &#123; if (buf[i] &lt; 0 &amp;&amp; !bChineseFirstHalf) &#123; bChineseFirstHalf = true; &#125; else &#123; num++; bChineseFirstHalf = false; &#125; &#125; return num; &#125;&#125; 有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数。答：如果一串字符如”aaaabbc中国1512”要分别统计英文字符的数量，中文字符的数量，和数字字符的数量，假设字符中没有中文字符、英文字符、数字字符之外的其他特殊字符。 1234567891011121314151617181920public class CountABC &#123; public static void main(String[] args) &#123; String str = "aaaabbc中国1512"; int engishCount = 0; int chineseCount = 0; int digitCount = 0; for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; digitCount++; &#125; else if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) &#123; engishCount++; &#125; else &#123; chineseCount++; &#125; &#125; System.out.println("英文字符的数量" + engishCount + ",中文字符的数量" + chineseCount + "，和数字字符的数量" + digitCount); &#125;&#125; 说明生活中遇到的二叉树，用java实现二叉树这是组合设计模式。 我有很多个(假设10万个)数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据，（我想说出二叉树的好处，该怎么说呢？那就是说别人的缺点），假如存在数组中，那么，碰巧要找的数字位于99999那个地方，那查找的速度将很慢，因为要从第1个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序，中序，后序）效率要比数组低很多。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Node &#123; public int value; public Node left; public Node right; public void store(int value) &#123; if (value &lt; this.value) &#123; if (left == null) &#123; left = new Node(); left.value = value; &#125; else &#123; left.store(value); &#125; &#125; else if (value &gt; this.value) &#123; if (right == null) &#123; right = new Node(); right.value = value; &#125; else &#123; right.store(value); &#125; &#125; &#125; public boolean find(int value) &#123; System.out.println("happen" + this.value); if (value == this.value) &#123; return true; &#125; else if (value &gt; this.value) &#123; if (right == null) return false; return right.find(value); &#125; else &#123; if (left == null) return false; return left.find(value); &#125; &#125; public void preList() &#123; System.out.print(this.value + ","); if (left != null) left.preList(); if (right != null) right.preList(); &#125; public void middleList() &#123; if (left != null) left.preList(); System.out.print(this.value + ","); if (right != null) right.preList(); &#125; public void afterList() &#123; if (left != null) left.preList(); if (right != null) right.preList(); System.out.print(this.value + ","); &#125; public static void main(String[] args) &#123; int[] data = new int[20]; for (int i = 0; i &lt; data.length; i++) &#123; data[i] = (int) (Math.random() * 100) + 1; System.out.print(data[i] + ","); &#125; System.out.println(); Node root = new Node(); root.value = data[0]; for (int i = 1; i &lt; data.length; i++) &#123; root.store(data[i]); &#125; root.find(data[19]); root.preList(); System.out.println(); root.middleList(); System.out.println(); root.afterList(); &#125;&#125; 从类似如下的文本文件中读取出所有的姓名，并打印出重复的姓名和重复的次数，并按重复次数排序：1,张三,28 2,李四,35 3,张三,28 4,王五,35 5,张三,28 6,李四,35 7,赵六,28 8,田七,35 程序代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* * 从类似如下的文本文件中读取出所有的姓名，并打印出重复的 * 姓名和重复的次数，并按重复次数排序： */import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.TreeMap;public class CopyOfGetNameTest &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; results = new TreeMap&lt;String, Integer&gt;(); List&lt;User&gt; tm = new ArrayList&lt;User&gt;(); tm.add(new User("张三", 28)); tm.add(new User("李四", 35)); tm.add(new User("张三", 28)); tm.add(new User("王五", 35)); tm.add(new User("张三", 28)); tm.add(new User("李四", 35)); tm.add(new User("赵六", 28)); tm.add(new User("田七", 35)); for (User x : tm) &#123; dealLine(x, results); &#125; for (Map.Entry&lt;String, Integer&gt; m : results.entrySet()) &#123; System.out.println(m); &#125; &#125; private static void dealLine(User x, Map&lt;String, Integer&gt; map) &#123; String name = x.getName(); Integer value = (Integer) map.get(name); if (value == null) &#123; value = 0; &#125; map.put(name, value + 1); &#125; public static void dealLine(String line, Map&lt;String, Integer&gt; map) &#123; if (!"".equals(line.trim())) &#123; String[] results = line.split(","); if (results.length == 3) &#123; String name = results[1]; Integer value = (Integer) map.get(name); if (value == null) &#123; value = 0; &#125; map.put(name, value + 1); &#125; &#125; &#125;&#125;class User implements Comparable&lt;User&gt; &#123; public String name; public Integer value; public User(String name, Integer value) &#123; this.name = name; this.value = value; &#125; public String getName() &#123; return name; &#125; public Integer getAge() &#123; return value; &#125; @Override public String toString() &#123; return "name = " + name + " value = " + value; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (obj instanceof User) &#123; User user = (User) obj; if ((this.name.equals(user.name)) &amp;&amp; (this.value == user.value)) &#123; return true; &#125; &#125; return false; &#125; public int compareTo(User user) &#123; int num = 0; int i = this.name.compareTo(user.name); if (i &gt; 0) &#123; num = 1; &#125; else if (i &lt; 0) &#123; num = -1; &#125; else &#123; num = this.value &gt; user.value ? 1 : (this.value == user.value ? 0 : -1); &#125; return num; &#125;&#125; 单实例Singleton设计模式单实例Singleton设计模式可能是被讨论和使用的最广泛的一个设计模式了，这可能也是面试中问得最多的一个设计模式了。这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类，等等。你希望这个类在整个系统中只能出现一个实例。当然，作为一个技术负责人的你，你当然有权利通过使用非技术的手段来达到你的目的。比如：你在团队内部明文规定，“XX类只能有一个全局实例，如果某人使用两次以上，那么该人将被处于2000元的罚款！”（呵呵），你当然有权这么做。但是如果你的设计的是东西是一个类库，或是一个需要提供给用户使用的API，恐怕你的这项规定将会失效。因为，你无权要求别人会那么做。所以，这就是为什么，我们希望通过使用技术的手段来达成这样一个目的的原因。 本文会带着你深入整个Singleton的世界，当然，我会放弃使用C++语言而改用Java语言，因为使用Java这个语言可能更容易让我说明一些事情。 Singleton的教学版本这里，我将直接给出一个Singleton的简单实现，因为我相信你已经有这方面的一些基础了。我们姑且把这个版本叫做1.0版 1234567891011// version 1.0public class Singleton &#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; singleton= new Singleton(); &#125; return singleton; &#125;&#125; 在上面的实例中，我想说明下面几个Singleton的特点：（下面这些东西可能是尽人皆知的，没有什么新鲜的） 私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。 即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。 在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。 所形成的实例保存在自己类中的私有成员中。 我们取实例时，只需要使用Singleton.getInstance()就行了。 当然，如果你觉得知道了上面这些事情后就学成了，那得给你当头棒喝一下了，事情远远没有那么简单。 Singleton的实际版本上面的这个程序存在比较严重的问题，因为是全局性的实例，所以，在多线程情况下，所有的全局共享的东西都会变得非常的危险，这个也一样，在多线程情况下，如果多个线程同时调用getInstance()的话，那么，可能会有多个进程同时通过 (singleton== null)的条件检查，于是，多个实例就创建出来，并且很可能造成内存泄露问题。嗯，熟悉多线程的你一定会说——“我们需要线程互斥或同步”，没错，我们需要这个事情，于是我们的Singleton升级成1.1版，如下所示： 1234567891011121314// version 1.1public class Singleton&#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; synchronized (Singleton.class) &#123; singleton= new Singleton(); &#125; &#125; return singleton; &#125;&#125; 嗯，使用了Java的synchronized方法，看起来不错哦。应该没有问题了吧？！错！这还是有问题！为什么呢？前面已经说过，如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，那不还是一样的吗？同样会出现很多实例。嗯，确实如此！看来，还得把那个判断(singleton== null)条件也同步起来。于是，我们的Singleton再次升级成1.2版本，如下所示： 1234567891011121314// version 1.2public class Singleton&#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; synchronized (Singleton.class) &#123; if (singleton== null) &#123; singleton= new Singleton(); &#125; &#125; return singleton; &#125;&#125; 不错不错，看似很不错了。在多线程下应该没有什么问题了，不是吗？的确是这样的，1.2版的Singleton在多线程下的确没有问题了，因为我们同步了所有的线程。只不过嘛……，什么？！还不行？！是的，还是有点小问题，我们本来只是想让new这个操作并行就可以了，现在，只要是进入getInstance()的线程都得同步啊，注意，创建对象的动作只有一次，后面的动作全是读取那个成员变量，这些读取的动作不需要线程同步啊。这样的作法感觉非常极端啊，为了一个初始化的创建动作，居然让我们达上了所有的读操作，严重影响后续的性能啊！ 还得改！嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton。 12345678910111213141516// version 1.3public class Singleton&#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; synchronized (Singleton.class) &#123; if (singleton== null) &#123; singleton= new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明： 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。 不然，我们就开始同步线程。 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。 相当不错啊，干得非常漂亮！请大家为我们的1.3版起立鼓掌！ 但是，如果你认为这个版本大攻告成，你就错了。 主要在于singleton = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。 给 singleton 分配内存 调用 Singleton 的构造函数来初始化成员变量，形成实例 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版： 12345678910111213141516// version 1.4public class Singleton&#123; private volatile static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; synchronized (Singleton.class) &#123; if (singleton== null) &#123; singleton= new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 使用 volatile 有两个功用： 1）这个变量不会在多个线程中存在复本，直接从内存读取。 2）这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。 但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。 Singleton 的简化版本上面的玩法实在是太复杂了，一点也不优雅，下面是一种更为优雅的方式： 这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 123456789// version 1.5public class Singleton&#123; private volatile static Singleton singleton = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 但是，这种玩法的最大问题是——当这个类被加载的时候，new Singleton() 这句话就会被执行，就算是getInstance()没有被调用，类也被初始化了。 于是，这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。 好吧，我们还得绕一下： 下面的这个1.6版是老版《Effective Java》中推荐的方式。 12345678910// version 1.6public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 Singleton 优雅版本123public enum Singleton&#123; INSTANCE;&#125; 居然用枚举！！看上去好牛逼，通过EasySingleton.INSTANCE来访问，这比调用getInstance()方法简单多了。 默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。 这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。 Singleton的其它问题怎么？还有问题？！当然还有，请记住下面这条规则——“无论你的代码写得有多好，其只能在特定的范围内工作，超出这个范围就要出Bug了”，这是“陈式第一定理”，呵呵。你能想一想还有什么情况会让这个我们上面的代码出问题吗？ 在C++下，我不是很好举例，但是在Java的环境下，嘿嘿，还是让我们来看看下面的一些反例和一些别的事情的讨论（当然，有些反例可能属于钻牛角尖，可能有点学院派，不过也不排除其实际可能性，就算是提个醒吧）： Class Loader。不知道你对Java的Class Loader熟悉吗？“类装载器”？！C++可没有这个东西啊。这是Java动态性的核心。顾名思义，类装载器是用来把类(class)装载进JVM的。JVM规范定义了两种类型的类装载器：启动内装载器(bootstrap)和用户自定义装载器(user-defined class loader)。 在一个JVM中可能存在多个ClassLoader，每个ClassLoader拥有自己的NameSpace。一个ClassLoader只能拥有一个class对象类型的实例，但是不同的ClassLoader可能拥有相同的class对象实例，这时可能产生致命的问题。如ClassLoaderA，装载了类A的类型实例A1，而ClassLoaderB，也装载了类A的对象实例A2。逻辑上讲A1=A2，但是由于A1和A2来自于不同的ClassLoader，它们实际上是完全不同的，如果A中定义了一个静态变量c，则c在不同的ClassLoader中的值是不同的。 于是，如果咱们的Singleton 1.3版本如果面对着多个Class Loader会怎么样？呵呵，多个实例同样会被多个Class Loader创建出来，当然，这个有点牵强，不过他确实存在。难道我们还要整出个1.4版吗？可是，我们怎么可能在我的Singleton类中操作Class Loader啊？是的，你根本不可能。在这种情况下，你能做的只有是——“保证多个Class Loader不会装载同一个Singleton”。 序例化。如果我们的这个Singleton类是一个关于我们程序配置信息的类。我们需要它有序列化的功能，那么，当反序列化的时候，我们将无法控制别人不多次反序列化。不过，我们可以利用一下Serializable接口的readResolve()方法，比如： 123456789public class Singleton implements Serializable&#123; ...... ...... protected Object readResolve() &#123; return getInstance(); &#125;&#125; 多个Java虚拟机。如果我们的程序运行在多个Java的虚拟机中。什么？多个虚拟机？这是一种什么样的情况啊。嗯，这种情况是有点极端，不过还是可能出现，比如EJB或RMI之流的东西。要在这种环境下避免多实例，看来只能通过良好的设计或非技术来解决了。 volatile变量。关于volatile这个关键字所声明的变量可以被看作是一种 “程度较轻的同步synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当然，如前面所述，我们需要的Singleton只是在创建的时候线程同步，而后面的读取则不需要同步。所以，volatile变量并不能帮助我们即能解决问题，又有好的性能。而且，这种变量只能在JDK 1.5+版后才能使用。 关于继承。是的，继承于Singleton后的子类也有可能造成多实例的问题。不过，因为我们早把Singleton的构造函数声明成了私有的，所以也就杜绝了继承这种事情。 关于代码重用。也话我们的系统中有很多个类需要用到这个模式，如果我们在每一个类都中有这样的代码，那么就显得有点傻了。那么，我们是否可以使用一种方法，把这具模式抽象出去？在C++下这是很容易的，因为有模板和友元，还支持栈上分配内存，所以比较容易一些（程序如下所示），Java下可能比较复杂一些，聪明的你知道怎么做吗？ 123456789101112131415161718192021222324template class Singleton&#123; public: static T&amp; Instance() &#123; static T theSingleInstance; //假设T有一个protected默认构造函数 return theSingleInstance; &#125;&#125;;class OnlyOne : public Singleton&#123; friend class Singleton; int example_data; public: int GetExampleData() const &#123;return example_data;&#125; protected: OnlyOne(): example_data(42) &#123;&#125; // 默认构造函数 OnlyOne(OnlyOne&amp;) &#123;&#125;&#125;;int main( )&#123; cout &lt;&lt; OnlyOne::Instance().GetExampleData() &lt;&lt; endl; return 0;&#125; 递归算法题1一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。例：n=1237则输出为：1237，2474，4948，9896，9896，4948，2474，1237， 提示：写程序时，先致谢按递增方式的代码，写好递增的以后，再增加考虑递减部分。 123456public static void doubleNum(int n)&#123; System.out.println(n); if(n&lt;=5000) doubleNum(n*2); System.out.println(n);&#125; 递归算法题2第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？ 123456789101112public class Test &#123; public static void main(String[] args) &#123; System.out.println(computeAge(8)); &#125; public static int computeAge(int n) &#123; if (n == 1) &#123; return 10; &#125; else &#123; return computeAge(n - 1) + 2; &#125; &#125;&#125; 排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391//插入排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class InsertSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; int temp; for(int i=1;i&lt;data.length;i++)&#123; for(int j=i;(j&gt;0)&amp;&amp;(data[j]&lt;data[j-1]);j--)&#123; SortUtil.swap(data,j,j-1); &#125; &#125; &#125;&#125;//冒泡排序: for(var i=0; i&lt;arr.length; i++) &#123; for(var j=i+1; j&lt;=arr.length-1; j++) &#123; if(eval(arr[i]) &lt; eval(arr[j])) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125;&#125; package org.rut.util.algorithm.support; import org.rut.util.algorithm.SortUtil;public class BubbleSort implements SortUtil.Sort public void sort(int[] data) &#123; int temp; for(int i=0;i&lt;data.length;i++)&#123; for(int j=data.length-1;j&gt;i;j--)&#123; if(data[j]&lt;data[j-1])&#123; SortUtil.swap(data,j,j-1); &#125; &#125; &#125; &#125; &#125; //选择排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class SelectionSort implements SortUtil.Sort &#123; public void sort(int[] data) &#123; int temp; for (int i = 0; i &lt; data.length; i++) &#123; int lowIndex = i; for (int j = data.length - 1; j &gt; i; j--) &#123; if (data[j] &lt; data[lowIndex]) &#123; lowIndex = j; &#125; &#125; SortUtil.swap(data,i,lowIndex); &#125; &#125; &#125; //Shell排序: package org.rut.util.algorithm.support; import org.rut.util.algorithm.SortUtil;public class ShellSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; for(int i=data.length/2;i&gt;2;i/=2)&#123; for(int j=0;j&lt;i;j++)&#123; insertSort(data,j,i); &#125; &#125; insertSort(data,0,1); &#125; private void insertSort(int[] data, int start, int inc) &#123; int temp; for(int i=start+inc;i&lt;data.length;i+=inc)&#123; for(int j=i;(j&gt;=inc)&amp;&amp;(data[j]&lt;data[j-inc]);j-=inc)&#123; SortUtil.swap(data,j,j-inc); &#125; &#125; &#125; &#125; //快速排序: package org.rut.util.algorithm.support; import org.rut.util.algorithm.SortUtil;public class QuickSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; quickSort(data,0,data.length-1); &#125; private void quickSort(int[] data,int i,int j)&#123; int pivotIndex=(i+j)/2; //swap SortUtil.swap(data,pivotIndex,j); int k=partition(data,i-1,j,data[j]); SortUtil.swap(data,k,j); if((k-i)&gt;1) quickSort(data,i,k-1); if((j-k)&gt;1) quickSort(data,k+1,j); &#125; private int partition(int[] data, int l, int r,int pivot) &#123; do&#123; while(data[++l]&lt;pivot); while((r!=0)&amp;&amp;data[--r]&gt;pivot); SortUtil.swap(data,l,r); &#125; while(l&lt;r); SortUtil.swap(data,l,r); return l; &#125; &#125;//改进后的快速排序: package org.rut.util.algorithm.support; import org.rut.util.algorithm.SortUtil;public class ImprovedQuickSort implements SortUtil.Sort &#123; private static int MAX_STACK_SIZE=4096; private static int THRESHOLD=10; public void sort(int[] data) &#123; int[] stack=new int[MAX_STACK_SIZE]; int top=-1; int pivot; int pivotIndex,l,r; stack[++top]=0; stack[++top]=data.length-1; while(top&gt;0)&#123; int j=stack[top--]; int i=stack[top--]; pivotIndex=(i+j)/2; pivot=data[pivotIndex]; SortUtil.swap(data,pivotIndex,j); //partition l=i-1; r=j; do&#123; while(data[++l]&lt;pivot); while((r!=0)&amp;&amp;(data[--r]&gt;pivot)); SortUtil.swap(data,l,r); &#125; while(l&lt;r); SortUtil.swap(data,l,r); SortUtil.swap(data,l,j); if((l-i)&gt;THRESHOLD)&#123; stack[++top]=i; stack[++top]=l-1; &#125; if((j-l)&gt;THRESHOLD)&#123; stack[++top]=l+1; stack[++top]=j; &#125; &#125; //new InsertSort().sort(data); insertSort(data); &#125; private void insertSort(int[] data) &#123; int temp; for(int i=1;i&lt;data.length;i++)&#123; for(int j=i;(j&gt;0)&amp;&amp;(data[j]&lt;data[j-1]);j--)&#123; SortUtil.swap(data,j,j-1); &#125; &#125; &#125; &#125; //归并排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class MergeSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; int[] temp=new int[data.length]; mergeSort(data,temp,0,data.length-1); &#125; private void mergeSort(int[] data,int[] temp,int l,int r)&#123; int mid=(l+r)/2; if(l==r) return ; mergeSort(data,temp,l,mid); mergeSort(data,temp,mid+1,r); for(int i=l;i&lt;=r;i++)&#123; temp[i]=data[i]; &#125; int i1=l; int i2=mid+1; for(int cur=l;cur&lt;=r;cur++)&#123; if(i1==mid+1) data[cur]=temp[i2++]; else if(i2&gt;r) data[cur]=temp[i1++]; else if(temp[i1]&lt;temp[i2]) data[cur]=temp[i1++]; else data[cur]=temp[i2++]; &#125; &#125; &#125; //改进后的归并排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class ImprovedMergeSort implements SortUtil.Sort &#123; private static final int THRESHOLD = 10; public void sort(int[] data) &#123; int[] temp=new int[data.length]; mergeSort(data,temp,0,data.length-1); &#125; private void mergeSort(int[] data, int[] temp, int l, int r) &#123; int i, j, k; int mid = (l + r) / 2; if (l == r) return; if ((mid - l) &gt;= THRESHOLD) mergeSort(data, temp, l, mid); else insertSort(data, l, mid - l + 1); if ((r - mid) &gt; THRESHOLD) mergeSort(data, temp, mid + 1, r); else insertSort(data, mid + 1, r - mid); for (i = l; i &lt;= mid; i++) &#123; temp[i] = data[i]; &#125; for (j = 1; j &lt;= r - mid; j++) &#123; temp[r - j + 1] = data[j + mid]; &#125; int a = temp[l]; int b = temp[r]; for (i = l, j = r, k = l; k &lt;= r; k++) &#123; if (a &lt; b) &#123; data[k] = temp[i++]; a = temp[i]; &#125; else &#123; data[k] = temp[j--]; b = temp[j]; &#125; &#125; private void insertSort(int[] data, int start, int len) &#123; for(int i=start+1;i&lt;start+len;i++)&#123; for(int j=i;(j&gt;start) &amp;&amp; data[j]&lt;data[j-1];j--)&#123; SortUtil.swap(data,j,j-1); &#125; &#125; &#125; &#125;//堆排序: package org.rut.util.algorithm.support;import org.rut.util.algorithm.SortUtil;public class HeapSort implements SortUtil.Sort&#123; public void sort(int[] data) &#123; MaxHeap h=new MaxHeap(); h.init(data); for(int i=0;i&lt;data.length;i++) h.remove(); System.arraycopy(h.queue,1,data,0,data.length); &#125; private static class MaxHeap&#123; void init(int[] data)&#123; this.queue=new int[data.length+1]; for(int i=0;i&lt;data.length;i++)&#123; queue[++size]=data[i]; fixUp(size); &#125; &#125; private int size=0; private int[] queue; public int get() &#123; return queue[1]; &#125; public void remove() &#123; SortUtil.swap(queue,1,size--); fixDown(1); &#125; //fixdown private void fixDown(int k) &#123; int j; while ((j = k &lt;&lt; 1) &lt;= size) &#123; if (j &lt; size &amp;&amp; queue[j]&lt;queue[j+1]) j++; if (queue[k]&gt;queue[j]) //不用交换 break; SortUtil.swap(queue,j,k); k = j; &#125; &#125; private void fixUp(int k) &#123; while (k &gt; 1) &#123; int j = k &gt;&gt; 1; if (queue[j]&gt;queue[k]) break; SortUtil.swap(queue,j,k); k = j; &#125; &#125; &#125; &#125; //SortUtil: package org.rut.util.algorithm; import org.rut.util.algorithm.support.BubbleSort;import org.rut.util.algorithm.support.HeapSort;import org.rut.util.algorithm.support.ImprovedMergeSort;import org.rut.util.algorithm.support.ImprovedQuickSort;import org.rut.util.algorithm.support.InsertSort;import org.rut.util.algorithm.support.MergeSort;import org.rut.util.algorithm.support.QuickSort;import org.rut.util.algorithm.support.SelectionSort;import org.rut.util.algorithm.support.ShellSort;public class SortUtil &#123; public final static int INSERT = 1; public final static int BUBBLE = 2; public final static int SELECTION = 3; public final static int SHELL = 4; public final static int QUICK = 5; public final static int IMPROVED_QUICK = 6; public final static int MERGE = 7; public final static int IMPROVED_MERGE = 8; public final static int HEAP = 9; public static void sort(int[] data) &#123; sort(data, IMPROVED_QUICK); &#125; private static String[] name=&#123; "insert","bubble","selection","shell","quick","improved_quick","merge","improved_merge","heap" &#125;; private static Sort[] impl=new Sort[]&#123; new InsertSort(), new BubbleSort(), new SelectionSort(), new ShellSort(), new QuickSort(), new ImprovedQuickSort(), new MergeSort(), new ImprovedMergeSort(), new HeapSort() &#125;; public static String toString(int algorithm)&#123; return name[algorithm-1]; &#125; public static void sort(int[] data, int algorithm) &#123; impl[algorithm-1].sort(data); &#125; public static interface Sort &#123; public void sort(int[] data); &#125; public static void swap(int[] data, int i, int j) &#123; int temp = data[i]; data[i] = data[j]; data[j] = temp; &#125;&#125; 有数组a[n]，用java代码将数组元素顺序颠倒1234567891011121314151617public class Test &#123; public static void reverse(int[] a, int left, int right) &#123; if (left &gt;= right) return; int temp; temp = a[left]; a[left] = a[right]; a[right] = temp; reverse(a, ++left, --right); &#125; public static void main(String args[]) &#123; int[] a = &#123; 1, 2, 3, 4, 5 &#125;; reverse(a, 0, a.length - 1); for (int i = 0; i &lt; a.length; i++) System.out.println(a[i]); &#125; &#125; 12．金额转换，阿拉伯数字的金额转换成中国传统的形式如：（￥1011）－&gt;（一千零一拾一元整）输出。 1234567891011121314151617181920212223public class Test &#123; private static final char[] data = new char[]&#123;'零','壹','贰','叁','肆','伍','陆','柒','捌','玖'&#125;; private static final char[] units = new char[]&#123;'元','拾','佰','仟','万','拾','佰','仟','亿'&#125;; /*去零的代码 return sb.reverse().toString().replaceAll("零[拾佰仟]","零").replaceAll("零+万","万").replaceAll("零+元","元").replaceAll("零+","零");*/ /*去零倒序 return sb.reverse().toString().replaceAll("零[拾佰仟]","零").replaceAll("零+万","万").replaceAll("零+元","元").replaceAll("零+","零");*/ public static void main(String[] args) &#123; System.out.println(convert(230009)); &#125; private static String convert(int money) &#123; StringBuffer sbf = new StringBuffer(); int unit = 0; while(money!=0) &#123; sbf.insert(0,units[unit++]); int number = money%10; sbf.insert(0, data[number]); money /= 10; &#125; return sbf.toString().replaceAll("零[拾佰仟]","零").replaceAll("零+万","万").replaceAll("零+元","元").replaceAll("零+","零"); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单例模式</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识梳理（一）——Java基础知识]]></title>
    <url>%2Fblog%2F50981.html</url>
    <content type="text"><![CDATA[基础部分的顺序：基本语法，类相关的语法，内部类的语法，继承相关的语法，异常的语法，线程的语法，集合的语法，io 的语法，虚拟机方面的语法。 1. 一个”.Java”源文件中是否可以包括多个类（不是内部类）？有什么限制？​ 可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 2. Java有没有goto?​ Java中的保留字，现在没有在Java中使用。 3. 说说&amp;和&amp;&amp;的区别。&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式 例如，对于if(str != null&amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。If(x==33 &amp; ++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 备注：这道题先说两者的共同点，再说出&amp;&amp;和&amp;的特殊之处，并列举一些经典的例子来表明自己理解透彻深入. 实际经验丰富。 4. 在Java中如何跳出当前的多重嵌套循环？在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如， 12345678ok:for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;10;j++)&#123;System.out.println(“i=” + i+ “,j=” + j);if(j == 5) break ok; &#125;&#125; 另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。 1234567891011int arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;;boolean found = false;for(int i=0;i&lt;arr.length &amp;&amp;!found;i++)&#123;for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.println(“i=” + i+ “,j=” + j); if(arri == 5) &#123;found = true;break; &#125; &#125;&#125; 5. switch语句能否作用在byte上，能否作用在long上，能否作用在String上?在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 6. short s1 = 1; s1= s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。 对于short s1 = 1; s1 += 1;由于 += 是Java语言规定的运算符，Java编译器会对它进行特殊处理，因此可以正确编译。 7.char型变量中能不能存贮一个中文汉字?为什么?char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 ​ 备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。 8.用最有效率的方法算出2乘以8等於几?2 &lt;&lt; 3， 因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 &lt;&lt; 3。 9. 请设计一个一百亿的计算器首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚. 要知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的面向对象的设计思想。 首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一定的范围的，为了便于讲解和理解，我们先以byte 类型的整数为例，它用1个字节进行存储，表示的最大数值范围为-128到+127。-1在内存中对应的二进制数据为11111111，如果两个-1相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,11111110，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为11111110，也就是-2，这正好利用溢位的方式实现了负数的运算。-128在内存中对应的二进制数据为10000000，如果两个-128相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,00000000，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为00000000，也就是0，这样的结果显然不是我们期望的，这说明计算机中的算术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。由于Java中涉及表达式运算时的类型自动提升，我们无法用byte类型来做演示这种问题和现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下： 1234int a = Integer.MAX_VALUE;int b = Integer.MAX_VALUE;int sum = a + b;System.out.println(“a=”+a+”,b=”+b+”,sum=”+sum); 先不考虑long类型，由于int的正数范围为2的31次方，表示的最大数值约等于210001000*1000，也就是20亿的大小，所以，要实现一个一百亿的计算器，我们得自己设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大概功能如下： （）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数 （）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中 （）提供加减乘除的功能 12345678910111213141516public class BigInteger&#123; int sign;byte[] val;public Biginteger(String val)&#123;sign = ;val = ; &#125;public BigInteger add(BigInteger other)&#123; &#125;public BigInteger subtract(BigIntegerother)&#123; &#125;public BigInteger multiply(BigIntegerother)&#123; &#125;public BigInteger divide(BigIntegerother)&#123; &#125;&#125; 备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看jdk中自带的Java.math.BigInteger类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这也是能力. 经验. 专业性. 英语水平等多个方面的体现，会给人留下很好的印象，在编程能力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一千元。 10. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句： 1final StringBuffer a=new StringBuffer("immutable"); 执行如下语句将报告编译期错误： 1a=new StringBuffer(""); 但是，执行如下语句则可以通过编译： 1a.append(" broken!"); 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： 12public voidmethod(final StringBuffer param)&#123;&#125; 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： 1param.append("a"); 11. “==”和equals方法究竟有什么区别？（单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区别自然就出来了，混在一起说，则很难说清楚） ==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。 如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = newObject();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。 equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码： 12String a=new String("foo");String b=new String("foo"); 两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。 在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。 如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下： 123boolean equals(Object o)&#123;return this==o;&#125; 这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object 类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。 12. 静态变量和实例变量的区别？在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。 例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。 123456789public class VariantTest&#123; public static int staticVar = 0; public int instanceVar = 0; public VariantTest()&#123; staticVar++; instanceVar++; System.out.println(“staticVar=” +staticVar + ”,instanceVar=” + instanceVar); &#125;&#125; 备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，体现了自己有很好的解说问题和设计案例的能力，思维敏捷, 超过一般程序员，有写作能力！ 13. 是否可以从一个static方法内部发出对非static方法的调用？不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不可以发出对非static方法的调用。 14. Integer与int的区别int是Java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是Java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。 在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。 另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。 15. Math.round(11.5)等於多少? Math.round(-11.5)等於多少?Math类中提供了三个与取整有关的方法：ceil. floor. round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.ceil(11.6)的结果为11,Math.ceil(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。 16. 下面的代码有什么不妥之处? if(username.equals(“zxx”){} int x = 1; return x==1?true:false; 17. 请说出作用域public，private，protected，以及不写时的区别这四个作用域的可见范围如下表所示。 说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。 作用域 当前类 同一package 子孙类其他package public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × 备注：只要记住了有4种访问权限，4个访问范围，然后将全选和范围在水平和垂直方向上分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。 18. Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?​ Overload是重载的意思，Override是覆盖的意思，也就是重写。 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。 至于Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，Java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。 override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点： 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果； 覆盖的方法的返回值必须和被覆盖的方法的返回一致； 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点： 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）； 不能通过访问权限. 返回类型. 抛出的异常进行重载； 方法的异常类型和数目不会对重载造成影响； 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 19. 构造器Constructor是否可被override?构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。 20. 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concreteclass)? 抽象类中是否可以有静态的main方法？​ 接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类中可以有静态的main方法。 备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是Java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。 只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。 21. 写clone()方法时，通常都有一行代码，是什么？clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。 22. 面向对象的特征有哪些方面计算机软件系统是现实生活中的业务在计算机中的映射，而现实生活中的业务其实就是一个个对象协作的过程。面向对象编程就是按现实业务一样的方式将程序代码按一个个对象进行组织和编写，让计算机系统能够识别和理解用对象方式组织和编写的程序代码，这样就可以把现实生活中的业务对象映射到计算机系统中。 面向对象的编程语言有封装. 继承 . 抽象. 多态等4个主要的特征。 封装： 封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚. 低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰. 更为有力。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。 例如，人要在黑板上画圆，这一共涉及三个对象：人. 黑板. 圆，画圆的方法要分配给哪个对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两个属性，人以后只是调用圆的画圆方法. 表示给圆发给消息而已，画圆这个方法不应该分配在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。 抽象： 抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下： 1234class Person&#123; String name; int age;&#125; 人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。 继承： 在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 多态： 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。例如，下面代码中的UserDao是一个接口，它定义引用变量userDao指向的实例对象由daofactory.getDao()在执行的时候返回，有时候指向的是UserJdbcDao这个实现，有时候指向的是UserHibernateDao这个实现，这样，不用修改源代码，就可以改变userDao指向的具体类实现，从而导致userDao.insertUser()方法调用的具体代码也随之改变，即有时候调用的是UserJdbcDao的insertUser方法，有时候调用的是UserHibernateDao的insertUser方法： 12UserDao userDao =daofactory.getDao(); userDao.insertUser(user); 比喻：人吃饭，你看到的是左手，还是右手？ 23. Java中实现多态的机制是什么？靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 24. abstract class和interface有什么区别?含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public staticfinal。 下面比较一下两者的语法区别： 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public staticfinal类型，并且默认即为public staticfinal类型。 一个类可以实现多个接口，但只能继承一个抽象类。 下面接着再说说两者在应用上的区别： 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断. 记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断. 记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下： 123456789101112131415161718192021public abstract class BaseServletextends HttpServlet&#123;public final voidservice(HttpServletRequest request, HttpServletResponse response) throwsIOExcetion,ServletException&#123;记录访问日志进行权限判断 if(具有权限)&#123; try&#123; doService(request,response); &#125; catch(Excetpion e)&#123; 记录异常信息 &#125; &#125;&#125;protected abstract voiddoService(HttpServletRequest request, HttpServletResponse response) throwsIOExcetion,ServletException; //注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的&#125; public class MyServlet1 extendsBaseServlet&#123; protected voiddoService(HttpServletRequest request, HttpServletResponse response) throwsIOExcetion,ServletException&#123; 本Servlet只处理的具体业务逻辑代码 &#125;&#125; 父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。 备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法. 普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。 25. abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！ native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 的源代码，可以发现FileOutputStream的open方法的定义如下： private native void open(String name)throws FileNotFoundException; 如果我们要用Java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照Java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按Java的要求来写的，我们这个c语言函数就可以与Java对接上，Java那边的对接方式就是定义出与我们这个c函数相对应的方法，Java中对应的方法不需要写具体的代码，但需要在前面声明native。 关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。 26. 什么是内部类？Static NestedClass 和 Inner Class的不同。内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示： 1234567891011121314public class Outer&#123; int out_x = 0; public void method()&#123; Inner1 inner1 = new Inner1(); public class Inner2 //在方法体内部定义的内部类&#123; public method()&#123; out_x = 3; &#125; &#125; Inner2 inner2 = new Inner2(); &#125; public class Inner1 //在方法体外面定义的内部类&#123; &#125;&#125; ​ 在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下： 12Outer outer = new Outer();Outer.Inner1 inner1 = outer.newInnner1(); ​ 在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。 对于这些细节，只要在eclipse写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。 在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称： 12345public class Outer&#123; public void start()&#123; new Thread(new Runable()&#123;public void run()&#123;&#125;;&#125;).start(); &#125;&#125; ​ 最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static NestedClass，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static NestedClass与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public. protected. 默认的. private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static NestedClass类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static NestedClass，例如，假设Inner是定义在Outer类中的Static NestedClass，那么可以使用如下语句创建Inner类： 1Outer.Inner inner = new Outer.Inner(); ​ 由于static Nested Class不依赖于外部类的实例对象，所以，static NestedClass能访问外部类的非static成员变量。当在外部类中访问Static NestedClass时，可以直接使用Static NestedClass的名字，而不需要加上外部类的名字了，在Static NestedClass中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。 ​ 在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static NestedClass与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。 ​ 备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。 27. 内部类可以引用它的包含类的成员吗？有没有什么限制？完全可以。如果不是静态内部类，那没有什么限制！ 如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码： 12345678class Outer&#123; static int x; static class Inner&#123; void test()&#123; syso(x); &#125; &#125;&#125; ​ 答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情况，让人家吃惊。 28. Anonymous InnerClass (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?​ 可以继承其他类或实现其他接口。不仅是可以，而是必须! 29. super.getClass()方法调用，下面程序的输出结果是多少？123456789import Java.util.Date;public class Test extends Date&#123; public static void main(String[]args) &#123; new Test().test(); &#125; public void test()&#123; System.out.println(super.getClass().getName()); &#125;&#125; 很奇怪，结果是Test 这属于脑筋急转弯的题目，在一个qq群有个网友正好问过这个问题，我觉得挺有趣，就研究了一下，没想到今天还被你面到了，哈哈。 在test方法中，直接调用getClass().getName()方法，返回的是Test类名 由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在 test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。 如果想得到父类的名称，应该用如下代码： ​ getClass().getSuperClass().getName(); 30. String是最基本的数据类型吗?​ 基本数据类型包括byte. int. char. long. float. double. boolean和short。 Java.lang.String类是final类型的，因此不可以继承这个类. 不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 31. String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？​ 没有。因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。 ​ 通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做： 12345678public class Demo &#123; private String s;... public Demo &#123; s = "Initial Value"; &#125;...&#125; 而非 1s = new String("Initial Value"); ​ 后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。​ 上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。​ 至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。 32. 是否可以继承String类?​ String类是final类故不可以继承。 33. String s = newString(“xyz”);创建了几个StringObject? 二者之间有什么区别？​ 两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。 34. String 和StringBuffer的区别​ Java平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(newString(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，newStringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。 ​ 接着要举一个具体的例子来说明，我们要把1到100的所有数字拼起来，组成一个串。 12345StringBuffer sbf = new StringBuffer(); for(int i=0;i&lt;100;i++) &#123; sbf.append(i); &#125; 上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。 1234String str = new String(); for(int i=0;i&lt;100;i++)&#123; str = str + i;&#125; ​ 在讲两者区别时，应把循环的次数搞成10000，然后用endTime-beginTime来比较两者执行的时间差异，最后还要讲讲StringBuilder与StringBuffer的区别。 ​ String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。 35. 如何把一段逗号分割的字符串转换成一个数组?​ 如果不查jdk api，我很难写出来！我可以说说我的思路： 用正则表达式，代码大概为：String [] result = orgStr.split(“,”); 用 StingTokenizer ,代码为：StringTokenizer tokener = StringTokenizer(orgStr,”,”); 12345String [] result = new String[tokener .countTokens()]; Int i=0;while(tokener.hasNext()&#123; result[i++]=toker.nextToken();&#125; 36. 数组有没有length()这个方法? String有没有length()这个方法？​ 数组没有length()这个方法，有length的属性。String有有length()这个方法。 37. 下面这条语句一共创建了多少个对象：Strings=”a”+”b”+”c”+”d”;答：对于如下代码： 12345String s1= "a";String s2 = s1 + "b";String s3 = "a" +"b";System.out.println(s2 =="ab");System.out.println(s3 =="ab"); ​ 第一条语句打印的结果为false，第二条语句打印的结果为true，这说明Javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。 ​ 题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码， 12String s = "a" + "b"+ "c" + "d";System.out.println(s =="abcd"); ​ 最终打印的结果应该为true。 38. try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?​ 也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果： 1234567891011121314public class Test &#123; public static void main(String[]args) &#123; System.out.println(new Test().test());; &#125;static int test()&#123; int x =1;try&#123; return x; &#125; finally&#123; ++x; &#125; &#125;&#125; ———执行结果 1 ​ 运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。 39. 下面的程序代码输出的结果是多少？123456789101112131415public class smallT&#123; public static void main(Stringargs[])&#123; smallT t = new smallT(); int b = t.get(); System.out.println(b); &#125; public int get()&#123; try&#123; return 1 ; &#125; finally&#123; return 2 ; &#125; &#125;&#125; 返回的结果是2。 ​ 我可以通过下面一个例子程序来帮助我解释这个答案，从下面例子的运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。 在讲解答案时可以用下面的程序来帮助分析： 123456789101112131415161718192021public class Test &#123; public static void main(String[]args) &#123; System.out.println(new Test().test());; &#125; int test()&#123; try&#123; return func1(); &#125; finally&#123; return func2(); &#125; &#125;int func1()&#123; System.out.println("func1"); return 1; &#125;int func2()&#123; System.out.println("func2"); return 2; &#125;&#125; ———–执行结果—————- func1 func2 2 结论：finally中的代码比return 和break语句后执行 40. final, finally,finalize的区别。final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码…… finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用 41. 运行时异常与一般异常有何异同？​ 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。Java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 42. error和exception有什么区别?​ error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 43. Java中的异常处理机制的简单原理和应用。​ 异常是指Java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间. 地点. 人物. 情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。 ​ Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为Java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）. 类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。 ​ Java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。 ​ 提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误； 44. 请写出你最常见到的5个runtime exception。这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面的异常，你不一定真要回答出5个具体的系统异常，但你要能够说出什么是系统异常，以及几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，那就用中文吧，有总比没有强！ 所谓系统异常，就是…..，它们都是RuntimeException的子类，在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比较有印象的系统异常有：NullPointerException. ArrayIndexOutOfBoundsException. ClassCastException。 45. Java语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？46. Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？Java5以前，有如下两种： 第一种： new Thread(){}.start();这表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下： 1234new Thread()&#123; public void run()&#123; &#125;&#125;.start(); 第二种： new Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下： 1234new Thread(new Runnable()&#123; public void run()&#123; &#125; &#125;).start(); 从Java5开始，还有如下一些线程池创建多线程的方式： 123456ExecutorService pool =Executors.newFixedThreadPool(3) for(int i=0;i&lt;10;i++)&#123; pool.execute(new Runable()&#123;publicvoid run()&#123;&#125;&#125;); &#125;Executors.newCachedThreadPool().execute(newRunable()&#123;public void run()&#123;&#125;&#125;);Executors.newSingleThreadExecutor().execute(newRunable()&#123;public void run()&#123;&#125;&#125;); ​ 有两种实现方法，分别使用new Thread()和newThread(runnable)形式，第一种直接调用thread的run方法，所以，我们往往使用Thread子类，即new SubThread()。第二种调用runnable的run方法。 ​ 有两种实现方法，分别是继承Thread类与实现Runnable接口 用synchronized关键字修饰同步方法 ​ 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 47. sleep() 和 wait() 有什么区别?​ （网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。） ​ sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.huawei.interview; public class MultiThread &#123; public static void main(String[]args) &#123; new Thread(new Thread1()).start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedExceptione) &#123; e.printStackTrace(); &#125; new Thread(new Thread2()).start(); &#125; private static class Thread1 implements Runnable &#123; @Override public void run() &#123; //由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。 synchronized (MultiThread.class) &#123; System.out.println("enterthread1..."); System.out.println("thread1is waiting"); try &#123; //释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键 字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方 法。这里，使用wait方法释放锁。 MultiThread.class.wait(); &#125; catch (InterruptedExceptione) &#123; e.printStackTrace(); &#125; System.out.println("thread1is going on..."); System.out.println("thread1is being over!"); &#125; &#125; &#125; private static class Thread2 implements Runnable &#123; @Override public void run() &#123; synchronized (MultiThread.class) &#123; System.out.println("enterthread2..."); System.out.println("thread2notify other thread can release wait status.."); //由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。 MultiThread.class.notify(); System.out.println("thread2is sleeping ten millisecond..."); try &#123; Thread.sleep(10); &#125; catch (InterruptedExceptione) &#123; e.printStackTrace(); &#125; System.out.println("thread2is going on..."); System.out.println("thread2is being over!"); &#125; &#125; &#125;&#125; 48. 同步和异步有何异同，在什么情况下分别使用他们？举例说明。​ 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 49. 下面两个方法同步吗？（自己发明）12345class Test&#123; synchronized static void sayHello3()&#123; &#125; synchronized void getX()&#123;&#125;&#125; 50. 多线程有几种实现方法?同步有几种实现方法?​ 多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 同步的实现方面有两种，分别是synchronized,wait与notify wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 51. 启动一个线程是用run()还是start()? .​ 启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。 52. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?分几种情况： 其他方法前是否加了synchronized关键字，如果没加，则能。 如果这个方法内部调用了wait，则可以进入其他synchronized方法。 如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。 如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。 53. 线程的基本概念. 线程的基本状态以及状态之间的关系​ 一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。 状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。 调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。 54. 简述synchronized和Java.util.concurrent.locks.Lock的异同 ？ 主要相同点：Lock能完成synchronized所实现的所有功能 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。 举例说明（对下面的题用lock进行了改写）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.huawei.interview; import Java.util.concurrent.locks.Lock; import Java.util.concurrent.locks.ReentrantLock; public class ThreadTest &#123; private int j; private Lock lock = new ReentrantLock(); public static void main(String[]args) &#123; ThreadTest tt = new ThreadTest(); for(int i=0;i&lt;2;i++)&#123; new Thread(tt.new Adder()).start(); new Thread(tt.new Subtractor()).start(); &#125; &#125; private class Subtractor implements Runnable&#123; public void run() &#123; while(true)&#123; /*synchronized (ThreadTest.this) &#123; System.out.println("j--=" +j--); //这里抛异常了，锁能释放吗？ &#125;*/ lock.lock(); try&#123; System.out.println("j--="+ j--); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125;&#125; private class Adder implements Runnable&#123; public void run() &#123; while(true)&#123; /*synchronized (ThreadTest.this) &#123; System.out.println("j++=" +j++); &#125;*/ lock.lock(); try&#123; System.out.println("j++="+ j++); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; &#125;&#125; 55. 设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。​ 以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。 123456789101112131415161718192021222324252627282930313233343536public class ThreadTest1&#123; private int j; public static void main(String args[])&#123; ThreadTest1 tt=newThreadTest1(); Inc inc=tt.new Inc(); Dec dec=tt.new Dec(); for(inti=0;i&lt;2;i++)&#123; Threadt=new Thread(inc); t.start(); t=new Thread(dec); t.start(); &#125; &#125; private synchronized void inc()&#123; j++; System.out.println(Thread.currentThread().getName()+"-inc:"+j); &#125; private synchronized void dec()&#123; j--; System.out.println(Thread.currentThread().getName()+"-dec:"+j); &#125; class Inc implements Runnable&#123; public void run()&#123; for(inti=0;i&lt;100;i++)&#123; inc(); &#125; &#125; &#125; class Dec implements Runnable&#123; public void run()&#123; for(inti=0;i&lt;100;i++)&#123; dec(); &#125; &#125; &#125;&#125; ———-随手再写的一个————- 123456789101112131415161718192021222324class A&#123; JManger j =new JManager(); main()&#123; new A().call(); &#125; void call&#123; for(int i=0;i&lt;2;i++) &#123; new Thread( new Runnable()&#123; public voidrun()&#123;while(true)&#123;j.accumulate()&#125;&#125;&#125; ).start(); new Thread(new Runnable()&#123; public voidrun()&#123;while(true)&#123;j.sub()&#125;&#125;&#125;).start(); &#125; &#125;&#125; class JManager&#123; private j = 0; public synchronized void subtract()&#123; j-- &#125; public synchronized void accumulate()&#123; j++; &#125;&#125; 56. 子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。最终的程序代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ThreadTest &#123; public static void main(String[]args) &#123; new ThreadTest().init(); &#125; public void init()&#123; final Business business = new Business(); new Thread( new Runnable()&#123; public void run() &#123; for(int i=0;i&lt;50;i++)&#123; business.SubThread(i); &#125; &#125; &#125; ).start(); for(int i=0;i&lt;50;i++)&#123; business.MainThread(i); &#125; &#125; private class Business&#123; boolean bShouldSub = true;//这里相当于定义了控制该谁执行的一个信号灯 public synchronized void MainThread(int i)&#123; if(bShouldSub) try &#123; this.wait(); &#125; catch (InterruptedExceptione) &#123; // TODO Auto-generatedcatch block e.printStackTrace(); &#125; for(int j=0;j&lt;5;j++)&#123; System.out.println(Thread.currentThread().getName()+ ":i=" + i +",j=" + j); &#125; bShouldSub = true; this.notify(); &#125; public synchronized void SubThread(int i)&#123; if(!bShouldSub) try &#123; this.wait(); &#125; catch (InterruptedExceptione) &#123; e.printStackTrace(); &#125; for(int j=0;j&lt;10;j++)&#123; System.out.println(Thread.currentThread().getName()+ ":i=" + i +",j=" + j); &#125; bShouldSub = false; this.notify(); &#125; &#125;&#125; 备注：不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 package com.huawei.interview.lym; public class ThreadTest &#123; private static boolean bShouldMain = false; public static void main(String[] args) &#123; // TODO Auto-generatedmethod stub /*new Thread()&#123; public void run() &#123; for(int i=0;i&lt;50;i++)&#123; for(int j=0;j&lt;10;j++)&#123; System.out.println("i=" + i +",j=" + j); &#125; &#125; &#125; &#125;.start();*/ //final String str = newString(""); new Thread( new Runnable()&#123; public void run()&#123; for(int i=0;i&lt;50;i++)&#123; synchronized (ThreadTest.class) &#123; if(bShouldMain)&#123; try &#123; ThreadTest.class.wait();&#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=0;j&lt;10;j++)&#123; System.out.println(Thread.currentThread().getName()+"i=" + i + ",j=" +j); &#125; bShouldMain = true; ThreadTest.class.notify(); &#125; &#125; &#125; &#125;).start(); for(int i=0;i&lt;50;i++)&#123; synchronized (ThreadTest.class) &#123; if(!bShouldMain)&#123; try &#123; ThreadTest.class.wait();&#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=0;j&lt;5;j++)&#123; System.out.println(Thread.currentThread().getName()+"i=" + i + ",j=" +j); &#125; bShouldMain = false; ThreadTest.class.notify(); &#125; &#125; &#125;&#125; 下面使用jdk5中的并发库来实现的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import Java.util.concurrent.Executors;importJava.util.concurrent.ExecutorService;import Java.util.concurrent.locks.Lock;importJava.util.concurrent.locks.ReentrantLock;importJava.util.concurrent.locks.Condition;public class ThreadTest&#123; private static Lock lock = newReentrantLock(); private static ConditionsubThreadCondition = lock.newCondition(); private static boolean bBhouldSubThread= false; public static void main(String [] args)&#123; ExecutorService threadPool =Executors.newFixedThreadPool(3); threadPool.execute(new Runnable()&#123; public void run()&#123; for(int i=0;i&lt;50;i++)&#123; lock.lock(); try&#123; if(!bBhouldSubThread) subThreadCondition.await(); for(int j=0;j&lt;10;j++)&#123; System.out.println(Thread.currentThread().getName()+ ",j=" + j); &#125; bBhouldSubThread = false; subThreadCondition.signal(); &#125;catch(Exception e)&#123; &#125; finally&#123; lock.unlock(); &#125; &#125; &#125; &#125;); threadPool.shutdown(); for(int i=0;i&lt;50;i++)&#123; lock.lock(); try&#123; if(bBhouldSubThread) subThreadCondition.await(); for(int j=0;j&lt;10;j++)&#123; System.out.println(Thread.currentThread().getName()+ ",j=" + j); &#125; bBhouldSubThread = true; subThreadCondition.signal(); &#125;catch(Exception e)&#123; &#125; finally&#123; lock.unlock(); &#125; &#125; &#125;&#125; 57. 介绍Collection框架的结构​ 答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。 58. Collection框架中实现比较要实现什么接口​ comparable/comparator 59. ArrayList和Vector的区别答：这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与hashset没有任何关系，但为了说清楚ArrayList与Vector的功能，我们使用对比方式，更有利于说明问题）。 接着才说ArrayList与Vector的区别，这主要包括两个方面： 同步性：Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 ​ 备注：对于Vector&amp;ArrayList. Hashtable&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是Java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是Java2时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。 数据增长： ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 ​ 总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。 60. HashMap和Hashtable的区别（条理上还需要整理，也是先说相同点，再说不同点） ​ HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 ​ HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 ​ HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 ​ Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 ​ Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 就HashMap与HashTable主要从三方面来说。 历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 值：只有HashMap可以让你将空值作为一个表的条目的key或value 61. List 和 Map 区别?​ 一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。 62. List, Set, Map是否继承自Collection接口? List，Set是，Map不是 63. List. Map. Set三个接口，存取元素时，各有什么特点？​ 这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不明白。 ​ 首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。 ​ List表示有先后顺序的集合， 注意，不是那种按年龄. 按大小. 按价格之类的排序。当我们多次调用add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(intindex,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。 ​ Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,objvalue)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。 List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。 ​ HashSet按照hashcode值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储。例如，”abc”—&gt; 78，”def”—&gt; 62，”xyz”—&gt; 65在hashSet中的存储顺序不是62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet按插入的顺序存储，那被存储对象的hashcode方法还有什么作用呢？学员想想!hashset集合比较两个对象是否相等，首先看hashcode方法是否相等，然后看equals方法是否相等。new 两个Student插入到HashSet中，看HashSet的size，实现hashcode和equals方法后再看size。 ​ 同一个对象可以在Vector中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往HashSet中却加不了多次的。 64. 说出ArrayList,Vector,LinkedList的存储性能和特性​ ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 65. 去掉一个Vector集合中重复的元素123456Vector newVector = new Vector();For (int i=0;i&lt;vector.size();i++)&#123; Object obj = vector.get(i); if(!newVector.contains(obj); newVector.add(obj); &#125; 还有一种简单的方式，HashSet set = new HashSet(vector); 66. Collection 和 Collections的区别。​ Collection是集合类的上级接口，继承与他的接口主要有Set 和List. ​ Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索. 排序. 线程安全化等操作。 67. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。 equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。 68. 你所知道的集合类都有哪些？主要方法？​ 最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建. 存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。 ArrayList/VectoràList ​ àCollection HashSet/TreeSetàSet PropetiesàHashTable àMap Treemap/HashMap ​ 我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，我记得不是很清楚，对于set，大概的方法是add,remove,contains；对于map，大概的方法就是put,remove，contains等，因为，我只要在eclispe下按点操作符，很自然的这些方法就出来了。我记住的一些思想就是List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value。 69. 两个对象值相同(x.equals(y) ==true)，但却可有不同的hash code，这句话对不对?对。 ​ 如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。 如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的，例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。 70. TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！（应该是没有针对问题的确切的答案，当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的） 实验代码： 1234567891011121314151617181920212223242526272829public class Parent implements Comparable&#123; private int age = 0; public Parent(int age)&#123; this.age = age; &#125; public int compareTo(Objecto) &#123; System.out.println("methodof parent"); Parent o1 = (Parent)o; return age&gt;o1.age?1:age&lt;o1.age?-1:0; &#125; &#125; public class Child extends Parent&#123; public Child()&#123; super(3); &#125; public int compareTo(Objecto) &#123; System.out.println("methodof child"); return 1; &#125; &#125; public class TreeSetTest &#123; public static void main(String[]args) &#123; TreeSet set = new TreeSet(); set.add(new Parent(3)); set.add(new Child()); set.add(new Parent(4)); System.out.println(set.size()); &#125;&#125; ##### 71. 说出一些常用的类，包，接口，请各举5个 要让人家感觉你对Java ee开发很熟，所以，不能仅仅只列core Java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。 常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer Java.util.Date，System，Class，List,HashMap 常用的包：Java.lang Java.io Java.util Java.sql,Javax.servlet,org.apache.strtuts.action,org.hibernate 常用的接口：Remote List Map Document NodeList,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate). Session(Hibernate),HttpSession 72. Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？​ 字节流，字符流。字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在Java.io包中还有许多其他的流，主要是为了提高性能和使用方便。 73. 字节流与字符流的区别​ 要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。 在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。 底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。 字符向字节转换时，要注意编码的问题，因为字符串转成字节数组， 其实是转成该字符的某种编码的字节形式，读取也是反之的道理。 讲解字节流与字符流关系的代码案例： 12345678910111213141516171819202122232425262728293031323334353637import Java.io.BufferedReader;import Java.io.FileInputStream;import Java.io.FileOutputStream;import Java.io.FileReader;import Java.io.FileWriter;import Java.io.InputStreamReader;import Java.io.PrintWriter;public class IOTest &#123; public static void main(String[] args)throws Exception &#123; String str = "中国人"; /*FileOutputStream fos = newFileOutputStream("1.txt"); fos.write(str.getBytes("UTF-8")); fos.close();*/ /*FileWriter fw = newFileWriter("1.txt"); fw.write(str); fw.close();*/ PrintWriter pw = newPrintWriter("1.txt","utf-8"); pw.write(str); pw.close(); /*FileReader fr = newFileReader("1.txt"); char[] buf = new char[1024]; int len = fr.read(buf); String myStr = new String(buf,0,len); System.out.println(myStr);*/ /*FileInputStream fr = newFileInputStream("1.txt"); byte[] buf = new byte[1024]; int len = fr.read(buf); String myStr = newString(buf,0,len,"UTF-8"); System.out.println(myStr);*/ BufferedReader br = new BufferedReader( new InputStreamReader(newFileInputStream("1.txt"),"UTF-8")); String myStr = br.readLine(); br.close(); System.out.println(myStr); &#125;&#125; 74. 什么是Java序列化，如何实现Java序列化？或者请解释Serializable接口的作用。​ 我们有时候将一个Java对象变成字节流的形式传出去或者从一个字节流中恢复成一个Java对象，例如，要将Java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个Java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让Java 帮我们做，要被传输的对象必须实现serializable接口，这样，Javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implementsSerializable只是为了标注该对象是可被序列化的。 ​ 例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过rmi等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。 75. 描述一下JVM加载class文件的原理机制?​ JVM中类的装载是由ClassLoader和它的子类来实现的,JavaClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。 76. heap和stack有什么区别。​ Java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。 77. GC是什么? 为什么要有GC?GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 78. 垃圾回收的优点和原理。并考虑2种回收机制。​ Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 79. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？​ 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址. 大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行. 80. 什么时候用assert。​ assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。一般来说，assertion用于保证程序最基本. 关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。 123456789101112package com.huawei.interview;public class AssertTest &#123; public static void main(String[]args) &#123; int i = 0; for(i=0;i&lt;5;i++)&#123; System.out.println(i); &#125; //假设程序不小心多了一句--i; --i; assert i==5; &#125;&#125; 81. Java中会存在内存泄漏吗，请简单描述。​ 所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。Java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.huawei.interview;import Java.io.IOException; public class GarbageTest &#123; public static void main(String[]args) throws IOException &#123; try &#123; gcTest(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; System.out.println("hasexited gcTest!"); System.in.read(); System.in.read(); System.out.println("outbegin gc!"); for(int i=0;i&lt;100;i++)&#123; System.gc(); System.in.read(); System.in.read(); &#125; &#125; private static void gcTest() throws IOException&#123; System.in.read(); System.in.read(); Person p1 = new Person(); System.in.read(); System.in.read(); Person p2 = new Person(); p1.setMate(p2); p2.setMate(p1); System.out.println("beforeexit gctest!"); System.in.read(); System.in.read(); System.gc(); System.out.println("exitgctest!"); &#125; private static class Person&#123; byte[] data = new byte[20000000]; Person mate = null; public void setMate(Personother) &#123; mate = other; &#125; &#125;&#125; ​ Java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是Java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。 ​ 检查Java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 ​ 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。 ​ 下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中消失，将那个元素所在的位置的值设置为null即可）： ​ 我实在想不到比那个堆栈更经典的例子了,以致于我还要引用别人的例子，下面的例子不是我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可是那时我说是我自己想到的也没有人相信的。 1234567891011121314151617181920public class Stack &#123; private Object[] elements=new Object[10]; private int size = 0; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if( size == 0) throw new EmptyStackException(); return elements[--size]; &#125; private void ensureCapacity()&#123; if(elements.length == size)&#123; Object[] oldElements = elements; elements = new Object[2 * elements.length+1]; System.arraycopy(oldElements,0, elements, 0, size); &#125; &#125;&#125; ​ 上面的原理应该很简单，假如堆栈加了10个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，无法回收。 ​ 但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪费了几个K内存而已，反正我们的内存都上G了，哪里会有什么影响，再说这个东西很快就会被回收的，有什么关系。下面看两个例子。 ​ 例子1 12345678public class Bad&#123; public static Stack s=Stack(); static&#123; s.push(new Object()); s.pop(); //这里有一个对象发生内存泄露 s.push(new Object()); //上面的对象可以被回收了，等于是自愈了 &#125; &#125; 因为是static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果你的Stack最多有100个对象，那么最多也就只有100个对象无法被回收其实这个应该很容易理解，Stack内部持有100个引用，最坏的情况就是他们都是无用的，因为我们一旦放新的进取，以前的引用自然消失！ ​ 内存泄露的另外一种情况：当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。 82. 能不能自己写个类，也叫Java.lang.String？可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个Java.lang.String。由于在tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB-INF/classess目录中的类，然后才委托上级的类加载器加载，如果我们在tomcat的web应用程序中写一个Java.lang.String，这时候Servlet程序加载的就是我们自己写的Java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了Java.lang.String类的都将出现问题。 ​ 虽然Java提供了endorsed技术，可以覆盖jdk中的某些类，具体做法是….。但是，能够被覆盖的类是有限制范围，反正不包括Java.lang这样的包中的类。 （下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题目泄露了）例如，运行下面的程序： ​ 123456package Java.lang; public class String &#123; public static void main(String[]args) &#123; System.out.println("string"); &#125;&#125; 报告的错误如下： ​ Java.lang.NoSuchMethodError: main ​ Exception in thread “main” 这是因为加载了jre自带的Java.lang.String，而该类中没有main方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的语法及基本命令]]></title>
    <url>%2Fblog%2F20927.html</url>
    <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。 概述宗旨Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTMLMarkdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 123456789这是一个普通段落。&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： 1http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： 1http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： 1&amp;copy; Markdown 会保留它不动。而若你写： 1AT&amp;T Markdown 就会将它转为： 1AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 14 &lt; 5 Markdown 将会把它转换为： 14 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素段落和换行一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1## 这是 H2###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的# 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 12345# 这是 H1 ### 这是 H2 ##### 这是 H3 ###### 区块引用 BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： 123* Red* Green* Blue 等同于： 123+ Red+ Green+ Blue 也等同于： 123- Red- Green- Blue 有序列表则使用数字接着一个英文句点： 1231. Bird2. McHale3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： 12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 如果你的列表标记写成： 1231. Bird1. McHale1. Parish 或甚至是： 1233. Bird1. McHale8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt; 标签包起来，举例来说： 12* Bird* Magic 会被转换为： 1234&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 但是这个： 123* Bird* Magic 会被转换为： 1234&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 11986\. What a great season. 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 123这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： 1234&lt;p&gt;这是一个普通段落：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： 12345Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： 123456&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beepend tell&lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： 123&lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; 会被转换为： 1234&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 123456789* * *********- - ---------------------------------------- 区段元素链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 会产生： 12345&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： 123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用方括号包起来： 1[id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： 12[id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： 12[link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： 1[Google][] 然后定义链接内容： 1[Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： 1Visit [Daring Fireball][] for more information. 然后接着定义链接： 1[Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： 123456I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： 123456I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 1234&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： 123I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or[MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或_ 包起来的话，则会被转成 &lt;strong&gt;，例如： 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 会转成： 1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： 1un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： 1\*this text is surrounded by literal asterisks\* 代码如果要标记一小段行内代码，你可以用反引号把它包起来（12 Use the printf() function. 12会产生： Use the printf() function. 12如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： There is a literal backtick (`) here. 12这段语法会产生： There is a literal backtick (`) here. 12代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 12会产生： A single backtick in a code span: ` A backtick-delimited string in a code span: foo 12在代码区段内，`&amp;` 和方括号**都**会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don’t use any &lt;blink&gt; tags. 12转为： Please don’t use any &lt;blink&gt; tags. 12你也可以这样写： &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;. 12以产生： &amp;#8212; is the decimal-encodedequivalent of &amp;mdash;. 12345678### 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： *行内式*和*参考式*。行内式的图片语法看起来像是： 12345678详细叙述如下：- 一个惊叹号 `!`- 接着一个方括号，里面放上图片的替代文字- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 &apos;title&apos; 文字。参考式的图片语法则长得像这样： 12「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 12345678910到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `&lt;img&gt;` 标签。------## 其它### 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://example.com/ 12Markdown 会转为： http://example.com/ 12邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &#97;&#x64;&#x64;&#114;&#x65;&#115;&#115;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#x6d; 12Markdown 会转成： &#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61; &#109;&#x70;&#x6C;e&#x2E;&#99;&#111;&#109; 12345678在浏览器里面，这段字串（其实是 `&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;`）会变成一个可以点击的「address@example.com」链接。（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）### 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `&lt;em&gt;` 标签），你可以在星号的前面加上反斜杠： *literal asterisks* 12Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 星号_ 底线{} 花括号[] 方括号() 括弧#. 井字号 加号 减号. 英文句点! 惊叹号` Markdown基本语法 标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。内联方式：This is an example link.引用方式：I get 10 times more traffic from Google than from Yahoo or MSN. 图片（Images）图片的处理方式和链接的处理方式，非常的类似。内联方式：引用方式： id: /path/to/img.jpg “Title” 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello^hello 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）]]></content>
      <categories>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JEECMS自定义标签]]></title>
    <url>%2Fblog%2F25712.html</url>
    <content type="text"><![CDATA[CMS是”Content Management System”的缩写，意为”内容管理系统”。 内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场。对于内容管理，业界还没有一个统一的定义，不同的机构有不同的理解。 自定义标签[mycontent_list]实现步骤:创建jc_mycontent的表12345678910111213141516171819202122232425-- Create tablecreate table JC_MYCONTENT( id NUMBER not null, title VARCHAR2(250), content VARCHAR2(250))tablespace CMS pctfree 10 initrans 1 maxtrans 255 storage ( initial 64K minextents 1 maxextents unlimited );-- Create/Recreate primary, unique and foreign key constraints alter table JC_MYCONTENT add constraint PK_ID primary key (ID) using index tablespace CMS pctfree 10 initrans 2 maxtrans 255; 创建实体类12345678910111213141516171819202122232425262728293031323334353637383940414243package com.jeecms.cms.entity.main;public class MyContent &#123; private Integer id; private String title; private String content; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public MyContent(Integer id, String title, String content) &#123; super(); this.id = id; this.title = title; this.content = content; &#125; public MyContent() &#123; super(); &#125;&#125; 接下来是配置hibernate中jc_mycontent表的配置文件123456789101112131415&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.jeecms.cms.entity.main"&gt; &lt;class name="MyContent" table="jc_mycontent"&gt; &lt;meta attribute="sync-DAO"&gt;false&lt;/meta&gt; &lt;cache usage="read-write" /&gt; &lt;id name="id" type="java.lang.Integer" column="id"&gt; &lt;generator class="identity" /&gt; &lt;/id&gt; &lt;property name="title" column="title" type="java.lang.String" not-null="true" /&gt; &lt;property name="content" column="content" type="java.lang.String" not-null="true" /&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 持久层接口123456789package com.jeecms.cms.dao.main;import java.util.List;import com.jeecms.cms.entity.main.MyContent;public interface MyContentDao &#123; public List&lt;MyContent&gt; getList();&#125; 持久层实现类12345678910111213141516171819202122232425262728293031package com.jeecms.cms.dao.main.impl;import java.util.List;import org.springframework.stereotype.Repository;import com.jeecms.cms.dao.main.MyContentDao;import com.jeecms.cms.entity.main.MyContent;import com.jeecms.common.hibernate4.Finder;import com.jeecms.common.hibernate4.HibernateBaseDao;@Repository// 持久层public class MyContentDaoImpl extends HibernateBaseDao&lt;MyContent, Integer&gt; implements MyContentDao &#123; @SuppressWarnings("unchecked") public List&lt;MyContent&gt; getList() &#123; return find(byNothing()); &#125; private Finder byNothing() &#123; Finder f = Finder.create(); f.append("from MyContent");// 可以在此处添加查询条件或者添加各种方法进行动态查询 f.setCacheable(true); return f; &#125; @Override protected Class&lt;MyContent&gt; getEntityClass() &#123; return MyContent.class; &#125;&#125; 业务层接口123456789package com.jeecms.cms.manager.main;import java.util.List;public interface MyContentMng &#123; public List getList();&#125;public interface MyContentMng &#123; public List getList();&#125; 业务层实现类1234567891011121314151617181920212223242526272829303132333435363738package com.jeecms.cms.manager.main.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.jeecms.cms.dao.main.MyContentDao;import com.jeecms.cms.entity.main.MyContent;import com.jeecms.cms.manager.main.MyContentMng;import com.jeecms.cms.service.ContentListener;@Service// ()业务层@Transactionalpublic class MyContentMngImpl implements MyContentMng &#123; @Transactional(readOnly = true) // 配置事务为只读 public List&lt;MyContent&gt; getList() &#123; return myContentDao.getList(); &#125; private MyContentDao myContentDao; @Autowired // 自动绑定 public void setMyContentDao(MyContentDao myContentDao) &#123; this.myContentDao = myContentDao; &#125; private List&lt;ContentListener&gt; listenerList; @Autowired public void setListenerList(List&lt;ContentListener&gt; listenerList) &#123; this.listenerList = listenerList; &#125;&#125; 标签类的抽象类最主要的就是getData这个方法，以及绑定业务层(其中也可以添加多种查询方法，可参考类AbstractContentDirective )。 1234567891011121314151617181920package com.jeecms.cms.action.directive.abs;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import com.jeecms.cms.manager.main.MyContentMng;import freemarker.core.Environment;import freemarker.template.TemplateDirectiveModel;import freemarker.template.TemplateException;public abstract class AbstractMyContentDirective implements TemplateDirectiveModel &#123; protected Object getData(Map params, Environment env) throws TemplateException &#123; return myContentMng.getList(); &#125; @Autowired protected MyContentMng myContentMng;&#125; 标签工具类DirectiveUtils下定义输出参数:MYOUT_LIST1public static final String MYOUT_LIST = "mytag_list"; 自定义标签中最重要的类继承上边的抽象类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.jeecms.cms.action.directive;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;import com.jeecms.cms.action.directive.abs.AbstractMyContentDirective;import com.jeecms.cms.entity.main.MyContent;import static com.jeecms.common.web.freemarker.DirectiveUtils.MYOUT_LIST;import com.jeecms.common.web.freemarker.DefaultObjectWrapperBuilderFactory;import com.jeecms.common.web.freemarker.DirectiveUtils;import com.jeecms.core.entity.CmsSite;import com.jeecms.core.web.util.FrontUtils;import freemarker.core.Environment;import freemarker.template.TemplateDirectiveBody;import freemarker.template.TemplateException;import freemarker.template.TemplateModel;public class MyContentListDirective extends AbstractMyContentDirective &#123; /** * 模板名称 */ public static final String TPL_NAME = "mycontent_list"; @SuppressWarnings("unchecked") public void execute(Environment env, @SuppressWarnings("rawtypes") Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException &#123; // 获取站点 CmsSite site = FrontUtils.getSite(env); // 获取内容列表 List&lt;MyContent&gt; list = getList(params, env); Map&lt;String, TemplateModel&gt; paramWrap = new HashMap&lt;String, TemplateModel&gt;(params); // OUT_LIST值为tag_list，将内容列表放入其中 paramWrap.put(MYOUT_LIST, DefaultObjectWrapperBuilderFactory.getDefaultObjectWrapper() .wrap(list)); // 将params的值复制到variable中 Map&lt;String, TemplateModel&gt; origMap = DirectiveUtils.addParamsToVariable(env, paramWrap); // 没有采用默认的模板，直接采用自己写的简单的模板（mycontent_list.html） FrontUtils.includeTpl(TPL_NAME, site, params, env); // 将variable中的params值移除 DirectiveUtils.removeParamsFromVariable(env, paramWrap, origMap); &#125; @SuppressWarnings("unchecked") protected List&lt;MyContent&gt; getList(Map&lt;String, TemplateModel&gt; params, Environment env) throws TemplateException &#123; return myContentMng.getList(); &#125;&#125; 在jeecms-context.xml中声明标签1&lt;bean id="cms_mycontent_list" class="com.jeecms.cms.action.directive.MyContentListDirective"/&gt; 在jeecms-context.xml中注入DAO1&lt;bean id="myContentDao" class="com.jeecms.cms.dao.main.impl.MyContentDaoImpl"/&gt; 在jeecms-context.xml中注入Manager1&lt;bean id="myContentMng" class="com.jeecms.cms.manager.main.impl.MyContentMngImpl"/&gt; 配置文件jeecms-servlet-front.xml中有一段对标签的配置jeecms.properties中配置标签名1directive.cms_mycontent_list=cms_mycontent_list 新建模板WEB-INF\t\cms\www\oa\tag下新建模板mycontent_list.html,并加入如下代码(里边也可以自己添加一些样式，可参考WEB-INF\t\cms_sys_defined\style_list下样式文件) 12345[#list mytag_list as a] &lt;li&gt; &lt;a href="$&#123;a.title&#125;"&gt;"$&#123;a.content&#125;"&lt;/a&gt; &lt;/li&gt;[/#list] 调用代码1234567[@cms_mycontent_list] [#list mycontent_list as a] &lt;li&gt; &lt;a href="$&#123;a.title&#125;"&gt;"$&#123;a.content&#125;"&lt;/a&gt; &lt;/li&gt; [/#list][/@cms_mycontent_list] 通过以上这些代码，实现将自己的表jc_mycontent中的数据查询并显示在页面上]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>cms</tag>
        <tag>jeecms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO主题图配置]]></title>
    <url>%2Fblog%2F13957.html</url>
    <content type="text"><![CDATA[为一篇博客添加相关的图片可以快速吸引读者的目光，也能帮助读者理解文章概要，尤其是在写技术博客或是某些很复杂的东西时。 然而，Hexo 主题一般只提供一种默认的图片样式，包括 Jacman。所以，我为 Jacman 实现了几种常见的图片样式。这里我会展示这几种图片样式以及其实现方法。 主题图片我比较喜欢像36氪那样，一篇文章带一张相关图片。图片能传达的信息永远比文字丰富。当浏览文章列表时，除了标题最吸引人的自然就属文章主题图片了。 所以为了方便使用，我创建了一个图片样式叫img-topic，大概是长这样子的。 12345678910/themes/jacman/source/css/_partial/index.styl.img-topic max-width: 300px; max-height: 1800px; display: block ; margin-left: .7em; margin-right: .7em; padding: 0; float: right; clear: right; 在博客中，我更希望主题图片居右，并且点进文章正文后该图片不会显示。我们可以使用HTML语法插入图片。 1&lt;img src=&quot;图片路径&quot; class=&quot;img-topic&quot; /&gt; 这儿是一张使用img-topic样式后的效果图。 img-topic效果图 Logo 图片Logo 图片可以快速定义一篇文章的主题。与主题图片非常类似，只不过 Logo 图片放置的是 Logo ，而且一般比主题图片要小。类似的，Logo 图片也是居右，并且在文章正文中不会显示。 关于img-logo的样式如下 12345678910/themes/jacman/source/css/_partial/index.styl.img-logo max-width: 180px; max-height: 96px; display: block; margin-right: .7em; margin-left: .7em; padding: 0; float: right; clear: right; 使用HTML语法插入图片 1&lt;img src=&quot;图片路径&quot; class=&quot;img-logo&quot; /&gt; 效果如下图： img-logo效果图 居中图片有网友抱怨 Jacman 的图片只能居左，他喜欢让图片居中却不知道该怎么做。为此，我也创建了一个图片样式叫img-center，所需的代码很短。 1234/themes/jacman/source/css/_partial/article.styl.img-center display: block ; margin: auto; 阴影图片有时候添加的图片可能会与文章背景混淆，使得读者看不清到底哪部分是图片哪部分是文章。使用img-shadow为图片添加边角阴影可以更加凸显图片的位置，也能更美观。 123/themes/jacman/source/css/_partial/article.styl.img-shadow box-shadow: 0 0 2px 3px #ddd; 使用HTML语法插入图片 1&lt;img src=&quot;http://ww1.sinaimg.cn/large/81b78497jw1enhkcat9mqj20go06g0sy.jpg&quot; class=&quot;img-shadow&quot; /&gt; 画廊图片Hexo 中提供了一种文章类别叫photo，Jacman 也为这种文章设计了图片浏览方式。具体效果可以看这篇 Demo。photo类文章的写法可以看 Demo Sample。 photo文章效果图 图片备注Jacman 中可以方便地为图片提供备注。 1![添加你的备注](http://ww1.sinaimg.cn/mw690/81b78497jw1emfgts2pt4j21hc0u0k1c.jpg) 效果就如下图，在图片左下方会显示关于图片的描述。 添加你的备注 OK，就这么多了，希望大家喜欢。如果嫌折腾麻烦，欢迎使用最新版的 Jacman，可以直接使用以上定义的样式！ PS:有任何关于 Hexo 的问题，欢迎来 Hexo 中文社区 咨询。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth2认证的基本流程]]></title>
    <url>%2Fblog%2F8224.html</url>
    <content type="text"><![CDATA[在一个单位中，可能是存在多个不同的应用，比如学校会有财务的系统会有学生工作的系统，还有图书馆的系统等等，如果每个系统都用独立的账号认证体系，会给用户带来很大困扰，也给管理带来很大不便。所以需要设计一种统一登录的解决方案。比如我登陆了百度账号，进贴吧时发现已经登录了，进糯米发现也自动登录了。常见的有两种情况，一种是SSO（单点登录）效果是一次输入密码多个网站可以识别在线状态；还有一种是多平台登录，效果是可以用一个账号（比如QQ账号）登录多个不同的网站。 SSO与多平台登录SSO一般用于同一单位的多个站点的登陆状态保持，技术上一般参考CAS协议；多平台登录一般是Oauth体系的协议，有多种认证模式但是不具备会话管理和状态保持。不过从本质上讲，我觉得两者都是通过可信的第三方进行身份验证，如果说同一单位的多个子系统共同只围绕一个第三方账户（可以称为认证中心）进行多平台登录验证，那么在第三方平台登录后再访问其他网站，效果和统一登录是差不多的。此外，Oauth2还有个好处就是可以实现跨平台的登录管理，因为他的认证过程不依赖于session和cookie，比如对于移动端设备，以及在前后端分离后这种登录认证方式也可以起到很大作用。这篇文章里我就着结合之前项目中整合过的OAUTH2来讲一讲这种登录认证的过程。项目是基于Shiro+ALTU实现，参考方案mkk/oauth2-shiro - 码云 - 开源中国 。 oauth2的基本概念在Oauth中至少是有用户，应用服务器，认证服务器这几个角色在交互。OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”应用服务器”进行互动。 OAuth2的基本流程用户通过浏览器访问一个应用，比如我要上慕课网学习。 网站要求我登录，我选择使用QQ登录，这里的QQ登录就是那个认证服务器。 这个时候慕课提供的QQ登录链接会把我带到QQ登录页面 在QQ的登录页面完成登录后，选择授权，也就是允许慕课网获取我的资料。 这个时候我们看到浏览器经过几次跳转后返回慕课网，这个时候我们已经完成了登录。 重点在于几次跳转的过程中，慕课网和QQ登录的服务之间还有过几次交互。 我们选择了授权的时候QQ登录服务器会根据慕课跳转到QQ时候给出的重定向链接返回给慕课网一个code，这个code代表QQ的登录服务器认可慕课网这个应用服务器的这个请求是合法的予以放行. 慕课这个时候就会用这个code再次向QQ登录服务发起请求服务令牌（token）。 拿到这个令牌之后，接下来慕课需要用户的一些基本信息时就可以通过在向QQ服务提交的请求头里带上这个令牌，令牌验证通过就可以拿到用户资源。 这一部分的操作是应用服务器和验证服务器之间的交互，这个过程对用户是透明的。这个过程中慕课网是不需要知道用户的账号密码也可以完成对用户身份的认证，这个token就可以用来标识用户资源。官方的运行流程图是这样的: OAuth的几种认证模式上述讲的是OAuth2中支持的授权码（CODE）方式的认证流程，也是其支持的四种认证方式里最复杂的，其他的三种种包括： 简化模式（implicit），(在redirect_uri 的Hash传递token; Auth客户端运行在浏览器中,如JS,Flash) 密码模式（resource owner password credentials），将用户名,密码传过去,直接获取token； 客户端模式（client credentials），无用户,用户向客户端注册,然后客户端以自己的名义向’服务端’获取资源；详细的OAuth2资料参考理解OAuth 2.0|阮一峰的网络日志分别适用不同场景，复杂度也比授权码模式要低，所以这里就只说说授权码模式的具体过程。 CODE方式认证实例假设现在有一个应用服务器跑在我本机8000端口，认证服务器在8090端口。在需要用户登录时候把用户带到以下的一个URL. 1http://localhost:8090/oauth/authorize?response_type=code&amp;scope=read write&amp;client_id=test&amp;redirect_uri=http://localhost:8000/login&amp;state=09876999 我们注意到几个重要的参数： response_type：表示授权类型，就是上面讲的那四种类型，这里用的是code方式。 client_id：表示客户端的ID，代表哪个应用请求验证 redirect_uri：表示重定向URI，验证以后的回调地址，一般用来接收返回的code，以及做下一步处理。 scope：表示申请的权限范围， state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。作为安全校验。 下面是验证服务器接受这个请求的控制器关键代码： 1234567891011121314151617@RequestMapping(&quot;authorize&quot;)public void authorize(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; try &#123; OAuthAuthxRequest oauthRequest = new OAuthAuthxRequest(request); if (oauthRequest.isCode()) &#123; CodeAuthorizeHandler codeAuthorizeHandler = new CodeAuthorizeHandler(oauthRequest, response); LOG.debug(&quot;Go to response_type = &apos;code&apos; handler: &#123;&#125;&quot;, codeAuthorizeHandler); codeAuthorizeHandler.handle(); &#125; else if (oauthRequest.isToken()) &#123; TokenAuthorizeHandler tokenAuthorizeHandler = new TokenAuthorizeHandler(oauthRequest, response); LOG.debug(&quot;Go to response_type = &apos;token&apos; handler: &#123;&#125;&quot;, tokenAuthorizeHandler); tokenAuthorizeHandler.handle(); &#125; else &#123; unsupportResponseType(oauthRequest, response); &#125; &#125; &#125; 首先拿到这个请求以后根据请求的参数将其封装成一个OAuthAuthxRequest,基本就是把请求过来的参数，方法绑定便于使用。这是由oltu提供的OAuthRequest的进一步封装。然后判断这个请求的授权的类型是否是code，也就是判断下请求参数的response_type是否为code，可以看到目前制作了两种类型的授权。然后根据对应的授权类型，构造对应的方法处理器。下面是handle的实现接口： 123456789101112131415161718192021222324public void handle() throws OAuthSystemException, ServletException, IOException &#123; //验证请求是否合法，主要是针对参数做基本的校验，重定向链接，客户端ID授权范围等这些信息与注册的是否相同。 if (validateFailed()) &#123; return; &#125; //判断用户是否登录过，根据session判断。因此多个应用使用同一个授权服务的话，是可以直接跳过登录步骤的也就实现了单点登录的效果。如果没有登录的话，这一步的请求会被重定向至登录页面。（登录也得隐藏域会带上这些参数） if (goLogin()) &#123; return; &#125; //这个请求如果是从登录页面提交过来的，那么就提交用户的登录，这个框架中交给shiro去做登录相关的操作。 if (submitLogin()) &#123; return; &#125; // 本系统中把登录和授权放在两个步骤中完成，有点像新浪微博的方式，QQ是一步完成授权。用户未授权则跳转授权页面 if (goApproval()) &#123; return; &#125; //与登录类似，也是提交用户批准或拒绝了权限请求 if (submitApproval()) &#123; return; &#125; //以上任意一步没有通过都是授权失败会进行相应处理，如果都通过了就发放Code码。 handleResponse(); &#125; 如果以上步骤都通过的话，认证服务器会转向这个会调地址，带上发放的Code码，类似如下： 1http://localhost:8000/login?code=bca654ab6133ab3cbc55bb751da93b1c&amp;state=09876999 可以看到带回了返回的参数，以及原样返回的状态码。应用服务器这时候拿到返回的code去换token,发起如下的一个请求： 1localhost:8090/oauth/token?client_id=test&amp;client_secret=test&amp;grant_type=authorization_code&amp;code=bca654ab6133ab3cbc55bb751da93b1c&amp;redirect_uri=http://localhost:8000/login&amp;scope=read%20write&amp;state=09876999 与之前请求类似只是多了一个code字段，去验证客户端的合法性。 验证服务器会在收到code以后去查找是否有支持这种code的处理器，如果有则发放token。 1234567for (OAuthTokenHandler handler : handlers) &#123; if (handler.support(tokenRequest)) &#123; LOG.debug(&quot;Found &apos;&#123;&#125;&apos; handle OAuthTokenxRequest: &#123;&#125;&quot;, handler, tokenRequest); handler.handle(tokenRequest, response); return; &#125; &#125; 初始化支持的handler 123456private void initialHandlers() &#123; handlers.add(new AuthorizationCodeTokenHandler()); handlers.add(new PasswordTokenHandler()); handlers.add(new RefreshTokenHandler()); handlers.add(new ClientCredentialsTokenHandler()); &#125; 验证通过后应用服务器会接受到包含token的一个json数据： 123456&#123;&quot;access_token&quot;: &quot;23e003b5e4b9b7eda228b845532d8336&quot;,&quot;refresh_token&quot;: &quot;d6b49710f398c405a62f31a6676c5830&quot;,&quot;token_type&quot;: &quot;Bearer&quot;,&quot;expires_in&quot;: 43199&#125; 这个token是有一定的有效期的，在服务端会缓存这个token以便下一次查询，应用客户端也应该保留这个token，访问受限资源时候需要带上这个token去验证身份。比如请求一个API如下： 123curl -i -X GET \ -H &quot;Authorization:Bearer 33dbfc80f5659c6fdec73a044ff724c3&quot; \ &apos;http://localhost:8090/api/test&apos; 资源服务器上使用shiro做安全验证，配置OAuth2对应的realms即可： 123456&lt;property name=&quot;realms&quot;&gt;&lt;list&gt; &lt;bean id=&quot;systemAuthorizingRealm&quot; class=&quot;me.kbiao.example.modules.sys.security.SystemAuthorizingRealm&quot;/&gt; &lt;bean id=&quot;oAuth2Realm&quot; class=&quot;me.kbiao.example..modules.sys.security.OAuth2Realm&quot;/&gt;&lt;/list&gt;&lt;/property&gt; 在这个reamls中根据token去查到用户信息，再去分发对应的资源。自此便完成了整个oauth2的流程。这个流程中认证服务系统需要配置三张数据表： client_details表中存放注册的客户端数据。如回调地址，授权类型，是否信任，权限信息等 code中存放发放给客户端应用的code，使用后失效，以保证安全性 access_token中存放用户信息、客户端和token的对应关系。 项目是基于Shiro+ALTU实现，参考方案mkk/oauth2-shiro - 码云 - 开源中国 ，更详细的内容，可以去读读Shengzhao Li开源的代码 总结 本文简单介绍了几种统一认证的解决方案，然后详细介绍了OAuth2的认证流程，并结合实例详细介绍了CODE授权的流程。尽管OAuth2被广泛用于多平台登录解决方案，我觉得在设置cookie、session共享之后也可以被应用于单点登录的解决方案。 作者： K_Biao 来源：慕课网]]></content>
      <categories>
        <category>OAuth</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2Fblog%2F5063.html</url>
    <content type="text"><![CDATA[NodeJS基础什么是NodeJSJS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。 有啥用处尽管存在一听说可以直接运行JS文件就觉得很酷的同学，但大多数同学在接触新东西时首先关心的是有啥用处，以及能带来啥价值。 NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器，他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制。JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一大群程序员，因此就成为了天然的选择。 如他所愿，NodeJS在服务端活跃起来，出现了大批基于NodeJS的Web服务。而另一方面，NodeJS让前端众如获神器，终于可以让自己的能力覆盖范围跳出浏览器窗口，更大批的前端工具如雨后春笋。 因此，对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。 NodeJS生态圈正欣欣向荣。 如何安装安装程序NodeJS提供了一些安装程序，都可以在nodejs.org这里下载并安装。 Windows系统下，选择和系统版本匹配的.msi后缀的安装文件。Mac OS X系统下，选择.pkg后缀的安装文件。 编译安装Linux系统下没有现成的安装程序可用，虽然一些发行版可以使用apt-get之类的方式安装，但不一定能安装到最新版。因此Linux系统下一般使用以下方式编译方式安装NodeJS。 确保系统下g++版本在4.6以上，python版本在2.6以上。 从nodejs.org下载tar.gz后缀的NodeJS最新版源代码包并解压到某个位置。 进入解压到的目录，使用以下命令编译和安装。 123$ ./configure$ make$ sudo make install 如何运行打开终端，键入node进入命令交互模式，可以输入一条代码语句后立即执行并显示结果，例如： 123$ node&gt; console.log(&apos;Hello World!&apos;);Hello World! 如果要运行一大段代码的话，可以先写一个JS文件再运行。例如有以下hello.js。 1234function hello() &#123; console.log(&apos;Hello World!&apos;);&#125;hello(); 写好后在终端下键入node hello.js运行，结果如下： 12$ node hello.jsHello World! 权限问题在Linux系统下，使用NodeJS监听80或443端口提供HTTP(S)服务时需要root权限，有两种方式可以做到。 一种方式是使用sudo命令运行NodeJS。例如通过以下命令运行的server.js中有权限使用80和443端口。一般推荐这种方式，可以保证仅为有需要的JS脚本提供root权限。 1$ sudo node server.js 另一种方式是使用chmod +s命令让NodeJS总是以root权限运行，具体做法如下。因为这种方式让任何JS脚本都有了root权限，不太安全，因此在需要很考虑安全的系统下不推荐使用。 12$ sudo chown root /usr/local/bin/node$ sudo chmod +s /usr/local/bin/node 模块编写稍大一点的程序时一般都会将代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。 在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。 requirerequire函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。 123456var foo1 = require(&apos;./foo&apos;);var foo2 = require(&apos;./foo.js&apos;);var foo3 = require(&apos;/home/user/foo&apos;);var foo4 = require(&apos;/home/user/foo.js&apos;);// foo1至foo4中保存的是同一个模块的导出对象。 另外，可以使用以下方式加载和使用一个JSON文件。 1var data = require(&apos;./data.json&apos;); exportsexports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法。 123exports.hello = function () &#123; console.log(&apos;Hello World!&apos;);&#125;; module通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。 123module.exports = function () &#123; console.log(&apos;Hello World!&apos;);&#125;; 以上代码中，模块默认导出对象被替换为一个函数。 模块初始化一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。 主模块通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，main.js就是主模块。 1$ node main.js 完整示例例如有以下目录。 1234- /home/user/hello/ - util/ counter.js main.js 其中counter.js内容如下： 1234567var i = 0;function count() &#123; return ++i;&#125;exports.count = count; 该模块内部定义了一个私有变量i，并在exports对象导出了一个公有方法count。 主模块main.js内容如下： 123456var counter1 = require(&apos;./util/counter&apos;);var counter2 = require(&apos;./util/counter&apos;);console.log(counter1.count());console.log(counter2.count());console.log(counter2.count()); 运行该程序的结果如下： 1234$ node main.js123 可以看到，counter.js并没有因为被require了两次而初始化两次。 二进制模块虽然一般我们使用JS编写模块，但NodeJS也支持使用C/C++编写二进制模块。编译好的二进制模块除了文件扩展名是.node外，和JS模块的使用方式相同。虽然二进制模块能使用操作系统提供的所有功能，拥有无限的潜能，但对于前端同学而言编写过于困难，并且难以跨平台使用，因此不在本教程的覆盖范围内。 小结本章介绍了有关NodeJS的基本概念和使用方法，总结起来有以下知识点： NodeJS是一个JS脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令。 终端下直接输入node命令可进入命令交互模式，很适合用来测试一些JS代码片段，比如正则表达式。 NodeJS使用CMD模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。 除非JS模块不能满足需求，否则不要轻易使用二进制模块，否则你的用户会叫苦连天。 代码的组织和部署有经验的C程序员在编写一个新程序时首先从make文件写起。同样的，使用NodeJS编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式，就如同修房子要先搭脚手架。本章将介绍与之相关的各种知识。 模块路径解析规则我们已经知道，require函数支持斜杠（/）或盘符（C:）开头的绝对路径，也支持./开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。因此，require函数支持第三种形式的路径，写法类似于foo/bar，并依次按照以下规则解析路径，直到找到模块位置。 内置模块 如果传递给require函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(&#39;fs&#39;)。 node_modules目录 NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，在该模块中使用require(&#39;foo/bar&#39;)方式加载模块时，则NodeJS依次尝试使用以下路径。 123/home/user/node_modules/foo/bar/home/node_modules/foo/bar/node_modules/foo/bar NODE_PATH环境变量 与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下NODE_PATH环境变量： 1NODE_PATH=/home/user/lib:/home/lib 当使用require(&#39;foo/bar&#39;)的方式加载模块时，则NodeJS依次尝试以下路径。 12/home/user/lib/foo/bar/home/lib/foo/bar 包（package）我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。 在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。 12345- /home/user/lib/ - cat/ head.js body.js main.js 其中cat目录定义了一个包，其中包含了3个子模块。main.js作为入口模块，其内容如下： 12345678910var head = require(&apos;./head&apos;);var body = require(&apos;./body&apos;);exports.create = function (name) &#123; return &#123; name: name, head: head.create(), body: body.create() &#125;;&#125;; 在其它模块里使用包的时候，需要加载包的入口模块。接着上例，使用require(&#39;/home/user/lib/cat/main&#39;)能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。 index.js当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。 12var cat = require(&apos;/home/user/lib/cat&apos;);var cat = require(&apos;/home/user/lib/cat/index&apos;); 这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。 package.json如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，并在其中指定入口模块的路径。上例中的cat模块可以重构如下。 123456789- /home/user/lib/ - cat/ + doc/ - lib/ head.js body.js main.js + tests/ package.json 其中package.json内容如下。 1234&#123; &quot;name&quot;: &quot;cat&quot;, &quot;main&quot;: &quot;./lib/main.js&quot;&#125; 如此一来，就同样可以使用require(&#39;/home/user/lib/cat&#39;)的方式加载模块。NodeJS会根据包目录下的package.json找到入口模块所在位置。 命令行程序使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。 例如我们用NodeJS写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在/home/user/bin/node-echo.js这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。 12$ node /home/user/bin/node-echo.js Hello WorldHello World 这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式。 1$ node-echo Hello World Linux在Linux系统下，我们可以把JS文件当作shell脚本来运行，从而达到上述目的，具体步骤如下： 在shell脚本中，可以通过#!注释来指定当前脚本使用的解析器。所以我们首先在node-echo.js文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。 1#! /usr/bin/env node NodeJS会忽略掉位于JS模块首行的#!注释，不必担心这行注释是非法语句。 然后，我们使用以下命令赋予node-echo.js文件执行权限。 1$ chmod +x /home/user/bin/node-echo.js 最后，我们在PATH环境变量中指定的某个目录下，例如在/usr/local/bin下边创建一个软链文件，文件名与我们希望使用的终端命令同名，命令如下： 1$ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo 这样处理后，我们就可以在任何目录下使用node-echo命令了。 Windows在Windows系统下的做法完全不同，我们得靠.cmd文件来解决问题。假设node-echo.js存放在C:\Users\user\bin目录，并且该目录已经添加到PATH环境变量里了。接下来需要在该目录下新建一个名为node-echo.cmd的文件，文件内容如下： 1@node &quot;C:\User\user\bin\node-echo.js&quot; %* 这样处理后，我们就可以在任何目录下使用node-echo命令了。 工程目录了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个命令行程序为例，一般我们会同时提供命令行模式和API模式两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。 1234567891011- /home/user/workspace/node-echo/ # 工程目录 - bin/ # 存放命令行相关代码 node-echo + doc/ # 存放文档 - lib/ # 存放API相关代码 echo.js - node_modules/ # 存放三方包 + argv/ + tests/ # 存放测试用例 package.json # 元数据文件 README.md # 说明文件 其中部分文件内容如下： 123456789101112131415/* bin/node-echo */var argv = require(&apos;argv&apos;), echo = require(&apos;../lib/echo&apos;);console.log(echo(argv.join(&apos; &apos;)));/* lib/echo.js */module.exports = function (message) &#123; return message;&#125;;/* package.json */&#123; &quot;name&quot;: &quot;node-echo&quot;, &quot;main&quot;: &quot;./lib/echo.js&quot;&#125; 以上例子中分类存放了不同类型的文件，并通过node_moudles目录直接使用三方包名加载模块。此外，定义了package.json之后，node-echo目录也可被当作一个包来使用。 NPMNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 可以看到，NPM建立了一个NodeJS生态圈，NodeJS开发者和用户可以在里边互通有无。以下分别介绍这三种场景下怎样使用NPM。 下载三方包需要使用三方包时，首先得知道有哪些包可用。虽然npmjs.org提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请百度一下吧。知道了包名后，比如上边例子中的argv，就可以在工程目录下打开终端，使用以下命令来下载三方包。 123$ npm install argv...argv@0.0.2 node_modules\argv 下载好之后，argv包就放在了工程目录下的node_modules目录中，因此在代码中只需要通过require(&#39;argv&#39;)的方式就好，无需指定三方包路径。 以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上@&lt;version&gt;，例如通过以下命令可下载0.0.1版的argv。 123$ npm install argv@0.0.1...argv@0.0.1 node_modules\argv 如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对package.json的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的package.json可以改写如下： 1234567&#123; &quot;name&quot;: &quot;node-echo&quot;, &quot;main&quot;: &quot;./lib/echo.js&quot;, &quot;dependencies&quot;: &#123; &quot;argv&quot;: &quot;0.0.2&quot; &#125;&#125; 这样处理后，在工程目录下就可以使用npm install命令批量安装三方包了。更重要的是，当以后node-echo也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用npm install node-echo命令时，NPM会自动创建以下目录结构。 1234567- project/ - node_modules/ - node-echo/ - node_modules/ + argv/ ... ... 如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。 安装命令行程序从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的node-echo提供了命令行使用方式，只要node-echo自己配置好了相关的package.json字段，对于用户而言，只需要使用以下命令安装程序。 1$ npm install node-echo -g 参数中的-g表示全局安装，因此node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的.cmd文件。 123456789101112131415- /usr/local/ # Linux系统下 - lib/node_modules/ + node-echo/ ... - bin/ node-echo ... ...- %APPDATA%\npm\ # Windows系统下 - node_modules\ + node-echo\ ... node-echo.cmd ... 发布代码第一次使用NPM发布代码前需要注册一个账号。终端下运行npm adduser，之后按照提示做即可。账号搞定后，接着我们需要编辑package.json文件，加入NPM必需的字段。接着上边node-echo的例子，package.json里必要的字段如下。 1234567891011&#123; &quot;name&quot;: &quot;node-echo&quot;, # 包名，在NPM服务器上须要保持唯一 &quot;version&quot;: &quot;1.0.0&quot;, # 当前版本号 &quot;dependencies&quot;: &#123; # 三方包依赖，需要指定包名和版本号 &quot;argv&quot;: &quot;0.0.2&quot; &#125;, &quot;main&quot;: &quot;./lib/echo.js&quot;, # 入口模块位置 &quot;bin&quot; : &#123; &quot;node-echo&quot;: &quot;./bin/node-echo&quot; # 命令行程序名和主模块位置 &#125;&#125; 之后，我们就可以在package.json所在目录下运行npm publish发布代码了。 版本号使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。 语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 12345+ 如果只是修复bug，需要更新Z位。+ 如果是新增了功能，但是向下兼容，需要更新Y位。+ 如果有大变动，向下不兼容，需要更新X位。 版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如&quot;argv&quot;: &quot;0.0.x&quot;表示依赖于0.0.x系列的最新版argv。NPM支持的所有版本号范围指定方式可以查看官方文档。 灵机一点除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。除了可以在npmjs.org/doc/查看官方文档外，这里再介绍一些NPM常用命令。 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 使用npm help &lt;command&gt;可查看某条命令的详细帮助，例如npm help install。 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update &lt;package&gt;可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。 使用npm update &lt;package&gt; -g可以把全局安装的对应命令行程序更新至最新版。 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 使用npm unpublish &lt;package&gt;@&lt;version&gt;可以撤销发布自己发布过的某个版本代码。 小结本章介绍了使用NodeJS编写代码前需要做的准备工作，总结起来有以下几点： 编写代码前先规划好目录结构，才能做到有条不紊。 稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块。 合理使用node_modules和NODE_PATH来解耦包的使用方式和物理路径。 使用NPM加入NodeJS生态圈互通有无。 想到了心仪的包名时请提前在NPM上抢注。 文件操作让前端觉得如获神器的不是NodeJS能做网络编程，而是NodeJS能够操作文件。小至文件查找，大至代码编译，几乎没有一个前端工具不操作文件。换个角度讲，几乎也只需要一些数据处理逻辑，再加上一些文件操作，就能够编写出大多数前端工具。本章将介绍与之相关的NodeJS内置模块。 开门红NodeJS提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与copy命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。 小文件拷贝我们使用NodeJS内置的fs模块简单实现这个程序如下。 1234567891011var fs = require(&apos;fs&apos;);function copy(src, dst) &#123; fs.writeFileSync(dst, fs.readFileSync(src));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 以上程序使用fs.readFileSync从源路径读取文件内容，并使用fs.writeFileSync将文件内容写入目标路径。 豆知识： process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。 大文件拷贝上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下。 1234567891011var fs = require(&apos;fs&apos;);function copy(src, dst) &#123; fs.createReadStream(src).pipe(fs.createWriteStream(dst));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 以上程序使用fs.createReadStream创建了一个源文件的只读数据流，并使用fs.createWriteStream创建了一个目标文件的只写数据流，并且用pipe方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。 API走马观花我们先大致看看NodeJS提供了哪些和文件操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。 Buffer（数据块） 官方文档： http://nodejs.org/api/buffer.html JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。除了可以读取文件得到Buffer的实例外，还能够直接构造，例如： 1var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]); Buffer与字符串类似，除了可以用.length属性得到字节长度外，还可以用[index]方式读取指定位置的字节，例如： 1bin[0]; // =&gt; 0x68; Buffer与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串： 1var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot; 或者反过来，将字符串转换为指定编码下的二进制数据： 1var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt; Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于Buffer，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节。 1bin[0] = 0x48; 而.slice方法也不是返回一个新的Buffer，而更像是返回了指向原Buffer中间的某个位置的指针，如下所示。 1234[ 0x68, 0x65, 0x6c, 0x6c, 0x6f ] ^ ^ | | bin bin.slice(2) 因此对.slice方法返回的Buffer的修改会作用于原Buffer，例如： 12345var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);var sub = bin.slice(2);sub[0] = 0x65;console.log(bin); // =&gt; &lt;Buffer 68 65 65 6c 6f&gt; 也因此，如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。 1234567var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);var dup = new Buffer(bin.length);bin.copy(dup);dup[0] = 0x48;console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt; 总之，Buffer将JS的数据处理能力从字符串扩展到了任意二进制数据。 Stream（数据流） 官方文档： http://nodejs.org/api/stream.html 当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种Stream来提供对数据流的操作。 以上边的大文件拷贝程序为例，我们可以为数据来源创建一个只读数据流，示例如下： 123456789var rs = fs.createReadStream(pathname);rs.on(&apos;data&apos;, function (chunk) &#123; doSomething(chunk);&#125;);rs.on(&apos;end&apos;, function () &#123; cleanUp();&#125;); 豆知识： Stream基于事件机制工作，所有Stream的实例都继承于NodeJS提供的EventEmitter。 上边的代码中data事件会源源不断地被触发，不管doSomething函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。 123456789101112var rs = fs.createReadStream(src);rs.on(&apos;data&apos;, function (chunk) &#123; rs.pause(); doSomething(chunk, function () &#123; rs.resume(); &#125;);&#125;);rs.on(&apos;end&apos;, function () &#123; cleanUp();&#125;); 以上代码给doSomething函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。 此外，我们也可以为数据目标创建一个只写数据流，示例如下： 12345678910var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on(&apos;data&apos;, function (chunk) &#123; ws.write(chunk);&#125;);rs.on(&apos;end&apos;, function () &#123; ws.end();&#125;); 我们把doSomething换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据.write方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据drain事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以改造如下： 12345678910111213141516var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on(&apos;data&apos;, function (chunk) &#123; if (ws.write(chunk) === false) &#123; rs.pause(); &#125;&#125;);rs.on(&apos;end&apos;, function () &#123; ws.end();&#125;);ws.on(&apos;drain&apos;, function () &#123; rs.resume();&#125;); 以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序，NodeJS直接提供了.pipe方法来做这件事情，其内部实现方式与上边的代码类似。 File System（文件系统） 官方文档： http://nodejs.org/api/fs.html NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类： 文件属性读写。 其中常用的有fs.stat、fs.chmod、fs.chown等等。 文件内容读写。 其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。 底层文件操作。 其中常用的有fs.open、fs.read、fs.write、fs.close等等。 NodeJS最精华的异步IO模型在fs模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以fs.readFile为例： 1234567fs.readFile(pathname, function (err, data) &#123; if (err) &#123; // Deal with error. &#125; else &#123; // Deal with data. &#125;&#125;); 如上边代码所示，基本上所有fs模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。 此外，fs模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。同步API除了方法名的末尾多了一个Sync之外，异常对象与执行结果的传递方式也有相应变化。同样以fs.readFileSync为例： 123456try &#123; var data = fs.readFileSync(pathname); // Deal with data.&#125; catch (err) &#123; // Deal with error.&#125; fs模块提供的API很多，这里不一一介绍，需要时请自行查阅官方文档。 Path（路径） 官方文档： http://nodejs.org/api/path.html 操作文件时难免不与文件路径打交道。NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。以下分别介绍几个常用的API。 path.normalize 将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子： 123456789var cache = &#123;&#125;;function store(key, value) &#123; cache[path.normalize(key)] = value;&#125;store(&apos;foo/bar&apos;, 1);store(&apos;foo//baz//../bar&apos;, 2);console.log(cache); // =&gt; &#123; &quot;foo/bar&quot;: 2 &#125; 坑出没注意： 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &#39;/&#39;)再替换一下标准路径。 path.join 将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子： 1path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot; path.extname 当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子： 1path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot; path模块提供的其余方法也不多，稍微看一下官方文档就能全部掌握。 遍历目录遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。 递归算法遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。 1234567function factorial(n) &#123; if (n === 1) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125; 上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。 陷阱： 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。 遍历算法目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是A &gt; B &gt; D &gt; E &gt; C &gt; F。 12345 A / \ B C / \ \D E F 同步遍历了解了必要的算法后，我们可以简单地实现以下目录遍历函数。 1234567891011function travel(dir, callback) &#123; fs.readdirSync(dir).forEach(function (file) &#123; var pathname = path.join(dir, file); if (fs.statSync(pathname).isDirectory()) &#123; travel(pathname, callback); &#125; else &#123; callback(pathname); &#125; &#125;);&#125; 可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录： 123456- /home/user/ - foo/ x.js - bar/ y.js z.css 使用以下代码遍历该目录时，得到的输入如下。 12345678travel(&apos;/home/user&apos;, function (pathname) &#123; console.log(pathname);&#125;);------------------------/home/user/foo/x.js/home/user/bar/y.js/home/user/z.css 异步遍历如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。travel函数的异步版本如下。 1234567891011121314151617181920212223function travel(dir, callback, finish) &#123; fs.readdir(dir, function (err, files) &#123; (function next(i) &#123; if (i &lt; files.length) &#123; var pathname = path.join(dir, files[i]); fs.stat(pathname, function (err, stats) &#123; if (stats.isDirectory()) &#123; travel(pathname, callback, function () &#123; next(i + 1); &#125;); &#125; else &#123; callback(pathname, function () &#123; next(i + 1); &#125;); &#125; &#125;); &#125; else &#123; finish &amp;&amp; finish(); &#125; &#125;(0)); &#125;);&#125; 这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的。 文本编码使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。 BOM的移除BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下： 12345 Bytes Encoding---------------------------- FE FF UTF16BE FF FE UTF16LE EF BB BF UTF8 因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。例如，以下代码实现了识别和去除UTF8 BOM的功能。 123456789function readText(pathname) &#123; var bin = fs.readFileSync(pathname); if (bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) &#123; bin = bin.slice(3); &#125; return bin.toString(&apos;utf-8&apos;);&#125; GBK转UTF8NodeJS支持在读取文本文件时，或者在Buffer转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助iconv-lite这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。 1234567var iconv = require(&apos;iconv-lite&apos;);function readGBKText(pathname) &#123; var bin = fs.readFileSync(pathname); return iconv.decode(bin, &apos;gbk&apos;);&#125; 单字节编码有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。 首先我们知道，如果一个文本文件只包含英文字符，比如Hello World，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。 反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。 1234567891011121. GBK编码源文件内容： var foo = &apos;中文&apos;;2. 对应字节： 76 61 72 20 66 6F 6F 20 3D 20 27 D6 D0 CE C4 27 3B3. 使用单字节编码读取后得到的内容： var foo = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;4. 替换内容： var bar = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;5. 使用单字节编码保存后对应字节： 76 61 72 20 62 61 72 20 3D 20 27 D6 D0 CE C4 27 3B6. 使用GBK编码读取后得到内容： var bar = &apos;中文&apos;; 这里的诀窍在于，不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。 NodeJS中自带了一种binary编码可以用来实现这个方法，因此在下例中，我们使用这种编码来演示上例对应的代码该怎么写。 12345function replace(pathname) &#123; var str = fs.readFileSync(pathname, &apos;binary&apos;); str = str.replace(&apos;foo&apos;, &apos;bar&apos;); fs.writeFileSync(pathname, str, &apos;binary&apos;);&#125; 小结本章介绍了使用NodeJS操作文件时需要的API以及一些技巧，总结起来有以下几点： 学好文件操作，编写各种程序都不怕。 如果不是很在意性能，fs模块的同步API能让生活更加美好。 需要对文件读写做到字节级别的精细控制时，请使用fs模块的文件底层操作API。 不要使用拼接字符串的方式来处理路径，使用path模块。 掌握好目录遍历和文件编码处理技巧，很实用。 网络操作不了解网络编程的程序员不是好前端，而NodeJS恰好提供了一扇了解网络编程的窗口。通过NodeJS，除了可以编写一些服务端程序来协助前端开发和测试外，还能够学习一些HTTP协议与Socket协议的相关知识，这些知识在优化前端性能和排查前端故障时说不定能派上用场。本章将介绍与之相关的NodeJS内置模块。 开门红NodeJS本来的用途是编写高性能Web服务器。我们首先在这里重复一下官方文档里的例子，使用NodeJS内置的http模块简单实现一个HTTP服务器。 123456var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text-plain&apos; &#125;); response.end(&apos;Hello World\n&apos;);&#125;).listen(8124); 以上程序创建了一个HTTP服务器并监听8124端口，打开浏览器访问该端口http://127.0.0.1:8124/就能够看到效果。 豆知识： 在Linux系统下，监听1024以下端口需要root权限。因此，如果想监听80或443端口的话，需要使用sudo命令启动程序。 API走马观花我们先大致看看NodeJS提供了哪些和网络操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。 HTTP 官方文档： http://nodejs.org/api/http.html ‘http’模块提供两种使用方式： 作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。 作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。 首先我们来看看服务端模式下如何工作。如开门红中的例子所示，首先需要使用.createServer方法创建一个服务器，然后调用.listen方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。可以看出，这是一种事件机制。 HTTP请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。例如以下是一个完整的HTTP请求数据内容。 12345678POST / HTTP/1.1User-Agent: curl/7.26.0Host: localhostAccept: */*Content-Length: 11Content-Type: application/x-www-form-urlencodedHello World 可以看到，空行之上是请求头，之下是请求体。HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而http模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用request对象访问请求头数据外，还能把request对象当作一个只读数据流来访问请求体数据。以下是一个例子。 123456789101112131415161718192021222324http.createServer(function (request, response) &#123; var body = []; console.log(request.method); console.log(request.headers); request.on(&apos;data&apos;, function (chunk) &#123; body.push(chunk); &#125;); request.on(&apos;end&apos;, function () &#123; body = Buffer.concat(body); console.log(body.toString()); &#125;);&#125;).listen(80);------------------------------------POST&#123; &apos;user-agent&apos;: &apos;curl/7.26.0&apos;, host: &apos;localhost&apos;, accept: &apos;*/*&apos;, &apos;content-length&apos;: &apos;11&apos;, &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;Hello World HTTP响应本质上也是一个数据流，同样由响应头（headers）和响应体（body）组成。例如以下是一个完整的HTTP请求数据内容。 1234567HTTP/1.1 200 OKContent-Type: text/plainContent-Length: 11Date: Tue, 05 Nov 2013 05:31:38 GMTConnection: keep-aliveHello World 在回调函数中，除了可以使用response对象来写入响应头数据外，还能把response对象当作一个只写数据流来写入响应体数据。例如在以下例子中，服务端原样将客户端请求的请求体数据返回给客户端。 1234567891011http.createServer(function (request, response) &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); request.on(&apos;data&apos;, function (chunk) &#123; response.write(chunk); &#125;); request.on(&apos;end&apos;, function () &#123; response.end(); &#125;);&#125;).listen(80); 接下来我们看看客户端模式下如何工作。为了发起一个客户端HTTP请求，我们需要指定目标服务器的位置并发送请求头和请求体，以下示例演示了具体做法。 1234567891011121314var options = &#123; hostname: &apos;www.example.com&apos;, port: 80, path: &apos;/upload&apos;, method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125; &#125;;var request = http.request(options, function (response) &#123;&#125;);request.write(&apos;Hello World&apos;);request.end(); 可以看到，.request方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把request对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中GET请求是最常见的一种，并且不需要请求体，因此http模块也提供了以下便捷API。 1http.get(&apos;http://www.example.com/&apos;, function (response) &#123;&#125;); 当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用response对象访问响应头数据外，还能把response对象当作一个只读数据流来访问响应体数据。以下是一个例子。 12345678910111213141516171819202122232425http.get(&apos;http://www.example.com/&apos;, function (response) &#123; var body = []; console.log(response.statusCode); console.log(response.headers); response.on(&apos;data&apos;, function (chunk) &#123; body.push(chunk); &#125;); response.on(&apos;end&apos;, function () &#123; body = Buffer.concat(body); console.log(body.toString()); &#125;);&#125;);------------------------------------200&#123; &apos;content-type&apos;: &apos;text/html&apos;, server: &apos;Apache&apos;, &apos;content-length&apos;: &apos;801&apos;, date: &apos;Tue, 05 Nov 2013 06:08:41 GMT&apos;, connection: &apos;keep-alive&apos; &#125;&lt;!DOCTYPE html&gt;... HTTPS 官方文档： http://nodejs.org/api/https.html https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。 在服务端模式下，创建一个HTTPS服务器的示例如下。 12345678var options = &#123; key: fs.readFileSync(&apos;./ssl/default.key&apos;), cert: fs.readFileSync(&apos;./ssl/default.cer&apos;) &#125;;var server = https.createServer(options, function (request, response) &#123; // ... &#125;); 可以看到，与创建HTTP服务器相比，多了一个options对象，通过key和cert字段指定了HTTPS服务器使用的私钥和公钥。 另外，NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。接着上例，可以使用以下方法为HTTPS服务器添加多组证书。 123456789server.addContext(&apos;foo.com&apos;, &#123; key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;), cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)&#125;);server.addContext(&apos;bar.com&apos;, &#123; key: fs.readFileSync(&apos;./ssl/bar.com.key&apos;), cert: fs.readFileSync(&apos;./ssl/bar.com.cer&apos;)&#125;); 在客户端模式下，发起一个HTTPS客户端请求与http模块几乎相同，示例如下。 12345678910var options = &#123; hostname: &apos;www.example.com&apos;, port: 443, path: &apos;/&apos;, method: &apos;GET&apos; &#125;;var request = https.request(options, function (response) &#123;&#125;);request.end(); 但如果目标服务器使用的SSL证书是自制的，不是从颁发机构购买的，默认情况下https模块会拒绝连接，提示说有证书安全问题。在options里加入rejectUnauthorized: false字段可以禁用对证书有效性的检查，从而允许https模块请求开发环境下使用自制证书的HTTPS服务器。 URL 官方文档： http://nodejs.org/api/url.html 处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。首先我们来看看一个完整的URL的各组成部分。 123456789 href ----------------------------------------------------------------- host path --------------- ---------------------------- http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash ----- --------- -------- ---- -------- ------------- -----protocol auth hostname port pathname search hash ------------ query 我们可以使用.parse方法来将一个URL字符串转换为URL对象，示例如下。 1234567891011121314url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;);/* =&gt;&#123; protocol: &apos;http:&apos;, auth: &apos;user:pass&apos;, host: &apos;host.com:8080&apos;, port: &apos;8080&apos;, hostname: &apos;host.com&apos;, hash: &apos;#hash&apos;, search: &apos;?query=string&apos;, query: &apos;query=string&apos;, pathname: &apos;/p/a/t/h&apos;, path: &apos;/p/a/t/h?query=string&apos;, href: &apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos; &#125;*/ 传给.parse方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，request.url不包含协议头和域名，但同样可以用.parse方法解析。 123456789101112131415161718http.createServer(function (request, response) &#123; var tmp = request.url; // =&gt; &quot;/foo/bar?a=b&quot; url.parse(tmp); /* =&gt; &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: &apos;?a=b&apos;, query: &apos;a=b&apos;, pathname: &apos;/foo/bar&apos;, path: &apos;/foo/bar?a=b&apos;, href: &apos;/foo/bar?a=b&apos; &#125; */&#125;).listen(80); .parse方法还支持第二个和第三个布尔类型可选参数。第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如//www.example.com/foo/bar。 反过来，format方法允许将一个URL对象转换为URL字符串，示例如下。 123456789url.format(&#123; protocol: &apos;http:&apos;, host: &apos;www.example.com&apos;, pathname: &apos;/p/a/t/h&apos;, search: &apos;query=string&apos;&#125;);/* =&gt;&apos;http://www.example.com/p/a/t/h?query=string&apos;*/ 另外，.resolve方法可以用于拼接URL，示例如下。 1234url.resolve(&apos;http://www.example.com/foo/bar&apos;, &apos;../baz&apos;);/* =&gt;http://www.example.com/baz*/ Query String 官方文档： http://nodejs.org/api/querystring.html querystring模块用于实现URL参数字符串与参数对象的互相转换，示例如下。 123456789querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;);/* =&gt;&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;*/querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;);/* =&gt;&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;*/ Zlib 官方文档： http://nodejs.org/api/zlib.html zlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。 首先我们看一个使用zlib模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用zlib模块返回gzip之后的响应体数据。 1234567891011121314151617181920212223http.createServer(function (request, response) &#123; var i = 1024, data = &apos;&apos;; while (i--) &#123; data += &apos;.&apos;; &#125; if ((request.headers[&apos;accept-encoding&apos;] || &apos;&apos;).indexOf(&apos;gzip&apos;) !== -1) &#123; zlib.gzip(data, function (err, data) &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos; &#125;); response.end(data); &#125;); &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); response.end(data); &#125;&#125;).listen(80); 接着我们看一个使用zlib模块解压HTTP响应体数据的例子。这个例子中，判断了服务端响应是否使用gzip压缩，并在压缩的情况下使用zlib模块解压响应体数据。 1234567891011121314151617181920212223242526272829var options = &#123; hostname: &apos;www.example.com&apos;, port: 80, path: &apos;/&apos;, method: &apos;GET&apos;, headers: &#123; &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos; &#125; &#125;;http.request(options, function (response) &#123; var body = []; response.on(&apos;data&apos;, function (chunk) &#123; body.push(chunk); &#125;); response.on(&apos;end&apos;, function () &#123; body = Buffer.concat(body); if (response.headers[&apos;content-encoding&apos;] === &apos;gzip&apos;) &#123; zlib.gunzip(body, function (err, data) &#123; console.log(data.toString()); &#125;); &#125; else &#123; console.log(data.toString()); &#125; &#125;);&#125;).end(); Net 官方文档： http://nodejs.org/api/net.html net模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，这里先不涉及到WebSocket的介绍，仅仅简单演示一下如何从Socket层面来实现HTTP请求和响应。 首先我们来看一个使用Socket搭建一个很不严谨的HTTP服务器的例子。这个HTTP服务器不管收到啥请求，都固定返回相同的响应。 1234567891011net.createServer(function (conn) &#123; conn.on(&apos;data&apos;, function (data) &#123; conn.write([ &apos;HTTP/1.1 200 OK&apos;, &apos;Content-Type: text/plain&apos;, &apos;Content-Length: 11&apos;, &apos;&apos;, &apos;Hello World&apos; ].join(&apos;\n&apos;)); &#125;);&#125;).listen(80); 接着我们来看一个使用Socket发起HTTP客户端请求的例子。这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过data事件监听函数来获取服务器响应。 1234567891011121314151617181920var options = &#123; port: 80, host: &apos;www.example.com&apos; &#125;;var client = net.connect(options, function () &#123; client.write([ &apos;GET / HTTP/1.1&apos;, &apos;User-Agent: curl/7.26.0&apos;, &apos;Host: www.baidu.com&apos;, &apos;Accept: */*&apos;, &apos;&apos;, &apos;&apos; ].join(&apos;\n&apos;)); &#125;);client.on(&apos;data&apos;, function (data) &#123; console.log(data.toString()); client.end();&#125;); 灵机一点使用NodeJS操作网络，特别是操作HTTP请求和响应时会遇到一些惊喜，这里对一些常见问题做解答。 问： 为什么通过headers对象访问到的HTTP请求头或响应头字段不是驼峰的？ 答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如headers[&#39;content-length&#39;]。 问： 为什么http模块创建的HTTP服务器返回的响应是chunked传输方式的？ 答： 因为默认情况下，使用.writeHead方法写入响应头后，允许使用.write方法写入任意长度的响应体数据，并使用.end方法结束一个响应。由于响应体数据长度不确定，因此NodeJS自动在响应头里添加了Transfer-Encoding: chunked字段，并采用chunked传输方式。但是当响应体数据长度确定时，可使用.writeHead方法在响应头里加上Content-Length字段，这样做之后NodeJS就不会自动添加Transfer-Encoding字段和使用chunked传输方式。 问： 为什么使用http模块发起HTTP客户端请求时，有时候会发生socket hang up错误？ 答： 发起客户端HTTP请求前需要先创建一个客户端。http模块提供了一个全局客户端http.globalAgent，可以让我们使用.request或.get方法时不用手动创建客户端。但是全局客户端默认只允许5个并发Socket连接，当某一个时刻HTTP客户端请求创建过多，超过这个数字时，就会发生socket hang up错误。解决方法也很简单，通过http.globalAgent.maxSockets属性把这个数字改大些即可。另外，https模块遇到这个问题时也一样通过https.globalAgent.maxSockets属性来处理。 小结本章介绍了使用NodeJS操作网络时需要的API以及一些坑回避技巧，总结起来有以下几点： http和https模块支持服务端模式和客户端模式两种使用方式。 request和response对象除了用于读写头数据外，都可以当作数据流来操作。 url.parse方法加上request.url属性是处理HTTP请求时的固定搭配。 使用zlib模块可以减少使用HTTP协议时的数据传输量。 通过net模块的Socket服务器与客户端可对HTTP协议做底层操作。 小心踩坑。 进程管理NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。本章除了介绍与之相关的NodeJS内置模块外，还会重点介绍典型的使用场景。 开门红我们已经知道了NodeJS自带的fs模块比较基础，把一个目录里的所有文件和子目录都拷贝到另一个目录里需要写不少代码。另外我们也知道，终端下的cp命令比较好用，一条cp -r source/* target命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，示例代码如下： 1234567891011var child_process = require(&apos;child_process&apos;);var util = require(&apos;util&apos;);function copy(source, target, callback) &#123; child_process.exec( util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);&#125;copy(&apos;a&apos;, &apos;b&apos;, function (err) &#123; // ...&#125;); 从以上代码中可以看到，子进程是异步运行的，通过回调函数返回执行结果。 API走马观花我们先大致看看NodeJS提供了哪些和进程管理有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。 Process 官方文档： http://nodejs.org/api/process.html 任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过process对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，process不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。 Child Process 官方文档： http://nodejs.org/api/child_process.html 使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。 Cluster 官方文档： http://nodejs.org/api/cluster.html cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。 应用场景和进程管理相关的API单独介绍起来比较枯燥，因此这里从一些典型的应用场景出发，分别介绍一些重要API的使用方法。 如何获取命令行参数在NodeJS中可以通过process.argv获取命令行参数。但是比较意外的是，node执行程序路径和主模块文件路径固定占据了argv[0]和argv[1]两个位置，而第一个命令行参数从argv[2]开始。为了让argv使用起来更加自然，可以按照以下方式处理。 12345function main(argv) &#123; // ...&#125;main(process.argv.slice(2)); 如何退出程序通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为0。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于0。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如1，就可以按照以下方式： 123456try &#123; // ...&#125; catch (err) &#123; // ... process.exit(1);&#125; 如何控制输入输出NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应process.stdin、process.stdout和process.stderr，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，console.log可以按照以下方式实现。 1234function log() &#123; process.stdout.write( util.format.apply(util, arguments) + &apos;\n&apos;);&#125; 如何降权在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。以下是这样一个例子。 12345678http.createServer(callback).listen(80, function () &#123; var env = process.env, uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10), gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10); process.setgid(gid); process.setuid(uid);&#125;); 上例中有几点需要注意： 如果是通过sudo获取root权限的，运行程序的用户的UID和GID保存在环境变量SUDO_UID和SUDO_GID里边。如果是通过chmod +s方式获取root权限的，运行程序的用户的UID和GID可直接通过process.getuid和process.getgid方法获取。 process.setuid和process.setgid方法只接受number类型的参数。 降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。 如何创建子进程以下是一个创建NodeJS子进程的例子。 12345678910111213var child = child_process.spawn(&apos;node&apos;, [ &apos;xxx.js&apos; ]);child.stdout.on(&apos;data&apos;, function (data) &#123; console.log(&apos;stdout: &apos; + data);&#125;);child.stderr.on(&apos;data&apos;, function (data) &#123; console.log(&apos;stderr: &apos; + data);&#125;);child.on(&apos;close&apos;, function (code) &#123; console.log(&apos;child process exited with code &apos; + code);&#125;); 上例中使用了.spawn(exec, args, options)方法，该方法支持三个参数。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。 另外，上例中虽然通过子进程对象的.stdout和.stderr访问子进程的输出，但通过options.stdio字段的不同配置，可以将子进程的输入输出重定向到任何数据流上，或者让子进程共享父进程的标准输入输出流，或者直接忽略子进程的输入输出。 进程间如何通讯在Linux系统下，进程之间可以通过信号互相通信。以下是一个例子。 12345678910/* parent.js */var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);child.kill(&apos;SIGTERM&apos;);/* child.js */process.on(&apos;SIGTERM&apos;, function () &#123; cleanUp(); process.exit(0);&#125;); 在上例中，父进程通过.kill方法向子进程发送SIGTERM信号，子进程监听process对象的SIGTERM事件响应信号。不要被.kill方法的名称迷惑了，该方法本质上是用来给进程发送信号的，进程收到信号后具体要做啥，完全取决于信号的种类和进程自身的代码。 另外，如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。以下是一个例子。 12345678910111213141516/* parent.js */var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123; stdio: [ 0, 1, 2, &apos;ipc&apos; ] &#125;);child.on(&apos;message&apos;, function (msg) &#123; console.log(msg);&#125;);child.send(&#123; hello: &apos;hello&apos; &#125;);/* child.js */process.on(&apos;message&apos;, function (msg) &#123; msg.hello = msg.hello.toUpperCase(); process.send(msg);&#125;); 可以看到，父进程在创建子进程时，在options.stdio字段中通过ipc开启了一条IPC通道，之后就可以监听子进程对象的message事件接收来自子进程的消息，并通过.send方法给子进程发送消息。在子进程这边，可以在process对象上监听message事件接收来自父进程的消息，并通过.send方法向父进程发送消息。数据在传递过程中，会先在发送端使用JSON.stringify方法序列化，再在接收端使用JSON.parse方法反序列化。 如何守护子进程守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。以下是一种实现方式。 123456789101112/* daemon.js */function spawn(mainModule) &#123; var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]); worker.on(&apos;exit&apos;, function (code) &#123; if (code !== 0) &#123; spawn(mainModule); &#125; &#125;);&#125;spawn(&apos;worker.js&apos;); 可以看到，工作进程非正常退出时，守护进程立即重启工作进程。 小结本章介绍了使用NodeJS管理进程时需要的API以及主要的应用场景，总结起来有以下几点： 使用process对象管理自身。 使用child_process模块创建和管理子进程。 异步编程NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点，而这一点也遭到了一些NodeJS反对者的抨击。但不管怎样，异步编程确实是NodeJS最大的特点，没有掌握异步编程就不能说是真正学会了NodeJS。本章将介绍与异步编程相关的各种知识。 回调在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码。 12345678910111213141516171819202122function heavyCompute(n, callback) &#123; var count = 0, i, j; for (i = n; i &gt; 0; --i) &#123; for (j = n; j &gt; 0; --j) &#123; count += 1; &#125; &#125; callback(count);&#125;heavyCompute(10000, function (count) &#123; console.log(count);&#125;);console.log(&apos;hello&apos;);-- Console ------------------------------100000000hello 可以看到，以上代码中的回调函数仍然先于后续代码执行。JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。 但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码。 123456789setTimeout(function () &#123; console.log(&apos;world&apos;);&#125;, 1000);console.log(&apos;hello&apos;);-- Console ------------------------------helloworld 这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS本身是单线程的，无法异步执行，因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了setTimeout、setInterval这些常见的，这类函数还包括NodeJS提供的诸如fs.readFile之类的异步API。 另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。以下就是这么一个例子。 123456789101112131415161718192021function heavyCompute(n) &#123; var count = 0, i, j; for (i = n; i &gt; 0; --i) &#123; for (j = n; j &gt; 0; --j) &#123; count += 1; &#125; &#125;&#125;var t = new Date();setTimeout(function () &#123; console.log(new Date() - t);&#125;, 1000);heavyCompute(50000);-- Console ------------------------------8520 可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。 代码设计模式异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。 函数返回值使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码： 12var output = fn1(fn2(&apos;input&apos;));// Do something. 而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码： 12345fn2(&apos;input&apos;, function (output2) &#123; fn1(output2, function (output1) &#123; // Do something. &#125;);&#125;); 可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出&gt;形状的代码。 遍历数组在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码： 12345678var len = arr.length, i = 0;for (; i &lt; len; ++i) &#123; arr[i] = sync(arr[i]);&#125;// All array items have processed. 如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码： 123456789101112(function next(i, len, callback) &#123; if (i &lt; len) &#123; async(arr[i], function (value) &#123; arr[i] = value; next(i + 1, len, callback); &#125;); &#125; else &#123; callback(); &#125;&#125;(0, arr.length, function () &#123; // All array items have processed.&#125;)); 可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。 如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式： 1234567891011121314(function (i, len, count, callback) &#123; for (; i &lt; len; ++i) &#123; (function (i) &#123; async(arr[i], function (value) &#123; arr[i] = value; if (++count === len) &#123; callback(); &#125; &#125;); &#125;(i)); &#125;&#125;(0, arr.length, 0, function () &#123; // All array items have processed.&#125;)); 可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。 异常处理JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。以下是一个例子。 12345678910111213function sync(fn) &#123; return fn();&#125;try &#123; sync(null); // Do something.&#125; catch (err) &#123; console.log(&apos;Error: %s&apos;, err.message);&#125;-- Console ------------------------------Error: object is not a function 可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个try语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到try语句，就作为一个全局异常抛出。以下是一个例子。 12345678910111213141516171819202122function async(fn, callback) &#123; // Code execution path breaks here. setTimeout(function () &#123; callback(fn()); &#125;, 0);&#125;try &#123; async(null, function (data) &#123; // Do something. &#125;);&#125; catch (err) &#123; console.log(&apos;Error: %s&apos;, err.message);&#125;-- Console ------------------------------/home/user/test.js:4 callback(fn()); ^TypeError: object is not a function at null._onTimeout (/home/user/test.js:4:13) at Timer.listOnTimeout [as ontimeout] (timers.js:110:15) 因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子。 123456789101112131415161718192021function async(fn, callback) &#123; // Code execution path breaks here. setTimeout(function () &#123; try &#123; callback(null, fn()); &#125; catch (err) &#123; callback(err); &#125; &#125;, 0);&#125;async(null, function (err, data) &#123; if (err) &#123; console.log(&apos;Error: %s&apos;, err.message); &#125; else &#123; // Do something. &#125;&#125;);-- Console ------------------------------Error: object is not a function 可以看到，异常再次被捕获住了。在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是err。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。 有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个try语句就能捕获所有冒泡上来的异常，示例如下。 1234567891011121314function main() &#123; // Do something. syncA(); // Do something. syncB(); // Do something. syncC();&#125;try &#123; main();&#125; catch (err) &#123; // Deal with exception.&#125; 但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码。 12345678910111213141516171819202122232425262728293031function main(callback) &#123; // Do something. asyncA(function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something asyncB(function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something asyncC(function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something callback(null); &#125; &#125;); &#125; &#125;); &#125; &#125;);&#125;main(function (err) &#123; if (err) &#123; // Deal with exception. &#125;&#125;); 可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果NodeJS的最大卖点最后变成这个样子，那就没人愿意用NodeJS了，因此接下来会介绍NodeJS提供的一些解决方案。 域（Domain） 官方文档： http://nodejs.org/api/domain.html NodeJS提供了domain模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法，示例代码如下 12345678910process.on(&apos;uncaughtException&apos;, function (err) &#123; console.log(&apos;Error: %s&apos;, err.message);&#125;);setTimeout(function (fn) &#123; fn();&#125;);-- Console ------------------------------Error: undefined is not a function 虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下HTTP服务器代码作为例子： 12345678910111213141516171819202122232425262728293031323334353637function async(request, callback) &#123; // Do something. asyncA(request, function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something asyncB(request, function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something asyncC(request, function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; // Do something callback(null, data); &#125; &#125;); &#125; &#125;); &#125; &#125;);&#125;http.createServer(function (request, response) &#123; async(request, function (err, data) &#123; if (err) &#123; response.writeHead(500); response.end(); &#125; else &#123; response.writeHead(200); response.end(data); &#125; &#125;);&#125;); 以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此async函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用domain模块创建一个子域（JS子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的error事件统一捕获。于是以上代码可以做如下改造： 1234567891011121314151617181920212223242526272829function async(request, callback) &#123; // Do something. asyncA(request, function (data) &#123; // Do something asyncB(request, function (data) &#123; // Do something asyncC(request, function (data) &#123; // Do something callback(data); &#125;); &#125;); &#125;);&#125;http.createServer(function (request, response) &#123; var d = domain.create(); d.on(&apos;error&apos;, function () &#123; response.writeHead(500); response.end(); &#125;); d.run(function () &#123; async(request, function (data) &#123; response.writeHead(200); response.end(data); &#125;); &#125;);&#125;); 可以看到，我们使用.create方法创建了一个子域对象，并通过.run方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。 陷阱无论是通过process对象的uncaughtException事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。 但这里需要澄清一些事实。JS本身的throw..try..catch异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但NodeJS并不是存粹的JS。NodeJS里大量的API内部是用C/C++实现的，因此NodeJS程序的运行过程中，代码执行路径穿梭于JS引擎内部和外部，而JS的异常抛出机制可能会打断正常的代码执行流程，导致C/C++部分的代码表现异常，进而导致内存泄漏等问题。 因此，使用uncaughtException或domain捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用try语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。 小结本章介绍了JS异步编程相关的知识，总结起来有以下几点： 不掌握异步编程就不算学会NodeJS。 异步编程依托于回调来实现，而使用回调不一定就是异步编程。 异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。 使用domain模块简化异步代码的异常处理，并小心陷阱。 大示例学习讲究的是学以致用和融会贯通。至此我们已经分别介绍了NodeJS的很多知识点，本章作为最后一章，将完整地介绍一个使用NodeJS开发Web服务器的示例。 需求我们要开发的是一个简单的静态文件合并服务器，该服务器需要支持类似以下格式的JS或CSS文件合并请求。 1http://assets.example.com/foo/??bar.js,baz.js 在以上URL中，??是一个分隔符，之前是需要合并的多个文件的URL的公共部分，之后是使用,分隔的差异部分。因此服务器处理这个URL时，返回的是以下两个文件按顺序合并后的内容。 12/foo/bar.js/foo/baz.js 另外，服务器也需要能支持类似以下格式的普通的JS或CSS文件请求。 1http://assets.example.com/foo/bar.js 以上就是整个需求。 第一次迭代快速迭代是一种不错的开发方式，因此我们在第一次迭代时先实现服务器的基本功能。 设计简单分析了需求之后，我们大致会得到以下的设计方案。 123 +---------+ +-----------+ +----------+request --&gt;| parse |--&gt;| combine |--&gt;| output |--&gt; response +---------+ +-----------+ +----------+ 也就是说，服务器会首先分析URL，得到请求的文件的路径和类型（MIME）。然后，服务器会读取请求的文件，并按顺序合并文件内容。最后，服务器返回响应，完成对一次请求的处理。 另外，服务器在读取文件时需要有个根目录，并且服务器监听的HTTP端口最好也不要写死在代码里，因此服务器需要是可配置的。 实现根据以上设计，我们写出了第一版代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var fs = require(&apos;fs&apos;), path = require(&apos;path&apos;), http = require(&apos;http&apos;);var MIME = &#123; &apos;.css&apos;: &apos;text/css&apos;, &apos;.js&apos;: &apos;application/javascript&apos;&#125;;function combineFiles(pathnames, callback) &#123; var output = []; (function next(i, len) &#123; if (i &lt; len) &#123; fs.readFile(pathnames[i], function (err, data) &#123; if (err) &#123; callback(err); &#125; else &#123; output.push(data); next(i + 1, len); &#125; &#125;); &#125; else &#123; callback(null, Buffer.concat(output)); &#125; &#125;(0, pathnames.length));&#125;function main(argv) &#123; var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)), root = config.root || &apos;.&apos;, port = config.port || 80; http.createServer(function (request, response) &#123; var urlInfo = parseURL(root, request.url); combineFiles(urlInfo.pathnames, function (err, data) &#123; if (err) &#123; response.writeHead(404); response.end(err.message); &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: urlInfo.mime &#125;); response.end(data); &#125; &#125;); &#125;).listen(port);&#125;function parseURL(root, url) &#123; var base, pathnames, parts; if (url.indexOf(&apos;??&apos;) === -1) &#123; url = url.replace(&apos;/&apos;, &apos;/??&apos;); &#125; parts = url.split(&apos;??&apos;); base = parts[0]; pathnames = parts[1].split(&apos;,&apos;).map(function (value) &#123; return path.join(root, base, value); &#125;); return &#123; mime: MIME[path.extname(pathnames[0])] || &apos;text/plain&apos;, pathnames: pathnames &#125;;&#125;main(process.argv.slice(2)); 以上代码完整实现了服务器所需的功能，并且有以下几点值得注意： 使用命令行参数传递JSON配置文件路径，入口函数负责读取配置并创建服务器。 入口函数完整描述了程序的运行逻辑，其中解析URL和合并文件的具体实现封装在其它两个函数里。 解析URL时先将普通URL转换为了文件合并URL，使得两种URL的处理方式可以一致。 合并文件时使用异步API读取文件，避免服务器因等待磁盘IO而发生阻塞。 我们可以把以上代码保存为server.js，之后就可以通过node server.js config.json命令启动程序，于是我们的第一版静态文件合并服务器就顺利完工了。 另外，以上代码存在一个不那么明显的逻辑缺陷。例如，使用以下URL请求服务器时会有惊喜。 1http://assets.example.com/foo/bar.js,foo/baz.js 经过分析之后我们会发现问题出在/被自动替换/??这个行为上，而这个问题我们可以到第二次迭代时再解决。 第二次迭代在第一次迭代之后，我们已经有了一个可工作的版本，满足了功能需求。接下来我们需要从性能的角度出发，看看代码还有哪些改进余地。 设计把map方法换成for循环或许会更快一些，但第一版代码最大的性能问题存在于从读取文件到输出响应的过程当中。我们以处理/??a.js,b.js,c.js这个请求为例，看看整个处理过程中耗时在哪儿。 12345678 发送请求 等待服务端响应 接收响应---------+----------------------+-------------&gt; -- 解析请求 ------ 读取a.js ------ 读取b.js ------ 读取c.js -- 合并数据 -- 输出响应 可以看到，第一版代码依次把请求的文件读取到内存中之后，再合并数据和输出响应。这会导致以下两个问题： 当请求的文件比较多比较大时，串行读取文件会比较耗时，从而拉长了服务端响应等待时间。 由于每次响应输出的数据都需要先完整地缓存在内存里，当服务器请求并发数较大时，会有较大的内存开销。 对于第一个问题，很容易想到把读取文件的方式从串行改为并行。但是别这样做，因为对于机械磁盘而言，因为只有一个磁头，尝试并行读取文件只会造成磁头频繁抖动，反而降低IO效率。而对于固态硬盘，虽然的确存在多个并行IO通道，但是对于服务器并行处理的多个请求而言，硬盘已经在做并行IO了，对单个请求采用并行IO无异于拆东墙补西墙。因此，正确的做法不是改用并行IO，而是一边读取文件一边输出响应，把响应输出时机提前至读取第一个文件的时刻。这样调整后，整个请求处理过程变成下边这样。 12345678发送请求 等待服务端响应 接收响应---------+----+-------------------------------&gt; -- 解析请求 -- 检查文件是否存在 -- 输出响应头 ------ 读取和输出a.js ------ 读取和输出b.js ------ 读取和输出c.js 按上述方式解决第一个问题后，因为服务器不需要完整地缓存每个请求的输出数据了，第二个问题也迎刃而解。 实现根据以上设计，第二版代码按以下方式调整了部分函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function main(argv) &#123; var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)), root = config.root || &apos;.&apos;, port = config.port || 80; http.createServer(function (request, response) &#123; var urlInfo = parseURL(root, request.url); validateFiles(urlInfo.pathnames, function (err, pathnames) &#123; if (err) &#123; response.writeHead(404); response.end(err.message); &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: urlInfo.mime &#125;); outputFiles(pathnames, response); &#125; &#125;); &#125;).listen(port);&#125;function outputFiles(pathnames, writer) &#123; (function next(i, len) &#123; if (i &lt; len) &#123; var reader = fs.createReadStream(pathnames[i]); reader.pipe(writer, &#123; end: false &#125;); reader.on(&apos;end&apos;, function() &#123; next(i + 1, len); &#125;); &#125; else &#123; writer.end(); &#125; &#125;(0, pathnames.length));&#125;function validateFiles(pathnames, callback) &#123; (function next(i, len) &#123; if (i &lt; len) &#123; fs.stat(pathnames[i], function (err, stats) &#123; if (err) &#123; callback(err); &#125; else if (!stats.isFile()) &#123; callback(new Error()); &#125; else &#123; next(i + 1, len); &#125; &#125;); &#125; else &#123; callback(null, pathnames); &#125; &#125;(0, pathnames.length));&#125; 可以看到，第二版代码在检查了请求的所有文件是否有效之后，立即就输出了响应头，并接着一边按顺序读取文件一边输出响应内容。并且，在读取文件时，第二版代码直接使用了只读数据流来简化代码。 第三次迭代第二次迭代之后，服务器本身的功能和性能已经得到了初步满足。接下来我们需要从稳定性的角度重新审视一下代码，看看还需要做些什么。 设计从工程角度上讲，没有绝对可靠的系统。即使第二次迭代的代码经过反复检查后能确保没有bug，也很难说是否会因为NodeJS本身，或者是操作系统本身，甚至是硬件本身导致我们的服务器程序在某一天挂掉。因此一般生产环境下的服务器程序都配有一个守护进程，在服务挂掉的时候立即重启服务。一般守护进程的代码会远比服务进程的代码简单，从概率上可以保证守护进程更难挂掉。如果再做得严谨一些，甚至守护进程自身可以在自己挂掉时重启自己，从而实现双保险。 因此在本次迭代时，我们先利用NodeJS的进程管理机制，将守护进程作为父进程，将服务器程序作为子进程，并让父进程监控子进程的运行状态，在其异常退出时重启子进程。 实现根据以上设计，我们编写了守护进程需要的代码。 12345678910111213141516171819202122var cp = require(&apos;child_process&apos;);var worker;function spawn(server, config) &#123; worker = cp.spawn(&apos;node&apos;, [ server, config ]); worker.on(&apos;exit&apos;, function (code) &#123; if (code !== 0) &#123; spawn(server, config); &#125; &#125;);&#125;function main(argv) &#123; spawn(&apos;server.js&apos;, argv[0]); process.on(&apos;SIGTERM&apos;, function () &#123; worker.kill(); process.exit(0); &#125;);&#125;main(process.argv.slice(2)); 此外，服务器代码本身的入口函数也要做以下调整。 12345678910111213141516function main(argv) &#123; var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)), root = config.root || &apos;.&apos;, port = config.port || 80, server; server = http.createServer(function (request, response) &#123; ... &#125;).listen(port); process.on(&apos;SIGTERM&apos;, function () &#123; server.close(function () &#123; process.exit(0); &#125;); &#125;);&#125; 我们可以把守护进程的代码保存为daemon.js，之后我们可以通过node daemon.js config.json启动服务，而守护进程会进一步启动和监控服务器进程。此外，为了能够正常终止服务，我们让守护进程在接收到SIGTERM信号时终止服务器进程。而在服务器进程这一端，同样在收到SIGTERM信号时先停掉HTTP服务再正常退出。至此，我们的服务器程序就靠谱很多了。 第四次迭代在我们解决了服务器本身的功能、性能和可靠性的问题后，接着我们需要考虑一下代码部署的问题，以及服务器控制的问题。 设计一般而言，程序在服务器上有一个固定的部署目录，每次程序有更新后，都重新发布到部署目录里。而一旦完成部署后，一般也可以通过固定的服务控制脚本启动和停止服务。因此我们的服务器程序部署目录可以做如下设计。 123456789- deploy/ - bin/ startws.sh killws.sh + conf/ config.json + lib/ daemon.js server.js 在以上目录结构中，我们分类存放了服务控制脚本、配置文件和服务器代码。 实现按以上目录结构分别存放对应的文件之后，接下来我们看看控制脚本怎么写。首先是start.sh。 123456#!/bin/shif [ ! -f &quot;pid&quot; ]then node ../lib/daemon.js ../conf/config.json &amp; echo $! &gt; pidfi 然后是killws.sh。 123456#!/bin/shif [ -f &quot;pid&quot; ]then kill $(tr -d &apos;\r\n&apos; &lt; pid) rm pidfi 于是这样我们就有了一个简单的代码部署目录和服务控制脚本，我们的服务器程序就可以上线工作了。 后续迭代我们的服务器程序正式上线工作后，我们接下来或许会发现还有很多可以改进的点。比如服务器程序在合并JS文件时可以自动在JS文件之间插入一个;来避免一些语法问题，比如服务器程序需要提供日志来统计访问量，比如服务器程序需要能充分利用多核CPU，等等。而此时的你，在学习了这么久NodeJS之后，应该已经知道该怎么做了。 小结本章将之前零散介绍的知识点串了起来，完整地演示了一个使用NodeJS开发程序的例子，至此我们的课程就全部结束了。以下是对新诞生的NodeJSer的一些建议。 要熟悉官方API文档。并不是说要熟悉到能记住每个API的名称和用法，而是要熟悉NodeJS提供了哪些功能，一旦需要时知道查询API文档的哪块地方。 要先设计再实现。在开发一个程序前首先要有一个全局的设计，不一定要很周全，但要足够能写出一些代码。 要实现后再设计。在写了一些代码，有了一些具体的东西后，一定会发现一些之前忽略掉的细节。这时再反过来改进之前的设计，为第二轮迭代做准备。 要充分利用三方包。NodeJS有一个庞大的生态圈，在写代码之前先看看有没有现成的三方包能节省不少时间。 不要迷信三方包。任何事情做过头了就不好了，三方包也是一样。三方包是一个黑盒，每多使用一个三方包，就为程序增加了一份潜在风险。并且三方包很难恰好只提供程序需要的功能，每多使用一个三方包，就让程序更加臃肿一些。因此在决定使用某个三方包之前，最好三思而后行。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约定优于配置（convention over configuration）]]></title>
    <url>%2Fblog%2F2779.html</url>
    <content type="text"><![CDATA[文章来自维基百科 约定优于配置（convention over configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。 本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为”products_sold”，才需写有关这个名字的配置。 如果您所用工具的约定与你的期待相符，便可省去配置；反之，你可以配置来达到你所期待的方式 动机设计不好的框架通常需要多个配置文件，每一个都有许多设置。这些配置文件为每一个项目提供信息说明从URL到将类映射到数据库表的各种信息。大量包含太多参数的配置文件通常是过度复杂的应用设计的指标（代码坏味道）。 例如，在知名的Java对象关系映射框架hibernate的早期版本中，将类及其属性映射到数据库上需要是在XML文件中的描述，其中大部分信息都应能够按照约定得到，如将类映射到同名的数据库表，将属性分别映射到表上的字段。后续的版本抛弃了XML配置文件，而是使用这些恰当的约定，对于不符合这些约定的情形，可以使用Java 标注来说明（参见下面提供的JavaBeans规范）。 使用许多新的框架使用了约定优于配置的方法，包括：spring，Ruby on Rails，Kohana PHP，Grails，Grok，Zend Framework，CakePHP，symfony，Maven，ASP.NET MVC，Web2py（MVC），Apache Wicket。 这是一个古老的概念, 甚至在Java类库中也可以找出这一概念的踪迹。例如，JavaBean规范非常多的依赖这一概念。下面摘录JavaBeans 1.1版规范的一段： 按照一般的规则，我们不希望造出一个奇怪的java.beans.everything类，其他类需要从该类派生。而是希望在运行时JavaBeans为一般的对象提供缺省的行为特征，但是允许对象通过继承特定的java.beans.something接口来覆盖缺省的行为特征的一部分。Maven约定的项目结构如下图： 只需配置很少的信息，Maven就可以自动完成编译、测试和打包等工作。]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet中web.xml配置详解]]></title>
    <url>%2Fblog%2F40270.html</url>
    <content type="text"><![CDATA[Web.xml常用元素 Web.xml常用元素1234567891011121314151617181920212223&lt;web-app&gt;&lt;display-name&gt;&lt;/display-name&gt; 定义了WEB应用的名字&lt;description&gt;&lt;/description&gt; 声明WEB应用的描述信息&lt;context-param&gt;&lt;/context-param&gt;context-param元素声明应用范围内的初始化参数。 &lt;filter&gt;&lt;/filter&gt;过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联。 &lt;filter-mapping&gt;&lt;/filter-mapping&gt; 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联。 &lt;listener&gt;&lt;/listener&gt; servletAPI的版本2.3增加了对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。 Listener元素指出事件监听程序类。 &lt;servlet&gt;&lt;/servlet&gt; 在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。 &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。 但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。在更改缺省URL时，使用servlet-mapping元素。 &lt;session-config&gt;&lt;/session-config&gt; 如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。 可通过使用HttpSession的setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值。 &lt;mime-mapping&gt;&lt;/mime-mapping&gt;如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证。 &lt;welcome-file-list&gt;&lt;/welcome-file-list&gt; 指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件。 &lt;error-page&gt;&lt;/error-page&gt; 在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。 &lt;taglib&gt;&lt;/taglib&gt; 对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置， 而不用编辑使用这些文件的JSP页面。 &lt;resource-env-ref&gt;&lt;/resource-env-ref&gt;声明与资源相关的一个管理对象。 &lt;resource-ref&gt;&lt;/resource-ref&gt; 声明一个资源工厂使用的外部资源。 &lt;security-constraint&gt;&lt;/security-constraint&gt; 制定应该保护的URL。它与login-config元素联合使用 &lt;login-config&gt;&lt;/login-config&gt; 指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用。 &lt;security-role&gt;&lt;/security-role&gt;给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易。&lt;env-entry&gt;&lt;/env-entry&gt;声明Web应用的环境项。 &lt;ejb-ref&gt;&lt;/ejb-ref&gt;声明一个EJB的主目录的引用。 &lt; ejb-local-ref&gt;&lt;/ ejb-local-ref&gt;声明一个EJB的本地主目录的应用。 &lt;/web-app&gt; 相应元素配置 Web应用图标：指出IDE和GUI工具用来表示Web应用的大图标和小图标 1234&lt;icon&gt; &lt;small-icon&gt;/images/app_small.gif&lt;/small-icon&gt; &lt;large-icon&gt;/images/app_large.gif&lt;/large-icon&gt; &lt;/icon&gt; Web 应用名称：提供GUI工具可能会用来标记这个特定的Web应用的一个名称 1&lt;display-name&gt;Tomcat Example&lt;/display-name&gt; Web 应用描述： 给出于此相关的说明性文本 1&lt;disciption&gt;Tomcat Example servlets and JSP pages.&lt;/disciption&gt; 上下文参数：声明应用范围内的初始化参数。 12345&lt;context-param&gt; &lt;param-name&gt;ContextParameter&lt;/para-name&gt; &lt;param-value&gt;test&lt;/param-value&gt; &lt;description&gt;It is a test parameter.&lt;/description&gt; &lt;/context-param&gt; 在servlet里面可以通过getServletContext().getInitParameter(“context/param”)得到 过滤器配置：将一个名字与一个实现javaxs.servlet.Filter接口的类相关联。 123456789101112&lt;filter&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;com.myTest.setCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;GB2312&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 监听器配置 123&lt;listener&gt; &lt;listerner-class&gt;listener.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; Servlet配置 基本配置 12345678&lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;SnoopServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 高级配置 12345678910111213141516&lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;SnoopServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;foo&lt;/param-name&gt; &lt;param-value&gt;bar&lt;/param-value&gt; &lt;/init-param&gt; &lt;run-as&gt; &lt;description&gt;Security role for anonymous access&lt;/description&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/run-as&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 元素说明123456789 &lt;servlet&gt;&lt;/servlet&gt; 用来声明一个servlet的数据，主要有以下子元素： &lt;servlet-name&gt;&lt;/servlet-name&gt; 指定servlet的名称 &lt;servlet-class&gt;&lt;/servlet-class&gt; 指定servlet的类名称 &lt;jsp-file&gt;&lt;/jsp-file&gt; 指定web站台中的某个JSP网页的完整路径 &lt;init-param&gt;&lt;/init-param&gt; 用来定义参数，可有多个init-param。在servlet类中通过getInitParamenter(String name)方法访问初始化参数 &lt;load-on-startup&gt;&lt;/load-on-startup&gt;指定当Web应用启动时，装载Servlet的次序。当值为正数或零时：Servlet容器先加载数值小的servlet，再依次加载其他数值大的servlet.当值为负或未定义：Servlet容器将在Web客户首次访问这个servlet时加载它 &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 用来定义servlet所对应的URL，包含两个子元素 &lt;servlet-name&gt;&lt;/servlet-name&gt; 指定servlet的名称 &lt;url-pattern&gt;&lt;/url-pattern&gt; 指定servlet所对应的URL 会话超时配置（单位为分钟） 123&lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt; &lt;/session-config&gt; MIME类型配置 1234&lt;mime-mapping&gt; &lt;extension&gt;htm&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; 指定欢迎文件页配置 12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 配置错误页面 通过错误码来配置error-page1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/NotFound.jsp&lt;/location&gt; &lt;/error-page&gt; 上面配置了当系统发生404错误时，跳转到错误处理页面NotFound.jsp。 通过异常的类型配置error-page1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; 上面配置了当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面error.jsp TLD配置 1234&lt;taglib&gt; &lt;taglib-uri&gt;http://jakarta.apache.org/tomcat/debug-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/jsp/debug-taglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; 如果MyEclipse一直在报错,应该把 放到 中 123456&lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://jakarta.apache.org/tomcat/debug-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/pager-taglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt; 资源管理对象配置 123&lt;resource-env-ref&gt; &lt;resource-env-ref-name&gt;jms/StockQueue&lt;/resource-env-ref-name&gt; &lt;/resource-env-ref&gt; 资源工厂配置 12345&lt;resource-ref&gt; &lt;res-ref-name&gt;mail/Session&lt;/res-ref-name&gt; &lt;res-type&gt;javax.mail.Session&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 配置数据库连接池就可在此配置： 123456&lt;resource-ref&gt; &lt;description&gt;JNDI JDBC DataSource of shop&lt;/description&gt; &lt;res-ref-name&gt;jdbc/sample_db&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 安全限制配置 123456789101112131415&lt;security-constraint&gt; &lt;display-name&gt;Example Security Constraint&lt;/display-name&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Protected Area&lt;/web-resource-name&gt; &lt;url-pattern&gt;/jsp/security/protected/*&lt;/url-pattern&gt; &lt;http-method&gt;DELETE&lt;/http-method&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;http-method&gt;PUT&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;role-name&gt;role1&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; 登陆验证配置 12345678&lt;login-config&gt; &lt;auth-method&gt;FORM&lt;/auth-method&gt; &lt;realm-name&gt;Example-Based Authentiation Area&lt;/realm-name&gt; &lt;form-login-config&gt; &lt;form-login-page&gt;/jsp/security/protected/login.jsp&lt;/form-login-page&gt; &lt;form-error-page&gt;/jsp/security/protected/error.jsp&lt;/form-error-page&gt; &lt;/form-login-config&gt; &lt;/login-config&gt; 安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易。 123&lt;security-role&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/security-role&gt; 123456718. Web环境参数：env-entry元素声明Web应用的环境项 ​```XML&lt;env-entry&gt; &lt;env-entry-name&gt;minExemptions&lt;/env-entry-name&gt; &lt;env-entry-value&gt;1&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt; &lt;/env-entry&gt; EJB 声明 1234567&lt;ejb-ref&gt; &lt;description&gt;Example EJB reference&lt;/decription&gt; &lt;ejb-ref-name&gt;ejb/Account&lt;/ejb-ref-name&gt; &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt; &lt;home&gt;com.mycompany.mypackage.AccountHome&lt;/home&gt; &lt;remote&gt;com.mycompany.mypackage.Account&lt;/remote&gt; &lt;/ejb-ref&gt; 本地EJB声明 1234567&lt;ejb-local-ref&gt; &lt;description&gt;Example Loacal EJB reference&lt;/decription&gt; &lt;ejb-ref-name&gt;ejb/ProcessOrder&lt;/ejb-ref-name&gt; &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt; &lt;local-home&gt;com.mycompany.mypackage.ProcessOrderHome&lt;/local-home&gt; &lt;local&gt;com.mycompany.mypackage.ProcessOrder&lt;/local&gt; &lt;/ejb-local-ref&gt; 配置DWR 12345678&lt;servlet&gt; &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;servlet-class&gt;uk.ltd.getahead.dwr.DWRServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;url-pattern&gt;/dwr/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置Struts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;display-name&gt;Struts Blank Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt; org.apache.struts.action.ActionServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;detail&lt;/param-name&gt; &lt;param-value&gt;2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;application&lt;/param-name&gt; &lt;param-value&gt;ApplicationResources&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- Struts Tag Library Descriptors --&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-bean&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-bean.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-html&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-html.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-nested&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-nested.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-logic&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-logic.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;struts-tiles&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tld/struts-tiles.tld&lt;/taglib-location&gt; &lt;/taglib&gt; 配置Spring（基本上都是在Struts中配置的） 123456789101112131415161718 &lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!--加载多个spring配置文件 --&gt; /WEB-INF/applicationContext.xml, /WEB-INF/action-servlet.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 定义SPRING监听器，加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt; &lt;/listener&gt; -end-]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 常用命令]]></title>
    <url>%2Fblog%2F32362.html</url>
    <content type="text"><![CDATA[hexo 常用的命令 npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的 hexo generate –deploy hexo deploy –generate hexo deploy -g hexo server -g 草稿 hexo publish [layout] &lt;title&gt; 模版 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 ​ title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold） hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要 以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作 hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上 hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g 报错 1.找不到git部署 ​ ERROR Deployer not found: git ​ 解决方法 npm install hexo-deployer-git --save 3.部署类型设置git hexo 3.0 部署类型不再是github，_config.yml 中修改 ​ # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master xcodebuild xcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance npm install bcrypt RSS不显示 安装RSS插件 npm install hexo-generator-feed --save 开启RSS功能 编辑hexo/_config.yml，添加如下代码： ​ rss: /atom.xml #rss地址 默认即可 开启评论 1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 复制到 themes\landscape\layout_partial\article.ejs把 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; ​ 改为 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt; ####hexo命令 更新hexo：npm update -g hexo 更新主题：cd 到主题文件夹，执行命令：git pull 更新插件：npm update]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题集成gitment评论系统]]></title>
    <url>%2Fblog%2F47815.html</url>
    <content type="text"><![CDATA[简介本文介绍hexo next主题(5.1.2)集成giment评论系统的过程。所谓gitment就是把评论放到github的issues系统里，评论支持md，比较适合程序员. 一.注册OAuth Application点击https://github.com/settings/applications/new注册，注意Authorization callback URL填自己的网站urlhttp://yangq.me/.记下Client ID和Client Secret. 二.修改themes/next/_config.yml在config.yml中添加:123456789# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true githubID: yourid repo: yourrepo ClientID: yourid ClientSecret: yoursecret lazy: true 注意:格式要正确，该空格的一定要空格。所有的yourXXX都换成自己的. 在主题的en.yml增加:1gitmentbutton: Show comments from Gitment zh-Hans.yml增加:1gitmentbutton: 显示 Gitment 评论 三.修改主题layout/_partials/comments.swig找到这个文件里的这两行: 12&#123;% elseif theme.valine.appidand theme.valine.appkey %&#125; "vcomments"&gt; 上面是最后一个elseif分支，在下面加一个elseif分支: 1234567&#123;% elseif theme.gitment.enable %&#125; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick="ShowGitment()" id="gitment-display-button"&gt;&#123;&#123; __('gitmentbutton') &#125;&#125;&lt;/div&gt; &lt;div id="gitment-container" style="display:none"&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id="gitment-container"&gt;&lt;/div&gt; &#123;% endif %&#125; 加完之后下面的内容是原来的，保持不变: 123&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 四.增加gitment.swig在主题下layout/_third-party/comments/目录下中添加文件gitment.swig：12345678910111213141516171819202122232425262728293031323334353637&#123;% if theme.gitment.enable %&#125; &#123;% set owner = theme.gitment.githubID %&#125; &#123;% set repo = theme.gitment.repo %&#125; &#123;% set cid = theme.gitment.ClientID %&#125; &#123;% set cs = theme.gitment.ClientSecret %&#125; &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; &#123;% if not theme.gitment.lazy %&#125; &lt;script type="text/javascript"&gt; var gitment = new Gitment(&#123; id: window.location.pathname, owner: '&#123;&#123;owner&#125;&#125;', repo: '&#123;&#123;repo&#125;&#125;', oauth: &#123; client_id: '&#123;&#123;cid&#125;&#125;', client_secret: '&#123;&#123;cs&#125;&#125;', &#125;&#125;); gitment.render('gitment-container'); &lt;/script&gt; &#123;% else %&#125; &lt;script type="text/javascript"&gt; function ShowGitment()&#123; document.getElementById("gitment-display-button").style.display = "none"; document.getElementById("gitment-container").style.display = "block"; var gitment = new Gitment(&#123; id: document.location.href, owner: '&#123;&#123;owner&#125;&#125;', repo: '&#123;&#123;repo&#125;&#125;', oauth: &#123; client_id: '&#123;&#123;cid&#125;&#125;', client_secret: '&#123;&#123;cs&#125;&#125;', &#125;&#125;); gitment.render('gitment-container'); &#125; &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 在主题下layout/_third-party/comments/index.swig文件中引入gitment.swig文件：1&#123;% include'gitment.swig' %&#125; 五.添加gitment.styl在主题下source/css/_common/components/third-party/目录下添加gitment.styl文件，设置button的样式： 12345678910111213#gitment-display-button&#123; display: inline-block; padding: 0 15px; color: #0a9caf; cursor: pointer; font-size: 14px; border: 1px solid #0a9caf; border-radius: 4px; &#125; #gitment-display-button:hover&#123; color: #fff; background: #0a9caf; &#125; 然后在主题下source/css/_common/components/third-party/third-party.styl文件中引入相应的CSS样式即可: 1@import"gitment"; 这样就ok了！ 易错点修改themes/next/_config.yml这个文件时，格式要正确。另外，repo是你要想创建issues的仓库，完全可以跟博文所放的仓库不一个。id就写自己的github用户名就可以，这个用户名跟repo必须匹配。gitment可能不支持链接地址里有中文，所以安装gitment前一定要参考前文把链接持久化搞成全是英文的。同一篇文章需要初始化comment两次的问题，是因为http://xxx.com/post/ab9bb85a.html和点击阅读全文进去的链接http://xxx.com/post/ab9bb85a.html#more对issues来说是不同的，所以创建两次。解决方法就是gitment.swig里id弄成window.location.pathname而不是document.location.href。初始化评论后，可以到github里自己放issues的仓库查看issues是否创建成功，有时候浏览器可能会有缓存依然提示你初始化评论。一般过个两分钟就显示正常了。参考文档 主要参考文档 一种相对简略的配置方式 作者issue]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery使用技巧]]></title>
    <url>%2Fblog%2F12197.html</url>
    <content type="text"><![CDATA[禁用页面的右键菜单12345$(document).ready(function()&#123; $(document).bind("contextmenu",function(e)&#123; return false; &#125;); &#125;); 新窗口打开页面123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="https://www.google.com"&gt;google_新窗口&lt;/a&gt; &lt;a href="https://www.google.com" rel="external"&gt;google_新窗口&lt;/a&gt; &lt;a href="demo1.html"&gt;当前窗口&lt;/a&gt;&lt;script&gt; $(function()&#123; $('a[href^="http://"]').attr("target","_blank"); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 输入框文字获取和失去焦点【推荐】 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" class="text1" /&gt;&lt;script&gt;$(document).ready(function() &#123; $("input.text1").val("Enter your search text here."); textFill( $('input.text1') ); &#125;);function textFill(input)&#123; //input focus text function var originalvalue = input.val(); input.focus( function()&#123; if( $.trim(input.val()) == originalvalue )&#123; input.val(''); &#125; &#125;).blur( function()&#123; if( $.trim(input.val()) == '' )&#123; input.val(originalvalue); &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 返回头部滑动动画123456789101112&lt;script&gt;jQuery.fn.scrollTo = function(speed) &#123; var targetOffset = $(this).offset().top; $('html,body').stop().animate(&#123;scrollTop: targetOffset&#125;, speed); return this;&#125;; // use$("#goheader").click(function()&#123; $("body").scrollTo(500); return false;&#125;); &lt;/script&gt; 获取鼠标位置123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="XY" &gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(document).mousemove(function(e)&#123; $('#XY').html("X : " + e.pageX + " | Y : " + e.pageY); &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 关闭所有 jQuery 动画效果1jQuery.fx.off = true; 检测鼠标的右键和左键123$('#box').mousedown(function(e) &#123; alert(e.which);&#125;); 回车提交表单1234567$(function() &#123; $('input').keyup(function(e) &#123; if(e.which == '13') &#123; alert('回车提交'); &#125; &#125;);&#125;); 切换复选框12345var tog = false;$('button').click(function() &#123; $("input[type=checkbox]").attr("checked",!tog); tog = !tog;&#125;); 使用 siblings() 来选择同辈元素123456789//不这样做$('#nav li').click(function()&#123; $('#nav li').removeClass('active'); $(this).addClass('active');&#125;);//替代做法是$('#nav li').click(function() &#123; $(this).addClass('active').siblings().removeClass('active');&#125;); 为任何与选择器相匹配的元素绑定事件123$("table").on("click","td",function()&#123; $(this).toggleClass("hover"); &#125;); $.proxy 的使用使用回调方法的缺点之一是当执行类库中的方法后，上下文对象被设置到另外一个元素，比如，执行下面代码：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #panel &#123; width: 300px; height: 300px; background-color: #ccc; &#125; &lt;/style&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel" style="display:none"&gt; &lt;button&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('#panel').fadeIn(function()&#123; $('#panel button').click(function()&#123; $(this).fadeOut(); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 你将遇到问题，button 元素会消失，而不是 panel 元素。可以使用 $.proxy 方法解决这个问题，代码如下：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #panel &#123; width: 300px; height: 300px; background-color: #ccc; &#125; &lt;/style&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel" style="display:none"&gt; &lt;button&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('#panel').fadeIn(function()&#123; $('#panel button').click($.proxy(function()&#123; $(this).fadeOut(); &#125;,this)); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样才正确执行。 限制 Text-Area 域中的字符的个数12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id="mytextarea"&gt;&lt;/textarea&gt; &lt;script&gt; jQuery.fn.maxLength = function(max)&#123; this.each(function()&#123; var type = this.tagName.toLowerCase(); var inputType = this.type? this.type.toLowerCase() : null; if(type == "input" &amp;&amp; inputType == "text" || inputType == "password")&#123; //应用标准的maxLength this.maxLength = max; &#125;else if(type == "textarea")&#123; this.onkeypress = function(e)&#123; var ob = e || event; var keyCode = ob.keyCode; var hasSelection = document.selection? document.selection.createRange().text.length &gt; 0 : this.selectionStart != this.selectionEnd; return !(this.value.length &gt;= max &amp;&amp; (keyCode &gt; 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection); &#125;; this.onkeyup = function()&#123; if(this.value.length &gt; max)&#123; this.value = this.value.substring(0,max); &#125; &#125;; &#125; &#125;); &#125;; //use $('#mytextarea').maxLength(10); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解析 json 数据时报 parseError 错误jQuery 在 1.4 版本后，采用了更为严格的 json 解析方式，即所有内容都必须要有双引号，如果升级 jQuery 版本后，ajax 加载 json 报错，有可能就是这个原因。比如：12345// 1.4之前版本，key没引号，这样没问题&#123; key:"coco", status:"0"&#125; 但升级成jQuery1.4后，都必须加上双引号，格式如下：1234&#123; "key":"coco", "status":"0"&#125; 从元素中除去 HTML12345678910111213&lt;script&gt;(function($) &#123; $.fn.stripHtml = function() &#123; var regexp = /&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/gi; this.each(function() &#123; $(this).html( $(this).html().replace(regexp,'') ); &#125;); return $(this); &#125; &#125;)(jQuery); //用法： $('div').stripHtml(); &lt;/script&gt; 扩展 String 对象的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;input type="text" /&gt;&lt;button &gt;check&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $.extend(String.prototype, &#123; isPositiveInteger:function()&#123; return (new RegExp(/^[1-9]\d*$/).test(this)); &#125;, isInteger:function()&#123; return (new RegExp(/^\d+$/).test(this)); &#125;, isNumber: function(value, element) &#123; return (new RegExp(/^-?(?:\d+|\d&#123;1,3&#125;(?:,\d&#123;3&#125;)+)(?:\.\d+)?$/).test(this)); &#125;, trim:function()&#123; return this.replace(/(^\s*)|(\s*$)|\r|\n/g, ""); &#125;, trans:function() &#123; return this.replace(/&amp;lt;/g, '&lt;').replace(/&amp;gt;/g,'&gt;').replace(/&amp;quot;/g, '"'); &#125;, replaceAll:function(os, ns) &#123; return this.replace(new RegExp(os,"gm"),ns); &#125;, skipChar:function(ch) &#123; if (!this || this.length===0) &#123;return '';&#125; if (this.charAt(0)===ch) &#123;return this.substring(1).skipChar(ch);&#125; return this; &#125;, isValidPwd:function() &#123; return (new RegExp(/^([_]|[a-zA-Z0-9])&#123;6,32&#125;$/).test(this)); &#125;, isValidMail:function()&#123; return(new RegExp(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/).test(this.trim())); &#125;, isSpaces:function() &#123; for(var i=0; i&lt;this.length; i+=1) &#123; var ch = this.charAt(i); if (ch!=' '&amp;&amp; ch!="\n" &amp;&amp; ch!="\t" &amp;&amp; ch!="\r") &#123;return false;&#125; &#125; return true; &#125;, isPhone:function() &#123; return (new RegExp(/(^([0-9]&#123;3,4&#125;[-])?\d&#123;3,8&#125;(-\d&#123;1,6&#125;)?$)|(^\([0-9]&#123;3,4&#125;\)\d&#123;3,8&#125;(\(\d&#123;1,6&#125;\))?$)|(^\d&#123;3,8&#125;$)/).test(this)); &#125;, isUrl:function()&#123; return (new RegExp(/^[a-zA-z]+:\/\/([a-zA-Z0-9\-\.]+)([-\w .\/?%&amp;=:]*)$/).test(this)); &#125;, isExternalUrl:function()&#123; return this.isUrl() &amp;&amp; this.indexOf("://"+document.domain) == -1; &#125; &#125;); $("button").click(function()&#123; alert( $("input").val().isInteger() ); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习总结]]></title>
    <url>%2Fblog%2F43183.html</url>
    <content type="text"><![CDATA[git 简介git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。在 git 中，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。 实用指令详解merge通常，合并分支时，如果可能，Git 会用 Fast froward 模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。git merge --no-ff -m &#39;merge with no-ff&#39; dev因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。 合并分支时，加上 --no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。 fetch一旦远程主机的版本库有了更新(git 术语叫做 commit)，需要将这些更新取回本地，这时就要用到 git fetch 命令。git fetch &lt;远程主机名&gt;上面命令将某个远程主机的更新，全部取回本地。默认情况下，git fetch 取回所有分支(branch)的更新。如果只想取回特定分支的更新，可以指定分支名。git fetch &lt;远程主机名&gt; &lt;分支名&gt;比如，取回 origin 主机的 master 分支git fetch origin master所取回的更新，在本地主机上要用“远程主机名/分支名”的形式读取。比如 origin 主机的 master，就要用 origin/master 读取。 git fetch -p ：取回远程更新，删除不存在的分支。 pullgit pull 命令的作用是，取回远程主机的某个分支的更新，再与本地的指定分支合并，完整格式如下：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。git pull origin next:master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin master上面的命令表示，取回 origin/master 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再 merge。12git fetch origingit merge origin/master 在某些场合，git 会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在 git clone 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 master 分支自动“追踪” origin/master 分支。git 也允许手动建立追踪关系。git branch --set-upstream master origin/next上面的命令指定 master 分支追踪 origin/next 分支。如果当前分支与远程分支存在追踪关系，git pull 就可以省略远程分支名。git pull origin上面命令表示，本地的当前分支自动与对应的 origin 主机“追踪分支”(remote-tracking branch)进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以忽略。git pull上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用 rebase 模式，可以使用 -rebase 选项。git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; pushgit push 命令用于将本地分支的更新，推送到远程主机。它的格式与 git pull 命令相仿。git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;如果省略远程分支名，则表示将本地分支推送与之存在“追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。git push origin master上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。git push origin :master等同于git push origin --delete master上面命令表示删除 origin 主机的 master 分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。git push origin上面命令表示，将当前分支推送到 origin 主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。git push如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 。git push -u origin master上面的命令将本地 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。不带任何参数的 git push ，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。git 2.0 版本之前，默认采用 matching 方式，现在改为默认采用 simple 方式，如果要修改这个设置，可以采用 git config 命令。git config --global push.default matching或者git config --global push.default simple还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 -all 选项。git push --all origin上面命令表示，将所有本地分支都推送到 origin 主机。如果远程主机的版本比本地版本更新，推送时 git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 -force 选项。git push --force origin上面命令使用-force选项，结果导致在远程主机产生一个“非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用 -force 选项。最后，git push 不会推送标签(tag)，除非使用 -tags 选项。git push origin --tags loggit log 命令可以查看历史记录，git log 命令显示从最近到最远的提交日志；如果嫌输出信息太多，看得眼花缭乱的，可以试试 git log --pretty=oneline 。我们可以看到当前版本以及之前的版本日志以及版本号。用 git log --graph 命令可以看到分支合并图。或者两个参数一起用：git log --graph --pretty=onelinegit log --graph --pretty=oneline --abbrev-commit首先，git 必须知道当前版本是哪个版本，在 git 中，用 HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ， 当然往上100个版本写100个 ^ 比较容易数不过来，所以写成 HEAD~100 。现在，我们要把当前版本回退到上一个版本，就可以使用 git reset 命令：git reset --hard HEAD^当你回退到了某个版本后，git log 只能显示此版本及之前的版本的日志，之后的版本日志就看不到了，但是，我们想恢复到之后教新的版本怎么办？Git 提供了一个命令 git reflog 用来记录你的每一次命令 tag查看标签（用来标记标志性的稳定版本信息）发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。相比于 commit 的版本号(40位16进制)，标签号则要好使的多。所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑定在一起。 git tag [tag name]如果没有标签名，则为查看所有标签，带标签名则为新建标签 git tag &lt;tag name&gt; 就可以打一个新标签 还可以创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字。git tag -a &lt;tag name&gt; -m &lt;comment&gt; ：添加带注释的标签eg: git tag -a v1.2 -m &#39;version 1.2 released&#39; git tag -a &lt;tag name&gt; &lt;md5&gt; ：对某个版本打标签默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的 commit id，然后打上就可以了。git log --pretty=oneline --abbrev-commit比方说要对 add merge 这次提交打标签，它对应的 commit id 是 6224937，那么我们就可以使用命令：git tag v1.2 6224937再用命令 git log 查看标签 可以用 git show &lt;tagname&gt; 查看标签信息 如果标签打错了，也可以删除：git tag -d v1.2 如果要推送某个标签到远程，使用命令 git push origin &lt;tagname&gt;eg: git push origin v1.2 如果标签已经推送到远程，要删除远程标签就要麻烦一点，先从本地删除：git tag -d v1.2然后，从远程删除；删除命令也是 push ，但是格式如下：git push origin :ref/tags/v1.2 git tag -l &#39;[expression]&#39;查看那符合正则表达式的 stashgit stash备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。git stash pop从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。git stash list显示 Git 栈中内的所有备份，可以利用这个列表来决定从哪个地方恢复。git stash clear : 清空 Git 栈。 使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码，如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 bug，那么使用 git stash 就可以将你当前未提交到本地的代码推入到 git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 bug，等到修完 bug，提交到服务器上后，再使用 git stash apply 将以前一般的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑， git stash list 命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用 git stash apply stash@{1} 就可以将你指定版本号为 stash@{1} 的工作取出来，当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。在这里顺便提下 git format-patch -n , n是具体某个数字， 例如 ‘git format-patch -1’ 这时便会根据log生成一个对应的补丁，如果 ‘git format-patch -2’ 那么便会生成 2 个补丁，当然前提是你的 log 上有至少有两个记录。 看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时 Boss 来了，说前面的分支上面有一个 bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法 checkout 到前面的分支。此时用 git stash 就相当于备份了工作区了。然后在 checkout 过去修改，就能够达到保存当前工作区，并及时恢复的作用。 注意这里由于只 stash 了一次所以要使用 pop，具体你存放了多少。 remote查看远程仓库名 git remote -v查看远程仓库url git remote add &lt;basename&gt; &lt;url&gt;新增远程仓库 git remote show &lt;basename&gt;查看远程仓库详细信息 git remote rename &lt;old basename&gt; &lt;new basename&gt;重命名远程仓库 commitgit commit -a -m &#39;xx&#39;暂存并提交 branchgit branch查看本地仓库分支 git branch -r查看远程分支情况 git branch -a查看本地和远程的所有分支情况 git branch -v查看本地仓库分支最后一次提交情况 git branch -vv查看分支跟踪情况 git branch &lt;branch name&gt;新建分支 git branch -d &lt;branch name&gt;删除分支 git branch -D &lt;branch name&gt;强制删除分支 git branch [--merged | --no-merged]查看已合并|未合并的本地仓库分支 git branch -u &lt;remote base&gt;/&lt;remote branch&gt;修改当前跟踪分支 checkoutgit checkout -- [file] ：恢复文件git checkout -- demo.html 意思就是，把 demo.html 文件在工作区的修改全部撤销，这里有两种情况：一种是 demo.html 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是 demo.html 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。总之，就是让这个文件回到最后一次 git commit 或 git add 时的状态。 但是如果 git add 到暂存区了，在 commit 之前，想撤销：Git 同样告诉我们，用命令 git reset HEAD file 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区，当我们用 HEAD 时，表示最新的版本。再用 git status 查看一下，现在暂存区是干净的，工作区有修改：还记得如果丢弃工作区的修改吗？对的，使用：git checkout -- demo.html git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。 git checkout -b [branchname] [tagname]在特定的版本上创建一个新的分支并切换到此分支 git checkout -b [local branch] [remote base]/[remote branch]将远程分支检出到本地分支，并追踪 git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;让当前分支跟踪远程分支 rebasegit rebase [basebranch]变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 常见问题git clonegit clone 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。使用 https 除了速度慢意外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。 git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;如果不写本地目录名，默认就是版本库的名字 如何新建分支本地建立 branch 並立即切换到新分支git checkout -b &lt;branch_name&gt; 下面的命令表示，在 origin/master 的基础上，创建一个分支。git checkout -b newBranch origin/master 修改分支名称git branch -m &lt;new_name&gt; 从远程仓库拉取代码到本地仓库，并建立跟踪关系git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt; 如何在远程仓库新建一个分支新建一个本地分支，按照正常流程提交完代码后，推送到远程git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt; 比较文件git diff HEAD -- demo.html命令可以查看工作区的 demo.html 和版本库里面最新版本的区别。 忽略某些文件默认方法是在当前项目目录下创建一个 .gitignore 文件，如果需要忽略的文件已经添加到版本库中，请先移除git rm --cached [file]不删除文件，只移除追踪。123cat .gitignore*.[oa]*~ 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 # 开头的目录都会被 git 忽略 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠（/）说明要忽略的目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 bug 分支git 提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。git stash修改完 bug 后，回到当前分支上继续干活，工作区是干净的，刚才的工作现场存到哪里去了？git stash list ：查看 stash 列表(stash 是一个栈的结构)git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法：一是用 git stash apply 恢复，但是恢复后，stash 内容并不删除，你需要用 git stash drop 来删除；另一种方式是用 git stash pop ，恢复的同时把 stash 内容也删了；你可以多次 stash ，恢复的时候，先用 git stash list 查看，然后恢复指定的 stash，用命令：git stash apply stash@{0} 配置文件配置 Git 的时候，加上 –global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的 Git 配置文件都放在 .git/config 文件中，在这份配置文件中，别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。 查看配置git config -1 设置git push 默认git config --global push.default current 设置别名git config --global alias.&lt;name&gt; &lt;commend&gt;我的设置：git config --global alias.st statusgit config --global alias.cm &quot;commit -m&quot;git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot; 保存用户名和密码对于http(s)协议，可以用下面命令临时缓存git config --global credential.helper cache开启linux缓存git config --global credential.helper wincred开启windows缓存 对于 ssh 协议，可以用 ssh key，具体教程网上很多解决问题问题一git 中执行命令 add .报错：Unlink of file ‘templates/opms.exe’ failed.Should I try again?(y/n) 因为这个文件正在被占用，所以不能添加到暂存区，而正好这个 .exe 文件，我们是不需要添加到版本管理工具的。所以我们选择 n 。 问题二git 中生成 sshkey: ssh-keygen -t rsa -C &quot;youremail&quot;这个email并没有什么用所以我们使用ssh-keygen -t rsa来生成sshkey就可以了。然后git中的配置文件：git config --listgit config --global user.name &quot;yu&quot;git config --global user.email &quot;react.dong.yu@gmail.com&quot;这种配置将会对本地所有的git仓库有效。那么在 push 的时候，远程就知道这个push来自于哪个email.但有时候在公司的时候，有的仓库是公司的，有的仓库是自己github的。这个时候就可以不设置global的配置了，而是在自己的仓库中设置git config --local user.email &quot;react.dong.yu@gmail.com&quot; 问题三使用 windows 的同学注意了，如果你在资源管理器里新建一个 .gitignore 文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 .gitignore 了。有些时候，你想添加一个文件到 git，但发现添加不了，原因是这个文件被 .gitignore 忽略了：git add App.class如果你确实想添加该文件，可以用 -f 制添加到 git：git add -f App.class或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了。可以用 git check-ignore 命令检查：git check-ignore -v App.class 问题四为什么我把我生成的 ssh key 添加到了 github 中然后 也 remote 了 https://github.com/Neveryu/Xxx.git为什么提交的时候报错，或者提示 输入密码账号是为什么 ssh key 是 ssh 协议的密钥，http 协议没权限 问题五git怎样删除未监视的文件 untracked files?用 git clean12345678910111213# 删除 untracked filesgit clean -f # 连 untracked 的目录也一起删掉git clean -fd # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）git clean -xfd # 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删git clean -nxfdgit clean -nfgit clean -nfd 我的常用命令12git branch -avvgit remote -v 权威教程Pro Git 简体中文版]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（五）]]></title>
    <url>%2Fblog%2F64470.html</url>
    <content type="text"><![CDATA[在这之前，我写过四篇关于 Hexo + NexT 构建博客的文章。=》【传送门】 本文将会介绍一些自定义的功能。相较于之前主要是修改配置文件中的内容，现在更多的是动手改源码来实现功能，而且还能帮你搞懂一些 Hexo NexT 的源码。如果你能弄懂源码的一些流程和逻辑，那么，你将能更好的来实现自己的一些想法。 文章封面文章封面的意思就是：在博客首页的时候会显示文章的封面图片，进入这篇文章的详细页面后，将不显示这张图片。 如果想添加文章封面的话，需要添加一个字段属性：summary_img，summary_img 的值是图片的路径。 例如：12345678---title: CSS 各种Hack手段date: 2017-06-25 03:25:24categories: 前端tags: [CSS]comments: falsesummary_img: /images/css-hack-1.png--- 具体实现细节如下：修改 \themes\next\layout\_macro\post.swing 文件。将代码：12345&#123;% if post.summary_img %&#125; &lt;div class=&quot;out-img-topic&quot;&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class=&quot;img-topic&quot;&gt; &lt;/div&gt;&#123;% endif %&#125; 添加到下图所示的位置 这样的话，就可以使用 summary_img: imageurl 来设置文章封面了。 开启了文章封面的文章，我建议将 &lt;!-- more --&gt; 放在文章内容的开头，像这样： 网页加载进度条打开 /themes/next/layout/_partials/head.swing 文件，在文件末尾添加如下代码：12&lt;!-- 网页加载条 --&gt;&lt;script src=&quot;https://neveryu.github.io/js/src/pace.min.js&quot;&gt;&lt;/script&gt; 然后，打开 /themes/source/css/_custom/custom.styl 文件，在文件末尾添加如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*网页加载条*//* This is a compiled file, you should be editing the file in the templates directory */.pace &#123; -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none;&#125;.pace-inactive &#123; display: none;&#125;.pace .pace-progress &#123; background: #1e92fb; position: fixed; z-index: 2000; top: 0; right: 100%; width: 100%; height: 3px;&#125;.pace .pace-progress-inner &#123; display: block; position: absolute; right: 0px; width: 100px; height: 100%; box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92; opacity: 1.0; -webkit-transform: rotate(3deg) translate(0px, -4px); -moz-transform: rotate(3deg) translate(0px, -4px); -ms-transform: rotate(3deg) translate(0px, -4px); -o-transform: rotate(3deg) translate(0px, -4px); transform: rotate(3deg) translate(0px, -4px);&#125;.pace .pace-activity &#123; display: block; position: fixed; z-index: 2000; top: 15px; right: 15px; width: 14px; height: 14px; border: solid 2px transparent; border-top-color: #e90f92; border-left-color: #e90f92; border-radius: 10px; -webkit-animation: pace-spinner 400ms linear infinite; -moz-animation: pace-spinner 400ms linear infinite; -ms-animation: pace-spinner 400ms linear infinite; -o-animation: pace-spinner 400ms linear infinite; animation: pace-spinner 400ms linear infinite;&#125;@-webkit-keyframes pace-spinner &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-moz-keyframes pace-spinner &#123; 0% &#123; -moz-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -moz-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-o-keyframes pace-spinner &#123; 0% &#123; -o-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -o-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-ms-keyframes pace-spinner &#123; 0% &#123; -ms-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -ms-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@keyframes pace-spinner &#123; 0% &#123; transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;/*网页加载条 END*/ 开发环境自动刷新在 Hexo-NexT搭建个人博客（一） 已经提到了本地调试三部曲：123hexo cleanhexo generatehexo server --debug 然后我在项目的 package.json 中配成了这样：1&quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --debug&quot;, 这样的话，我执行 npm run dev 就可以启动本地环境了，省去了前面需要分别敲三次命令的步骤。为什么可以这样写，详情看这里：npm 全面介绍npm 的一个小细节 这样还不爽，我希望在写博客的时候，按下 Ctrl + S 后能自动刷新浏览器，看到实时的效果，省去了自己手动刷新浏览器的过程，在双屏下，真的很好用，一边写一边看。具体的做法是:在项目的根目录下添加一个 gulpfile.js 文件，文件内容参看 源码，这里我就不贴了。然后安装 gulpfile.js 里面的依赖包。 gulpfile.js 里面有一个 dev-proxy 方法，会代理本地的 4000 端口，并且监听文件变化，如有变化就会自动刷新浏览器。 最后，我们的开发步骤就变成这样了：先打开一个 Terminal ，使用 npm run dev 开启本地的博客服务。然后再开一个 Terminal，使用 gulp 命令来开启监听和代理服务。 代码压缩在项目的根目录下，执行以下命令：12cnpm install gulp -gcnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp --save-dev 然后在 gulpfile.js 里面写上相关代码，详情查看 源码 。 然后执行 gulp min 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 鼠标右键 -&gt; 查看网页源代码，可以看到已经是压缩过的。 自定义页面与目录下面介绍两种方法： 第一种方法是使用 Hexo 提供的跳过渲染配置，适用于整个目录的设置。 具体步骤，打开博客根目录_config.yml，找到其中 skip_render 配置项，这个用来配置 /source/ 中需要跳过渲染的文件或目录，例如希望跳过 /source/projects/ 里的所有文件渲染，可以配置为：1skip_render: projects/** 匹配规则是一种类似正则的规则，官方给出的参考是这个。另外在测试这个功能的时候发现，Hexo 的内部缓存不是特别好用，有时候你修改了配置但生成出来的内容不一定及时应用了新配置，最好在生成之前执行一下 hexo clean 命令，清除掉旧的生成文件和缓存。 第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个 html 格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 123---layout: false--- 这样，这个文件就不会经过模板渲染，最终发布到 /public/ 里的文件就是去掉标记后的文件的样子。 关于 categories 和 tags 页面 Cannot GET 的解决方案有同学反馈在配置文件中配置了 categories 和 tags 后依然没有 categories 和 tags 页面，提示 Cannot GET。 其实在配置了 categories 和 tags 后，还需要在 /source/ 目录下新建 categories 目录和 tags 目录，里面的要有 index.md 文件，并且文件开头不能少，也不能写错。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（四）]]></title>
    <url>%2Fblog%2F14696.html</url>
    <content type="text"><![CDATA[提示：本篇文章将介绍在使用 heox 做博客框架中的一些 bug 处理情况。 按照之前的教程介绍应该是会比较顺利的搭建好你的博客，但是难免会遇到一些意外，这个时候就要学会解决问题了。解决问题的原则是：查看 bug 信息，从上到下依次解决 bug。下面来看几个例子： 首先这个是在 hexo clean 时报的错：提示插件 hexo-deployer-git 加载失败，想了一下，应该是上次我在移动博客目录的时候，这个模块中有一些文件名比较长的文件，系统会提示移动不过来，导致这个模块异常，很简单，文件夹中删除这个模块，重新安装即可。（或者使用 npm 来卸载这个模块，然后重新安装）如下： OK ， 现在好了，hexo clean 没有报错了。 下面，我是在执行 hexo g 的操作，同样也出现了错误： 按照图中我标注的步骤，来看一下错误信息：如 1 所示：我们首先会发现缺少模块 isarray ，但是我们查看 package.json 文件，我们的项目根本就没有引入 isarray 这个模块，我猜测这个 isarray 模块应该是某个模块的子模块 。 如 2 所示：我们顺着 at 一路往下找。 如 3 所示：发现这个 isarray 是在 hexo-generator-sitemap 里面的 ，所以我们删除这个 hexo-generator-sitemap 模块，然后重新安装这个模块。如下： OK ， 现在好了，hexo g 没有报错了。 那么，就以这两个例子来作为本次的示范吧，其实，Hexo 中的一些问题还是比较好解决的，因为它都是依赖其他模块的，定位到出问题的模块，卸载重装即可。 总结：遇到问题 bug，一定要仔细查阅错误提示信息，遵守从上往下解决的方案。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（三）]]></title>
    <url>%2Fblog%2F22441.html</url>
    <content type="text"><![CDATA[经过前面两期文章，我相信你已经可以在本地建立一个非常令人满意的静态博客了，本篇文章将介绍如何将自己的静态博客部署到 gitpage 上，并托管到 github 上；以及关于 Hexo 和 NexT 中更深层次的一些问题及解方案。 一、菜单栏中标签与侧边栏中标签关联的问题 以我的博客为例，关于菜单栏中的选项 与侧边栏中的选项，由于顶部菜单栏中位置有限，所以我就想在顶部菜单栏中不显示标签这一项，于是我在 主题配置文件 中 将 menu 配置项中的标签这一个选项给注释掉了，所以它不会在菜单栏中显示，但是不代表没有这个页面，这个页面是存在的，我们只是使其不显示在顶部的菜单栏中而已，我们可以直接输入绝对地址来查看这个页面，例如：https://neveryu.github.io/tags/。但是与此同时，我们发现侧边栏中的标签选项只能显示标签数量，不能点击。 这是因为侧边栏中的点击链接是根据菜单栏中对应的项来添加的，什么意思呢？就是说如果顶部菜单栏中有 标签 这一项，那么就会给侧边栏中标签这一项也添加点击链接；如果顶部菜单栏中没有标签这一项，那么就不给侧边栏中标签这一项添加点击链接，导致侧边栏中的标签项只有显示数据，不提供点击链接。 如果我们不想在菜单栏中显示标签项，但是希望侧边栏中的标签项 可以点击，该怎么做呢？ 在 主题配置文件 \themes\next\layout\_macro\sidebar.swing_ 中，将12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class=&quot;site-state-item site-state-tags&quot;&gt; &#123;% if theme.menu.tags %&#125;&lt;a href=&quot;&#123;&#123; url_for(theme.menu.tags) &#125;&#125;&quot;&gt;&#123;% endif %&#125; &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;state.tags&apos;) &#125;&#125;&lt;/span&gt; &#123;% if theme.menu.tags %&#125;&lt;/a&gt;&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 改成：12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class=&quot;site-state-item site-state-tags&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(theme.menu.tags) &#125;&#125;&quot;&gt; &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;state.tags&apos;) &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&#123;% endif %&#125; 同理，关于菜单栏中 归档 和 分类 的类似操作也是如此。 二、关于High一下中的音乐多次点击重叠播放的解决方案 在之前的 High一下 的播放音乐，如果多次点击的话，音乐会重复叠加播放，严重影响听歌体验，而且只能播放一首歌。 而现在的 High一下 已经解决了这个问题，而且可以列表循环多首歌曲。我将之前的那段播放音乐的代码换了。由于代码太长了，就不在这里贴出来了。大家可以去查看我的源码：https://github.com/Neveryu/Blog。关于播放音乐的代码是在： https://github.com/Neveryu/Blog/blob/master/themes/next/layout/_partials/header.swig 中的第 60 行开始。 需要说明的是：现在的 High一下 实现了歌曲列表循环，所以，我们可以放入多首歌的链接。在代码中以数组元素的形式加入歌曲链接。1234var songs = [ &quot;http://v.65dj.com/wailian/84791c997d8c55023dad0d5690e48c28.mp3&quot;, &quot;http://7xoiki.com1.z0.glb.clouddn.com/Music-sunburst.mp3&quot;]; 三、关于github屏蔽vendors ，导致页面空白的解决方案关于 Github Pages 过滤掉了 source/vendors 目录的访问，导致加载 vendor 里面的文件全部 404 ，页面大面积空白。1.在根目录添加 .nojekyll 文件。2.也可以手动将 source/vendors 目录修改成 source/lib 同时，修改主题配置文件 _config.yml ，将 _internal: vendors 改成你所修改的名字，例如 _internal: lib 。 四、关于如何获取自己的多说userid首先进入自己的帐号管理页面，点击左上自己的名字此时地址栏后面的一串数字就是你的多说 userid。 五、关于如何修改内容区域宽度Next 对内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 如果你需要修改内容的宽度，同样需要编辑样式文件。编辑主题的 source\css_variables\custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 此方法不适用于 Pisces Scheme ， Pisces Scheme 编辑 themes\next\source\css\_schemes\Picses\_layout.styl 文件，更改以下 css 选项定义值：123.header &#123;width: 1150px;&#125;.container .main-inner &#123;width: 1150px;&#125;.content-wrap &#123;width: calc(100% - 260px);&#125; 六、图片模式新建博文，设置 type: &quot;picture&quot; ，使用 {\% gp x-x \%}...{\% endgp \%} 标签引用要展示的图片地址，如下所示：1234567891011121314---title: Naruto-Picturescategories: [picture]tags: [picture,naruto]date: 2016-11-02 14:36:04type: &quot;picture&quot;---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125; 图片展示效果 {\% gp 5-3 \%}：设置图片展示效果，参考 themes\next\scripts\tags\group-pictures.js 注释示意图。5-3 的意思就是5张图片将会按照这种布局来展示，Next 提供了多张图片的多种布局，你可以随意选择。 注意点主题目前首页可以正常显示设置的图片效果，但是点击进入后显示效果丢失，所以需要修改一下文件 themes\next\source\css\_common\components\tags\group-pictures.styl 中的以下样式：123456.page-post-detail .post-body .group-picture-column &#123; // float: none; margin-top: 10px; // width: auto !important; img &#123; margin: 0 auto; &#125;&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（二）]]></title>
    <url>%2Fblog%2F23504.html</url>
    <content type="text"><![CDATA[本篇文章将介绍基于NexT主题下的一些扩展功能的实现。首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 1.设置侧栏的位置修改 主题配置文件 中 sidebar.position 的值，支持的选项有：left right目前仅 Pisces Scheme 支持 position 配置，也就是说NexT主题的侧栏位置是不能设置的，设置了也没用，反正都在右边。 2. 关于添加居中模块优秀的人，不是不合群，而是他们合群的人里面没有你代码如下：1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 3. 添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 4. 添加最近访客在需要添加最近访客的网页对应的 markdown 文件中添加如下代码：12最近访客&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 5. 鼠标点击小红心的设置 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt; 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 6. 背景的设置 将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt;标签之前 添加以下代码：12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 7.修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 8. 多说评论不稳定，加载速度慢怎么办？把多说评论依赖的 embed.js 放置底部，这里需要修改的文件是 duoshuo.swig。将1(document.getElementsByTagName(&apos;head&apos;)[0] 修改成下面的代码1(document.getElementById(&apos;footer&apos;) 9. 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 10. 给 Blog 添加 LICENSE在 主题配置文件 中的 160 行左右：12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: 将其中第 4 行的注释放开，然后选择你想使用的 LICENSE 即可，可选项参照第 3 行。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（一）]]></title>
    <url>%2Fblog%2F52138.html</url>
    <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 精于心，简于形 的风格，一直被广大用户所喜爱。 安装安装 Hexo 只需几分钟时间，若你在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决你的问题。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Nowwindows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装 Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。1$ npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在 D 盘目录下创建了一个文件夹 blog 。D:\blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。1$ hexo init 等待安装，安装完成后，指定文件夹 的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 我们继续执行命令12$ hexo g$ hexo s --debug Hexo 将 source 文件夹中除 _posts 文件夹之外，开头命名为 _(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 安装 NexT 主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 启用 NexT 主题打开 站点配置文件 ，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000/ ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，我们已经成功安装并启用了 NexT 主题。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 总结本地调试步骤三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。 部署步骤三部曲：123$ hexo clean$ hexo g$ hexo d 当然在部署之前，需要先配置好配置文件中的 deploy。 常用命令1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" # 新建页面$ hexo generate # 生成静态页面至public目录$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)$ hexo deploy # 项目部署$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本 简写命令1234$ hexo new == hexo n$ hexo generate == hexo g$ hexo server == hexo s$ hexo deploy == hexo d 常见问题1在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：错误的设置：123author:Neveryuemail:react.dong.yu@gmail.comlanguage:zh-CN 正确的设置：123author: Neveryuemail: react.dong.yu@gmail.comlanguage: zh-CN 常见问题2关于 Git 提交中用户名和 Email 的设置12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot; 常见问题3Hexo 中的图标使用的是 Font Awesome ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。 &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO添加音乐播放器]]></title>
    <url>%2Fblog%2F17996.html</url>
    <content type="text"><![CDATA[HTML5 音乐播放器 jQuery 插件参考HTML5 悬浮音乐播放器和h5 audio 播放器。 HTML5 音乐播放器 下载播放器 密码：oznd，解压后丢到站点根目录，也就是source-static目录下面。在站点_config.yml中，设置skip_rende: static/**（两个星号） 如果你想整个博客都能够播放音乐，添加如下代码： 123456~/hexo/themes/next/layout/_layout.swig&#123;% include '_third-party/exturl.swig' %&#125;+ &#123;% include '_my/audio.swig' %&#125;&lt;/body&gt;&lt;/html&gt; 在 ~/hexo/themes/next/layout 中新建_my目录 和audio.swig 文件，添加如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556~/hexo/themes/next/layout/_my/audio.swig&#123;% if theme.audio.enable %&#125;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="/static/css/player.css"&gt;&lt;/head&gt;&lt;div id="QPlayer"&gt; &lt;div id="pContent"&gt; &lt;div id="player"&gt; &lt;span class="cover"&gt;&lt;/span&gt; &lt;div class="ctrl"&gt; &lt;div class="musicTag marquee"&gt; &lt;strong&gt;Title&lt;/strong&gt; &lt;span&gt; - &lt;/span&gt; &lt;span class="artist"&gt;Artist&lt;/span&gt; &lt;/div&gt; &lt;div class="progress"&gt; &lt;div class="timer left"&gt;0:00&lt;/div&gt; &lt;div class="contr"&gt; &lt;div class="rewind icon"&gt;&lt;/div&gt; &lt;div class="playback icon"&gt;&lt;/div&gt; &lt;div class="fastforward icon"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;div class="liebiao icon"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ssBtn"&gt; &lt;div class="adf"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;ol id="playlist"&gt;&lt;/ol&gt;&lt;/div&gt;&lt;script src="//cdn.bootcss.com/jQuery.Marquee/1.3.94/jquery.marquee.min.js"&gt;&lt;/script&gt;&lt;script&gt; var playlist = []; &#123;% for src in theme.audio.sources %&#125; playlist.push(&#123;title:'&#123;&#123;src.title&#125;&#125;',artist:'&#123;&#123;src.artist&#125;&#125;',mp3:'&#123;&#123; src.mp3 &#125;&#125;',cover:'&#123;&#123;src.cover&#125;&#125;'&#125;) &#123;% endfor %&#125; var isRotate = true; var autoplay = false;&lt;/script&gt;&lt;script src="/static/js/player.js"&gt;&lt;/script&gt;&lt;script&gt; function bgChange()&#123; var lis= $('.lib'); for(var i=0; i&lt;lis.length; i+=2) lis[i].style.background = 'rgba(246, 246, 246, 0.5)'; &#125; window.onload = bgChange;&lt;/script&gt;&#123;% endif %&#125; 在主题配置文件中添加如下项：其中sources就是我们主要要填写的配置项。enable是控制整个播放器是否开启。如果有多个音乐的话，每个音乐之间用,隔开。 12345678~/hexo/themes/next/_config.ymlaudio: enable: true sources: [ &#123; title: '爱是昂贵的', artist: '声音玩具', mp3: 'http://m2.music.126.net/66i9ySu3BLIQ8_fwK9yvVQ==/7963762720382833.mp3', cover: 'http://img.xiami.net/images/album/img29/3029/16250159661472438031.jpg' &#125; ] 获取音乐外链，使用前试听一下得到的音乐链接。 修改 HTML5 音乐播放器颜色： 123456789101112131415161718192021222324252627~/hexo/source/static/css/player.css#pContent .ssBtn &#123; width:20px; height:60px;+ background:#1abc9c none repeat scroll 0% 0%; position:relative; right:0px; bottom:0px; box-sizing:border-box; border-left:none; cursor:pointer; display:box-shadow:; float:right;&#125;#playlist li:hover &#123; color:#716e6e; font-weight:bold;+ border-left:3px solid #1abc9c; padding:3px 15px 3px 11px;&#125;#playlist li.playing &#123; color:#716e6e; font-weight:bold;+ border-left:3px solid #bc1a1a; padding:3px 15px 3px 11px;&#125; HTML5 音乐播放器添加音量控制。播放器里是有两个上一首和下一首的按钮的，左键点击他们就会切换歌曲，那么我们让他右键点击降低和升高声音就好啦。无缓存第一次的声音存在 bug，如有缓存时，音量默认为系统音量的 0.2 倍。 1234567891011121314151617181920212223242526272829303132333435~/hexo/source/static/js/player.js$(document).bind("contextmenu", function () &#123; return false;&#125;)$('.rewind').on('click', function () &#123; if (isShuffle) &#123; shufflePlay(0); &#125; else &#123; switchTrack(--currentTrack); &#125;&#125;).mousedown(function (e) &#123; if (3 == e.which) &#123; if (audio.volume &gt;= 0.05) &#123; audio.volume -= 0.05 &#125; else &#123; audio.volume = 0; &#125; localStorage.volume = audio.volume &#125;&#125;);$('.fastforward').on('click', function () &#123; if (isShuffle) &#123; shufflePlay(1); &#125; else &#123; switchTrack(++currentTrack); &#125;&#125;).mousedown(function (e) &#123; if (3 == e.which) &#123; if (audio.volume &lt;= 0.95) &#123; audio.volume += 0.05 &#125; else &#123; audio.volume = 1; &#125; localStorage.volume = audio.volume &#125;&#125;); HTML5 音乐播放器使用localstorage存储音乐的播放状态： 在~/hexo/source/static/js/player.js的setProgress函数中加入 12345678~/hexo/source/static/js/player.jsvar setProgress = function (value) &#123; var currentSec = parseInt(value % 60) &lt; 10 ? '0' + parseInt(value % 60) : parseInt(value % 60), ratio = value / audio.duration * 100; $('.timer').html(parseInt(value / 60) + ':' + currentSec);+ localStorage.time = value+ localStorage.song = currentTrack&#125; loadMusic函数后面，新定义一个函数。sessionStorage.autoPlay = &quot;true&quot;控制自动播放。 123456789101112131415161718~/hexo/source/static/js/player.jsvar FirstLoad = function (i, time) &#123; if (i == undefined) &#123; i = 0 currentTrack = 0 shuffleIndex = 0 &#125; loadMusic(i) if (time) &#123; audio.currentTime = time &#125; if (localStorage.volume) &#123; audio.volume = localStorage.volume &#125; if (sessionStorage.autoPlay == undefined) &#123; sessionStorage.autoPlay = "true" &#125;&#125; 修改currentTrack的赋值部分。 12345678910111213~/hexo/source/static/js/player.jsvar currentTrack = localStorage.song, audio, timeout;var shuffle_array = localStorage.qplayer_shuffle_array;if (isShuffle &amp;&amp; shuffle_array != undefined &amp;&amp; playlist.length === (shuffleArray = JSON.parse(shuffle_array)).length) &#123; shuffleIndex = 0; if (currentTrack == undefined) &#123; currentTrack = shuffleArray[0]; $('#QPlayer .cover').attr('title', '点击关闭随机播放'); &#125;&#125; else &#123; isShuffle = false; $('#QPlayer .cover').attr('title', '点击开启随机播放');&#125; 然后，将最开始调用的loadMusic替换为FirstLoad函数，这样就可以在打开 / 刷新页面时将播放上次的音乐和上次的时间。 12345678~/hexo/source/static/js/player.js- loadMusic(currentTrack);+ FirstLoad(currentTrack, localStorage.time);if (sessionStorage.autoPlay == "true") &#123; play()&#125;if (localStorage.volume == undefined) &#123; localStorage.volume = 0.2&#125; ~/hexo/source/static/js/player.js的$(&quot;div.ssBtn&quot;).click()控制播放器是否一直弹出，注释掉即可。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
